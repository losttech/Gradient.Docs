<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
	<!--[if lt IE 9]>
	<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
    <title>tf.nest - LostTech.TensorFlow Documentation</title>
    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"/>
    <link type="text/css" rel="stylesheet" href="../main.css"/>
    <script type="text/javascript" src="../js/jquery-1.3.2.min.js"></script>
    <script type="text/javascript" src="../js/jquery.scrollTo-min.js"></script>
    <script type="text/javascript" src="../js/navigation.js"></script>
    <script type="text/javascript" src="../js/example.js"></script>
  </head>
  <body>
  	<header><h1>LostTech.TensorFlow : API Documentation</h1>
	</header>

    <nav id="namespaces">
      <iframe src="../namespaces.htm"></iframe>
    </nav><nav id="types">
  <h2 class="fixed">Types in tensorflow</h2>
	<div class="scroll">
		<ul>
				<li>
            <a href="../tensorflow/AggregationMethod.htm">AggregationMethod</a>
        </li>
				<li>
            <a href="../tensorflow/ConditionalAccumulator.htm">ConditionalAccumulator</a>
        </li>
				<li>
            <a href="../tensorflow/ConditionalAccumulatorBase.htm">ConditionalAccumulatorBase</a>
        </li>
				<li>
            <a href="../tensorflow/constant_initializer.htm">constant_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/CriticalSection.htm">CriticalSection</a>
        </li>
				<li>
            <a href="../tensorflow/DeviceSpec.htm">DeviceSpec</a>
        </li>
				<li>
            <a href="../tensorflow/Dimension.htm">Dimension</a>
        </li>
				<li>
            <a href="../tensorflow/DType.htm">DType</a>
        </li>
				<li>
            <a href="../tensorflow/FIFOQueue.htm">FIFOQueue</a>
        </li>
				<li>
            <a href="../tensorflow/FixedLenFeature.htm">FixedLenFeature</a>
        </li>
				<li>
            <a href="../tensorflow/FixedLengthRecordReader.htm">FixedLengthRecordReader</a>
        </li>
				<li>
            <a href="../tensorflow/FixedLenSequenceFeature.htm">FixedLenSequenceFeature</a>
        </li>
				<li>
            <a href="../tensorflow/glorot_normal_initializer.htm">glorot_normal_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/glorot_uniform_initializer.htm">glorot_uniform_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/GradientTape.htm">GradientTape</a>
        </li>
				<li>
            <a href="../tensorflow/Graph.htm">Graph</a>
        </li>
				<li>
            <a href="../tensorflow/Graph._ControlDependenciesController.htm">Graph._ControlDependenciesController</a>
        </li>
				<li>
            <a href="../tensorflow/Graph.I_ControlDependenciesController.htm">Graph.I_ControlDependenciesController</a>
        </li>
				<li>
            <a href="../tensorflow/GraphKeys.htm">GraphKeys</a>
        </li>
				<li>
            <a href="../tensorflow/HeadingAxes.htm">HeadingAxes</a>
        </li>
				<li>
            <a href="../tensorflow/IAggregationMethod.htm">IAggregationMethod</a>
        </li>
				<li>
            <a href="../tensorflow/IConditionalAccumulator.htm">IConditionalAccumulator</a>
        </li>
				<li>
            <a href="../tensorflow/IConditionalAccumulatorBase.htm">IConditionalAccumulatorBase</a>
        </li>
				<li>
            <a href="../tensorflow/Iconstant_initializer.htm">Iconstant_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/ICriticalSection.htm">ICriticalSection</a>
        </li>
				<li>
            <a href="../tensorflow/IdentityReader.htm">IdentityReader</a>
        </li>
				<li>
            <a href="../tensorflow/IDeviceSpec.htm">IDeviceSpec</a>
        </li>
				<li>
            <a href="../tensorflow/IDimension.htm">IDimension</a>
        </li>
				<li>
            <a href="../tensorflow/IDType.htm">IDType</a>
        </li>
				<li>
            <a href="../tensorflow/IFIFOQueue.htm">IFIFOQueue</a>
        </li>
				<li>
            <a href="../tensorflow/IFixedLenFeature.htm">IFixedLenFeature</a>
        </li>
				<li>
            <a href="../tensorflow/IFixedLengthRecordReader.htm">IFixedLengthRecordReader</a>
        </li>
				<li>
            <a href="../tensorflow/IFixedLenSequenceFeature.htm">IFixedLenSequenceFeature</a>
        </li>
				<li>
            <a href="../tensorflow/Iglorot_normal_initializer.htm">Iglorot_normal_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/Iglorot_uniform_initializer.htm">Iglorot_uniform_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/IGradientTape.htm">IGradientTape</a>
        </li>
				<li>
            <a href="../tensorflow/IGraph.htm">IGraph</a>
        </li>
				<li>
            <a href="../tensorflow/IGraphKeys.htm">IGraphKeys</a>
        </li>
				<li>
            <a href="../tensorflow/IIdentityReader.htm">IIdentityReader</a>
        </li>
				<li>
            <a href="../tensorflow/IIndexedSlices.htm">IIndexedSlices</a>
        </li>
				<li>
            <a href="../tensorflow/IIndexedSlicesSpec.htm">IIndexedSlicesSpec</a>
        </li>
				<li>
            <a href="../tensorflow/IInteractiveSession.htm">IInteractiveSession</a>
        </li>
				<li>
            <a href="../tensorflow/ILazyLoader.htm">ILazyLoader</a>
        </li>
				<li>
            <a href="../tensorflow/ILMDBReader.htm">ILMDBReader</a>
        </li>
				<li>
            <a href="../tensorflow/IModule.htm">IModule</a>
        </li>
				<li>
            <a href="../tensorflow/Iname_scope.htm">Iname_scope</a>
        </li>
				<li>
            <a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a>
        </li>
				<li>
            <a href="../tensorflow/IndexedSlicesSpec.htm">IndexedSlicesSpec</a>
        </li>
				<li>
            <a href="../tensorflow/InteractiveSession.htm">InteractiveSession</a>
        </li>
				<li>
            <a href="../tensorflow/Iones_initializer.htm">Iones_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/IOperation.htm">IOperation</a>
        </li>
				<li>
            <a href="../tensorflow/IOpError.htm">IOpError</a>
        </li>
				<li>
            <a href="../tensorflow/IOptionalSpec.htm">IOptionalSpec</a>
        </li>
				<li>
            <a href="../tensorflow/Iorthogonal_initializer.htm">Iorthogonal_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/IPaddingFIFOQueue.htm">IPaddingFIFOQueue</a>
        </li>
				<li>
            <a href="../tensorflow/IPriorityQueue.htm">IPriorityQueue</a>
        </li>
				<li>
            <a href="../tensorflow/IQueueBase.htm">IQueueBase</a>
        </li>
				<li>
            <a href="../tensorflow/IRaggedTensor.htm">IRaggedTensor</a>
        </li>
				<li>
            <a href="../tensorflow/IRaggedTensorSpec.htm">IRaggedTensorSpec</a>
        </li>
				<li>
            <a href="../tensorflow/Irandom_normal_initializer.htm">Irandom_normal_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/Irandom_uniform_initializer.htm">Irandom_uniform_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/IRandomShuffleQueue.htm">IRandomShuffleQueue</a>
        </li>
				<li>
            <a href="../tensorflow/IReaderBase.htm">IReaderBase</a>
        </li>
				<li>
            <a href="../tensorflow/IRegisterGradient.htm">IRegisterGradient</a>
        </li>
				<li>
            <a href="../tensorflow/ISession.htm">ISession</a>
        </li>
				<li>
            <a href="../tensorflow/ISparseConditionalAccumulator.htm">ISparseConditionalAccumulator</a>
        </li>
				<li>
            <a href="../tensorflow/ISparseFeature.htm">ISparseFeature</a>
        </li>
				<li>
            <a href="../tensorflow/ISparseTensor.htm">ISparseTensor</a>
        </li>
				<li>
            <a href="../tensorflow/ISparseTensorSpec.htm">ISparseTensorSpec</a>
        </li>
				<li>
            <a href="../tensorflow/ISparseTensorValue.htm">ISparseTensorValue</a>
        </li>
				<li>
            <a href="../tensorflow/ITensor.htm">ITensor</a>
        </li>
				<li>
            <a href="../tensorflow/ITensorArray.htm">ITensorArray</a>
        </li>
				<li>
            <a href="../tensorflow/ITensorArraySpec.htm">ITensorArraySpec</a>
        </li>
				<li>
            <a href="../tensorflow/ITensorShape.htm">ITensorShape</a>
        </li>
				<li>
            <a href="../tensorflow/ITensorSpec.htm">ITensorSpec</a>
        </li>
				<li>
            <a href="../tensorflow/ITextLineReader.htm">ITextLineReader</a>
        </li>
				<li>
            <a href="../tensorflow/ITFRecordReader.htm">ITFRecordReader</a>
        </li>
				<li>
            <a href="../tensorflow/Itruncated_normal_initializer.htm">Itruncated_normal_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/ITypeSpec.htm">ITypeSpec</a>
        </li>
				<li>
            <a href="../tensorflow/IUnconnectedGradients.htm">IUnconnectedGradients</a>
        </li>
				<li>
            <a href="../tensorflow/Iuniform_unit_scaling_initializer.htm">Iuniform_unit_scaling_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/IVariable.htm">IVariable</a>
        </li>
				<li>
            <a href="../tensorflow/Ivariable_scope.htm">Ivariable_scope</a>
        </li>
				<li>
            <a href="../tensorflow/IVariableScope.htm">IVariableScope</a>
        </li>
				<li>
            <a href="../tensorflow/Ivariance_scaling_initializer.htm">Ivariance_scaling_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/IVarLenFeature.htm">IVarLenFeature</a>
        </li>
				<li>
            <a href="../tensorflow/IWholeFileReader.htm">IWholeFileReader</a>
        </li>
				<li>
            <a href="../tensorflow/Izeros_initializer.htm">Izeros_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/LazyLoader.htm">LazyLoader</a>
        </li>
				<li>
            <a href="../tensorflow/LMDBReader.htm">LMDBReader</a>
        </li>
				<li>
            <a href="../tensorflow/Module.htm">Module</a>
        </li>
				<li>
            <a href="../tensorflow/name_scope.htm">name_scope</a>
        </li>
				<li>
            <a href="../tensorflow/ones_initializer.htm">ones_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/Operation.htm">Operation</a>
        </li>
				<li>
            <a href="../tensorflow/Operation._InputList.htm">Operation._InputList</a>
        </li>
				<li>
            <a href="../tensorflow/Operation.I_InputList.htm">Operation.I_InputList</a>
        </li>
				<li>
            <a href="../tensorflow/OpError.htm">OpError</a>
        </li>
				<li>
            <a href="../tensorflow/OptionalSpec.htm">OptionalSpec</a>
        </li>
				<li>
            <a href="../tensorflow/orthogonal_initializer.htm">orthogonal_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/PaddingFIFOQueue.htm">PaddingFIFOQueue</a>
        </li>
				<li>
            <a href="../tensorflow/PriorityQueue.htm">PriorityQueue</a>
        </li>
				<li>
            <a href="../tensorflow/QueueBase.htm">QueueBase</a>
        </li>
				<li>
            <a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a>
        </li>
				<li>
            <a href="../tensorflow/RaggedTensorSpec.htm">RaggedTensorSpec</a>
        </li>
				<li>
            <a href="../tensorflow/random_normal_initializer.htm">random_normal_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/random_uniform_initializer.htm">random_uniform_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/RandomShuffleQueue.htm">RandomShuffleQueue</a>
        </li>
				<li>
            <a href="../tensorflow/ReaderBase.htm">ReaderBase</a>
        </li>
				<li>
            <a href="../tensorflow/RegisterGradient.htm">RegisterGradient</a>
        </li>
				<li>
            <a href="../tensorflow/Session.htm">Session</a>
        </li>
				<li>
            <a href="../tensorflow/SparseConditionalAccumulator.htm">SparseConditionalAccumulator</a>
        </li>
				<li>
            <a href="../tensorflow/SparseFeature.htm">SparseFeature</a>
        </li>
				<li>
            <a href="../tensorflow/SparseTensor.htm">SparseTensor</a>
        </li>
				<li>
            <a href="../tensorflow/SparseTensorSpec.htm">SparseTensorSpec</a>
        </li>
				<li>
            <a href="../tensorflow/SparseTensorValue.htm">SparseTensorValue</a>
        </li>
				<li>
            <a href="../tensorflow/Tensor.htm">Tensor</a>
        </li>
				<li>
            <a href="../tensorflow/Tensor`1.htm">Tensor&lt;T&gt;</a>
        </li>
				<li>
            <a href="../tensorflow/TensorArray.htm">TensorArray</a>
        </li>
				<li>
            <a href="../tensorflow/TensorArraySpec.htm">TensorArraySpec</a>
        </li>
				<li>
            <a href="../tensorflow/TensorDimension.htm">TensorDimension</a>
        </li>
				<li>
            <a href="../tensorflow/TensorDimensionSlice.htm">TensorDimensionSlice</a>
        </li>
				<li>
            <a href="../tensorflow/TensorShape.htm">TensorShape</a>
        </li>
				<li>
            <a href="../tensorflow/TensorSpec.htm">TensorSpec</a>
        </li>
				<li>
            <a href="../tensorflow/TextLineReader.htm">TextLineReader</a>
        </li>
				<li>
            <a href="../tensorflow/tf.htm">tf</a>
        </li>
				<li>
            <a href="../tensorflow/tf.audio.htm">tf.audio</a>
        </li>
				<li>
            <a href="../tensorflow/tf.autograph.htm">tf.autograph</a>
        </li>
				<li>
            <a href="../tensorflow/tf.autograph.experimental.htm">tf.autograph.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.bitwise.htm">tf.bitwise</a>
        </li>
				<li>
            <a href="../tensorflow/tf.compat.htm">tf.compat</a>
        </li>
				<li>
            <a href="../tensorflow/tf.config.htm">tf.config</a>
        </li>
				<li>
            <a href="../tensorflow/tf.config.experimental.htm">tf.config.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.config.optimizer.htm">tf.config.optimizer</a>
        </li>
				<li>
            <a href="../tensorflow/tf.config.threading.htm">tf.config.threading</a>
        </li>
				<li>
            <a href="../tensorflow/tf.data.htm">tf.data</a>
        </li>
				<li>
            <a href="../tensorflow/tf.data.experimental.htm">tf.data.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.debugging.htm">tf.debugging</a>
        </li>
				<li>
            <a href="../tensorflow/tf.distribute.htm">tf.distribute</a>
        </li>
				<li>
            <a href="../tensorflow/tf.distributions.htm">tf.distributions</a>
        </li>
				<li>
            <a href="../tensorflow/tf.errors.htm">tf.errors</a>
        </li>
				<li>
            <a href="../tensorflow/tf.estimator.htm">tf.estimator</a>
        </li>
				<li>
            <a href="../tensorflow/tf.estimator.experimental.htm">tf.estimator.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.estimator.export.htm">tf.estimator.export</a>
        </li>
				<li>
            <a href="../tensorflow/tf.estimator.inputs.htm">tf.estimator.inputs</a>
        </li>
				<li>
            <a href="../tensorflow/tf.experimental.htm">tf.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.feature_column.htm">tf.feature_column</a>
        </li>
				<li>
            <a href="../tensorflow/tf.gfile.htm">tf.gfile</a>
        </li>
				<li>
            <a href="../tensorflow/tf.graph_util.htm">tf.graph_util</a>
        </li>
				<li>
            <a href="../tensorflow/tf.image.htm">tf.image</a>
        </li>
				<li>
            <a href="../tensorflow/tf.initializers.htm">tf.initializers</a>
        </li>
				<li>
            <a href="../tensorflow/tf.io.htm">tf.io</a>
        </li>
				<li>
            <a href="../tensorflow/tf.io.gfile.htm">tf.io.gfile</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.htm">tf.keras</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.activations.htm">tf.keras.activations</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.htm">tf.keras.applications</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.densenet.htm">tf.keras.applications.densenet</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.imagenet_utils.htm">tf.keras.applications.imagenet_utils</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.inception_resnet_v2.htm">tf.keras.applications.inception_resnet_v2</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.inception_v3.htm">tf.keras.applications.inception_v3</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.mobilenet.htm">tf.keras.applications.mobilenet</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.mobilenet_v2.htm">tf.keras.applications.mobilenet_v2</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.nasnet.htm">tf.keras.applications.nasnet</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.resnet.htm">tf.keras.applications.resnet</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.resnet_v2.htm">tf.keras.applications.resnet_v2</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.vgg16.htm">tf.keras.applications.vgg16</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.vgg19.htm">tf.keras.applications.vgg19</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.xception.htm">tf.keras.applications.xception</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.backend.htm">tf.keras.backend</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.constraints.htm">tf.keras.constraints</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.datasets.htm">tf.keras.datasets</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.datasets.boston_housing.htm">tf.keras.datasets.boston_housing</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.datasets.cifar10.htm">tf.keras.datasets.cifar10</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.datasets.cifar100.htm">tf.keras.datasets.cifar100</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.datasets.fashion_mnist.htm">tf.keras.datasets.fashion_mnist</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.datasets.imdb.htm">tf.keras.datasets.imdb</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.datasets.mnist.htm">tf.keras.datasets.mnist</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.datasets.reuters.htm">tf.keras.datasets.reuters</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.estimator.htm">tf.keras.estimator</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.experimental.htm">tf.keras.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.initializers.htm">tf.keras.initializers</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.layers.htm">tf.keras.layers</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.losses.htm">tf.keras.losses</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.metrics.htm">tf.keras.metrics</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.mixed_precision.htm">tf.keras.mixed_precision</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.mixed_precision.experimental.htm">tf.keras.mixed_precision.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.models.htm">tf.keras.models</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.optimizers.htm">tf.keras.optimizers</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.optimizers.schedules.htm">tf.keras.optimizers.schedules</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.preprocessing.htm">tf.keras.preprocessing</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.preprocessing.image.htm">tf.keras.preprocessing.image</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.regularizers.htm">tf.keras.regularizers</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.utils.htm">tf.keras.utils</a>
        </li>
				<li>
            <a href="../tensorflow/tf.layers.htm">tf.layers</a>
        </li>
				<li>
            <a href="../tensorflow/tf.layers.experimental.htm">tf.layers.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.linalg.htm">tf.linalg</a>
        </li>
				<li>
            <a href="../tensorflow/tf.lite.htm">tf.lite</a>
        </li>
				<li>
            <a href="../tensorflow/tf.lite.experimental.htm">tf.lite.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.lite.experimental.microfrontend.htm">tf.lite.experimental.microfrontend</a>
        </li>
				<li>
            <a href="../tensorflow/tf.lite.experimental.microfrontend.python.htm">tf.lite.experimental.microfrontend.python</a>
        </li>
				<li>
            <a href="../tensorflow/tf.lite.experimental.microfrontend.python.ops.htm">tf.lite.experimental.microfrontend.python.ops</a>
        </li>
				<li>
            <a href="../tensorflow/tf.lite.experimental.nn.htm">tf.lite.experimental.nn</a>
        </li>
				<li>
            <a href="../tensorflow/tf.logging.htm">tf.logging</a>
        </li>
				<li>
            <a href="../tensorflow/tf.losses.htm">tf.losses</a>
        </li>
				<li>
            <a href="../tensorflow/tf.math.htm">tf.math</a>
        </li>
				<li>
            <a href="../tensorflow/tf.metrics.htm">tf.metrics</a>
        </li>
				<li>
            <a href="../tensorflow/tf.nest.htm" class="current">tf.nest</a>
        </li>
				<li>
            <a href="../tensorflow/tf.nn.htm">tf.nn</a>
        </li>
				<li>
            <a href="../tensorflow/tf.profiler.htm">tf.profiler</a>
        </li>
				<li>
            <a href="../tensorflow/tf.quantization.htm">tf.quantization</a>
        </li>
				<li>
            <a href="../tensorflow/tf.ragged.htm">tf.ragged</a>
        </li>
				<li>
            <a href="../tensorflow/tf.random.htm">tf.random</a>
        </li>
				<li>
            <a href="../tensorflow/tf.random.experimental.htm">tf.random.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.resource_loader.htm">tf.resource_loader</a>
        </li>
				<li>
            <a href="../tensorflow/tf.saved_model.htm">tf.saved_model</a>
        </li>
				<li>
            <a href="../tensorflow/tf.saved_model.main_op.htm">tf.saved_model.main_op</a>
        </li>
				<li>
            <a href="../tensorflow/tf.sets.htm">tf.sets</a>
        </li>
				<li>
            <a href="../tensorflow/tf.signal.htm">tf.signal</a>
        </li>
				<li>
            <a href="../tensorflow/tf.sparse.htm">tf.sparse</a>
        </li>
				<li>
            <a href="../tensorflow/tf.strings.htm">tf.strings</a>
        </li>
				<li>
            <a href="../tensorflow/tf.summary.htm">tf.summary</a>
        </li>
				<li>
            <a href="../tensorflow/tf.summary.experimental.htm">tf.summary.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.sysconfig.htm">tf.sysconfig</a>
        </li>
				<li>
            <a href="../tensorflow/tf.test.htm">tf.test</a>
        </li>
				<li>
            <a href="../tensorflow/tf.tpu.htm">tf.tpu</a>
        </li>
				<li>
            <a href="../tensorflow/tf.tpu.experimental.htm">tf.tpu.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.train.htm">tf.train</a>
        </li>
				<li>
            <a href="../tensorflow/tf.train.experimental.htm">tf.train.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.user_ops.htm">tf.user_ops</a>
        </li>
				<li>
            <a href="../tensorflow/tf.xla.htm">tf.xla</a>
        </li>
				<li>
            <a href="../tensorflow/tf.xla.experimental.htm">tf.xla.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/TFRecordReader.htm">TFRecordReader</a>
        </li>
				<li>
            <a href="../tensorflow/truncated_normal_initializer.htm">truncated_normal_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/TypeSpec.htm">TypeSpec</a>
        </li>
				<li>
            <a href="../tensorflow/UnconnectedGradients.htm">UnconnectedGradients</a>
        </li>
				<li>
            <a href="../tensorflow/uniform_unit_scaling_initializer.htm">uniform_unit_scaling_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/Variable.htm">Variable</a>
        </li>
				<li>
            <a href="../tensorflow/variable_scope.htm">variable_scope</a>
        </li>
				<li>
            <a href="../tensorflow/VariableAggregation.htm">VariableAggregation</a>
        </li>
				<li>
            <a href="../tensorflow/VariableScope.htm">VariableScope</a>
        </li>
				<li>
            <a href="../tensorflow/VariableSynchronization.htm">VariableSynchronization</a>
        </li>
				<li>
            <a href="../tensorflow/variance_scaling_initializer.htm">variance_scaling_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/VarLenFeature.htm">VarLenFeature</a>
        </li>
				<li>
            <a href="../tensorflow/WholeFileReader.htm">WholeFileReader</a>
        </li>
				<li>
            <a href="../tensorflow/zeros_initializer.htm">zeros_initializer</a>
        </li>
		</ul>
	</div>
</nav>
	<article>
    <header>
		<p class="class"><strong>Type</strong> tf.nest</p>
	</header>
	<section>
		<header>
		<p><strong>Namespace</strong> tensorflow</p>
		</header>
    <div class="sub-header">
		
		
			<h3 class="section">Methods</h3>
			<ul>
				<li><a href="../tensorflow/tf.nest.htm#assert_same_structure">assert_same_structure</a></li>
				<li><a href="../tensorflow/tf.nest.htm#assert_same_structure">assert_same_structure</a></li>
				<li><a href="../tensorflow/tf.nest.htm#assert_same_structure">assert_same_structure</a></li>
				<li><a href="../tensorflow/tf.nest.htm#assert_same_structure">assert_same_structure</a></li>
				<li><a href="../tensorflow/tf.nest.htm#assert_same_structure">assert_same_structure</a></li>
				<li><a href="../tensorflow/tf.nest.htm#assert_same_structure">assert_same_structure</a></li>
				<li><a href="../tensorflow/tf.nest.htm#assert_same_structure">assert_same_structure</a></li>
				<li><a href="../tensorflow/tf.nest.htm#assert_same_structure">assert_same_structure</a></li>
				<li><a href="../tensorflow/tf.nest.htm#assert_same_structure">assert_same_structure</a></li>
				<li><a href="../tensorflow/tf.nest.htm#assert_same_structure">assert_same_structure</a></li>
				<li><a href="../tensorflow/tf.nest.htm#assert_same_structure">assert_same_structure</a></li>
				<li><a href="../tensorflow/tf.nest.htm#assert_same_structure">assert_same_structure</a></li>
				<li><a href="../tensorflow/tf.nest.htm#assert_same_structure">assert_same_structure</a></li>
				<li><a href="../tensorflow/tf.nest.htm#assert_same_structure">assert_same_structure</a></li>
				<li><a href="../tensorflow/tf.nest.htm#assert_same_structure">assert_same_structure</a></li>
				<li><a href="../tensorflow/tf.nest.htm#assert_same_structure">assert_same_structure</a></li>
				<li><a href="../tensorflow/tf.nest.htm#assert_same_structure">assert_same_structure</a></li>
				<li><a href="../tensorflow/tf.nest.htm#assert_same_structure">assert_same_structure</a></li>
				<li><a href="../tensorflow/tf.nest.htm#assert_same_structure_dyn">assert_same_structure_dyn</a></li>
				<li><a href="../tensorflow/tf.nest.htm#flatten">flatten</a></li>
				<li><a href="../tensorflow/tf.nest.htm#flatten">flatten</a></li>
				<li><a href="../tensorflow/tf.nest.htm#flatten">flatten</a></li>
				<li><a href="../tensorflow/tf.nest.htm#flatten">flatten</a></li>
				<li><a href="../tensorflow/tf.nest.htm#flatten">flatten</a></li>
				<li><a href="../tensorflow/tf.nest.htm#flatten">flatten</a></li>
				<li><a href="../tensorflow/tf.nest.htm#flatten_dyn">flatten_dyn</a></li>
				<li><a href="../tensorflow/tf.nest.htm#is_nested">is_nested</a></li>
				<li><a href="../tensorflow/tf.nest.htm#is_nested_dyn">is_nested_dyn</a></li>
				<li><a href="../tensorflow/tf.nest.htm#pack_sequence_as">pack_sequence_as</a></li>
				<li><a href="../tensorflow/tf.nest.htm#pack_sequence_as">pack_sequence_as</a></li>
				<li><a href="../tensorflow/tf.nest.htm#pack_sequence_as">pack_sequence_as</a></li>
				<li><a href="../tensorflow/tf.nest.htm#pack_sequence_as">pack_sequence_as</a></li>
				<li><a href="../tensorflow/tf.nest.htm#pack_sequence_as">pack_sequence_as</a></li>
				<li><a href="../tensorflow/tf.nest.htm#pack_sequence_as">pack_sequence_as</a></li>
				<li><a href="../tensorflow/tf.nest.htm#pack_sequence_as">pack_sequence_as</a></li>
				<li><a href="../tensorflow/tf.nest.htm#pack_sequence_as">pack_sequence_as</a></li>
				<li><a href="../tensorflow/tf.nest.htm#pack_sequence_as">pack_sequence_as</a></li>
				<li><a href="../tensorflow/tf.nest.htm#pack_sequence_as">pack_sequence_as</a></li>
				<li><a href="../tensorflow/tf.nest.htm#pack_sequence_as">pack_sequence_as</a></li>
				<li><a href="../tensorflow/tf.nest.htm#pack_sequence_as">pack_sequence_as</a></li>
				<li><a href="../tensorflow/tf.nest.htm#pack_sequence_as">pack_sequence_as</a></li>
				<li><a href="../tensorflow/tf.nest.htm#pack_sequence_as">pack_sequence_as</a></li>
				<li><a href="../tensorflow/tf.nest.htm#pack_sequence_as">pack_sequence_as</a></li>
				<li><a href="../tensorflow/tf.nest.htm#pack_sequence_as">pack_sequence_as</a></li>
				<li><a href="../tensorflow/tf.nest.htm#pack_sequence_as">pack_sequence_as</a></li>
				<li><a href="../tensorflow/tf.nest.htm#pack_sequence_as">pack_sequence_as</a></li>
				<li><a href="../tensorflow/tf.nest.htm#pack_sequence_as_dyn">pack_sequence_as_dyn</a></li>
			</ul>
		
			<h3 class="section">Properties</h3>
			<ul>
				<li><a href="../tensorflow/tf.nest.htm#assert_same_structure_fn">assert_same_structure_fn</a></li>
				<li><a href="../tensorflow/tf.nest.htm#flatten_fn">flatten_fn</a></li>
				<li><a href="../tensorflow/tf.nest.htm#is_nested_fn">is_nested_fn</a></li>
				<li><a href="../tensorflow/tf.nest.htm#map_structure_fn">map_structure_fn</a></li>
				<li><a href="../tensorflow/tf.nest.htm#pack_sequence_as_fn">pack_sequence_as_fn</a></li>
			</ul>
		
	</div>
	
	
	<h3 class="section">Public static methods</h3>

	<div id="assert_same_structure" class="method">
		<h4>
			<span title="System.void">void</span> <strong>assert_same_structure</strong>(<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> nest1, <span title="System.object">object</span> nest2, <span title="System.string">string</span> check_types, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> expand_composites)
		</h4>
		<div class="content">Asserts that two structures are nested in the same way. <p></p> Note that namedtuples with identical name and fields are always considered
to have the same shallow structure (even with `check_types=True`).
For instance, this code will print `True`: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> nest1
						</dt>
						<dd>an arbitrarily nested structure. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> nest2
						</dt>
						<dd>an arbitrarily nested structure. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> check_types
						</dt>
						<dd>if `True` (default) types of sequences are checked as well,
including the keys of dictionaries. If set to `False`, for example a
list and a tuple of objects will look the same if they have the same
size. Note that namedtuples with identical name and fields are always
considered to have the same shallow structure. Two types will also be
considered the same if they are both list subtypes (which allows "list"
and "_ListWrapper" from trackable dependency tracking to compare
equal). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> expand_composites
						</dt>
						<dd>If true, then composite tensors such as <a href="..\..\tf\sparse\SparseTensor.md"><code>tf.SparseTensor</code></a>
and <a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a> are expanded into their component tensors. 
						</dd>
				</dl>
			</div>

<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>def nt(a, b):
              return collections.namedtuple('foo', 'a b')(a, b)
            print(assert_same_structure(nt(0, 1), nt(2, 3))) </pre>
</div>
		</div>
	</div>
	<div id="assert_same_structure" class="method">
		<h4>
			<span title="System.void">void</span> <strong>assert_same_structure</strong>(<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> nest1, <span title="System.object">object</span> nest2, <span title="System.bool">bool</span> check_types, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> expand_composites)
		</h4>
		<div class="content">Asserts that two structures are nested in the same way. <p></p> Note that namedtuples with identical name and fields are always considered
to have the same shallow structure (even with `check_types=True`).
For instance, this code will print `True`: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> nest1
						</dt>
						<dd>an arbitrarily nested structure. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> nest2
						</dt>
						<dd>an arbitrarily nested structure. 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> check_types
						</dt>
						<dd>if `True` (default) types of sequences are checked as well,
including the keys of dictionaries. If set to `False`, for example a
list and a tuple of objects will look the same if they have the same
size. Note that namedtuples with identical name and fields are always
considered to have the same shallow structure. Two types will also be
considered the same if they are both list subtypes (which allows "list"
and "_ListWrapper" from trackable dependency tracking to compare
equal). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> expand_composites
						</dt>
						<dd>If true, then composite tensors such as <a href="..\..\tf\sparse\SparseTensor.md"><code>tf.SparseTensor</code></a>
and <a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a> are expanded into their component tensors. 
						</dd>
				</dl>
			</div>

<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>def nt(a, b):
              return collections.namedtuple('foo', 'a b')(a, b)
            print(assert_same_structure(nt(0, 1), nt(2, 3))) </pre>
</div>
		</div>
	</div>
	<div id="assert_same_structure" class="method">
		<h4>
			<span title="System.void">void</span> <strong>assert_same_structure</strong>(<span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span> nest1, <span title="System.object">object</span> nest2, <span title="System.string">string</span> check_types, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> expand_composites)
		</h4>
		<div class="content">Asserts that two structures are nested in the same way. <p></p> Note that namedtuples with identical name and fields are always considered
to have the same shallow structure (even with `check_types=True`).
For instance, this code will print `True`: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span></code> nest1
						</dt>
						<dd>an arbitrarily nested structure. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> nest2
						</dt>
						<dd>an arbitrarily nested structure. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> check_types
						</dt>
						<dd>if `True` (default) types of sequences are checked as well,
including the keys of dictionaries. If set to `False`, for example a
list and a tuple of objects will look the same if they have the same
size. Note that namedtuples with identical name and fields are always
considered to have the same shallow structure. Two types will also be
considered the same if they are both list subtypes (which allows "list"
and "_ListWrapper" from trackable dependency tracking to compare
equal). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> expand_composites
						</dt>
						<dd>If true, then composite tensors such as <a href="..\..\tf\sparse\SparseTensor.md"><code>tf.SparseTensor</code></a>
and <a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a> are expanded into their component tensors. 
						</dd>
				</dl>
			</div>

<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>def nt(a, b):
              return collections.namedtuple('foo', 'a b')(a, b)
            print(assert_same_structure(nt(0, 1), nt(2, 3))) </pre>
</div>
		</div>
	</div>
	<div id="assert_same_structure" class="method">
		<h4>
			<span title="System.void">void</span> <strong>assert_same_structure</strong>(<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> nest1, <span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span> nest2, <span title="System.bool">bool</span> check_types, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> expand_composites)
		</h4>
		<div class="content">Asserts that two structures are nested in the same way. <p></p> Note that namedtuples with identical name and fields are always considered
to have the same shallow structure (even with `check_types=True`).
For instance, this code will print `True`: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> nest1
						</dt>
						<dd>an arbitrarily nested structure. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span></code> nest2
						</dt>
						<dd>an arbitrarily nested structure. 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> check_types
						</dt>
						<dd>if `True` (default) types of sequences are checked as well,
including the keys of dictionaries. If set to `False`, for example a
list and a tuple of objects will look the same if they have the same
size. Note that namedtuples with identical name and fields are always
considered to have the same shallow structure. Two types will also be
considered the same if they are both list subtypes (which allows "list"
and "_ListWrapper" from trackable dependency tracking to compare
equal). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> expand_composites
						</dt>
						<dd>If true, then composite tensors such as <a href="..\..\tf\sparse\SparseTensor.md"><code>tf.SparseTensor</code></a>
and <a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a> are expanded into their component tensors. 
						</dd>
				</dl>
			</div>

<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>def nt(a, b):
              return collections.namedtuple('foo', 'a b')(a, b)
            print(assert_same_structure(nt(0, 1), nt(2, 3))) </pre>
</div>
		</div>
	</div>
	<div id="assert_same_structure" class="method">
		<h4>
			<span title="System.void">void</span> <strong>assert_same_structure</strong>(<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> nest1, <span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span> nest2, <span title="System.string">string</span> check_types, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> expand_composites)
		</h4>
		<div class="content">Asserts that two structures are nested in the same way. <p></p> Note that namedtuples with identical name and fields are always considered
to have the same shallow structure (even with `check_types=True`).
For instance, this code will print `True`: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> nest1
						</dt>
						<dd>an arbitrarily nested structure. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span></code> nest2
						</dt>
						<dd>an arbitrarily nested structure. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> check_types
						</dt>
						<dd>if `True` (default) types of sequences are checked as well,
including the keys of dictionaries. If set to `False`, for example a
list and a tuple of objects will look the same if they have the same
size. Note that namedtuples with identical name and fields are always
considered to have the same shallow structure. Two types will also be
considered the same if they are both list subtypes (which allows "list"
and "_ListWrapper" from trackable dependency tracking to compare
equal). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> expand_composites
						</dt>
						<dd>If true, then composite tensors such as <a href="..\..\tf\sparse\SparseTensor.md"><code>tf.SparseTensor</code></a>
and <a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a> are expanded into their component tensors. 
						</dd>
				</dl>
			</div>

<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>def nt(a, b):
              return collections.namedtuple('foo', 'a b')(a, b)
            print(assert_same_structure(nt(0, 1), nt(2, 3))) </pre>
</div>
		</div>
	</div>
	<div id="assert_same_structure" class="method">
		<h4>
			<span title="System.void">void</span> <strong>assert_same_structure</strong>(<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> nest1, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> nest2, <span title="System.bool">bool</span> check_types, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> expand_composites)
		</h4>
		<div class="content">Asserts that two structures are nested in the same way. <p></p> Note that namedtuples with identical name and fields are always considered
to have the same shallow structure (even with `check_types=True`).
For instance, this code will print `True`: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> nest1
						</dt>
						<dd>an arbitrarily nested structure. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> nest2
						</dt>
						<dd>an arbitrarily nested structure. 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> check_types
						</dt>
						<dd>if `True` (default) types of sequences are checked as well,
including the keys of dictionaries. If set to `False`, for example a
list and a tuple of objects will look the same if they have the same
size. Note that namedtuples with identical name and fields are always
considered to have the same shallow structure. Two types will also be
considered the same if they are both list subtypes (which allows "list"
and "_ListWrapper" from trackable dependency tracking to compare
equal). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> expand_composites
						</dt>
						<dd>If true, then composite tensors such as <a href="..\..\tf\sparse\SparseTensor.md"><code>tf.SparseTensor</code></a>
and <a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a> are expanded into their component tensors. 
						</dd>
				</dl>
			</div>

<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>def nt(a, b):
              return collections.namedtuple('foo', 'a b')(a, b)
            print(assert_same_structure(nt(0, 1), nt(2, 3))) </pre>
</div>
		</div>
	</div>
	<div id="assert_same_structure" class="method">
		<h4>
			<span title="System.void">void</span> <strong>assert_same_structure</strong>(<span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span> nest1, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> nest2, <span title="System.bool">bool</span> check_types, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> expand_composites)
		</h4>
		<div class="content">Asserts that two structures are nested in the same way. <p></p> Note that namedtuples with identical name and fields are always considered
to have the same shallow structure (even with `check_types=True`).
For instance, this code will print `True`: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span></code> nest1
						</dt>
						<dd>an arbitrarily nested structure. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> nest2
						</dt>
						<dd>an arbitrarily nested structure. 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> check_types
						</dt>
						<dd>if `True` (default) types of sequences are checked as well,
including the keys of dictionaries. If set to `False`, for example a
list and a tuple of objects will look the same if they have the same
size. Note that namedtuples with identical name and fields are always
considered to have the same shallow structure. Two types will also be
considered the same if they are both list subtypes (which allows "list"
and "_ListWrapper" from trackable dependency tracking to compare
equal). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> expand_composites
						</dt>
						<dd>If true, then composite tensors such as <a href="..\..\tf\sparse\SparseTensor.md"><code>tf.SparseTensor</code></a>
and <a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a> are expanded into their component tensors. 
						</dd>
				</dl>
			</div>

<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>def nt(a, b):
              return collections.namedtuple('foo', 'a b')(a, b)
            print(assert_same_structure(nt(0, 1), nt(2, 3))) </pre>
</div>
		</div>
	</div>
	<div id="assert_same_structure" class="method">
		<h4>
			<span title="System.void">void</span> <strong>assert_same_structure</strong>(<span title="System.object">object</span> nest1, <span title="System.object">object</span> nest2, <span title="System.string">string</span> check_types, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> expand_composites)
		</h4>
		<div class="content">Asserts that two structures are nested in the same way. <p></p> Note that namedtuples with identical name and fields are always considered
to have the same shallow structure (even with `check_types=True`).
For instance, this code will print `True`: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> nest1
						</dt>
						<dd>an arbitrarily nested structure. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> nest2
						</dt>
						<dd>an arbitrarily nested structure. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> check_types
						</dt>
						<dd>if `True` (default) types of sequences are checked as well,
including the keys of dictionaries. If set to `False`, for example a
list and a tuple of objects will look the same if they have the same
size. Note that namedtuples with identical name and fields are always
considered to have the same shallow structure. Two types will also be
considered the same if they are both list subtypes (which allows "list"
and "_ListWrapper" from trackable dependency tracking to compare
equal). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> expand_composites
						</dt>
						<dd>If true, then composite tensors such as <a href="..\..\tf\sparse\SparseTensor.md"><code>tf.SparseTensor</code></a>
and <a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a> are expanded into their component tensors. 
						</dd>
				</dl>
			</div>

<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>def nt(a, b):
              return collections.namedtuple('foo', 'a b')(a, b)
            print(assert_same_structure(nt(0, 1), nt(2, 3))) </pre>
</div>
		</div>
	</div>
	<div id="assert_same_structure" class="method">
		<h4>
			<span title="System.void">void</span> <strong>assert_same_structure</strong>(<span title="System.object">object</span> nest1, <span title="System.object">object</span> nest2, <span title="System.bool">bool</span> check_types, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> expand_composites)
		</h4>
		<div class="content">Asserts that two structures are nested in the same way. <p></p> Note that namedtuples with identical name and fields are always considered
to have the same shallow structure (even with `check_types=True`).
For instance, this code will print `True`: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> nest1
						</dt>
						<dd>an arbitrarily nested structure. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> nest2
						</dt>
						<dd>an arbitrarily nested structure. 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> check_types
						</dt>
						<dd>if `True` (default) types of sequences are checked as well,
including the keys of dictionaries. If set to `False`, for example a
list and a tuple of objects will look the same if they have the same
size. Note that namedtuples with identical name and fields are always
considered to have the same shallow structure. Two types will also be
considered the same if they are both list subtypes (which allows "list"
and "_ListWrapper" from trackable dependency tracking to compare
equal). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> expand_composites
						</dt>
						<dd>If true, then composite tensors such as <a href="..\..\tf\sparse\SparseTensor.md"><code>tf.SparseTensor</code></a>
and <a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a> are expanded into their component tensors. 
						</dd>
				</dl>
			</div>

<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>def nt(a, b):
              return collections.namedtuple('foo', 'a b')(a, b)
            print(assert_same_structure(nt(0, 1), nt(2, 3))) </pre>
</div>
		</div>
	</div>
	<div id="assert_same_structure" class="method">
		<h4>
			<span title="System.void">void</span> <strong>assert_same_structure</strong>(<span title="System.object">object</span> nest1, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> nest2, <span title="System.string">string</span> check_types, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> expand_composites)
		</h4>
		<div class="content">Asserts that two structures are nested in the same way. <p></p> Note that namedtuples with identical name and fields are always considered
to have the same shallow structure (even with `check_types=True`).
For instance, this code will print `True`: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> nest1
						</dt>
						<dd>an arbitrarily nested structure. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> nest2
						</dt>
						<dd>an arbitrarily nested structure. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> check_types
						</dt>
						<dd>if `True` (default) types of sequences are checked as well,
including the keys of dictionaries. If set to `False`, for example a
list and a tuple of objects will look the same if they have the same
size. Note that namedtuples with identical name and fields are always
considered to have the same shallow structure. Two types will also be
considered the same if they are both list subtypes (which allows "list"
and "_ListWrapper" from trackable dependency tracking to compare
equal). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> expand_composites
						</dt>
						<dd>If true, then composite tensors such as <a href="..\..\tf\sparse\SparseTensor.md"><code>tf.SparseTensor</code></a>
and <a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a> are expanded into their component tensors. 
						</dd>
				</dl>
			</div>

<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>def nt(a, b):
              return collections.namedtuple('foo', 'a b')(a, b)
            print(assert_same_structure(nt(0, 1), nt(2, 3))) </pre>
</div>
		</div>
	</div>
	<div id="assert_same_structure" class="method">
		<h4>
			<span title="System.void">void</span> <strong>assert_same_structure</strong>(<span title="System.object">object</span> nest1, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> nest2, <span title="System.bool">bool</span> check_types, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> expand_composites)
		</h4>
		<div class="content">Asserts that two structures are nested in the same way. <p></p> Note that namedtuples with identical name and fields are always considered
to have the same shallow structure (even with `check_types=True`).
For instance, this code will print `True`: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> nest1
						</dt>
						<dd>an arbitrarily nested structure. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> nest2
						</dt>
						<dd>an arbitrarily nested structure. 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> check_types
						</dt>
						<dd>if `True` (default) types of sequences are checked as well,
including the keys of dictionaries. If set to `False`, for example a
list and a tuple of objects will look the same if they have the same
size. Note that namedtuples with identical name and fields are always
considered to have the same shallow structure. Two types will also be
considered the same if they are both list subtypes (which allows "list"
and "_ListWrapper" from trackable dependency tracking to compare
equal). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> expand_composites
						</dt>
						<dd>If true, then composite tensors such as <a href="..\..\tf\sparse\SparseTensor.md"><code>tf.SparseTensor</code></a>
and <a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a> are expanded into their component tensors. 
						</dd>
				</dl>
			</div>

<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>def nt(a, b):
              return collections.namedtuple('foo', 'a b')(a, b)
            print(assert_same_structure(nt(0, 1), nt(2, 3))) </pre>
</div>
		</div>
	</div>
	<div id="assert_same_structure" class="method">
		<h4>
			<span title="System.void">void</span> <strong>assert_same_structure</strong>(<span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span> nest1, <span title="System.object">object</span> nest2, <span title="System.bool">bool</span> check_types, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> expand_composites)
		</h4>
		<div class="content">Asserts that two structures are nested in the same way. <p></p> Note that namedtuples with identical name and fields are always considered
to have the same shallow structure (even with `check_types=True`).
For instance, this code will print `True`: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span></code> nest1
						</dt>
						<dd>an arbitrarily nested structure. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> nest2
						</dt>
						<dd>an arbitrarily nested structure. 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> check_types
						</dt>
						<dd>if `True` (default) types of sequences are checked as well,
including the keys of dictionaries. If set to `False`, for example a
list and a tuple of objects will look the same if they have the same
size. Note that namedtuples with identical name and fields are always
considered to have the same shallow structure. Two types will also be
considered the same if they are both list subtypes (which allows "list"
and "_ListWrapper" from trackable dependency tracking to compare
equal). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> expand_composites
						</dt>
						<dd>If true, then composite tensors such as <a href="..\..\tf\sparse\SparseTensor.md"><code>tf.SparseTensor</code></a>
and <a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a> are expanded into their component tensors. 
						</dd>
				</dl>
			</div>

<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>def nt(a, b):
              return collections.namedtuple('foo', 'a b')(a, b)
            print(assert_same_structure(nt(0, 1), nt(2, 3))) </pre>
</div>
		</div>
	</div>
	<div id="assert_same_structure" class="method">
		<h4>
			<span title="System.void">void</span> <strong>assert_same_structure</strong>(<span title="System.object">object</span> nest1, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> nest2, <span title="System.string">string</span> check_types, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> expand_composites)
		</h4>
		<div class="content">Asserts that two structures are nested in the same way. <p></p> Note that namedtuples with identical name and fields are always considered
to have the same shallow structure (even with `check_types=True`).
For instance, this code will print `True`: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> nest1
						</dt>
						<dd>an arbitrarily nested structure. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> nest2
						</dt>
						<dd>an arbitrarily nested structure. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> check_types
						</dt>
						<dd>if `True` (default) types of sequences are checked as well,
including the keys of dictionaries. If set to `False`, for example a
list and a tuple of objects will look the same if they have the same
size. Note that namedtuples with identical name and fields are always
considered to have the same shallow structure. Two types will also be
considered the same if they are both list subtypes (which allows "list"
and "_ListWrapper" from trackable dependency tracking to compare
equal). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> expand_composites
						</dt>
						<dd>If true, then composite tensors such as <a href="..\..\tf\sparse\SparseTensor.md"><code>tf.SparseTensor</code></a>
and <a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a> are expanded into their component tensors. 
						</dd>
				</dl>
			</div>

<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>def nt(a, b):
              return collections.namedtuple('foo', 'a b')(a, b)
            print(assert_same_structure(nt(0, 1), nt(2, 3))) </pre>
</div>
		</div>
	</div>
	<div id="assert_same_structure" class="method">
		<h4>
			<span title="System.void">void</span> <strong>assert_same_structure</strong>(<span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span> nest1, <span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span> nest2, <span title="System.bool">bool</span> check_types, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> expand_composites)
		</h4>
		<div class="content">Asserts that two structures are nested in the same way. <p></p> Note that namedtuples with identical name and fields are always considered
to have the same shallow structure (even with `check_types=True`).
For instance, this code will print `True`: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span></code> nest1
						</dt>
						<dd>an arbitrarily nested structure. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span></code> nest2
						</dt>
						<dd>an arbitrarily nested structure. 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> check_types
						</dt>
						<dd>if `True` (default) types of sequences are checked as well,
including the keys of dictionaries. If set to `False`, for example a
list and a tuple of objects will look the same if they have the same
size. Note that namedtuples with identical name and fields are always
considered to have the same shallow structure. Two types will also be
considered the same if they are both list subtypes (which allows "list"
and "_ListWrapper" from trackable dependency tracking to compare
equal). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> expand_composites
						</dt>
						<dd>If true, then composite tensors such as <a href="..\..\tf\sparse\SparseTensor.md"><code>tf.SparseTensor</code></a>
and <a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a> are expanded into their component tensors. 
						</dd>
				</dl>
			</div>

<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>def nt(a, b):
              return collections.namedtuple('foo', 'a b')(a, b)
            print(assert_same_structure(nt(0, 1), nt(2, 3))) </pre>
</div>
		</div>
	</div>
	<div id="assert_same_structure" class="method">
		<h4>
			<span title="System.void">void</span> <strong>assert_same_structure</strong>(<span title="System.object">object</span> nest1, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> nest2, <span title="System.bool">bool</span> check_types, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> expand_composites)
		</h4>
		<div class="content">Asserts that two structures are nested in the same way. <p></p> Note that namedtuples with identical name and fields are always considered
to have the same shallow structure (even with `check_types=True`).
For instance, this code will print `True`: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> nest1
						</dt>
						<dd>an arbitrarily nested structure. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> nest2
						</dt>
						<dd>an arbitrarily nested structure. 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> check_types
						</dt>
						<dd>if `True` (default) types of sequences are checked as well,
including the keys of dictionaries. If set to `False`, for example a
list and a tuple of objects will look the same if they have the same
size. Note that namedtuples with identical name and fields are always
considered to have the same shallow structure. Two types will also be
considered the same if they are both list subtypes (which allows "list"
and "_ListWrapper" from trackable dependency tracking to compare
equal). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> expand_composites
						</dt>
						<dd>If true, then composite tensors such as <a href="..\..\tf\sparse\SparseTensor.md"><code>tf.SparseTensor</code></a>
and <a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a> are expanded into their component tensors. 
						</dd>
				</dl>
			</div>

<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>def nt(a, b):
              return collections.namedtuple('foo', 'a b')(a, b)
            print(assert_same_structure(nt(0, 1), nt(2, 3))) </pre>
</div>
		</div>
	</div>
	<div id="assert_same_structure" class="method">
		<h4>
			<span title="System.void">void</span> <strong>assert_same_structure</strong>(<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> nest1, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> nest2, <span title="System.string">string</span> check_types, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> expand_composites)
		</h4>
		<div class="content">Asserts that two structures are nested in the same way. <p></p> Note that namedtuples with identical name and fields are always considered
to have the same shallow structure (even with `check_types=True`).
For instance, this code will print `True`: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> nest1
						</dt>
						<dd>an arbitrarily nested structure. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> nest2
						</dt>
						<dd>an arbitrarily nested structure. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> check_types
						</dt>
						<dd>if `True` (default) types of sequences are checked as well,
including the keys of dictionaries. If set to `False`, for example a
list and a tuple of objects will look the same if they have the same
size. Note that namedtuples with identical name and fields are always
considered to have the same shallow structure. Two types will also be
considered the same if they are both list subtypes (which allows "list"
and "_ListWrapper" from trackable dependency tracking to compare
equal). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> expand_composites
						</dt>
						<dd>If true, then composite tensors such as <a href="..\..\tf\sparse\SparseTensor.md"><code>tf.SparseTensor</code></a>
and <a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a> are expanded into their component tensors. 
						</dd>
				</dl>
			</div>

<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>def nt(a, b):
              return collections.namedtuple('foo', 'a b')(a, b)
            print(assert_same_structure(nt(0, 1), nt(2, 3))) </pre>
</div>
		</div>
	</div>
	<div id="assert_same_structure" class="method">
		<h4>
			<span title="System.void">void</span> <strong>assert_same_structure</strong>(<span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span> nest1, <span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span> nest2, <span title="System.string">string</span> check_types, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> expand_composites)
		</h4>
		<div class="content">Asserts that two structures are nested in the same way. <p></p> Note that namedtuples with identical name and fields are always considered
to have the same shallow structure (even with `check_types=True`).
For instance, this code will print `True`: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span></code> nest1
						</dt>
						<dd>an arbitrarily nested structure. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span></code> nest2
						</dt>
						<dd>an arbitrarily nested structure. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> check_types
						</dt>
						<dd>if `True` (default) types of sequences are checked as well,
including the keys of dictionaries. If set to `False`, for example a
list and a tuple of objects will look the same if they have the same
size. Note that namedtuples with identical name and fields are always
considered to have the same shallow structure. Two types will also be
considered the same if they are both list subtypes (which allows "list"
and "_ListWrapper" from trackable dependency tracking to compare
equal). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> expand_composites
						</dt>
						<dd>If true, then composite tensors such as <a href="..\..\tf\sparse\SparseTensor.md"><code>tf.SparseTensor</code></a>
and <a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a> are expanded into their component tensors. 
						</dd>
				</dl>
			</div>

<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>def nt(a, b):
              return collections.namedtuple('foo', 'a b')(a, b)
            print(assert_same_structure(nt(0, 1), nt(2, 3))) </pre>
</div>
		</div>
	</div>
	<div id="assert_same_structure" class="method">
		<h4>
			<span title="System.void">void</span> <strong>assert_same_structure</strong>(<span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span> nest1, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> nest2, <span title="System.string">string</span> check_types, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> expand_composites)
		</h4>
		<div class="content">Asserts that two structures are nested in the same way. <p></p> Note that namedtuples with identical name and fields are always considered
to have the same shallow structure (even with `check_types=True`).
For instance, this code will print `True`: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span></code> nest1
						</dt>
						<dd>an arbitrarily nested structure. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> nest2
						</dt>
						<dd>an arbitrarily nested structure. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> check_types
						</dt>
						<dd>if `True` (default) types of sequences are checked as well,
including the keys of dictionaries. If set to `False`, for example a
list and a tuple of objects will look the same if they have the same
size. Note that namedtuples with identical name and fields are always
considered to have the same shallow structure. Two types will also be
considered the same if they are both list subtypes (which allows "list"
and "_ListWrapper" from trackable dependency tracking to compare
equal). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> expand_composites
						</dt>
						<dd>If true, then composite tensors such as <a href="..\..\tf\sparse\SparseTensor.md"><code>tf.SparseTensor</code></a>
and <a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a> are expanded into their component tensors. 
						</dd>
				</dl>
			</div>

<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>def nt(a, b):
              return collections.namedtuple('foo', 'a b')(a, b)
            print(assert_same_structure(nt(0, 1), nt(2, 3))) </pre>
</div>
		</div>
	</div>
	<div id="assert_same_structure_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>assert_same_structure_dyn</strong>(<span title="System.object">object</span> nest1, <span title="System.object">object</span> nest2, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> check_types, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> expand_composites)
		</h4>
		<div class="content">Asserts that two structures are nested in the same way. <p></p> Note that namedtuples with identical name and fields are always considered
to have the same shallow structure (even with `check_types=True`).
For instance, this code will print `True`: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> nest1
						</dt>
						<dd>an arbitrarily nested structure. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> nest2
						</dt>
						<dd>an arbitrarily nested structure. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> check_types
						</dt>
						<dd>if `True` (default) types of sequences are checked as well,
including the keys of dictionaries. If set to `False`, for example a
list and a tuple of objects will look the same if they have the same
size. Note that namedtuples with identical name and fields are always
considered to have the same shallow structure. Two types will also be
considered the same if they are both list subtypes (which allows "list"
and "_ListWrapper" from trackable dependency tracking to compare
equal). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> expand_composites
						</dt>
						<dd>If true, then composite tensors such as <a href="..\..\tf\sparse\SparseTensor.md"><code>tf.SparseTensor</code></a>
and <a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a> are expanded into their component tensors. 
						</dd>
				</dl>
			</div>

<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>def nt(a, b):
              return collections.namedtuple('foo', 'a b')(a, b)
            print(assert_same_structure(nt(0, 1), nt(2, 3))) </pre>
</div>
		</div>
	</div>
	<div id="flatten" class="method">
		<h4>
			<span title="System.object">object</span> <strong>flatten</strong>(<span title="System.object">object</span> structure, <span title="System.string">string</span> expand_composites)
		</h4>
		<div class="content">Returns a flat list from a given nested structure. <p></p> If nest is not a sequence, tuple, or dict, then returns a single-element list:
[nest]. <p></p> In the case of dict instances, the sequence consists of the values, sorted by
key to ensure deterministic behavior. This is true also for OrderedDict
instances: their sequence order is ignored, the sorting order of keys is used
instead. The same convention is followed in pack_sequence_as. This correctly
repacks dicts and OrderedDicts after they have been flattened, and also allows
flattening an OrderedDict and then repacking it back using a corresponding
plain dict, or vice-versa. Dictionaries with non-sortable keys cannot be
flattened. <p></p> Users must not modify any collections used in nest while this function is
running. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> structure
						</dt>
						<dd>an arbitrarily nested structure or a scalar object. Note, numpy
arrays are considered scalars. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> expand_composites
						</dt>
						<dd>If true, then composite tensors such as tf.SparseTensor
and tf.RaggedTensor are expanded into their component tensors. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A Python list, the flattened version of the input. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="flatten" class="method">
		<h4>
			<span title="System.object">object</span> <strong>flatten</strong>(<span title="System.object">object</span> structure, <span title="System.bool">bool</span> expand_composites)
		</h4>
		<div class="content">Returns a flat list from a given nested structure. <p></p> If nest is not a sequence, tuple, or dict, then returns a single-element list:
[nest]. <p></p> In the case of dict instances, the sequence consists of the values, sorted by
key to ensure deterministic behavior. This is true also for OrderedDict
instances: their sequence order is ignored, the sorting order of keys is used
instead. The same convention is followed in pack_sequence_as. This correctly
repacks dicts and OrderedDicts after they have been flattened, and also allows
flattening an OrderedDict and then repacking it back using a corresponding
plain dict, or vice-versa. Dictionaries with non-sortable keys cannot be
flattened. <p></p> Users must not modify any collections used in nest while this function is
running. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> structure
						</dt>
						<dd>an arbitrarily nested structure or a scalar object. Note, numpy
arrays are considered scalars. 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> expand_composites
						</dt>
						<dd>If true, then composite tensors such as tf.SparseTensor
and tf.RaggedTensor are expanded into their component tensors. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A Python list, the flattened version of the input. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="flatten" class="method">
		<h4>
			<span title="System.object">object</span> <strong>flatten</strong>(<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> structure, <span title="System.string">string</span> expand_composites)
		</h4>
		<div class="content">Returns a flat list from a given nested structure. <p></p> If nest is not a sequence, tuple, or dict, then returns a single-element list:
[nest]. <p></p> In the case of dict instances, the sequence consists of the values, sorted by
key to ensure deterministic behavior. This is true also for OrderedDict
instances: their sequence order is ignored, the sorting order of keys is used
instead. The same convention is followed in pack_sequence_as. This correctly
repacks dicts and OrderedDicts after they have been flattened, and also allows
flattening an OrderedDict and then repacking it back using a corresponding
plain dict, or vice-versa. Dictionaries with non-sortable keys cannot be
flattened. <p></p> Users must not modify any collections used in nest while this function is
running. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> structure
						</dt>
						<dd>an arbitrarily nested structure or a scalar object. Note, numpy
arrays are considered scalars. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> expand_composites
						</dt>
						<dd>If true, then composite tensors such as tf.SparseTensor
and tf.RaggedTensor are expanded into their component tensors. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A Python list, the flattened version of the input. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="flatten" class="method">
		<h4>
			<span title="System.object">object</span> <strong>flatten</strong>(<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> structure, <span title="System.bool">bool</span> expand_composites)
		</h4>
		<div class="content">Returns a flat list from a given nested structure. <p></p> If nest is not a sequence, tuple, or dict, then returns a single-element list:
[nest]. <p></p> In the case of dict instances, the sequence consists of the values, sorted by
key to ensure deterministic behavior. This is true also for OrderedDict
instances: their sequence order is ignored, the sorting order of keys is used
instead. The same convention is followed in pack_sequence_as. This correctly
repacks dicts and OrderedDicts after they have been flattened, and also allows
flattening an OrderedDict and then repacking it back using a corresponding
plain dict, or vice-versa. Dictionaries with non-sortable keys cannot be
flattened. <p></p> Users must not modify any collections used in nest while this function is
running. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> structure
						</dt>
						<dd>an arbitrarily nested structure or a scalar object. Note, numpy
arrays are considered scalars. 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> expand_composites
						</dt>
						<dd>If true, then composite tensors such as tf.SparseTensor
and tf.RaggedTensor are expanded into their component tensors. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A Python list, the flattened version of the input. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="flatten" class="method">
		<h4>
			<span title="System.object">object</span> <strong>flatten</strong>(<span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span> structure, <span title="System.string">string</span> expand_composites)
		</h4>
		<div class="content">Returns a flat list from a given nested structure. <p></p> If nest is not a sequence, tuple, or dict, then returns a single-element list:
[nest]. <p></p> In the case of dict instances, the sequence consists of the values, sorted by
key to ensure deterministic behavior. This is true also for OrderedDict
instances: their sequence order is ignored, the sorting order of keys is used
instead. The same convention is followed in pack_sequence_as. This correctly
repacks dicts and OrderedDicts after they have been flattened, and also allows
flattening an OrderedDict and then repacking it back using a corresponding
plain dict, or vice-versa. Dictionaries with non-sortable keys cannot be
flattened. <p></p> Users must not modify any collections used in nest while this function is
running. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span></code> structure
						</dt>
						<dd>an arbitrarily nested structure or a scalar object. Note, numpy
arrays are considered scalars. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> expand_composites
						</dt>
						<dd>If true, then composite tensors such as tf.SparseTensor
and tf.RaggedTensor are expanded into their component tensors. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A Python list, the flattened version of the input. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="flatten" class="method">
		<h4>
			<span title="System.object">object</span> <strong>flatten</strong>(<span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span> structure, <span title="System.bool">bool</span> expand_composites)
		</h4>
		<div class="content">Returns a flat list from a given nested structure. <p></p> If nest is not a sequence, tuple, or dict, then returns a single-element list:
[nest]. <p></p> In the case of dict instances, the sequence consists of the values, sorted by
key to ensure deterministic behavior. This is true also for OrderedDict
instances: their sequence order is ignored, the sorting order of keys is used
instead. The same convention is followed in pack_sequence_as. This correctly
repacks dicts and OrderedDicts after they have been flattened, and also allows
flattening an OrderedDict and then repacking it back using a corresponding
plain dict, or vice-versa. Dictionaries with non-sortable keys cannot be
flattened. <p></p> Users must not modify any collections used in nest while this function is
running. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span></code> structure
						</dt>
						<dd>an arbitrarily nested structure or a scalar object. Note, numpy
arrays are considered scalars. 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> expand_composites
						</dt>
						<dd>If true, then composite tensors such as tf.SparseTensor
and tf.RaggedTensor are expanded into their component tensors. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A Python list, the flattened version of the input. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="flatten_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>flatten_dyn</strong>(<span title="System.object">object</span> structure, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> expand_composites)
		</h4>
		<div class="content">Returns a flat list from a given nested structure. <p></p> If nest is not a sequence, tuple, or dict, then returns a single-element list:
[nest]. <p></p> In the case of dict instances, the sequence consists of the values, sorted by
key to ensure deterministic behavior. This is true also for OrderedDict
instances: their sequence order is ignored, the sorting order of keys is used
instead. The same convention is followed in pack_sequence_as. This correctly
repacks dicts and OrderedDicts after they have been flattened, and also allows
flattening an OrderedDict and then repacking it back using a corresponding
plain dict, or vice-versa. Dictionaries with non-sortable keys cannot be
flattened. <p></p> Users must not modify any collections used in nest while this function is
running. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> structure
						</dt>
						<dd>an arbitrarily nested structure or a scalar object. Note, numpy
arrays are considered scalars. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> expand_composites
						</dt>
						<dd>If true, then composite tensors such as tf.SparseTensor
and tf.RaggedTensor are expanded into their component tensors. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A Python list, the flattened version of the input. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="is_nested" class="method">
		<h4>
			<span title="System.object">object</span> <strong>is_nested</strong>(<span title="System.object">object</span> seq)
		</h4>
		<div class="content">Returns true if its input is a collections.abc.Sequence (except strings). 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> seq
						</dt>
						<dd>an input sequence. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>True if the sequence is a not a string and is a collections.abc.Sequence
or a dict. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="is_nested_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>is_nested_dyn</strong>(<span title="System.object">object</span> seq)
		</h4>
		<div class="content">Returns true if its input is a collections.abc.Sequence (except strings). 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> seq
						</dt>
						<dd>an input sequence. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>True if the sequence is a not a string and is a collections.abc.Sequence
or a dict. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="pack_sequence_as" class="method">
		<h4>
			<span title="System.object">object</span> <strong>pack_sequence_as</strong>(<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> structure, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> flat_sequence, <span title="System.bool">bool</span> expand_composites)
		</h4>
		<div class="content">Returns a given flattened sequence packed into a given structure. <p></p> If `structure` is a scalar, `flat_sequence` must be a single-element list;
in this case the return value is `flat_sequence[0]`. <p></p> If `structure` is or contains a dict instance, the keys will be sorted to
pack the flat sequence in deterministic order. This is true also for
`OrderedDict` instances: their sequence order is ignored, the sorting order of
keys is used instead. The same convention is followed in `flatten`.
This correctly repacks dicts and `OrderedDict`s after they have been
flattened, and also allows flattening an `OrderedDict` and then repacking it
back using a corresponding plain dict, or vice-versa.
Dictionaries with non-sortable keys cannot be flattened. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> structure
						</dt>
						<dd>Nested structure, whose structure is given by nested lists,
tuples, and dicts. Note: numpy arrays and strings are considered
scalars. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> flat_sequence
						</dt>
						<dd>flat sequence to pack. 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> expand_composites
						</dt>
						<dd>If true, then composite tensors such as <a href="..\..\tf\sparse\SparseTensor.md"><code>tf.SparseTensor</code></a>
and <a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a> are expanded into their component tensors. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="pack_sequence_as" class="method">
		<h4>
			<span title="System.object">object</span> <strong>pack_sequence_as</strong>(<span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span> structure, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> flat_sequence, <span title="System.bool">bool</span> expand_composites)
		</h4>
		<div class="content">Returns a given flattened sequence packed into a given structure. <p></p> If `structure` is a scalar, `flat_sequence` must be a single-element list;
in this case the return value is `flat_sequence[0]`. <p></p> If `structure` is or contains a dict instance, the keys will be sorted to
pack the flat sequence in deterministic order. This is true also for
`OrderedDict` instances: their sequence order is ignored, the sorting order of
keys is used instead. The same convention is followed in `flatten`.
This correctly repacks dicts and `OrderedDict`s after they have been
flattened, and also allows flattening an `OrderedDict` and then repacking it
back using a corresponding plain dict, or vice-versa.
Dictionaries with non-sortable keys cannot be flattened. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span></code> structure
						</dt>
						<dd>Nested structure, whose structure is given by nested lists,
tuples, and dicts. Note: numpy arrays and strings are considered
scalars. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> flat_sequence
						</dt>
						<dd>flat sequence to pack. 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> expand_composites
						</dt>
						<dd>If true, then composite tensors such as <a href="..\..\tf\sparse\SparseTensor.md"><code>tf.SparseTensor</code></a>
and <a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a> are expanded into their component tensors. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="pack_sequence_as" class="method">
		<h4>
			<span title="System.object">object</span> <strong>pack_sequence_as</strong>(<span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span> structure, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> flat_sequence, <span title="System.string">string</span> expand_composites)
		</h4>
		<div class="content">Returns a given flattened sequence packed into a given structure. <p></p> If `structure` is a scalar, `flat_sequence` must be a single-element list;
in this case the return value is `flat_sequence[0]`. <p></p> If `structure` is or contains a dict instance, the keys will be sorted to
pack the flat sequence in deterministic order. This is true also for
`OrderedDict` instances: their sequence order is ignored, the sorting order of
keys is used instead. The same convention is followed in `flatten`.
This correctly repacks dicts and `OrderedDict`s after they have been
flattened, and also allows flattening an `OrderedDict` and then repacking it
back using a corresponding plain dict, or vice-versa.
Dictionaries with non-sortable keys cannot be flattened. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span></code> structure
						</dt>
						<dd>Nested structure, whose structure is given by nested lists,
tuples, and dicts. Note: numpy arrays and strings are considered
scalars. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> flat_sequence
						</dt>
						<dd>flat sequence to pack. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> expand_composites
						</dt>
						<dd>If true, then composite tensors such as <a href="..\..\tf\sparse\SparseTensor.md"><code>tf.SparseTensor</code></a>
and <a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a> are expanded into their component tensors. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="pack_sequence_as" class="method">
		<h4>
			<span title="System.object">object</span> <strong>pack_sequence_as</strong>(<span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span> structure, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> flat_sequence, <span title="System.bool">bool</span> expand_composites)
		</h4>
		<div class="content">Returns a given flattened sequence packed into a given structure. <p></p> If `structure` is a scalar, `flat_sequence` must be a single-element list;
in this case the return value is `flat_sequence[0]`. <p></p> If `structure` is or contains a dict instance, the keys will be sorted to
pack the flat sequence in deterministic order. This is true also for
`OrderedDict` instances: their sequence order is ignored, the sorting order of
keys is used instead. The same convention is followed in `flatten`.
This correctly repacks dicts and `OrderedDict`s after they have been
flattened, and also allows flattening an `OrderedDict` and then repacking it
back using a corresponding plain dict, or vice-versa.
Dictionaries with non-sortable keys cannot be flattened. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span></code> structure
						</dt>
						<dd>Nested structure, whose structure is given by nested lists,
tuples, and dicts. Note: numpy arrays and strings are considered
scalars. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> flat_sequence
						</dt>
						<dd>flat sequence to pack. 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> expand_composites
						</dt>
						<dd>If true, then composite tensors such as <a href="..\..\tf\sparse\SparseTensor.md"><code>tf.SparseTensor</code></a>
and <a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a> are expanded into their component tensors. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="pack_sequence_as" class="method">
		<h4>
			<span title="System.object">object</span> <strong>pack_sequence_as</strong>(<span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span> structure, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> flat_sequence, <span title="System.string">string</span> expand_composites)
		</h4>
		<div class="content">Returns a given flattened sequence packed into a given structure. <p></p> If `structure` is a scalar, `flat_sequence` must be a single-element list;
in this case the return value is `flat_sequence[0]`. <p></p> If `structure` is or contains a dict instance, the keys will be sorted to
pack the flat sequence in deterministic order. This is true also for
`OrderedDict` instances: their sequence order is ignored, the sorting order of
keys is used instead. The same convention is followed in `flatten`.
This correctly repacks dicts and `OrderedDict`s after they have been
flattened, and also allows flattening an `OrderedDict` and then repacking it
back using a corresponding plain dict, or vice-versa.
Dictionaries with non-sortable keys cannot be flattened. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span></code> structure
						</dt>
						<dd>Nested structure, whose structure is given by nested lists,
tuples, and dicts. Note: numpy arrays and strings are considered
scalars. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> flat_sequence
						</dt>
						<dd>flat sequence to pack. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> expand_composites
						</dt>
						<dd>If true, then composite tensors such as <a href="..\..\tf\sparse\SparseTensor.md"><code>tf.SparseTensor</code></a>
and <a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a> are expanded into their component tensors. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="pack_sequence_as" class="method">
		<h4>
			<span title="System.object">object</span> <strong>pack_sequence_as</strong>(<span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span> structure, <span title="System.object">object</span> flat_sequence, <span title="System.string">string</span> expand_composites)
		</h4>
		<div class="content">Returns a given flattened sequence packed into a given structure. <p></p> If `structure` is a scalar, `flat_sequence` must be a single-element list;
in this case the return value is `flat_sequence[0]`. <p></p> If `structure` is or contains a dict instance, the keys will be sorted to
pack the flat sequence in deterministic order. This is true also for
`OrderedDict` instances: their sequence order is ignored, the sorting order of
keys is used instead. The same convention is followed in `flatten`.
This correctly repacks dicts and `OrderedDict`s after they have been
flattened, and also allows flattening an `OrderedDict` and then repacking it
back using a corresponding plain dict, or vice-versa.
Dictionaries with non-sortable keys cannot be flattened. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span></code> structure
						</dt>
						<dd>Nested structure, whose structure is given by nested lists,
tuples, and dicts. Note: numpy arrays and strings are considered
scalars. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> flat_sequence
						</dt>
						<dd>flat sequence to pack. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> expand_composites
						</dt>
						<dd>If true, then composite tensors such as <a href="..\..\tf\sparse\SparseTensor.md"><code>tf.SparseTensor</code></a>
and <a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a> are expanded into their component tensors. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="pack_sequence_as" class="method">
		<h4>
			<span title="System.object">object</span> <strong>pack_sequence_as</strong>(<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> structure, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> flat_sequence, <span title="System.bool">bool</span> expand_composites)
		</h4>
		<div class="content">Returns a given flattened sequence packed into a given structure. <p></p> If `structure` is a scalar, `flat_sequence` must be a single-element list;
in this case the return value is `flat_sequence[0]`. <p></p> If `structure` is or contains a dict instance, the keys will be sorted to
pack the flat sequence in deterministic order. This is true also for
`OrderedDict` instances: their sequence order is ignored, the sorting order of
keys is used instead. The same convention is followed in `flatten`.
This correctly repacks dicts and `OrderedDict`s after they have been
flattened, and also allows flattening an `OrderedDict` and then repacking it
back using a corresponding plain dict, or vice-versa.
Dictionaries with non-sortable keys cannot be flattened. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> structure
						</dt>
						<dd>Nested structure, whose structure is given by nested lists,
tuples, and dicts. Note: numpy arrays and strings are considered
scalars. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> flat_sequence
						</dt>
						<dd>flat sequence to pack. 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> expand_composites
						</dt>
						<dd>If true, then composite tensors such as <a href="..\..\tf\sparse\SparseTensor.md"><code>tf.SparseTensor</code></a>
and <a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a> are expanded into their component tensors. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="pack_sequence_as" class="method">
		<h4>
			<span title="System.object">object</span> <strong>pack_sequence_as</strong>(<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> structure, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> flat_sequence, <span title="System.string">string</span> expand_composites)
		</h4>
		<div class="content">Returns a given flattened sequence packed into a given structure. <p></p> If `structure` is a scalar, `flat_sequence` must be a single-element list;
in this case the return value is `flat_sequence[0]`. <p></p> If `structure` is or contains a dict instance, the keys will be sorted to
pack the flat sequence in deterministic order. This is true also for
`OrderedDict` instances: their sequence order is ignored, the sorting order of
keys is used instead. The same convention is followed in `flatten`.
This correctly repacks dicts and `OrderedDict`s after they have been
flattened, and also allows flattening an `OrderedDict` and then repacking it
back using a corresponding plain dict, or vice-versa.
Dictionaries with non-sortable keys cannot be flattened. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> structure
						</dt>
						<dd>Nested structure, whose structure is given by nested lists,
tuples, and dicts. Note: numpy arrays and strings are considered
scalars. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> flat_sequence
						</dt>
						<dd>flat sequence to pack. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> expand_composites
						</dt>
						<dd>If true, then composite tensors such as <a href="..\..\tf\sparse\SparseTensor.md"><code>tf.SparseTensor</code></a>
and <a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a> are expanded into their component tensors. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="pack_sequence_as" class="method">
		<h4>
			<span title="System.object">object</span> <strong>pack_sequence_as</strong>(<span title="System.object">object</span> structure, <span title="System.object">object</span> flat_sequence, <span title="System.string">string</span> expand_composites)
		</h4>
		<div class="content">Returns a given flattened sequence packed into a given structure. <p></p> If `structure` is a scalar, `flat_sequence` must be a single-element list;
in this case the return value is `flat_sequence[0]`. <p></p> If `structure` is or contains a dict instance, the keys will be sorted to
pack the flat sequence in deterministic order. This is true also for
`OrderedDict` instances: their sequence order is ignored, the sorting order of
keys is used instead. The same convention is followed in `flatten`.
This correctly repacks dicts and `OrderedDict`s after they have been
flattened, and also allows flattening an `OrderedDict` and then repacking it
back using a corresponding plain dict, or vice-versa.
Dictionaries with non-sortable keys cannot be flattened. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> structure
						</dt>
						<dd>Nested structure, whose structure is given by nested lists,
tuples, and dicts. Note: numpy arrays and strings are considered
scalars. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> flat_sequence
						</dt>
						<dd>flat sequence to pack. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> expand_composites
						</dt>
						<dd>If true, then composite tensors such as <a href="..\..\tf\sparse\SparseTensor.md"><code>tf.SparseTensor</code></a>
and <a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a> are expanded into their component tensors. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="pack_sequence_as" class="method">
		<h4>
			<span title="System.object">object</span> <strong>pack_sequence_as</strong>(<span title="System.object">object</span> structure, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> flat_sequence, <span title="System.string">string</span> expand_composites)
		</h4>
		<div class="content">Returns a given flattened sequence packed into a given structure. <p></p> If `structure` is a scalar, `flat_sequence` must be a single-element list;
in this case the return value is `flat_sequence[0]`. <p></p> If `structure` is or contains a dict instance, the keys will be sorted to
pack the flat sequence in deterministic order. This is true also for
`OrderedDict` instances: their sequence order is ignored, the sorting order of
keys is used instead. The same convention is followed in `flatten`.
This correctly repacks dicts and `OrderedDict`s after they have been
flattened, and also allows flattening an `OrderedDict` and then repacking it
back using a corresponding plain dict, or vice-versa.
Dictionaries with non-sortable keys cannot be flattened. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> structure
						</dt>
						<dd>Nested structure, whose structure is given by nested lists,
tuples, and dicts. Note: numpy arrays and strings are considered
scalars. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> flat_sequence
						</dt>
						<dd>flat sequence to pack. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> expand_composites
						</dt>
						<dd>If true, then composite tensors such as <a href="..\..\tf\sparse\SparseTensor.md"><code>tf.SparseTensor</code></a>
and <a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a> are expanded into their component tensors. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="pack_sequence_as" class="method">
		<h4>
			<span title="System.object">object</span> <strong>pack_sequence_as</strong>(<span title="System.object">object</span> structure, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> flat_sequence, <span title="System.bool">bool</span> expand_composites)
		</h4>
		<div class="content">Returns a given flattened sequence packed into a given structure. <p></p> If `structure` is a scalar, `flat_sequence` must be a single-element list;
in this case the return value is `flat_sequence[0]`. <p></p> If `structure` is or contains a dict instance, the keys will be sorted to
pack the flat sequence in deterministic order. This is true also for
`OrderedDict` instances: their sequence order is ignored, the sorting order of
keys is used instead. The same convention is followed in `flatten`.
This correctly repacks dicts and `OrderedDict`s after they have been
flattened, and also allows flattening an `OrderedDict` and then repacking it
back using a corresponding plain dict, or vice-versa.
Dictionaries with non-sortable keys cannot be flattened. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> structure
						</dt>
						<dd>Nested structure, whose structure is given by nested lists,
tuples, and dicts. Note: numpy arrays and strings are considered
scalars. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> flat_sequence
						</dt>
						<dd>flat sequence to pack. 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> expand_composites
						</dt>
						<dd>If true, then composite tensors such as <a href="..\..\tf\sparse\SparseTensor.md"><code>tf.SparseTensor</code></a>
and <a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a> are expanded into their component tensors. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="pack_sequence_as" class="method">
		<h4>
			<span title="System.object">object</span> <strong>pack_sequence_as</strong>(<span title="System.object">object</span> structure, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> flat_sequence, <span title="System.string">string</span> expand_composites)
		</h4>
		<div class="content">Returns a given flattened sequence packed into a given structure. <p></p> If `structure` is a scalar, `flat_sequence` must be a single-element list;
in this case the return value is `flat_sequence[0]`. <p></p> If `structure` is or contains a dict instance, the keys will be sorted to
pack the flat sequence in deterministic order. This is true also for
`OrderedDict` instances: their sequence order is ignored, the sorting order of
keys is used instead. The same convention is followed in `flatten`.
This correctly repacks dicts and `OrderedDict`s after they have been
flattened, and also allows flattening an `OrderedDict` and then repacking it
back using a corresponding plain dict, or vice-versa.
Dictionaries with non-sortable keys cannot be flattened. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> structure
						</dt>
						<dd>Nested structure, whose structure is given by nested lists,
tuples, and dicts. Note: numpy arrays and strings are considered
scalars. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> flat_sequence
						</dt>
						<dd>flat sequence to pack. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> expand_composites
						</dt>
						<dd>If true, then composite tensors such as <a href="..\..\tf\sparse\SparseTensor.md"><code>tf.SparseTensor</code></a>
and <a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a> are expanded into their component tensors. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="pack_sequence_as" class="method">
		<h4>
			<span title="System.object">object</span> <strong>pack_sequence_as</strong>(<span title="System.object">object</span> structure, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> flat_sequence, <span title="System.bool">bool</span> expand_composites)
		</h4>
		<div class="content">Returns a given flattened sequence packed into a given structure. <p></p> If `structure` is a scalar, `flat_sequence` must be a single-element list;
in this case the return value is `flat_sequence[0]`. <p></p> If `structure` is or contains a dict instance, the keys will be sorted to
pack the flat sequence in deterministic order. This is true also for
`OrderedDict` instances: their sequence order is ignored, the sorting order of
keys is used instead. The same convention is followed in `flatten`.
This correctly repacks dicts and `OrderedDict`s after they have been
flattened, and also allows flattening an `OrderedDict` and then repacking it
back using a corresponding plain dict, or vice-versa.
Dictionaries with non-sortable keys cannot be flattened. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> structure
						</dt>
						<dd>Nested structure, whose structure is given by nested lists,
tuples, and dicts. Note: numpy arrays and strings are considered
scalars. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> flat_sequence
						</dt>
						<dd>flat sequence to pack. 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> expand_composites
						</dt>
						<dd>If true, then composite tensors such as <a href="..\..\tf\sparse\SparseTensor.md"><code>tf.SparseTensor</code></a>
and <a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a> are expanded into their component tensors. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="pack_sequence_as" class="method">
		<h4>
			<span title="System.object">object</span> <strong>pack_sequence_as</strong>(<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> structure, <span title="System.object">object</span> flat_sequence, <span title="System.string">string</span> expand_composites)
		</h4>
		<div class="content">Returns a given flattened sequence packed into a given structure. <p></p> If `structure` is a scalar, `flat_sequence` must be a single-element list;
in this case the return value is `flat_sequence[0]`. <p></p> If `structure` is or contains a dict instance, the keys will be sorted to
pack the flat sequence in deterministic order. This is true also for
`OrderedDict` instances: their sequence order is ignored, the sorting order of
keys is used instead. The same convention is followed in `flatten`.
This correctly repacks dicts and `OrderedDict`s after they have been
flattened, and also allows flattening an `OrderedDict` and then repacking it
back using a corresponding plain dict, or vice-versa.
Dictionaries with non-sortable keys cannot be flattened. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> structure
						</dt>
						<dd>Nested structure, whose structure is given by nested lists,
tuples, and dicts. Note: numpy arrays and strings are considered
scalars. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> flat_sequence
						</dt>
						<dd>flat sequence to pack. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> expand_composites
						</dt>
						<dd>If true, then composite tensors such as <a href="..\..\tf\sparse\SparseTensor.md"><code>tf.SparseTensor</code></a>
and <a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a> are expanded into their component tensors. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="pack_sequence_as" class="method">
		<h4>
			<span title="System.object">object</span> <strong>pack_sequence_as</strong>(<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> structure, <span title="System.object">object</span> flat_sequence, <span title="System.bool">bool</span> expand_composites)
		</h4>
		<div class="content">Returns a given flattened sequence packed into a given structure. <p></p> If `structure` is a scalar, `flat_sequence` must be a single-element list;
in this case the return value is `flat_sequence[0]`. <p></p> If `structure` is or contains a dict instance, the keys will be sorted to
pack the flat sequence in deterministic order. This is true also for
`OrderedDict` instances: their sequence order is ignored, the sorting order of
keys is used instead. The same convention is followed in `flatten`.
This correctly repacks dicts and `OrderedDict`s after they have been
flattened, and also allows flattening an `OrderedDict` and then repacking it
back using a corresponding plain dict, or vice-versa.
Dictionaries with non-sortable keys cannot be flattened. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> structure
						</dt>
						<dd>Nested structure, whose structure is given by nested lists,
tuples, and dicts. Note: numpy arrays and strings are considered
scalars. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> flat_sequence
						</dt>
						<dd>flat sequence to pack. 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> expand_composites
						</dt>
						<dd>If true, then composite tensors such as <a href="..\..\tf\sparse\SparseTensor.md"><code>tf.SparseTensor</code></a>
and <a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a> are expanded into their component tensors. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="pack_sequence_as" class="method">
		<h4>
			<span title="System.object">object</span> <strong>pack_sequence_as</strong>(<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> structure, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> flat_sequence, <span title="System.string">string</span> expand_composites)
		</h4>
		<div class="content">Returns a given flattened sequence packed into a given structure. <p></p> If `structure` is a scalar, `flat_sequence` must be a single-element list;
in this case the return value is `flat_sequence[0]`. <p></p> If `structure` is or contains a dict instance, the keys will be sorted to
pack the flat sequence in deterministic order. This is true also for
`OrderedDict` instances: their sequence order is ignored, the sorting order of
keys is used instead. The same convention is followed in `flatten`.
This correctly repacks dicts and `OrderedDict`s after they have been
flattened, and also allows flattening an `OrderedDict` and then repacking it
back using a corresponding plain dict, or vice-versa.
Dictionaries with non-sortable keys cannot be flattened. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> structure
						</dt>
						<dd>Nested structure, whose structure is given by nested lists,
tuples, and dicts. Note: numpy arrays and strings are considered
scalars. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> flat_sequence
						</dt>
						<dd>flat sequence to pack. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> expand_composites
						</dt>
						<dd>If true, then composite tensors such as <a href="..\..\tf\sparse\SparseTensor.md"><code>tf.SparseTensor</code></a>
and <a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a> are expanded into their component tensors. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="pack_sequence_as" class="method">
		<h4>
			<span title="System.object">object</span> <strong>pack_sequence_as</strong>(<span title="System.object">object</span> structure, <span title="System.object">object</span> flat_sequence, <span title="System.bool">bool</span> expand_composites)
		</h4>
		<div class="content">Returns a given flattened sequence packed into a given structure. <p></p> If `structure` is a scalar, `flat_sequence` must be a single-element list;
in this case the return value is `flat_sequence[0]`. <p></p> If `structure` is or contains a dict instance, the keys will be sorted to
pack the flat sequence in deterministic order. This is true also for
`OrderedDict` instances: their sequence order is ignored, the sorting order of
keys is used instead. The same convention is followed in `flatten`.
This correctly repacks dicts and `OrderedDict`s after they have been
flattened, and also allows flattening an `OrderedDict` and then repacking it
back using a corresponding plain dict, or vice-versa.
Dictionaries with non-sortable keys cannot be flattened. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> structure
						</dt>
						<dd>Nested structure, whose structure is given by nested lists,
tuples, and dicts. Note: numpy arrays and strings are considered
scalars. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> flat_sequence
						</dt>
						<dd>flat sequence to pack. 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> expand_composites
						</dt>
						<dd>If true, then composite tensors such as <a href="..\..\tf\sparse\SparseTensor.md"><code>tf.SparseTensor</code></a>
and <a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a> are expanded into their component tensors. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="pack_sequence_as" class="method">
		<h4>
			<span title="System.object">object</span> <strong>pack_sequence_as</strong>(<span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span> structure, <span title="System.object">object</span> flat_sequence, <span title="System.bool">bool</span> expand_composites)
		</h4>
		<div class="content">Returns a given flattened sequence packed into a given structure. <p></p> If `structure` is a scalar, `flat_sequence` must be a single-element list;
in this case the return value is `flat_sequence[0]`. <p></p> If `structure` is or contains a dict instance, the keys will be sorted to
pack the flat sequence in deterministic order. This is true also for
`OrderedDict` instances: their sequence order is ignored, the sorting order of
keys is used instead. The same convention is followed in `flatten`.
This correctly repacks dicts and `OrderedDict`s after they have been
flattened, and also allows flattening an `OrderedDict` and then repacking it
back using a corresponding plain dict, or vice-versa.
Dictionaries with non-sortable keys cannot be flattened. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span></code> structure
						</dt>
						<dd>Nested structure, whose structure is given by nested lists,
tuples, and dicts. Note: numpy arrays and strings are considered
scalars. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> flat_sequence
						</dt>
						<dd>flat sequence to pack. 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> expand_composites
						</dt>
						<dd>If true, then composite tensors such as <a href="..\..\tf\sparse\SparseTensor.md"><code>tf.SparseTensor</code></a>
and <a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a> are expanded into their component tensors. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="pack_sequence_as_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>pack_sequence_as_dyn</strong>(<span title="System.object">object</span> structure, <span title="System.object">object</span> flat_sequence, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> expand_composites)
		</h4>
		<div class="content">Returns a given flattened sequence packed into a given structure. <p></p> If `structure` is a scalar, `flat_sequence` must be a single-element list;
in this case the return value is `flat_sequence[0]`. <p></p> If `structure` is or contains a dict instance, the keys will be sorted to
pack the flat sequence in deterministic order. This is true also for
`OrderedDict` instances: their sequence order is ignored, the sorting order of
keys is used instead. The same convention is followed in `flatten`.
This correctly repacks dicts and `OrderedDict`s after they have been
flattened, and also allows flattening an `OrderedDict` and then repacking it
back using a corresponding plain dict, or vice-versa.
Dictionaries with non-sortable keys cannot be flattened. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> structure
						</dt>
						<dd>Nested structure, whose structure is given by nested lists,
tuples, and dicts. Note: numpy arrays and strings are considered
scalars. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> flat_sequence
						</dt>
						<dd>flat sequence to pack. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> expand_composites
						</dt>
						<dd>If true, then composite tensors such as <a href="..\..\tf\sparse\SparseTensor.md"><code>tf.SparseTensor</code></a>
and <a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a> are expanded into their component tensors. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	
	<h3 class="section">Public properties</h3>

	<div id="assert_same_structure_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>assert_same_structure_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="flatten_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>flatten_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="is_nested_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>is_nested_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="map_structure_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>map_structure_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="pack_sequence_as_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>pack_sequence_as_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	</section>
	</article><footer>
	<span id="version">Built from v1.15.0.0 of LostTech.TensorFlow</span>
	<span id="docu-link">
		Generated by <a href="http://docu.jagregory.com">docu</a>
	</span>
</footer>
  </body>
</html>