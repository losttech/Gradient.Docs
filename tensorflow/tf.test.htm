<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
	<!--[if lt IE 9]>
	<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
    <title>tf.test - LostTech.TensorFlow Documentation</title>
    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"/>
    <link type="text/css" rel="stylesheet" href="../main.css"/>
    <script type="text/javascript" src="../js/jquery-1.3.2.min.js"></script>
    <script type="text/javascript" src="../js/jquery.scrollTo-min.js"></script>
    <script type="text/javascript" src="../js/navigation.js"></script>
    <script type="text/javascript" src="../js/example.js"></script>
  </head>
  <body>
  	<header><h1>LostTech.TensorFlow : API Documentation</h1>
	</header>

    <nav id="namespaces">
      <iframe src="../namespaces.htm"></iframe>
    </nav><nav id="types">
  <h2 class="fixed">Types in tensorflow</h2>
	<div class="scroll">
		<ul>
				<li>
            <a href="../tensorflow/AggregationMethod.htm">AggregationMethod</a>
        </li>
				<li>
            <a href="../tensorflow/ConditionalAccumulator.htm">ConditionalAccumulator</a>
        </li>
				<li>
            <a href="../tensorflow/ConditionalAccumulatorBase.htm">ConditionalAccumulatorBase</a>
        </li>
				<li>
            <a href="../tensorflow/constant_initializer.htm">constant_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/CriticalSection.htm">CriticalSection</a>
        </li>
				<li>
            <a href="../tensorflow/DeviceSpec.htm">DeviceSpec</a>
        </li>
				<li>
            <a href="../tensorflow/Dimension.htm">Dimension</a>
        </li>
				<li>
            <a href="../tensorflow/DType.htm">DType</a>
        </li>
				<li>
            <a href="../tensorflow/FIFOQueue.htm">FIFOQueue</a>
        </li>
				<li>
            <a href="../tensorflow/FixedLenFeature.htm">FixedLenFeature</a>
        </li>
				<li>
            <a href="../tensorflow/FixedLengthRecordReader.htm">FixedLengthRecordReader</a>
        </li>
				<li>
            <a href="../tensorflow/FixedLenSequenceFeature.htm">FixedLenSequenceFeature</a>
        </li>
				<li>
            <a href="../tensorflow/glorot_normal_initializer.htm">glorot_normal_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/glorot_uniform_initializer.htm">glorot_uniform_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/GradientTape.htm">GradientTape</a>
        </li>
				<li>
            <a href="../tensorflow/Graph.htm">Graph</a>
        </li>
				<li>
            <a href="../tensorflow/Graph._ControlDependenciesController.htm">Graph._ControlDependenciesController</a>
        </li>
				<li>
            <a href="../tensorflow/Graph.I_ControlDependenciesController.htm">Graph.I_ControlDependenciesController</a>
        </li>
				<li>
            <a href="../tensorflow/GraphKeys.htm">GraphKeys</a>
        </li>
				<li>
            <a href="../tensorflow/HeadingAxes.htm">HeadingAxes</a>
        </li>
				<li>
            <a href="../tensorflow/IAggregationMethod.htm">IAggregationMethod</a>
        </li>
				<li>
            <a href="../tensorflow/IConditionalAccumulator.htm">IConditionalAccumulator</a>
        </li>
				<li>
            <a href="../tensorflow/IConditionalAccumulatorBase.htm">IConditionalAccumulatorBase</a>
        </li>
				<li>
            <a href="../tensorflow/Iconstant_initializer.htm">Iconstant_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/ICriticalSection.htm">ICriticalSection</a>
        </li>
				<li>
            <a href="../tensorflow/IdentityReader.htm">IdentityReader</a>
        </li>
				<li>
            <a href="../tensorflow/IDeviceSpec.htm">IDeviceSpec</a>
        </li>
				<li>
            <a href="../tensorflow/IDimension.htm">IDimension</a>
        </li>
				<li>
            <a href="../tensorflow/IDType.htm">IDType</a>
        </li>
				<li>
            <a href="../tensorflow/IFIFOQueue.htm">IFIFOQueue</a>
        </li>
				<li>
            <a href="../tensorflow/IFixedLenFeature.htm">IFixedLenFeature</a>
        </li>
				<li>
            <a href="../tensorflow/IFixedLengthRecordReader.htm">IFixedLengthRecordReader</a>
        </li>
				<li>
            <a href="../tensorflow/IFixedLenSequenceFeature.htm">IFixedLenSequenceFeature</a>
        </li>
				<li>
            <a href="../tensorflow/Iglorot_normal_initializer.htm">Iglorot_normal_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/Iglorot_uniform_initializer.htm">Iglorot_uniform_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/IGradientTape.htm">IGradientTape</a>
        </li>
				<li>
            <a href="../tensorflow/IGraph.htm">IGraph</a>
        </li>
				<li>
            <a href="../tensorflow/IGraphKeys.htm">IGraphKeys</a>
        </li>
				<li>
            <a href="../tensorflow/IIdentityReader.htm">IIdentityReader</a>
        </li>
				<li>
            <a href="../tensorflow/IIndexedSlices.htm">IIndexedSlices</a>
        </li>
				<li>
            <a href="../tensorflow/IIndexedSlicesSpec.htm">IIndexedSlicesSpec</a>
        </li>
				<li>
            <a href="../tensorflow/IInteractiveSession.htm">IInteractiveSession</a>
        </li>
				<li>
            <a href="../tensorflow/ILazyLoader.htm">ILazyLoader</a>
        </li>
				<li>
            <a href="../tensorflow/ILMDBReader.htm">ILMDBReader</a>
        </li>
				<li>
            <a href="../tensorflow/IModule.htm">IModule</a>
        </li>
				<li>
            <a href="../tensorflow/Iname_scope.htm">Iname_scope</a>
        </li>
				<li>
            <a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a>
        </li>
				<li>
            <a href="../tensorflow/IndexedSlicesSpec.htm">IndexedSlicesSpec</a>
        </li>
				<li>
            <a href="../tensorflow/InteractiveSession.htm">InteractiveSession</a>
        </li>
				<li>
            <a href="../tensorflow/Iones_initializer.htm">Iones_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/IOperation.htm">IOperation</a>
        </li>
				<li>
            <a href="../tensorflow/IOpError.htm">IOpError</a>
        </li>
				<li>
            <a href="../tensorflow/IOptionalSpec.htm">IOptionalSpec</a>
        </li>
				<li>
            <a href="../tensorflow/Iorthogonal_initializer.htm">Iorthogonal_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/IPaddingFIFOQueue.htm">IPaddingFIFOQueue</a>
        </li>
				<li>
            <a href="../tensorflow/IPriorityQueue.htm">IPriorityQueue</a>
        </li>
				<li>
            <a href="../tensorflow/IQueueBase.htm">IQueueBase</a>
        </li>
				<li>
            <a href="../tensorflow/IRaggedTensor.htm">IRaggedTensor</a>
        </li>
				<li>
            <a href="../tensorflow/IRaggedTensorSpec.htm">IRaggedTensorSpec</a>
        </li>
				<li>
            <a href="../tensorflow/Irandom_normal_initializer.htm">Irandom_normal_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/Irandom_uniform_initializer.htm">Irandom_uniform_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/IRandomShuffleQueue.htm">IRandomShuffleQueue</a>
        </li>
				<li>
            <a href="../tensorflow/IReaderBase.htm">IReaderBase</a>
        </li>
				<li>
            <a href="../tensorflow/IRegisterGradient.htm">IRegisterGradient</a>
        </li>
				<li>
            <a href="../tensorflow/ISession.htm">ISession</a>
        </li>
				<li>
            <a href="../tensorflow/ISparseConditionalAccumulator.htm">ISparseConditionalAccumulator</a>
        </li>
				<li>
            <a href="../tensorflow/ISparseFeature.htm">ISparseFeature</a>
        </li>
				<li>
            <a href="../tensorflow/ISparseTensor.htm">ISparseTensor</a>
        </li>
				<li>
            <a href="../tensorflow/ISparseTensorSpec.htm">ISparseTensorSpec</a>
        </li>
				<li>
            <a href="../tensorflow/ISparseTensorValue.htm">ISparseTensorValue</a>
        </li>
				<li>
            <a href="../tensorflow/ITensor.htm">ITensor</a>
        </li>
				<li>
            <a href="../tensorflow/ITensorArray.htm">ITensorArray</a>
        </li>
				<li>
            <a href="../tensorflow/ITensorArraySpec.htm">ITensorArraySpec</a>
        </li>
				<li>
            <a href="../tensorflow/ITensorShape.htm">ITensorShape</a>
        </li>
				<li>
            <a href="../tensorflow/ITensorSpec.htm">ITensorSpec</a>
        </li>
				<li>
            <a href="../tensorflow/ITextLineReader.htm">ITextLineReader</a>
        </li>
				<li>
            <a href="../tensorflow/ITFRecordReader.htm">ITFRecordReader</a>
        </li>
				<li>
            <a href="../tensorflow/Itruncated_normal_initializer.htm">Itruncated_normal_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/ITypeSpec.htm">ITypeSpec</a>
        </li>
				<li>
            <a href="../tensorflow/IUnconnectedGradients.htm">IUnconnectedGradients</a>
        </li>
				<li>
            <a href="../tensorflow/Iuniform_unit_scaling_initializer.htm">Iuniform_unit_scaling_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/IVariable.htm">IVariable</a>
        </li>
				<li>
            <a href="../tensorflow/Ivariable_scope.htm">Ivariable_scope</a>
        </li>
				<li>
            <a href="../tensorflow/IVariableScope.htm">IVariableScope</a>
        </li>
				<li>
            <a href="../tensorflow/Ivariance_scaling_initializer.htm">Ivariance_scaling_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/IVarLenFeature.htm">IVarLenFeature</a>
        </li>
				<li>
            <a href="../tensorflow/IWholeFileReader.htm">IWholeFileReader</a>
        </li>
				<li>
            <a href="../tensorflow/Izeros_initializer.htm">Izeros_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/LazyLoader.htm">LazyLoader</a>
        </li>
				<li>
            <a href="../tensorflow/LMDBReader.htm">LMDBReader</a>
        </li>
				<li>
            <a href="../tensorflow/Module.htm">Module</a>
        </li>
				<li>
            <a href="../tensorflow/name_scope.htm">name_scope</a>
        </li>
				<li>
            <a href="../tensorflow/ones_initializer.htm">ones_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/Operation.htm">Operation</a>
        </li>
				<li>
            <a href="../tensorflow/Operation._InputList.htm">Operation._InputList</a>
        </li>
				<li>
            <a href="../tensorflow/Operation.I_InputList.htm">Operation.I_InputList</a>
        </li>
				<li>
            <a href="../tensorflow/OpError.htm">OpError</a>
        </li>
				<li>
            <a href="../tensorflow/OptionalSpec.htm">OptionalSpec</a>
        </li>
				<li>
            <a href="../tensorflow/orthogonal_initializer.htm">orthogonal_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/PaddingFIFOQueue.htm">PaddingFIFOQueue</a>
        </li>
				<li>
            <a href="../tensorflow/PriorityQueue.htm">PriorityQueue</a>
        </li>
				<li>
            <a href="../tensorflow/QueueBase.htm">QueueBase</a>
        </li>
				<li>
            <a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a>
        </li>
				<li>
            <a href="../tensorflow/RaggedTensorSpec.htm">RaggedTensorSpec</a>
        </li>
				<li>
            <a href="../tensorflow/random_normal_initializer.htm">random_normal_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/random_uniform_initializer.htm">random_uniform_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/RandomShuffleQueue.htm">RandomShuffleQueue</a>
        </li>
				<li>
            <a href="../tensorflow/ReaderBase.htm">ReaderBase</a>
        </li>
				<li>
            <a href="../tensorflow/RegisterGradient.htm">RegisterGradient</a>
        </li>
				<li>
            <a href="../tensorflow/Session.htm">Session</a>
        </li>
				<li>
            <a href="../tensorflow/SparseConditionalAccumulator.htm">SparseConditionalAccumulator</a>
        </li>
				<li>
            <a href="../tensorflow/SparseFeature.htm">SparseFeature</a>
        </li>
				<li>
            <a href="../tensorflow/SparseTensor.htm">SparseTensor</a>
        </li>
				<li>
            <a href="../tensorflow/SparseTensorSpec.htm">SparseTensorSpec</a>
        </li>
				<li>
            <a href="../tensorflow/SparseTensorValue.htm">SparseTensorValue</a>
        </li>
				<li>
            <a href="../tensorflow/Tensor.htm">Tensor</a>
        </li>
				<li>
            <a href="../tensorflow/Tensor`1.htm">Tensor&lt;T&gt;</a>
        </li>
				<li>
            <a href="../tensorflow/TensorArray.htm">TensorArray</a>
        </li>
				<li>
            <a href="../tensorflow/TensorArraySpec.htm">TensorArraySpec</a>
        </li>
				<li>
            <a href="../tensorflow/TensorDimension.htm">TensorDimension</a>
        </li>
				<li>
            <a href="../tensorflow/TensorDimensionSlice.htm">TensorDimensionSlice</a>
        </li>
				<li>
            <a href="../tensorflow/TensorShape.htm">TensorShape</a>
        </li>
				<li>
            <a href="../tensorflow/TensorSpec.htm">TensorSpec</a>
        </li>
				<li>
            <a href="../tensorflow/TextLineReader.htm">TextLineReader</a>
        </li>
				<li>
            <a href="../tensorflow/tf.htm">tf</a>
        </li>
				<li>
            <a href="../tensorflow/tf.audio.htm">tf.audio</a>
        </li>
				<li>
            <a href="../tensorflow/tf.autograph.htm">tf.autograph</a>
        </li>
				<li>
            <a href="../tensorflow/tf.autograph.experimental.htm">tf.autograph.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.bitwise.htm">tf.bitwise</a>
        </li>
				<li>
            <a href="../tensorflow/tf.compat.htm">tf.compat</a>
        </li>
				<li>
            <a href="../tensorflow/tf.config.htm">tf.config</a>
        </li>
				<li>
            <a href="../tensorflow/tf.config.experimental.htm">tf.config.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.config.optimizer.htm">tf.config.optimizer</a>
        </li>
				<li>
            <a href="../tensorflow/tf.config.threading.htm">tf.config.threading</a>
        </li>
				<li>
            <a href="../tensorflow/tf.data.htm">tf.data</a>
        </li>
				<li>
            <a href="../tensorflow/tf.data.experimental.htm">tf.data.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.debugging.htm">tf.debugging</a>
        </li>
				<li>
            <a href="../tensorflow/tf.distribute.htm">tf.distribute</a>
        </li>
				<li>
            <a href="../tensorflow/tf.distributions.htm">tf.distributions</a>
        </li>
				<li>
            <a href="../tensorflow/tf.errors.htm">tf.errors</a>
        </li>
				<li>
            <a href="../tensorflow/tf.estimator.htm">tf.estimator</a>
        </li>
				<li>
            <a href="../tensorflow/tf.estimator.experimental.htm">tf.estimator.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.estimator.export.htm">tf.estimator.export</a>
        </li>
				<li>
            <a href="../tensorflow/tf.estimator.inputs.htm">tf.estimator.inputs</a>
        </li>
				<li>
            <a href="../tensorflow/tf.experimental.htm">tf.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.feature_column.htm">tf.feature_column</a>
        </li>
				<li>
            <a href="../tensorflow/tf.gfile.htm">tf.gfile</a>
        </li>
				<li>
            <a href="../tensorflow/tf.graph_util.htm">tf.graph_util</a>
        </li>
				<li>
            <a href="../tensorflow/tf.image.htm">tf.image</a>
        </li>
				<li>
            <a href="../tensorflow/tf.initializers.htm">tf.initializers</a>
        </li>
				<li>
            <a href="../tensorflow/tf.io.htm">tf.io</a>
        </li>
				<li>
            <a href="../tensorflow/tf.io.gfile.htm">tf.io.gfile</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.htm">tf.keras</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.activations.htm">tf.keras.activations</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.htm">tf.keras.applications</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.densenet.htm">tf.keras.applications.densenet</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.imagenet_utils.htm">tf.keras.applications.imagenet_utils</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.inception_resnet_v2.htm">tf.keras.applications.inception_resnet_v2</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.inception_v3.htm">tf.keras.applications.inception_v3</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.mobilenet.htm">tf.keras.applications.mobilenet</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.mobilenet_v2.htm">tf.keras.applications.mobilenet_v2</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.nasnet.htm">tf.keras.applications.nasnet</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.resnet.htm">tf.keras.applications.resnet</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.resnet_v2.htm">tf.keras.applications.resnet_v2</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.vgg16.htm">tf.keras.applications.vgg16</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.vgg19.htm">tf.keras.applications.vgg19</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.xception.htm">tf.keras.applications.xception</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.backend.htm">tf.keras.backend</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.constraints.htm">tf.keras.constraints</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.datasets.htm">tf.keras.datasets</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.datasets.boston_housing.htm">tf.keras.datasets.boston_housing</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.datasets.cifar10.htm">tf.keras.datasets.cifar10</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.datasets.cifar100.htm">tf.keras.datasets.cifar100</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.datasets.fashion_mnist.htm">tf.keras.datasets.fashion_mnist</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.datasets.imdb.htm">tf.keras.datasets.imdb</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.datasets.mnist.htm">tf.keras.datasets.mnist</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.datasets.reuters.htm">tf.keras.datasets.reuters</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.estimator.htm">tf.keras.estimator</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.experimental.htm">tf.keras.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.initializers.htm">tf.keras.initializers</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.layers.htm">tf.keras.layers</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.losses.htm">tf.keras.losses</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.metrics.htm">tf.keras.metrics</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.mixed_precision.htm">tf.keras.mixed_precision</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.mixed_precision.experimental.htm">tf.keras.mixed_precision.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.models.htm">tf.keras.models</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.optimizers.htm">tf.keras.optimizers</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.optimizers.schedules.htm">tf.keras.optimizers.schedules</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.preprocessing.htm">tf.keras.preprocessing</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.preprocessing.image.htm">tf.keras.preprocessing.image</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.regularizers.htm">tf.keras.regularizers</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.utils.htm">tf.keras.utils</a>
        </li>
				<li>
            <a href="../tensorflow/tf.layers.htm">tf.layers</a>
        </li>
				<li>
            <a href="../tensorflow/tf.layers.experimental.htm">tf.layers.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.linalg.htm">tf.linalg</a>
        </li>
				<li>
            <a href="../tensorflow/tf.lite.htm">tf.lite</a>
        </li>
				<li>
            <a href="../tensorflow/tf.lite.experimental.htm">tf.lite.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.lite.experimental.microfrontend.htm">tf.lite.experimental.microfrontend</a>
        </li>
				<li>
            <a href="../tensorflow/tf.lite.experimental.microfrontend.python.htm">tf.lite.experimental.microfrontend.python</a>
        </li>
				<li>
            <a href="../tensorflow/tf.lite.experimental.microfrontend.python.ops.htm">tf.lite.experimental.microfrontend.python.ops</a>
        </li>
				<li>
            <a href="../tensorflow/tf.lite.experimental.nn.htm">tf.lite.experimental.nn</a>
        </li>
				<li>
            <a href="../tensorflow/tf.logging.htm">tf.logging</a>
        </li>
				<li>
            <a href="../tensorflow/tf.losses.htm">tf.losses</a>
        </li>
				<li>
            <a href="../tensorflow/tf.math.htm">tf.math</a>
        </li>
				<li>
            <a href="../tensorflow/tf.metrics.htm">tf.metrics</a>
        </li>
				<li>
            <a href="../tensorflow/tf.nest.htm">tf.nest</a>
        </li>
				<li>
            <a href="../tensorflow/tf.nn.htm">tf.nn</a>
        </li>
				<li>
            <a href="../tensorflow/tf.profiler.htm">tf.profiler</a>
        </li>
				<li>
            <a href="../tensorflow/tf.quantization.htm">tf.quantization</a>
        </li>
				<li>
            <a href="../tensorflow/tf.ragged.htm">tf.ragged</a>
        </li>
				<li>
            <a href="../tensorflow/tf.random.htm">tf.random</a>
        </li>
				<li>
            <a href="../tensorflow/tf.random.experimental.htm">tf.random.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.resource_loader.htm">tf.resource_loader</a>
        </li>
				<li>
            <a href="../tensorflow/tf.saved_model.htm">tf.saved_model</a>
        </li>
				<li>
            <a href="../tensorflow/tf.saved_model.main_op.htm">tf.saved_model.main_op</a>
        </li>
				<li>
            <a href="../tensorflow/tf.sets.htm">tf.sets</a>
        </li>
				<li>
            <a href="../tensorflow/tf.signal.htm">tf.signal</a>
        </li>
				<li>
            <a href="../tensorflow/tf.sparse.htm">tf.sparse</a>
        </li>
				<li>
            <a href="../tensorflow/tf.strings.htm">tf.strings</a>
        </li>
				<li>
            <a href="../tensorflow/tf.summary.htm">tf.summary</a>
        </li>
				<li>
            <a href="../tensorflow/tf.summary.experimental.htm">tf.summary.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.sysconfig.htm">tf.sysconfig</a>
        </li>
				<li>
            <a href="../tensorflow/tf.test.htm" class="current">tf.test</a>
        </li>
				<li>
            <a href="../tensorflow/tf.tpu.htm">tf.tpu</a>
        </li>
				<li>
            <a href="../tensorflow/tf.tpu.experimental.htm">tf.tpu.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.train.htm">tf.train</a>
        </li>
				<li>
            <a href="../tensorflow/tf.train.experimental.htm">tf.train.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.user_ops.htm">tf.user_ops</a>
        </li>
				<li>
            <a href="../tensorflow/tf.xla.htm">tf.xla</a>
        </li>
				<li>
            <a href="../tensorflow/tf.xla.experimental.htm">tf.xla.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/TFRecordReader.htm">TFRecordReader</a>
        </li>
				<li>
            <a href="../tensorflow/truncated_normal_initializer.htm">truncated_normal_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/TypeSpec.htm">TypeSpec</a>
        </li>
				<li>
            <a href="../tensorflow/UnconnectedGradients.htm">UnconnectedGradients</a>
        </li>
				<li>
            <a href="../tensorflow/uniform_unit_scaling_initializer.htm">uniform_unit_scaling_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/Variable.htm">Variable</a>
        </li>
				<li>
            <a href="../tensorflow/variable_scope.htm">variable_scope</a>
        </li>
				<li>
            <a href="../tensorflow/VariableAggregation.htm">VariableAggregation</a>
        </li>
				<li>
            <a href="../tensorflow/VariableScope.htm">VariableScope</a>
        </li>
				<li>
            <a href="../tensorflow/VariableSynchronization.htm">VariableSynchronization</a>
        </li>
				<li>
            <a href="../tensorflow/variance_scaling_initializer.htm">variance_scaling_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/VarLenFeature.htm">VarLenFeature</a>
        </li>
				<li>
            <a href="../tensorflow/WholeFileReader.htm">WholeFileReader</a>
        </li>
				<li>
            <a href="../tensorflow/zeros_initializer.htm">zeros_initializer</a>
        </li>
		</ul>
	</div>
</nav>
	<article>
    <header>
		<p class="class"><strong>Type</strong> tf.test</p>
	</header>
	<section>
		<header>
		<p><strong>Namespace</strong> tensorflow</p>
		</header>
    <div class="sub-header">
		
		
			<h3 class="section">Methods</h3>
			<ul>
				<li><a href="../tensorflow/tf.test.htm#benchmark_config">benchmark_config</a></li>
				<li><a href="../tensorflow/tf.test.htm#benchmark_config_dyn">benchmark_config_dyn</a></li>
				<li><a href="../tensorflow/tf.test.htm#compute_gradient">compute_gradient</a></li>
				<li><a href="../tensorflow/tf.test.htm#compute_gradient">compute_gradient</a></li>
				<li><a href="../tensorflow/tf.test.htm#compute_gradient">compute_gradient</a></li>
				<li><a href="../tensorflow/tf.test.htm#compute_gradient">compute_gradient</a></li>
				<li><a href="../tensorflow/tf.test.htm#compute_gradient">compute_gradient</a></li>
				<li><a href="../tensorflow/tf.test.htm#compute_gradient">compute_gradient</a></li>
				<li><a href="../tensorflow/tf.test.htm#compute_gradient">compute_gradient</a></li>
				<li><a href="../tensorflow/tf.test.htm#compute_gradient">compute_gradient</a></li>
				<li><a href="../tensorflow/tf.test.htm#compute_gradient">compute_gradient</a></li>
				<li><a href="../tensorflow/tf.test.htm#compute_gradient">compute_gradient</a></li>
				<li><a href="../tensorflow/tf.test.htm#compute_gradient">compute_gradient</a></li>
				<li><a href="../tensorflow/tf.test.htm#compute_gradient">compute_gradient</a></li>
				<li><a href="../tensorflow/tf.test.htm#compute_gradient">compute_gradient</a></li>
				<li><a href="../tensorflow/tf.test.htm#compute_gradient">compute_gradient</a></li>
				<li><a href="../tensorflow/tf.test.htm#compute_gradient">compute_gradient</a></li>
				<li><a href="../tensorflow/tf.test.htm#compute_gradient">compute_gradient</a></li>
				<li><a href="../tensorflow/tf.test.htm#compute_gradient">compute_gradient</a></li>
				<li><a href="../tensorflow/tf.test.htm#compute_gradient">compute_gradient</a></li>
				<li><a href="../tensorflow/tf.test.htm#compute_gradient">compute_gradient</a></li>
				<li><a href="../tensorflow/tf.test.htm#compute_gradient">compute_gradient</a></li>
				<li><a href="../tensorflow/tf.test.htm#compute_gradient">compute_gradient</a></li>
				<li><a href="../tensorflow/tf.test.htm#compute_gradient">compute_gradient</a></li>
				<li><a href="../tensorflow/tf.test.htm#compute_gradient">compute_gradient</a></li>
				<li><a href="../tensorflow/tf.test.htm#compute_gradient">compute_gradient</a></li>
				<li><a href="../tensorflow/tf.test.htm#compute_gradient_dyn">compute_gradient_dyn</a></li>
				<li><a href="../tensorflow/tf.test.htm#compute_gradient_error">compute_gradient_error</a></li>
				<li><a href="../tensorflow/tf.test.htm#compute_gradient_error">compute_gradient_error</a></li>
				<li><a href="../tensorflow/tf.test.htm#compute_gradient_error">compute_gradient_error</a></li>
				<li><a href="../tensorflow/tf.test.htm#compute_gradient_error">compute_gradient_error</a></li>
				<li><a href="../tensorflow/tf.test.htm#compute_gradient_error">compute_gradient_error</a></li>
				<li><a href="../tensorflow/tf.test.htm#compute_gradient_error">compute_gradient_error</a></li>
				<li><a href="../tensorflow/tf.test.htm#compute_gradient_error">compute_gradient_error</a></li>
				<li><a href="../tensorflow/tf.test.htm#compute_gradient_error">compute_gradient_error</a></li>
				<li><a href="../tensorflow/tf.test.htm#compute_gradient_error">compute_gradient_error</a></li>
				<li><a href="../tensorflow/tf.test.htm#compute_gradient_error">compute_gradient_error</a></li>
				<li><a href="../tensorflow/tf.test.htm#compute_gradient_error">compute_gradient_error</a></li>
				<li><a href="../tensorflow/tf.test.htm#compute_gradient_error">compute_gradient_error</a></li>
				<li><a href="../tensorflow/tf.test.htm#compute_gradient_error">compute_gradient_error</a></li>
				<li><a href="../tensorflow/tf.test.htm#compute_gradient_error">compute_gradient_error</a></li>
				<li><a href="../tensorflow/tf.test.htm#compute_gradient_error">compute_gradient_error</a></li>
				<li><a href="../tensorflow/tf.test.htm#compute_gradient_error">compute_gradient_error</a></li>
				<li><a href="../tensorflow/tf.test.htm#compute_gradient_error">compute_gradient_error</a></li>
				<li><a href="../tensorflow/tf.test.htm#compute_gradient_error">compute_gradient_error</a></li>
				<li><a href="../tensorflow/tf.test.htm#compute_gradient_error_dyn">compute_gradient_error_dyn</a></li>
				<li><a href="../tensorflow/tf.test.htm#create_local_cluster">create_local_cluster</a></li>
				<li><a href="../tensorflow/tf.test.htm#create_local_cluster_dyn">create_local_cluster_dyn</a></li>
				<li><a href="../tensorflow/tf.test.htm#gpu_device_name">gpu_device_name</a></li>
				<li><a href="../tensorflow/tf.test.htm#gpu_device_name_dyn">gpu_device_name_dyn</a></li>
				<li><a href="../tensorflow/tf.test.htm#is_built_with_cuda">is_built_with_cuda</a></li>
				<li><a href="../tensorflow/tf.test.htm#is_built_with_cuda_dyn">is_built_with_cuda_dyn</a></li>
				<li><a href="../tensorflow/tf.test.htm#is_built_with_gpu_support">is_built_with_gpu_support</a></li>
				<li><a href="../tensorflow/tf.test.htm#is_built_with_gpu_support_dyn">is_built_with_gpu_support_dyn</a></li>
				<li><a href="../tensorflow/tf.test.htm#is_built_with_rocm">is_built_with_rocm</a></li>
				<li><a href="../tensorflow/tf.test.htm#is_built_with_rocm_dyn">is_built_with_rocm_dyn</a></li>
				<li><a href="../tensorflow/tf.test.htm#is_gpu_available">is_gpu_available</a></li>
				<li><a href="../tensorflow/tf.test.htm#is_gpu_available_dyn">is_gpu_available_dyn</a></li>
			</ul>
		
			<h3 class="section">Properties</h3>
			<ul>
				<li><a href="../tensorflow/tf.test.htm#assert_equal_graph_def_fn_">assert_equal_graph_def_fn_</a></li>
				<li><a href="../tensorflow/tf.test.htm#benchmark_config_fn">benchmark_config_fn</a></li>
				<li><a href="../tensorflow/tf.test.htm#compute_gradient_error_fn">compute_gradient_error_fn</a></li>
				<li><a href="../tensorflow/tf.test.htm#compute_gradient_fn">compute_gradient_fn</a></li>
				<li><a href="../tensorflow/tf.test.htm#create_local_cluster_fn">create_local_cluster_fn</a></li>
				<li><a href="../tensorflow/tf.test.htm#get_temp_dir_fn">get_temp_dir_fn</a></li>
				<li><a href="../tensorflow/tf.test.htm#gpu_device_name_fn">gpu_device_name_fn</a></li>
				<li><a href="../tensorflow/tf.test.htm#is_built_with_cuda_fn">is_built_with_cuda_fn</a></li>
				<li><a href="../tensorflow/tf.test.htm#is_built_with_gpu_support_fn">is_built_with_gpu_support_fn</a></li>
				<li><a href="../tensorflow/tf.test.htm#is_built_with_rocm_fn">is_built_with_rocm_fn</a></li>
				<li><a href="../tensorflow/tf.test.htm#is_gpu_available_fn">is_gpu_available_fn</a></li>
				<li><a href="../tensorflow/tf.test.htm#main_fn">main_fn</a></li>
				<li><a href="../tensorflow/tf.test.htm#test_src_dir_path_fn">test_src_dir_path_fn</a></li>
			</ul>
		
	</div>
	
	
	<h3 class="section">Public static methods</h3>

	<div id="benchmark_config" class="method">
		<h4>
			<span title="System.object">object</span> <strong>benchmark_config</strong>()
		</h4>
		<div class="content">Returns a tf.compat.v1.ConfigProto for disabling the dependency optimizer. 



			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A TensorFlow ConfigProto object. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="benchmark_config_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>benchmark_config_dyn</strong>()
		</h4>
		<div class="content">Returns a tf.compat.v1.ConfigProto for disabling the dependency optimizer. 



			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A TensorFlow ConfigProto object. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="compute_gradient" class="method">
		<h4>
			<span title="System.object">object</span> <strong>compute_gradient</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> x, <a href="../tensorflow/TensorShape.htm">TensorShape</a> x_shape, <span title="System.object">object</span> y, <a href="../tensorflow/TensorShape.htm">TensorShape</a> y_shape, <span title="System.object">object</span> x_init_value, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> delta, <span title="System.Nullable<ValueTuple<IEnumerable<object>, object>>">Nullable&lt;ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;&gt;</span> init_targets, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> extra_feed_dict)
		</h4>
		<div class="content">Computes and returns the theoretical and numerical Jacobian. (deprecated) <p></p> Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Use tf.test.compute_gradient in 2.0, which has better support for functions. Note that the two versions have different usage, so code change is needed. <p></p> If `x` or `y` is complex, the Jacobian will still be real but the
corresponding Jacobian dimension(s) will be twice as large.  This is required
even if both input and output is complex since TensorFlow graphs are not
necessarily holomorphic, and may have gradients not expressible as complex
numbers.  For example, if `x` is complex with shape `[m]` and `y` is complex
with shape `[n]`, each Jacobian `J` will have shape `[m * 2, n * 2]` with <p></p> J[:m, :n] = d(Re y)/d(Re x)
J[:m, n:] = d(Im y)/d(Re x)
J[m:, :n] = d(Re y)/d(Im x)
J[m:, n:] = d(Im y)/d(Im x) 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> x
						</dt>
						<dd>a tensor or list of tensors 
						</dd>
						<dt>
							<code><a href="../tensorflow/TensorShape.htm">TensorShape</a></code> x_shape
						</dt>
						<dd>the dimensions of x as a tuple or an array of ints. If x is a list,
then this is the list of shapes. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y
						</dt>
						<dd>a tensor 
						</dd>
						<dt>
							<code><a href="../tensorflow/TensorShape.htm">TensorShape</a></code> y_shape
						</dt>
						<dd>the dimensions of y as a tuple or an array of ints. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> x_init_value
						</dt>
						<dd>(optional) a numpy array of the same shape as "x"
representing the initial value of x. If x is a list, this should be a list
of numpy arrays.  If this is none, the function will pick a random tensor
as the initial value. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> delta
						</dt>
						<dd>(optional) the amount of perturbation. 
						</dd>
						<dt>
							<code><span title="System.Nullable<ValueTuple<IEnumerable<object>, object>>">Nullable&lt;ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;&gt;</span></code> init_targets
						</dt>
						<dd>list of targets to run to initialize model params. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> extra_feed_dict
						</dt>
						<dd>dict that allows fixing specified tensor values
during the Jacobian calculation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>Two 2-d numpy arrays representing the theoretical and numerical
Jacobian for dy/dx. Each has "x_size" rows and "y_size" columns
where "x_size" is the number of elements in x and "y_size" is the
number of elements in y. If x is a list, returns a list of two numpy arrays. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="compute_gradient" class="method">
		<h4>
			<span title="System.object">object</span> <strong>compute_gradient</strong>(<a href="../numpy/ndarray.htm">ndarray</a> x, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> x_shape, <span title="System.object">object</span> y, <a href="../tensorflow/TensorShape.htm">TensorShape</a> y_shape, <span title="System.object">object</span> x_init_value, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> delta, <span title="System.Nullable<ValueTuple<IEnumerable<object>, object>>">Nullable&lt;ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;&gt;</span> init_targets, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> extra_feed_dict)
		</h4>
		<div class="content">Computes and returns the theoretical and numerical Jacobian. (deprecated) <p></p> Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Use tf.test.compute_gradient in 2.0, which has better support for functions. Note that the two versions have different usage, so code change is needed. <p></p> If `x` or `y` is complex, the Jacobian will still be real but the
corresponding Jacobian dimension(s) will be twice as large.  This is required
even if both input and output is complex since TensorFlow graphs are not
necessarily holomorphic, and may have gradients not expressible as complex
numbers.  For example, if `x` is complex with shape `[m]` and `y` is complex
with shape `[n]`, each Jacobian `J` will have shape `[m * 2, n * 2]` with <p></p> J[:m, :n] = d(Re y)/d(Re x)
J[:m, n:] = d(Im y)/d(Re x)
J[m:, :n] = d(Re y)/d(Im x)
J[m:, n:] = d(Im y)/d(Im x) 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> x
						</dt>
						<dd>a tensor or list of tensors 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> x_shape
						</dt>
						<dd>the dimensions of x as a tuple or an array of ints. If x is a list,
then this is the list of shapes. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y
						</dt>
						<dd>a tensor 
						</dd>
						<dt>
							<code><a href="../tensorflow/TensorShape.htm">TensorShape</a></code> y_shape
						</dt>
						<dd>the dimensions of y as a tuple or an array of ints. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> x_init_value
						</dt>
						<dd>(optional) a numpy array of the same shape as "x"
representing the initial value of x. If x is a list, this should be a list
of numpy arrays.  If this is none, the function will pick a random tensor
as the initial value. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> delta
						</dt>
						<dd>(optional) the amount of perturbation. 
						</dd>
						<dt>
							<code><span title="System.Nullable<ValueTuple<IEnumerable<object>, object>>">Nullable&lt;ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;&gt;</span></code> init_targets
						</dt>
						<dd>list of targets to run to initialize model params. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> extra_feed_dict
						</dt>
						<dd>dict that allows fixing specified tensor values
during the Jacobian calculation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>Two 2-d numpy arrays representing the theoretical and numerical
Jacobian for dy/dx. Each has "x_size" rows and "y_size" columns
where "x_size" is the number of elements in x and "y_size" is the
number of elements in y. If x is a list, returns a list of two numpy arrays. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="compute_gradient" class="method">
		<h4>
			<span title="System.object">object</span> <strong>compute_gradient</strong>(<a href="../numpy/ndarray.htm">ndarray</a> x, <a href="../tensorflow/TensorShape.htm">TensorShape</a> x_shape, <span title="System.object">object</span> y, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> y_shape, <span title="System.object">object</span> x_init_value, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> delta, <span title="System.Nullable<ValueTuple<IEnumerable<object>, object>>">Nullable&lt;ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;&gt;</span> init_targets, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> extra_feed_dict)
		</h4>
		<div class="content">Computes and returns the theoretical and numerical Jacobian. (deprecated) <p></p> Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Use tf.test.compute_gradient in 2.0, which has better support for functions. Note that the two versions have different usage, so code change is needed. <p></p> If `x` or `y` is complex, the Jacobian will still be real but the
corresponding Jacobian dimension(s) will be twice as large.  This is required
even if both input and output is complex since TensorFlow graphs are not
necessarily holomorphic, and may have gradients not expressible as complex
numbers.  For example, if `x` is complex with shape `[m]` and `y` is complex
with shape `[n]`, each Jacobian `J` will have shape `[m * 2, n * 2]` with <p></p> J[:m, :n] = d(Re y)/d(Re x)
J[:m, n:] = d(Im y)/d(Re x)
J[m:, :n] = d(Re y)/d(Im x)
J[m:, n:] = d(Im y)/d(Im x) 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> x
						</dt>
						<dd>a tensor or list of tensors 
						</dd>
						<dt>
							<code><a href="../tensorflow/TensorShape.htm">TensorShape</a></code> x_shape
						</dt>
						<dd>the dimensions of x as a tuple or an array of ints. If x is a list,
then this is the list of shapes. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y
						</dt>
						<dd>a tensor 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> y_shape
						</dt>
						<dd>the dimensions of y as a tuple or an array of ints. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> x_init_value
						</dt>
						<dd>(optional) a numpy array of the same shape as "x"
representing the initial value of x. If x is a list, this should be a list
of numpy arrays.  If this is none, the function will pick a random tensor
as the initial value. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> delta
						</dt>
						<dd>(optional) the amount of perturbation. 
						</dd>
						<dt>
							<code><span title="System.Nullable<ValueTuple<IEnumerable<object>, object>>">Nullable&lt;ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;&gt;</span></code> init_targets
						</dt>
						<dd>list of targets to run to initialize model params. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> extra_feed_dict
						</dt>
						<dd>dict that allows fixing specified tensor values
during the Jacobian calculation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>Two 2-d numpy arrays representing the theoretical and numerical
Jacobian for dy/dx. Each has "x_size" rows and "y_size" columns
where "x_size" is the number of elements in x and "y_size" is the
number of elements in y. If x is a list, returns a list of two numpy arrays. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="compute_gradient" class="method">
		<h4>
			<span title="System.object">object</span> <strong>compute_gradient</strong>(<a href="../numpy/ndarray.htm">ndarray</a> x, <a href="../tensorflow/TensorShape.htm">TensorShape</a> x_shape, <span title="System.object">object</span> y, <a href="../tensorflow/TensorShape.htm">TensorShape</a> y_shape, <span title="System.object">object</span> x_init_value, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> delta, <span title="System.Nullable<ValueTuple<IEnumerable<object>, object>>">Nullable&lt;ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;&gt;</span> init_targets, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> extra_feed_dict)
		</h4>
		<div class="content">Computes and returns the theoretical and numerical Jacobian. (deprecated) <p></p> Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Use tf.test.compute_gradient in 2.0, which has better support for functions. Note that the two versions have different usage, so code change is needed. <p></p> If `x` or `y` is complex, the Jacobian will still be real but the
corresponding Jacobian dimension(s) will be twice as large.  This is required
even if both input and output is complex since TensorFlow graphs are not
necessarily holomorphic, and may have gradients not expressible as complex
numbers.  For example, if `x` is complex with shape `[m]` and `y` is complex
with shape `[n]`, each Jacobian `J` will have shape `[m * 2, n * 2]` with <p></p> J[:m, :n] = d(Re y)/d(Re x)
J[:m, n:] = d(Im y)/d(Re x)
J[m:, :n] = d(Re y)/d(Im x)
J[m:, n:] = d(Im y)/d(Im x) 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> x
						</dt>
						<dd>a tensor or list of tensors 
						</dd>
						<dt>
							<code><a href="../tensorflow/TensorShape.htm">TensorShape</a></code> x_shape
						</dt>
						<dd>the dimensions of x as a tuple or an array of ints. If x is a list,
then this is the list of shapes. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y
						</dt>
						<dd>a tensor 
						</dd>
						<dt>
							<code><a href="../tensorflow/TensorShape.htm">TensorShape</a></code> y_shape
						</dt>
						<dd>the dimensions of y as a tuple or an array of ints. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> x_init_value
						</dt>
						<dd>(optional) a numpy array of the same shape as "x"
representing the initial value of x. If x is a list, this should be a list
of numpy arrays.  If this is none, the function will pick a random tensor
as the initial value. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> delta
						</dt>
						<dd>(optional) the amount of perturbation. 
						</dd>
						<dt>
							<code><span title="System.Nullable<ValueTuple<IEnumerable<object>, object>>">Nullable&lt;ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;&gt;</span></code> init_targets
						</dt>
						<dd>list of targets to run to initialize model params. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> extra_feed_dict
						</dt>
						<dd>dict that allows fixing specified tensor values
during the Jacobian calculation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>Two 2-d numpy arrays representing the theoretical and numerical
Jacobian for dy/dx. Each has "x_size" rows and "y_size" columns
where "x_size" is the number of elements in x and "y_size" is the
number of elements in y. If x is a list, returns a list of two numpy arrays. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="compute_gradient" class="method">
		<h4>
			<span title="System.object">object</span> <strong>compute_gradient</strong>(<span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> x, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> x_shape, <span title="System.object">object</span> y, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> y_shape, <span title="System.object">object</span> x_init_value, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> delta, <span title="System.Nullable<ValueTuple<IEnumerable<object>, object>>">Nullable&lt;ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;&gt;</span> init_targets, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> extra_feed_dict)
		</h4>
		<div class="content">Computes and returns the theoretical and numerical Jacobian. (deprecated) <p></p> Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Use tf.test.compute_gradient in 2.0, which has better support for functions. Note that the two versions have different usage, so code change is needed. <p></p> If `x` or `y` is complex, the Jacobian will still be real but the
corresponding Jacobian dimension(s) will be twice as large.  This is required
even if both input and output is complex since TensorFlow graphs are not
necessarily holomorphic, and may have gradients not expressible as complex
numbers.  For example, if `x` is complex with shape `[m]` and `y` is complex
with shape `[n]`, each Jacobian `J` will have shape `[m * 2, n * 2]` with <p></p> J[:m, :n] = d(Re y)/d(Re x)
J[:m, n:] = d(Im y)/d(Re x)
J[m:, :n] = d(Re y)/d(Im x)
J[m:, n:] = d(Im y)/d(Im x) 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> x
						</dt>
						<dd>a tensor or list of tensors 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> x_shape
						</dt>
						<dd>the dimensions of x as a tuple or an array of ints. If x is a list,
then this is the list of shapes. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y
						</dt>
						<dd>a tensor 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> y_shape
						</dt>
						<dd>the dimensions of y as a tuple or an array of ints. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> x_init_value
						</dt>
						<dd>(optional) a numpy array of the same shape as "x"
representing the initial value of x. If x is a list, this should be a list
of numpy arrays.  If this is none, the function will pick a random tensor
as the initial value. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> delta
						</dt>
						<dd>(optional) the amount of perturbation. 
						</dd>
						<dt>
							<code><span title="System.Nullable<ValueTuple<IEnumerable<object>, object>>">Nullable&lt;ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;&gt;</span></code> init_targets
						</dt>
						<dd>list of targets to run to initialize model params. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> extra_feed_dict
						</dt>
						<dd>dict that allows fixing specified tensor values
during the Jacobian calculation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>Two 2-d numpy arrays representing the theoretical and numerical
Jacobian for dy/dx. Each has "x_size" rows and "y_size" columns
where "x_size" is the number of elements in x and "y_size" is the
number of elements in y. If x is a list, returns a list of two numpy arrays. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="compute_gradient" class="method">
		<h4>
			<span title="System.object">object</span> <strong>compute_gradient</strong>(<span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> x, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> x_shape, <span title="System.object">object</span> y, <a href="../tensorflow/TensorShape.htm">TensorShape</a> y_shape, <span title="System.object">object</span> x_init_value, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> delta, <span title="System.Nullable<ValueTuple<IEnumerable<object>, object>>">Nullable&lt;ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;&gt;</span> init_targets, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> extra_feed_dict)
		</h4>
		<div class="content">Computes and returns the theoretical and numerical Jacobian. (deprecated) <p></p> Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Use tf.test.compute_gradient in 2.0, which has better support for functions. Note that the two versions have different usage, so code change is needed. <p></p> If `x` or `y` is complex, the Jacobian will still be real but the
corresponding Jacobian dimension(s) will be twice as large.  This is required
even if both input and output is complex since TensorFlow graphs are not
necessarily holomorphic, and may have gradients not expressible as complex
numbers.  For example, if `x` is complex with shape `[m]` and `y` is complex
with shape `[n]`, each Jacobian `J` will have shape `[m * 2, n * 2]` with <p></p> J[:m, :n] = d(Re y)/d(Re x)
J[:m, n:] = d(Im y)/d(Re x)
J[m:, :n] = d(Re y)/d(Im x)
J[m:, n:] = d(Im y)/d(Im x) 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> x
						</dt>
						<dd>a tensor or list of tensors 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> x_shape
						</dt>
						<dd>the dimensions of x as a tuple or an array of ints. If x is a list,
then this is the list of shapes. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y
						</dt>
						<dd>a tensor 
						</dd>
						<dt>
							<code><a href="../tensorflow/TensorShape.htm">TensorShape</a></code> y_shape
						</dt>
						<dd>the dimensions of y as a tuple or an array of ints. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> x_init_value
						</dt>
						<dd>(optional) a numpy array of the same shape as "x"
representing the initial value of x. If x is a list, this should be a list
of numpy arrays.  If this is none, the function will pick a random tensor
as the initial value. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> delta
						</dt>
						<dd>(optional) the amount of perturbation. 
						</dd>
						<dt>
							<code><span title="System.Nullable<ValueTuple<IEnumerable<object>, object>>">Nullable&lt;ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;&gt;</span></code> init_targets
						</dt>
						<dd>list of targets to run to initialize model params. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> extra_feed_dict
						</dt>
						<dd>dict that allows fixing specified tensor values
during the Jacobian calculation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>Two 2-d numpy arrays representing the theoretical and numerical
Jacobian for dy/dx. Each has "x_size" rows and "y_size" columns
where "x_size" is the number of elements in x and "y_size" is the
number of elements in y. If x is a list, returns a list of two numpy arrays. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="compute_gradient" class="method">
		<h4>
			<span title="System.object">object</span> <strong>compute_gradient</strong>(<span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> x, <a href="../tensorflow/TensorShape.htm">TensorShape</a> x_shape, <span title="System.object">object</span> y, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> y_shape, <span title="System.object">object</span> x_init_value, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> delta, <span title="System.Nullable<ValueTuple<IEnumerable<object>, object>>">Nullable&lt;ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;&gt;</span> init_targets, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> extra_feed_dict)
		</h4>
		<div class="content">Computes and returns the theoretical and numerical Jacobian. (deprecated) <p></p> Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Use tf.test.compute_gradient in 2.0, which has better support for functions. Note that the two versions have different usage, so code change is needed. <p></p> If `x` or `y` is complex, the Jacobian will still be real but the
corresponding Jacobian dimension(s) will be twice as large.  This is required
even if both input and output is complex since TensorFlow graphs are not
necessarily holomorphic, and may have gradients not expressible as complex
numbers.  For example, if `x` is complex with shape `[m]` and `y` is complex
with shape `[n]`, each Jacobian `J` will have shape `[m * 2, n * 2]` with <p></p> J[:m, :n] = d(Re y)/d(Re x)
J[:m, n:] = d(Im y)/d(Re x)
J[m:, :n] = d(Re y)/d(Im x)
J[m:, n:] = d(Im y)/d(Im x) 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> x
						</dt>
						<dd>a tensor or list of tensors 
						</dd>
						<dt>
							<code><a href="../tensorflow/TensorShape.htm">TensorShape</a></code> x_shape
						</dt>
						<dd>the dimensions of x as a tuple or an array of ints. If x is a list,
then this is the list of shapes. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y
						</dt>
						<dd>a tensor 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> y_shape
						</dt>
						<dd>the dimensions of y as a tuple or an array of ints. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> x_init_value
						</dt>
						<dd>(optional) a numpy array of the same shape as "x"
representing the initial value of x. If x is a list, this should be a list
of numpy arrays.  If this is none, the function will pick a random tensor
as the initial value. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> delta
						</dt>
						<dd>(optional) the amount of perturbation. 
						</dd>
						<dt>
							<code><span title="System.Nullable<ValueTuple<IEnumerable<object>, object>>">Nullable&lt;ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;&gt;</span></code> init_targets
						</dt>
						<dd>list of targets to run to initialize model params. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> extra_feed_dict
						</dt>
						<dd>dict that allows fixing specified tensor values
during the Jacobian calculation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>Two 2-d numpy arrays representing the theoretical and numerical
Jacobian for dy/dx. Each has "x_size" rows and "y_size" columns
where "x_size" is the number of elements in x and "y_size" is the
number of elements in y. If x is a list, returns a list of two numpy arrays. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="compute_gradient" class="method">
		<h4>
			<span title="System.object">object</span> <strong>compute_gradient</strong>(<span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> x, <a href="../tensorflow/TensorShape.htm">TensorShape</a> x_shape, <span title="System.object">object</span> y, <a href="../tensorflow/TensorShape.htm">TensorShape</a> y_shape, <span title="System.object">object</span> x_init_value, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> delta, <span title="System.Nullable<ValueTuple<IEnumerable<object>, object>>">Nullable&lt;ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;&gt;</span> init_targets, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> extra_feed_dict)
		</h4>
		<div class="content">Computes and returns the theoretical and numerical Jacobian. (deprecated) <p></p> Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Use tf.test.compute_gradient in 2.0, which has better support for functions. Note that the two versions have different usage, so code change is needed. <p></p> If `x` or `y` is complex, the Jacobian will still be real but the
corresponding Jacobian dimension(s) will be twice as large.  This is required
even if both input and output is complex since TensorFlow graphs are not
necessarily holomorphic, and may have gradients not expressible as complex
numbers.  For example, if `x` is complex with shape `[m]` and `y` is complex
with shape `[n]`, each Jacobian `J` will have shape `[m * 2, n * 2]` with <p></p> J[:m, :n] = d(Re y)/d(Re x)
J[:m, n:] = d(Im y)/d(Re x)
J[m:, :n] = d(Re y)/d(Im x)
J[m:, n:] = d(Im y)/d(Im x) 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> x
						</dt>
						<dd>a tensor or list of tensors 
						</dd>
						<dt>
							<code><a href="../tensorflow/TensorShape.htm">TensorShape</a></code> x_shape
						</dt>
						<dd>the dimensions of x as a tuple or an array of ints. If x is a list,
then this is the list of shapes. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y
						</dt>
						<dd>a tensor 
						</dd>
						<dt>
							<code><a href="../tensorflow/TensorShape.htm">TensorShape</a></code> y_shape
						</dt>
						<dd>the dimensions of y as a tuple or an array of ints. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> x_init_value
						</dt>
						<dd>(optional) a numpy array of the same shape as "x"
representing the initial value of x. If x is a list, this should be a list
of numpy arrays.  If this is none, the function will pick a random tensor
as the initial value. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> delta
						</dt>
						<dd>(optional) the amount of perturbation. 
						</dd>
						<dt>
							<code><span title="System.Nullable<ValueTuple<IEnumerable<object>, object>>">Nullable&lt;ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;&gt;</span></code> init_targets
						</dt>
						<dd>list of targets to run to initialize model params. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> extra_feed_dict
						</dt>
						<dd>dict that allows fixing specified tensor values
during the Jacobian calculation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>Two 2-d numpy arrays representing the theoretical and numerical
Jacobian for dy/dx. Each has "x_size" rows and "y_size" columns
where "x_size" is the number of elements in x and "y_size" is the
number of elements in y. If x is a list, returns a list of two numpy arrays. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="compute_gradient" class="method">
		<h4>
			<span title="System.object">object</span> <strong>compute_gradient</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> x, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> x_shape, <span title="System.object">object</span> y, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> y_shape, <span title="System.object">object</span> x_init_value, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> delta, <span title="System.Nullable<ValueTuple<IEnumerable<object>, object>>">Nullable&lt;ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;&gt;</span> init_targets, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> extra_feed_dict)
		</h4>
		<div class="content">Computes and returns the theoretical and numerical Jacobian. (deprecated) <p></p> Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Use tf.test.compute_gradient in 2.0, which has better support for functions. Note that the two versions have different usage, so code change is needed. <p></p> If `x` or `y` is complex, the Jacobian will still be real but the
corresponding Jacobian dimension(s) will be twice as large.  This is required
even if both input and output is complex since TensorFlow graphs are not
necessarily holomorphic, and may have gradients not expressible as complex
numbers.  For example, if `x` is complex with shape `[m]` and `y` is complex
with shape `[n]`, each Jacobian `J` will have shape `[m * 2, n * 2]` with <p></p> J[:m, :n] = d(Re y)/d(Re x)
J[:m, n:] = d(Im y)/d(Re x)
J[m:, :n] = d(Re y)/d(Im x)
J[m:, n:] = d(Im y)/d(Im x) 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> x
						</dt>
						<dd>a tensor or list of tensors 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> x_shape
						</dt>
						<dd>the dimensions of x as a tuple or an array of ints. If x is a list,
then this is the list of shapes. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y
						</dt>
						<dd>a tensor 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> y_shape
						</dt>
						<dd>the dimensions of y as a tuple or an array of ints. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> x_init_value
						</dt>
						<dd>(optional) a numpy array of the same shape as "x"
representing the initial value of x. If x is a list, this should be a list
of numpy arrays.  If this is none, the function will pick a random tensor
as the initial value. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> delta
						</dt>
						<dd>(optional) the amount of perturbation. 
						</dd>
						<dt>
							<code><span title="System.Nullable<ValueTuple<IEnumerable<object>, object>>">Nullable&lt;ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;&gt;</span></code> init_targets
						</dt>
						<dd>list of targets to run to initialize model params. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> extra_feed_dict
						</dt>
						<dd>dict that allows fixing specified tensor values
during the Jacobian calculation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>Two 2-d numpy arrays representing the theoretical and numerical
Jacobian for dy/dx. Each has "x_size" rows and "y_size" columns
where "x_size" is the number of elements in x and "y_size" is the
number of elements in y. If x is a list, returns a list of two numpy arrays. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="compute_gradient" class="method">
		<h4>
			<span title="System.object">object</span> <strong>compute_gradient</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> x, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> x_shape, <span title="System.object">object</span> y, <a href="../tensorflow/TensorShape.htm">TensorShape</a> y_shape, <span title="System.object">object</span> x_init_value, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> delta, <span title="System.Nullable<ValueTuple<IEnumerable<object>, object>>">Nullable&lt;ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;&gt;</span> init_targets, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> extra_feed_dict)
		</h4>
		<div class="content">Computes and returns the theoretical and numerical Jacobian. (deprecated) <p></p> Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Use tf.test.compute_gradient in 2.0, which has better support for functions. Note that the two versions have different usage, so code change is needed. <p></p> If `x` or `y` is complex, the Jacobian will still be real but the
corresponding Jacobian dimension(s) will be twice as large.  This is required
even if both input and output is complex since TensorFlow graphs are not
necessarily holomorphic, and may have gradients not expressible as complex
numbers.  For example, if `x` is complex with shape `[m]` and `y` is complex
with shape `[n]`, each Jacobian `J` will have shape `[m * 2, n * 2]` with <p></p> J[:m, :n] = d(Re y)/d(Re x)
J[:m, n:] = d(Im y)/d(Re x)
J[m:, :n] = d(Re y)/d(Im x)
J[m:, n:] = d(Im y)/d(Im x) 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> x
						</dt>
						<dd>a tensor or list of tensors 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> x_shape
						</dt>
						<dd>the dimensions of x as a tuple or an array of ints. If x is a list,
then this is the list of shapes. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y
						</dt>
						<dd>a tensor 
						</dd>
						<dt>
							<code><a href="../tensorflow/TensorShape.htm">TensorShape</a></code> y_shape
						</dt>
						<dd>the dimensions of y as a tuple or an array of ints. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> x_init_value
						</dt>
						<dd>(optional) a numpy array of the same shape as "x"
representing the initial value of x. If x is a list, this should be a list
of numpy arrays.  If this is none, the function will pick a random tensor
as the initial value. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> delta
						</dt>
						<dd>(optional) the amount of perturbation. 
						</dd>
						<dt>
							<code><span title="System.Nullable<ValueTuple<IEnumerable<object>, object>>">Nullable&lt;ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;&gt;</span></code> init_targets
						</dt>
						<dd>list of targets to run to initialize model params. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> extra_feed_dict
						</dt>
						<dd>dict that allows fixing specified tensor values
during the Jacobian calculation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>Two 2-d numpy arrays representing the theoretical and numerical
Jacobian for dy/dx. Each has "x_size" rows and "y_size" columns
where "x_size" is the number of elements in x and "y_size" is the
number of elements in y. If x is a list, returns a list of two numpy arrays. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="compute_gradient" class="method">
		<h4>
			<span title="System.object">object</span> <strong>compute_gradient</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> x, <a href="../tensorflow/TensorShape.htm">TensorShape</a> x_shape, <span title="System.object">object</span> y, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> y_shape, <span title="System.object">object</span> x_init_value, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> delta, <span title="System.Nullable<ValueTuple<IEnumerable<object>, object>>">Nullable&lt;ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;&gt;</span> init_targets, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> extra_feed_dict)
		</h4>
		<div class="content">Computes and returns the theoretical and numerical Jacobian. (deprecated) <p></p> Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Use tf.test.compute_gradient in 2.0, which has better support for functions. Note that the two versions have different usage, so code change is needed. <p></p> If `x` or `y` is complex, the Jacobian will still be real but the
corresponding Jacobian dimension(s) will be twice as large.  This is required
even if both input and output is complex since TensorFlow graphs are not
necessarily holomorphic, and may have gradients not expressible as complex
numbers.  For example, if `x` is complex with shape `[m]` and `y` is complex
with shape `[n]`, each Jacobian `J` will have shape `[m * 2, n * 2]` with <p></p> J[:m, :n] = d(Re y)/d(Re x)
J[:m, n:] = d(Im y)/d(Re x)
J[m:, :n] = d(Re y)/d(Im x)
J[m:, n:] = d(Im y)/d(Im x) 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> x
						</dt>
						<dd>a tensor or list of tensors 
						</dd>
						<dt>
							<code><a href="../tensorflow/TensorShape.htm">TensorShape</a></code> x_shape
						</dt>
						<dd>the dimensions of x as a tuple or an array of ints. If x is a list,
then this is the list of shapes. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y
						</dt>
						<dd>a tensor 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> y_shape
						</dt>
						<dd>the dimensions of y as a tuple or an array of ints. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> x_init_value
						</dt>
						<dd>(optional) a numpy array of the same shape as "x"
representing the initial value of x. If x is a list, this should be a list
of numpy arrays.  If this is none, the function will pick a random tensor
as the initial value. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> delta
						</dt>
						<dd>(optional) the amount of perturbation. 
						</dd>
						<dt>
							<code><span title="System.Nullable<ValueTuple<IEnumerable<object>, object>>">Nullable&lt;ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;&gt;</span></code> init_targets
						</dt>
						<dd>list of targets to run to initialize model params. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> extra_feed_dict
						</dt>
						<dd>dict that allows fixing specified tensor values
during the Jacobian calculation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>Two 2-d numpy arrays representing the theoretical and numerical
Jacobian for dy/dx. Each has "x_size" rows and "y_size" columns
where "x_size" is the number of elements in x and "y_size" is the
number of elements in y. If x is a list, returns a list of two numpy arrays. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="compute_gradient" class="method">
		<h4>
			<span title="System.object">object</span> <strong>compute_gradient</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> x, <a href="../tensorflow/TensorShape.htm">TensorShape</a> x_shape, <span title="System.object">object</span> y, <a href="../tensorflow/TensorShape.htm">TensorShape</a> y_shape, <span title="System.object">object</span> x_init_value, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> delta, <span title="System.Nullable<ValueTuple<IEnumerable<object>, object>>">Nullable&lt;ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;&gt;</span> init_targets, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> extra_feed_dict)
		</h4>
		<div class="content">Computes and returns the theoretical and numerical Jacobian. (deprecated) <p></p> Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Use tf.test.compute_gradient in 2.0, which has better support for functions. Note that the two versions have different usage, so code change is needed. <p></p> If `x` or `y` is complex, the Jacobian will still be real but the
corresponding Jacobian dimension(s) will be twice as large.  This is required
even if both input and output is complex since TensorFlow graphs are not
necessarily holomorphic, and may have gradients not expressible as complex
numbers.  For example, if `x` is complex with shape `[m]` and `y` is complex
with shape `[n]`, each Jacobian `J` will have shape `[m * 2, n * 2]` with <p></p> J[:m, :n] = d(Re y)/d(Re x)
J[:m, n:] = d(Im y)/d(Re x)
J[m:, :n] = d(Re y)/d(Im x)
J[m:, n:] = d(Im y)/d(Im x) 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> x
						</dt>
						<dd>a tensor or list of tensors 
						</dd>
						<dt>
							<code><a href="../tensorflow/TensorShape.htm">TensorShape</a></code> x_shape
						</dt>
						<dd>the dimensions of x as a tuple or an array of ints. If x is a list,
then this is the list of shapes. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y
						</dt>
						<dd>a tensor 
						</dd>
						<dt>
							<code><a href="../tensorflow/TensorShape.htm">TensorShape</a></code> y_shape
						</dt>
						<dd>the dimensions of y as a tuple or an array of ints. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> x_init_value
						</dt>
						<dd>(optional) a numpy array of the same shape as "x"
representing the initial value of x. If x is a list, this should be a list
of numpy arrays.  If this is none, the function will pick a random tensor
as the initial value. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> delta
						</dt>
						<dd>(optional) the amount of perturbation. 
						</dd>
						<dt>
							<code><span title="System.Nullable<ValueTuple<IEnumerable<object>, object>>">Nullable&lt;ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;&gt;</span></code> init_targets
						</dt>
						<dd>list of targets to run to initialize model params. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> extra_feed_dict
						</dt>
						<dd>dict that allows fixing specified tensor values
during the Jacobian calculation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>Two 2-d numpy arrays representing the theoretical and numerical
Jacobian for dy/dx. Each has "x_size" rows and "y_size" columns
where "x_size" is the number of elements in x and "y_size" is the
number of elements in y. If x is a list, returns a list of two numpy arrays. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="compute_gradient" class="method">
		<h4>
			<span title="System.object">object</span> <strong>compute_gradient</strong>(<span title="System.ValueTuple<double, object>">ValueTuple&lt;double, object&gt;</span> x, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> x_shape, <span title="System.object">object</span> y, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> y_shape, <span title="System.object">object</span> x_init_value, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> delta, <span title="System.Nullable<ValueTuple<IEnumerable<object>, object>>">Nullable&lt;ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;&gt;</span> init_targets, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> extra_feed_dict)
		</h4>
		<div class="content">Computes and returns the theoretical and numerical Jacobian. (deprecated) <p></p> Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Use tf.test.compute_gradient in 2.0, which has better support for functions. Note that the two versions have different usage, so code change is needed. <p></p> If `x` or `y` is complex, the Jacobian will still be real but the
corresponding Jacobian dimension(s) will be twice as large.  This is required
even if both input and output is complex since TensorFlow graphs are not
necessarily holomorphic, and may have gradients not expressible as complex
numbers.  For example, if `x` is complex with shape `[m]` and `y` is complex
with shape `[n]`, each Jacobian `J` will have shape `[m * 2, n * 2]` with <p></p> J[:m, :n] = d(Re y)/d(Re x)
J[:m, n:] = d(Im y)/d(Re x)
J[m:, :n] = d(Re y)/d(Im x)
J[m:, n:] = d(Im y)/d(Im x) 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<double, object>">ValueTuple&lt;double, object&gt;</span></code> x
						</dt>
						<dd>a tensor or list of tensors 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> x_shape
						</dt>
						<dd>the dimensions of x as a tuple or an array of ints. If x is a list,
then this is the list of shapes. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y
						</dt>
						<dd>a tensor 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> y_shape
						</dt>
						<dd>the dimensions of y as a tuple or an array of ints. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> x_init_value
						</dt>
						<dd>(optional) a numpy array of the same shape as "x"
representing the initial value of x. If x is a list, this should be a list
of numpy arrays.  If this is none, the function will pick a random tensor
as the initial value. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> delta
						</dt>
						<dd>(optional) the amount of perturbation. 
						</dd>
						<dt>
							<code><span title="System.Nullable<ValueTuple<IEnumerable<object>, object>>">Nullable&lt;ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;&gt;</span></code> init_targets
						</dt>
						<dd>list of targets to run to initialize model params. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> extra_feed_dict
						</dt>
						<dd>dict that allows fixing specified tensor values
during the Jacobian calculation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>Two 2-d numpy arrays representing the theoretical and numerical
Jacobian for dy/dx. Each has "x_size" rows and "y_size" columns
where "x_size" is the number of elements in x and "y_size" is the
number of elements in y. If x is a list, returns a list of two numpy arrays. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="compute_gradient" class="method">
		<h4>
			<span title="System.object">object</span> <strong>compute_gradient</strong>(<span title="System.ValueTuple<double, object>">ValueTuple&lt;double, object&gt;</span> x, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> x_shape, <span title="System.object">object</span> y, <a href="../tensorflow/TensorShape.htm">TensorShape</a> y_shape, <span title="System.object">object</span> x_init_value, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> delta, <span title="System.Nullable<ValueTuple<IEnumerable<object>, object>>">Nullable&lt;ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;&gt;</span> init_targets, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> extra_feed_dict)
		</h4>
		<div class="content">Computes and returns the theoretical and numerical Jacobian. (deprecated) <p></p> Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Use tf.test.compute_gradient in 2.0, which has better support for functions. Note that the two versions have different usage, so code change is needed. <p></p> If `x` or `y` is complex, the Jacobian will still be real but the
corresponding Jacobian dimension(s) will be twice as large.  This is required
even if both input and output is complex since TensorFlow graphs are not
necessarily holomorphic, and may have gradients not expressible as complex
numbers.  For example, if `x` is complex with shape `[m]` and `y` is complex
with shape `[n]`, each Jacobian `J` will have shape `[m * 2, n * 2]` with <p></p> J[:m, :n] = d(Re y)/d(Re x)
J[:m, n:] = d(Im y)/d(Re x)
J[m:, :n] = d(Re y)/d(Im x)
J[m:, n:] = d(Im y)/d(Im x) 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<double, object>">ValueTuple&lt;double, object&gt;</span></code> x
						</dt>
						<dd>a tensor or list of tensors 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> x_shape
						</dt>
						<dd>the dimensions of x as a tuple or an array of ints. If x is a list,
then this is the list of shapes. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y
						</dt>
						<dd>a tensor 
						</dd>
						<dt>
							<code><a href="../tensorflow/TensorShape.htm">TensorShape</a></code> y_shape
						</dt>
						<dd>the dimensions of y as a tuple or an array of ints. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> x_init_value
						</dt>
						<dd>(optional) a numpy array of the same shape as "x"
representing the initial value of x. If x is a list, this should be a list
of numpy arrays.  If this is none, the function will pick a random tensor
as the initial value. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> delta
						</dt>
						<dd>(optional) the amount of perturbation. 
						</dd>
						<dt>
							<code><span title="System.Nullable<ValueTuple<IEnumerable<object>, object>>">Nullable&lt;ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;&gt;</span></code> init_targets
						</dt>
						<dd>list of targets to run to initialize model params. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> extra_feed_dict
						</dt>
						<dd>dict that allows fixing specified tensor values
during the Jacobian calculation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>Two 2-d numpy arrays representing the theoretical and numerical
Jacobian for dy/dx. Each has "x_size" rows and "y_size" columns
where "x_size" is the number of elements in x and "y_size" is the
number of elements in y. If x is a list, returns a list of two numpy arrays. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="compute_gradient" class="method">
		<h4>
			<span title="System.object">object</span> <strong>compute_gradient</strong>(<span title="System.ValueTuple<double, object>">ValueTuple&lt;double, object&gt;</span> x, <a href="../tensorflow/TensorShape.htm">TensorShape</a> x_shape, <span title="System.object">object</span> y, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> y_shape, <span title="System.object">object</span> x_init_value, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> delta, <span title="System.Nullable<ValueTuple<IEnumerable<object>, object>>">Nullable&lt;ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;&gt;</span> init_targets, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> extra_feed_dict)
		</h4>
		<div class="content">Computes and returns the theoretical and numerical Jacobian. (deprecated) <p></p> Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Use tf.test.compute_gradient in 2.0, which has better support for functions. Note that the two versions have different usage, so code change is needed. <p></p> If `x` or `y` is complex, the Jacobian will still be real but the
corresponding Jacobian dimension(s) will be twice as large.  This is required
even if both input and output is complex since TensorFlow graphs are not
necessarily holomorphic, and may have gradients not expressible as complex
numbers.  For example, if `x` is complex with shape `[m]` and `y` is complex
with shape `[n]`, each Jacobian `J` will have shape `[m * 2, n * 2]` with <p></p> J[:m, :n] = d(Re y)/d(Re x)
J[:m, n:] = d(Im y)/d(Re x)
J[m:, :n] = d(Re y)/d(Im x)
J[m:, n:] = d(Im y)/d(Im x) 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<double, object>">ValueTuple&lt;double, object&gt;</span></code> x
						</dt>
						<dd>a tensor or list of tensors 
						</dd>
						<dt>
							<code><a href="../tensorflow/TensorShape.htm">TensorShape</a></code> x_shape
						</dt>
						<dd>the dimensions of x as a tuple or an array of ints. If x is a list,
then this is the list of shapes. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y
						</dt>
						<dd>a tensor 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> y_shape
						</dt>
						<dd>the dimensions of y as a tuple or an array of ints. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> x_init_value
						</dt>
						<dd>(optional) a numpy array of the same shape as "x"
representing the initial value of x. If x is a list, this should be a list
of numpy arrays.  If this is none, the function will pick a random tensor
as the initial value. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> delta
						</dt>
						<dd>(optional) the amount of perturbation. 
						</dd>
						<dt>
							<code><span title="System.Nullable<ValueTuple<IEnumerable<object>, object>>">Nullable&lt;ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;&gt;</span></code> init_targets
						</dt>
						<dd>list of targets to run to initialize model params. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> extra_feed_dict
						</dt>
						<dd>dict that allows fixing specified tensor values
during the Jacobian calculation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>Two 2-d numpy arrays representing the theoretical and numerical
Jacobian for dy/dx. Each has "x_size" rows and "y_size" columns
where "x_size" is the number of elements in x and "y_size" is the
number of elements in y. If x is a list, returns a list of two numpy arrays. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="compute_gradient" class="method">
		<h4>
			<span title="System.object">object</span> <strong>compute_gradient</strong>(<span title="System.ValueTuple<double, object>">ValueTuple&lt;double, object&gt;</span> x, <a href="../tensorflow/TensorShape.htm">TensorShape</a> x_shape, <span title="System.object">object</span> y, <a href="../tensorflow/TensorShape.htm">TensorShape</a> y_shape, <span title="System.object">object</span> x_init_value, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> delta, <span title="System.Nullable<ValueTuple<IEnumerable<object>, object>>">Nullable&lt;ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;&gt;</span> init_targets, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> extra_feed_dict)
		</h4>
		<div class="content">Computes and returns the theoretical and numerical Jacobian. (deprecated) <p></p> Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Use tf.test.compute_gradient in 2.0, which has better support for functions. Note that the two versions have different usage, so code change is needed. <p></p> If `x` or `y` is complex, the Jacobian will still be real but the
corresponding Jacobian dimension(s) will be twice as large.  This is required
even if both input and output is complex since TensorFlow graphs are not
necessarily holomorphic, and may have gradients not expressible as complex
numbers.  For example, if `x` is complex with shape `[m]` and `y` is complex
with shape `[n]`, each Jacobian `J` will have shape `[m * 2, n * 2]` with <p></p> J[:m, :n] = d(Re y)/d(Re x)
J[:m, n:] = d(Im y)/d(Re x)
J[m:, :n] = d(Re y)/d(Im x)
J[m:, n:] = d(Im y)/d(Im x) 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<double, object>">ValueTuple&lt;double, object&gt;</span></code> x
						</dt>
						<dd>a tensor or list of tensors 
						</dd>
						<dt>
							<code><a href="../tensorflow/TensorShape.htm">TensorShape</a></code> x_shape
						</dt>
						<dd>the dimensions of x as a tuple or an array of ints. If x is a list,
then this is the list of shapes. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y
						</dt>
						<dd>a tensor 
						</dd>
						<dt>
							<code><a href="../tensorflow/TensorShape.htm">TensorShape</a></code> y_shape
						</dt>
						<dd>the dimensions of y as a tuple or an array of ints. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> x_init_value
						</dt>
						<dd>(optional) a numpy array of the same shape as "x"
representing the initial value of x. If x is a list, this should be a list
of numpy arrays.  If this is none, the function will pick a random tensor
as the initial value. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> delta
						</dt>
						<dd>(optional) the amount of perturbation. 
						</dd>
						<dt>
							<code><span title="System.Nullable<ValueTuple<IEnumerable<object>, object>>">Nullable&lt;ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;&gt;</span></code> init_targets
						</dt>
						<dd>list of targets to run to initialize model params. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> extra_feed_dict
						</dt>
						<dd>dict that allows fixing specified tensor values
during the Jacobian calculation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>Two 2-d numpy arrays representing the theoretical and numerical
Jacobian for dy/dx. Each has "x_size" rows and "y_size" columns
where "x_size" is the number of elements in x and "y_size" is the
number of elements in y. If x is a list, returns a list of two numpy arrays. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="compute_gradient" class="method">
		<h4>
			<span title="System.object">object</span> <strong>compute_gradient</strong>(<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> x, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> x_shape, <span title="System.object">object</span> y, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> y_shape, <span title="System.object">object</span> x_init_value, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> delta, <span title="System.Nullable<ValueTuple<IEnumerable<object>, object>>">Nullable&lt;ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;&gt;</span> init_targets, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> extra_feed_dict)
		</h4>
		<div class="content">Computes and returns the theoretical and numerical Jacobian. (deprecated) <p></p> Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Use tf.test.compute_gradient in 2.0, which has better support for functions. Note that the two versions have different usage, so code change is needed. <p></p> If `x` or `y` is complex, the Jacobian will still be real but the
corresponding Jacobian dimension(s) will be twice as large.  This is required
even if both input and output is complex since TensorFlow graphs are not
necessarily holomorphic, and may have gradients not expressible as complex
numbers.  For example, if `x` is complex with shape `[m]` and `y` is complex
with shape `[n]`, each Jacobian `J` will have shape `[m * 2, n * 2]` with <p></p> J[:m, :n] = d(Re y)/d(Re x)
J[:m, n:] = d(Im y)/d(Re x)
J[m:, :n] = d(Re y)/d(Im x)
J[m:, n:] = d(Im y)/d(Im x) 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code> x
						</dt>
						<dd>a tensor or list of tensors 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> x_shape
						</dt>
						<dd>the dimensions of x as a tuple or an array of ints. If x is a list,
then this is the list of shapes. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y
						</dt>
						<dd>a tensor 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> y_shape
						</dt>
						<dd>the dimensions of y as a tuple or an array of ints. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> x_init_value
						</dt>
						<dd>(optional) a numpy array of the same shape as "x"
representing the initial value of x. If x is a list, this should be a list
of numpy arrays.  If this is none, the function will pick a random tensor
as the initial value. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> delta
						</dt>
						<dd>(optional) the amount of perturbation. 
						</dd>
						<dt>
							<code><span title="System.Nullable<ValueTuple<IEnumerable<object>, object>>">Nullable&lt;ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;&gt;</span></code> init_targets
						</dt>
						<dd>list of targets to run to initialize model params. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> extra_feed_dict
						</dt>
						<dd>dict that allows fixing specified tensor values
during the Jacobian calculation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>Two 2-d numpy arrays representing the theoretical and numerical
Jacobian for dy/dx. Each has "x_size" rows and "y_size" columns
where "x_size" is the number of elements in x and "y_size" is the
number of elements in y. If x is a list, returns a list of two numpy arrays. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="compute_gradient" class="method">
		<h4>
			<span title="System.object">object</span> <strong>compute_gradient</strong>(<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> x, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> x_shape, <span title="System.object">object</span> y, <a href="../tensorflow/TensorShape.htm">TensorShape</a> y_shape, <span title="System.object">object</span> x_init_value, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> delta, <span title="System.Nullable<ValueTuple<IEnumerable<object>, object>>">Nullable&lt;ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;&gt;</span> init_targets, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> extra_feed_dict)
		</h4>
		<div class="content">Computes and returns the theoretical and numerical Jacobian. (deprecated) <p></p> Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Use tf.test.compute_gradient in 2.0, which has better support for functions. Note that the two versions have different usage, so code change is needed. <p></p> If `x` or `y` is complex, the Jacobian will still be real but the
corresponding Jacobian dimension(s) will be twice as large.  This is required
even if both input and output is complex since TensorFlow graphs are not
necessarily holomorphic, and may have gradients not expressible as complex
numbers.  For example, if `x` is complex with shape `[m]` and `y` is complex
with shape `[n]`, each Jacobian `J` will have shape `[m * 2, n * 2]` with <p></p> J[:m, :n] = d(Re y)/d(Re x)
J[:m, n:] = d(Im y)/d(Re x)
J[m:, :n] = d(Re y)/d(Im x)
J[m:, n:] = d(Im y)/d(Im x) 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code> x
						</dt>
						<dd>a tensor or list of tensors 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> x_shape
						</dt>
						<dd>the dimensions of x as a tuple or an array of ints. If x is a list,
then this is the list of shapes. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y
						</dt>
						<dd>a tensor 
						</dd>
						<dt>
							<code><a href="../tensorflow/TensorShape.htm">TensorShape</a></code> y_shape
						</dt>
						<dd>the dimensions of y as a tuple or an array of ints. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> x_init_value
						</dt>
						<dd>(optional) a numpy array of the same shape as "x"
representing the initial value of x. If x is a list, this should be a list
of numpy arrays.  If this is none, the function will pick a random tensor
as the initial value. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> delta
						</dt>
						<dd>(optional) the amount of perturbation. 
						</dd>
						<dt>
							<code><span title="System.Nullable<ValueTuple<IEnumerable<object>, object>>">Nullable&lt;ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;&gt;</span></code> init_targets
						</dt>
						<dd>list of targets to run to initialize model params. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> extra_feed_dict
						</dt>
						<dd>dict that allows fixing specified tensor values
during the Jacobian calculation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>Two 2-d numpy arrays representing the theoretical and numerical
Jacobian for dy/dx. Each has "x_size" rows and "y_size" columns
where "x_size" is the number of elements in x and "y_size" is the
number of elements in y. If x is a list, returns a list of two numpy arrays. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="compute_gradient" class="method">
		<h4>
			<span title="System.object">object</span> <strong>compute_gradient</strong>(<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> x, <a href="../tensorflow/TensorShape.htm">TensorShape</a> x_shape, <span title="System.object">object</span> y, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> y_shape, <span title="System.object">object</span> x_init_value, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> delta, <span title="System.Nullable<ValueTuple<IEnumerable<object>, object>>">Nullable&lt;ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;&gt;</span> init_targets, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> extra_feed_dict)
		</h4>
		<div class="content">Computes and returns the theoretical and numerical Jacobian. (deprecated) <p></p> Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Use tf.test.compute_gradient in 2.0, which has better support for functions. Note that the two versions have different usage, so code change is needed. <p></p> If `x` or `y` is complex, the Jacobian will still be real but the
corresponding Jacobian dimension(s) will be twice as large.  This is required
even if both input and output is complex since TensorFlow graphs are not
necessarily holomorphic, and may have gradients not expressible as complex
numbers.  For example, if `x` is complex with shape `[m]` and `y` is complex
with shape `[n]`, each Jacobian `J` will have shape `[m * 2, n * 2]` with <p></p> J[:m, :n] = d(Re y)/d(Re x)
J[:m, n:] = d(Im y)/d(Re x)
J[m:, :n] = d(Re y)/d(Im x)
J[m:, n:] = d(Im y)/d(Im x) 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code> x
						</dt>
						<dd>a tensor or list of tensors 
						</dd>
						<dt>
							<code><a href="../tensorflow/TensorShape.htm">TensorShape</a></code> x_shape
						</dt>
						<dd>the dimensions of x as a tuple or an array of ints. If x is a list,
then this is the list of shapes. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y
						</dt>
						<dd>a tensor 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> y_shape
						</dt>
						<dd>the dimensions of y as a tuple or an array of ints. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> x_init_value
						</dt>
						<dd>(optional) a numpy array of the same shape as "x"
representing the initial value of x. If x is a list, this should be a list
of numpy arrays.  If this is none, the function will pick a random tensor
as the initial value. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> delta
						</dt>
						<dd>(optional) the amount of perturbation. 
						</dd>
						<dt>
							<code><span title="System.Nullable<ValueTuple<IEnumerable<object>, object>>">Nullable&lt;ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;&gt;</span></code> init_targets
						</dt>
						<dd>list of targets to run to initialize model params. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> extra_feed_dict
						</dt>
						<dd>dict that allows fixing specified tensor values
during the Jacobian calculation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>Two 2-d numpy arrays representing the theoretical and numerical
Jacobian for dy/dx. Each has "x_size" rows and "y_size" columns
where "x_size" is the number of elements in x and "y_size" is the
number of elements in y. If x is a list, returns a list of two numpy arrays. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="compute_gradient" class="method">
		<h4>
			<span title="System.object">object</span> <strong>compute_gradient</strong>(<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> x, <a href="../tensorflow/TensorShape.htm">TensorShape</a> x_shape, <span title="System.object">object</span> y, <a href="../tensorflow/TensorShape.htm">TensorShape</a> y_shape, <span title="System.object">object</span> x_init_value, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> delta, <span title="System.Nullable<ValueTuple<IEnumerable<object>, object>>">Nullable&lt;ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;&gt;</span> init_targets, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> extra_feed_dict)
		</h4>
		<div class="content">Computes and returns the theoretical and numerical Jacobian. (deprecated) <p></p> Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Use tf.test.compute_gradient in 2.0, which has better support for functions. Note that the two versions have different usage, so code change is needed. <p></p> If `x` or `y` is complex, the Jacobian will still be real but the
corresponding Jacobian dimension(s) will be twice as large.  This is required
even if both input and output is complex since TensorFlow graphs are not
necessarily holomorphic, and may have gradients not expressible as complex
numbers.  For example, if `x` is complex with shape `[m]` and `y` is complex
with shape `[n]`, each Jacobian `J` will have shape `[m * 2, n * 2]` with <p></p> J[:m, :n] = d(Re y)/d(Re x)
J[:m, n:] = d(Im y)/d(Re x)
J[m:, :n] = d(Re y)/d(Im x)
J[m:, n:] = d(Im y)/d(Im x) 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code> x
						</dt>
						<dd>a tensor or list of tensors 
						</dd>
						<dt>
							<code><a href="../tensorflow/TensorShape.htm">TensorShape</a></code> x_shape
						</dt>
						<dd>the dimensions of x as a tuple or an array of ints. If x is a list,
then this is the list of shapes. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y
						</dt>
						<dd>a tensor 
						</dd>
						<dt>
							<code><a href="../tensorflow/TensorShape.htm">TensorShape</a></code> y_shape
						</dt>
						<dd>the dimensions of y as a tuple or an array of ints. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> x_init_value
						</dt>
						<dd>(optional) a numpy array of the same shape as "x"
representing the initial value of x. If x is a list, this should be a list
of numpy arrays.  If this is none, the function will pick a random tensor
as the initial value. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> delta
						</dt>
						<dd>(optional) the amount of perturbation. 
						</dd>
						<dt>
							<code><span title="System.Nullable<ValueTuple<IEnumerable<object>, object>>">Nullable&lt;ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;&gt;</span></code> init_targets
						</dt>
						<dd>list of targets to run to initialize model params. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> extra_feed_dict
						</dt>
						<dd>dict that allows fixing specified tensor values
during the Jacobian calculation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>Two 2-d numpy arrays representing the theoretical and numerical
Jacobian for dy/dx. Each has "x_size" rows and "y_size" columns
where "x_size" is the number of elements in x and "y_size" is the
number of elements in y. If x is a list, returns a list of two numpy arrays. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="compute_gradient" class="method">
		<h4>
			<span title="System.object">object</span> <strong>compute_gradient</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> x, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> x_shape, <span title="System.object">object</span> y, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> y_shape, <span title="System.object">object</span> x_init_value, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> delta, <span title="System.Nullable<ValueTuple<IEnumerable<object>, object>>">Nullable&lt;ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;&gt;</span> init_targets, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> extra_feed_dict)
		</h4>
		<div class="content">Computes and returns the theoretical and numerical Jacobian. (deprecated) <p></p> Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Use tf.test.compute_gradient in 2.0, which has better support for functions. Note that the two versions have different usage, so code change is needed. <p></p> If `x` or `y` is complex, the Jacobian will still be real but the
corresponding Jacobian dimension(s) will be twice as large.  This is required
even if both input and output is complex since TensorFlow graphs are not
necessarily holomorphic, and may have gradients not expressible as complex
numbers.  For example, if `x` is complex with shape `[m]` and `y` is complex
with shape `[n]`, each Jacobian `J` will have shape `[m * 2, n * 2]` with <p></p> J[:m, :n] = d(Re y)/d(Re x)
J[:m, n:] = d(Im y)/d(Re x)
J[m:, :n] = d(Re y)/d(Im x)
J[m:, n:] = d(Im y)/d(Im x) 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> x
						</dt>
						<dd>a tensor or list of tensors 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> x_shape
						</dt>
						<dd>the dimensions of x as a tuple or an array of ints. If x is a list,
then this is the list of shapes. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y
						</dt>
						<dd>a tensor 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> y_shape
						</dt>
						<dd>the dimensions of y as a tuple or an array of ints. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> x_init_value
						</dt>
						<dd>(optional) a numpy array of the same shape as "x"
representing the initial value of x. If x is a list, this should be a list
of numpy arrays.  If this is none, the function will pick a random tensor
as the initial value. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> delta
						</dt>
						<dd>(optional) the amount of perturbation. 
						</dd>
						<dt>
							<code><span title="System.Nullable<ValueTuple<IEnumerable<object>, object>>">Nullable&lt;ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;&gt;</span></code> init_targets
						</dt>
						<dd>list of targets to run to initialize model params. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> extra_feed_dict
						</dt>
						<dd>dict that allows fixing specified tensor values
during the Jacobian calculation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>Two 2-d numpy arrays representing the theoretical and numerical
Jacobian for dy/dx. Each has "x_size" rows and "y_size" columns
where "x_size" is the number of elements in x and "y_size" is the
number of elements in y. If x is a list, returns a list of two numpy arrays. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="compute_gradient" class="method">
		<h4>
			<span title="System.object">object</span> <strong>compute_gradient</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> x, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> x_shape, <span title="System.object">object</span> y, <a href="../tensorflow/TensorShape.htm">TensorShape</a> y_shape, <span title="System.object">object</span> x_init_value, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> delta, <span title="System.Nullable<ValueTuple<IEnumerable<object>, object>>">Nullable&lt;ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;&gt;</span> init_targets, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> extra_feed_dict)
		</h4>
		<div class="content">Computes and returns the theoretical and numerical Jacobian. (deprecated) <p></p> Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Use tf.test.compute_gradient in 2.0, which has better support for functions. Note that the two versions have different usage, so code change is needed. <p></p> If `x` or `y` is complex, the Jacobian will still be real but the
corresponding Jacobian dimension(s) will be twice as large.  This is required
even if both input and output is complex since TensorFlow graphs are not
necessarily holomorphic, and may have gradients not expressible as complex
numbers.  For example, if `x` is complex with shape `[m]` and `y` is complex
with shape `[n]`, each Jacobian `J` will have shape `[m * 2, n * 2]` with <p></p> J[:m, :n] = d(Re y)/d(Re x)
J[:m, n:] = d(Im y)/d(Re x)
J[m:, :n] = d(Re y)/d(Im x)
J[m:, n:] = d(Im y)/d(Im x) 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> x
						</dt>
						<dd>a tensor or list of tensors 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> x_shape
						</dt>
						<dd>the dimensions of x as a tuple or an array of ints. If x is a list,
then this is the list of shapes. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y
						</dt>
						<dd>a tensor 
						</dd>
						<dt>
							<code><a href="../tensorflow/TensorShape.htm">TensorShape</a></code> y_shape
						</dt>
						<dd>the dimensions of y as a tuple or an array of ints. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> x_init_value
						</dt>
						<dd>(optional) a numpy array of the same shape as "x"
representing the initial value of x. If x is a list, this should be a list
of numpy arrays.  If this is none, the function will pick a random tensor
as the initial value. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> delta
						</dt>
						<dd>(optional) the amount of perturbation. 
						</dd>
						<dt>
							<code><span title="System.Nullable<ValueTuple<IEnumerable<object>, object>>">Nullable&lt;ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;&gt;</span></code> init_targets
						</dt>
						<dd>list of targets to run to initialize model params. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> extra_feed_dict
						</dt>
						<dd>dict that allows fixing specified tensor values
during the Jacobian calculation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>Two 2-d numpy arrays representing the theoretical and numerical
Jacobian for dy/dx. Each has "x_size" rows and "y_size" columns
where "x_size" is the number of elements in x and "y_size" is the
number of elements in y. If x is a list, returns a list of two numpy arrays. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="compute_gradient" class="method">
		<h4>
			<span title="System.object">object</span> <strong>compute_gradient</strong>(<a href="../numpy/ndarray.htm">ndarray</a> x, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> x_shape, <span title="System.object">object</span> y, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> y_shape, <span title="System.object">object</span> x_init_value, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> delta, <span title="System.Nullable<ValueTuple<IEnumerable<object>, object>>">Nullable&lt;ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;&gt;</span> init_targets, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> extra_feed_dict)
		</h4>
		<div class="content">Computes and returns the theoretical and numerical Jacobian. (deprecated) <p></p> Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Use tf.test.compute_gradient in 2.0, which has better support for functions. Note that the two versions have different usage, so code change is needed. <p></p> If `x` or `y` is complex, the Jacobian will still be real but the
corresponding Jacobian dimension(s) will be twice as large.  This is required
even if both input and output is complex since TensorFlow graphs are not
necessarily holomorphic, and may have gradients not expressible as complex
numbers.  For example, if `x` is complex with shape `[m]` and `y` is complex
with shape `[n]`, each Jacobian `J` will have shape `[m * 2, n * 2]` with <p></p> J[:m, :n] = d(Re y)/d(Re x)
J[:m, n:] = d(Im y)/d(Re x)
J[m:, :n] = d(Re y)/d(Im x)
J[m:, n:] = d(Im y)/d(Im x) 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> x
						</dt>
						<dd>a tensor or list of tensors 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> x_shape
						</dt>
						<dd>the dimensions of x as a tuple or an array of ints. If x is a list,
then this is the list of shapes. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y
						</dt>
						<dd>a tensor 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> y_shape
						</dt>
						<dd>the dimensions of y as a tuple or an array of ints. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> x_init_value
						</dt>
						<dd>(optional) a numpy array of the same shape as "x"
representing the initial value of x. If x is a list, this should be a list
of numpy arrays.  If this is none, the function will pick a random tensor
as the initial value. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> delta
						</dt>
						<dd>(optional) the amount of perturbation. 
						</dd>
						<dt>
							<code><span title="System.Nullable<ValueTuple<IEnumerable<object>, object>>">Nullable&lt;ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;&gt;</span></code> init_targets
						</dt>
						<dd>list of targets to run to initialize model params. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> extra_feed_dict
						</dt>
						<dd>dict that allows fixing specified tensor values
during the Jacobian calculation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>Two 2-d numpy arrays representing the theoretical and numerical
Jacobian for dy/dx. Each has "x_size" rows and "y_size" columns
where "x_size" is the number of elements in x and "y_size" is the
number of elements in y. If x is a list, returns a list of two numpy arrays. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="compute_gradient" class="method">
		<h4>
			<span title="System.object">object</span> <strong>compute_gradient</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> x, <a href="../tensorflow/TensorShape.htm">TensorShape</a> x_shape, <span title="System.object">object</span> y, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> y_shape, <span title="System.object">object</span> x_init_value, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> delta, <span title="System.Nullable<ValueTuple<IEnumerable<object>, object>>">Nullable&lt;ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;&gt;</span> init_targets, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> extra_feed_dict)
		</h4>
		<div class="content">Computes and returns the theoretical and numerical Jacobian. (deprecated) <p></p> Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Use tf.test.compute_gradient in 2.0, which has better support for functions. Note that the two versions have different usage, so code change is needed. <p></p> If `x` or `y` is complex, the Jacobian will still be real but the
corresponding Jacobian dimension(s) will be twice as large.  This is required
even if both input and output is complex since TensorFlow graphs are not
necessarily holomorphic, and may have gradients not expressible as complex
numbers.  For example, if `x` is complex with shape `[m]` and `y` is complex
with shape `[n]`, each Jacobian `J` will have shape `[m * 2, n * 2]` with <p></p> J[:m, :n] = d(Re y)/d(Re x)
J[:m, n:] = d(Im y)/d(Re x)
J[m:, :n] = d(Re y)/d(Im x)
J[m:, n:] = d(Im y)/d(Im x) 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> x
						</dt>
						<dd>a tensor or list of tensors 
						</dd>
						<dt>
							<code><a href="../tensorflow/TensorShape.htm">TensorShape</a></code> x_shape
						</dt>
						<dd>the dimensions of x as a tuple or an array of ints. If x is a list,
then this is the list of shapes. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y
						</dt>
						<dd>a tensor 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> y_shape
						</dt>
						<dd>the dimensions of y as a tuple or an array of ints. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> x_init_value
						</dt>
						<dd>(optional) a numpy array of the same shape as "x"
representing the initial value of x. If x is a list, this should be a list
of numpy arrays.  If this is none, the function will pick a random tensor
as the initial value. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> delta
						</dt>
						<dd>(optional) the amount of perturbation. 
						</dd>
						<dt>
							<code><span title="System.Nullable<ValueTuple<IEnumerable<object>, object>>">Nullable&lt;ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;&gt;</span></code> init_targets
						</dt>
						<dd>list of targets to run to initialize model params. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> extra_feed_dict
						</dt>
						<dd>dict that allows fixing specified tensor values
during the Jacobian calculation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>Two 2-d numpy arrays representing the theoretical and numerical
Jacobian for dy/dx. Each has "x_size" rows and "y_size" columns
where "x_size" is the number of elements in x and "y_size" is the
number of elements in y. If x is a list, returns a list of two numpy arrays. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="compute_gradient_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>compute_gradient_dyn</strong>(<span title="System.object">object</span> x, <span title="System.object">object</span> x_shape, <span title="System.object">object</span> y, <span title="System.object">object</span> y_shape, <span title="System.object">object</span> x_init_value, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> delta, <span title="System.object">object</span> init_targets, <span title="System.object">object</span> extra_feed_dict)
		</h4>
		<div class="content">Computes and returns the theoretical and numerical Jacobian. (deprecated) <p></p> Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Use tf.test.compute_gradient in 2.0, which has better support for functions. Note that the two versions have different usage, so code change is needed. <p></p> If `x` or `y` is complex, the Jacobian will still be real but the
corresponding Jacobian dimension(s) will be twice as large.  This is required
even if both input and output is complex since TensorFlow graphs are not
necessarily holomorphic, and may have gradients not expressible as complex
numbers.  For example, if `x` is complex with shape `[m]` and `y` is complex
with shape `[n]`, each Jacobian `J` will have shape `[m * 2, n * 2]` with <p></p> J[:m, :n] = d(Re y)/d(Re x)
J[:m, n:] = d(Im y)/d(Re x)
J[m:, :n] = d(Re y)/d(Im x)
J[m:, n:] = d(Im y)/d(Im x) 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> x
						</dt>
						<dd>a tensor or list of tensors 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> x_shape
						</dt>
						<dd>the dimensions of x as a tuple or an array of ints. If x is a list,
then this is the list of shapes. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y
						</dt>
						<dd>a tensor 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y_shape
						</dt>
						<dd>the dimensions of y as a tuple or an array of ints. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> x_init_value
						</dt>
						<dd>(optional) a numpy array of the same shape as "x"
representing the initial value of x. If x is a list, this should be a list
of numpy arrays.  If this is none, the function will pick a random tensor
as the initial value. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> delta
						</dt>
						<dd>(optional) the amount of perturbation. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> init_targets
						</dt>
						<dd>list of targets to run to initialize model params. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> extra_feed_dict
						</dt>
						<dd>dict that allows fixing specified tensor values
during the Jacobian calculation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>Two 2-d numpy arrays representing the theoretical and numerical
Jacobian for dy/dx. Each has "x_size" rows and "y_size" columns
where "x_size" is the number of elements in x and "y_size" is the
number of elements in y. If x is a list, returns a list of two numpy arrays. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="compute_gradient_error" class="method">
		<h4>
			<span title="System.int">int</span> <strong>compute_gradient_error</strong>(<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> x, <span title="System.ValueTuple<int, object, int>">ValueTuple&lt;int, object, int&gt;</span> x_shape, <span title="System.object">object</span> y, <span title="System.object">object</span> y_shape, <span title="System.object">object</span> x_init_value, <span title="System.double">double</span> delta, <span title="System.object">object</span> init_targets, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> extra_feed_dict)
		</h4>
		<div class="content">Computes the gradient error. (deprecated) <p></p> Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Use tf.test.compute_gradient in 2.0, which has better support for functions. Note that the two versions have different usage, so code change is needed. <p></p> Computes the maximum error for dy/dx between the computed Jacobian and the
numerically estimated Jacobian. <p></p> This function will modify the tensors passed in as it adds more operations
and hence changing the consumers of the operations of the input tensors. <p></p> This function adds operations to the current session. To compute the error
using a particular device, such as a GPU, use the standard methods for
setting a device (e.g. using with sess.graph.device() or setting a device
function in the session constructor). 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code> x
						</dt>
						<dd>a tensor or list of tensors 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<int, object, int>">ValueTuple&lt;int, object, int&gt;</span></code> x_shape
						</dt>
						<dd>the dimensions of x as a tuple or an array of ints. If x is a list,
then this is the list of shapes. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y
						</dt>
						<dd>a tensor 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y_shape
						</dt>
						<dd>the dimensions of y as a tuple or an array of ints. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> x_init_value
						</dt>
						<dd>(optional) a numpy array of the same shape as "x"
representing the initial value of x. If x is a list, this should be a list
of numpy arrays.  If this is none, the function will pick a random tensor
as the initial value. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> delta
						</dt>
						<dd>(optional) the amount of perturbation. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> init_targets
						</dt>
						<dd>list of targets to run to initialize model params. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> extra_feed_dict
						</dt>
						<dd>dict that allows fixing specified tensor values
during the Jacobian calculation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.int">int</span></code>
					</dt>
					<dd>The maximum error in between the two Jacobians. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="compute_gradient_error" class="method">
		<h4>
			<span title="System.int">int</span> <strong>compute_gradient_error</strong>(<span title="System.ValueTuple<double, object>">ValueTuple&lt;double, object&gt;</span> x, <span title="System.ValueTuple<int, object, int>">ValueTuple&lt;int, object, int&gt;</span> x_shape, <span title="System.object">object</span> y, <span title="System.object">object</span> y_shape, <span title="System.object">object</span> x_init_value, <span title="System.double">double</span> delta, <span title="System.object">object</span> init_targets, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> extra_feed_dict)
		</h4>
		<div class="content">Computes the gradient error. (deprecated) <p></p> Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Use tf.test.compute_gradient in 2.0, which has better support for functions. Note that the two versions have different usage, so code change is needed. <p></p> Computes the maximum error for dy/dx between the computed Jacobian and the
numerically estimated Jacobian. <p></p> This function will modify the tensors passed in as it adds more operations
and hence changing the consumers of the operations of the input tensors. <p></p> This function adds operations to the current session. To compute the error
using a particular device, such as a GPU, use the standard methods for
setting a device (e.g. using with sess.graph.device() or setting a device
function in the session constructor). 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<double, object>">ValueTuple&lt;double, object&gt;</span></code> x
						</dt>
						<dd>a tensor or list of tensors 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<int, object, int>">ValueTuple&lt;int, object, int&gt;</span></code> x_shape
						</dt>
						<dd>the dimensions of x as a tuple or an array of ints. If x is a list,
then this is the list of shapes. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y
						</dt>
						<dd>a tensor 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y_shape
						</dt>
						<dd>the dimensions of y as a tuple or an array of ints. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> x_init_value
						</dt>
						<dd>(optional) a numpy array of the same shape as "x"
representing the initial value of x. If x is a list, this should be a list
of numpy arrays.  If this is none, the function will pick a random tensor
as the initial value. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> delta
						</dt>
						<dd>(optional) the amount of perturbation. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> init_targets
						</dt>
						<dd>list of targets to run to initialize model params. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> extra_feed_dict
						</dt>
						<dd>dict that allows fixing specified tensor values
during the Jacobian calculation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.int">int</span></code>
					</dt>
					<dd>The maximum error in between the two Jacobians. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="compute_gradient_error" class="method">
		<h4>
			<span title="System.int">int</span> <strong>compute_gradient_error</strong>(<span title="System.ValueTuple<double, object>">ValueTuple&lt;double, object&gt;</span> x, <a href="../tensorflow/TensorShape.htm">TensorShape</a> x_shape, <span title="System.object">object</span> y, <span title="System.object">object</span> y_shape, <span title="System.object">object</span> x_init_value, <span title="System.double">double</span> delta, <span title="System.object">object</span> init_targets, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> extra_feed_dict)
		</h4>
		<div class="content">Computes the gradient error. (deprecated) <p></p> Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Use tf.test.compute_gradient in 2.0, which has better support for functions. Note that the two versions have different usage, so code change is needed. <p></p> Computes the maximum error for dy/dx between the computed Jacobian and the
numerically estimated Jacobian. <p></p> This function will modify the tensors passed in as it adds more operations
and hence changing the consumers of the operations of the input tensors. <p></p> This function adds operations to the current session. To compute the error
using a particular device, such as a GPU, use the standard methods for
setting a device (e.g. using with sess.graph.device() or setting a device
function in the session constructor). 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<double, object>">ValueTuple&lt;double, object&gt;</span></code> x
						</dt>
						<dd>a tensor or list of tensors 
						</dd>
						<dt>
							<code><a href="../tensorflow/TensorShape.htm">TensorShape</a></code> x_shape
						</dt>
						<dd>the dimensions of x as a tuple or an array of ints. If x is a list,
then this is the list of shapes. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y
						</dt>
						<dd>a tensor 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y_shape
						</dt>
						<dd>the dimensions of y as a tuple or an array of ints. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> x_init_value
						</dt>
						<dd>(optional) a numpy array of the same shape as "x"
representing the initial value of x. If x is a list, this should be a list
of numpy arrays.  If this is none, the function will pick a random tensor
as the initial value. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> delta
						</dt>
						<dd>(optional) the amount of perturbation. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> init_targets
						</dt>
						<dd>list of targets to run to initialize model params. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> extra_feed_dict
						</dt>
						<dd>dict that allows fixing specified tensor values
during the Jacobian calculation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.int">int</span></code>
					</dt>
					<dd>The maximum error in between the two Jacobians. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="compute_gradient_error" class="method">
		<h4>
			<span title="System.int">int</span> <strong>compute_gradient_error</strong>(<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> x, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> x_shape, <span title="System.object">object</span> y, <span title="System.object">object</span> y_shape, <span title="System.object">object</span> x_init_value, <span title="System.double">double</span> delta, <span title="System.object">object</span> init_targets, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> extra_feed_dict)
		</h4>
		<div class="content">Computes the gradient error. (deprecated) <p></p> Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Use tf.test.compute_gradient in 2.0, which has better support for functions. Note that the two versions have different usage, so code change is needed. <p></p> Computes the maximum error for dy/dx between the computed Jacobian and the
numerically estimated Jacobian. <p></p> This function will modify the tensors passed in as it adds more operations
and hence changing the consumers of the operations of the input tensors. <p></p> This function adds operations to the current session. To compute the error
using a particular device, such as a GPU, use the standard methods for
setting a device (e.g. using with sess.graph.device() or setting a device
function in the session constructor). 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code> x
						</dt>
						<dd>a tensor or list of tensors 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> x_shape
						</dt>
						<dd>the dimensions of x as a tuple or an array of ints. If x is a list,
then this is the list of shapes. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y
						</dt>
						<dd>a tensor 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y_shape
						</dt>
						<dd>the dimensions of y as a tuple or an array of ints. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> x_init_value
						</dt>
						<dd>(optional) a numpy array of the same shape as "x"
representing the initial value of x. If x is a list, this should be a list
of numpy arrays.  If this is none, the function will pick a random tensor
as the initial value. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> delta
						</dt>
						<dd>(optional) the amount of perturbation. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> init_targets
						</dt>
						<dd>list of targets to run to initialize model params. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> extra_feed_dict
						</dt>
						<dd>dict that allows fixing specified tensor values
during the Jacobian calculation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.int">int</span></code>
					</dt>
					<dd>The maximum error in between the two Jacobians. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="compute_gradient_error" class="method">
		<h4>
			<span title="System.int">int</span> <strong>compute_gradient_error</strong>(<span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span> x, <span title="System.ValueTuple<int, object, int>">ValueTuple&lt;int, object, int&gt;</span> x_shape, <span title="System.object">object</span> y, <span title="System.object">object</span> y_shape, <span title="System.object">object</span> x_init_value, <span title="System.double">double</span> delta, <span title="System.object">object</span> init_targets, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> extra_feed_dict)
		</h4>
		<div class="content">Computes the gradient error. (deprecated) <p></p> Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Use tf.test.compute_gradient in 2.0, which has better support for functions. Note that the two versions have different usage, so code change is needed. <p></p> Computes the maximum error for dy/dx between the computed Jacobian and the
numerically estimated Jacobian. <p></p> This function will modify the tensors passed in as it adds more operations
and hence changing the consumers of the operations of the input tensors. <p></p> This function adds operations to the current session. To compute the error
using a particular device, such as a GPU, use the standard methods for
setting a device (e.g. using with sess.graph.device() or setting a device
function in the session constructor). 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span></code> x
						</dt>
						<dd>a tensor or list of tensors 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<int, object, int>">ValueTuple&lt;int, object, int&gt;</span></code> x_shape
						</dt>
						<dd>the dimensions of x as a tuple or an array of ints. If x is a list,
then this is the list of shapes. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y
						</dt>
						<dd>a tensor 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y_shape
						</dt>
						<dd>the dimensions of y as a tuple or an array of ints. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> x_init_value
						</dt>
						<dd>(optional) a numpy array of the same shape as "x"
representing the initial value of x. If x is a list, this should be a list
of numpy arrays.  If this is none, the function will pick a random tensor
as the initial value. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> delta
						</dt>
						<dd>(optional) the amount of perturbation. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> init_targets
						</dt>
						<dd>list of targets to run to initialize model params. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> extra_feed_dict
						</dt>
						<dd>dict that allows fixing specified tensor values
during the Jacobian calculation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.int">int</span></code>
					</dt>
					<dd>The maximum error in between the two Jacobians. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="compute_gradient_error" class="method">
		<h4>
			<span title="System.int">int</span> <strong>compute_gradient_error</strong>(<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> x, <a href="../tensorflow/TensorShape.htm">TensorShape</a> x_shape, <span title="System.object">object</span> y, <span title="System.object">object</span> y_shape, <span title="System.object">object</span> x_init_value, <span title="System.double">double</span> delta, <span title="System.object">object</span> init_targets, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> extra_feed_dict)
		</h4>
		<div class="content">Computes the gradient error. (deprecated) <p></p> Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Use tf.test.compute_gradient in 2.0, which has better support for functions. Note that the two versions have different usage, so code change is needed. <p></p> Computes the maximum error for dy/dx between the computed Jacobian and the
numerically estimated Jacobian. <p></p> This function will modify the tensors passed in as it adds more operations
and hence changing the consumers of the operations of the input tensors. <p></p> This function adds operations to the current session. To compute the error
using a particular device, such as a GPU, use the standard methods for
setting a device (e.g. using with sess.graph.device() or setting a device
function in the session constructor). 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code> x
						</dt>
						<dd>a tensor or list of tensors 
						</dd>
						<dt>
							<code><a href="../tensorflow/TensorShape.htm">TensorShape</a></code> x_shape
						</dt>
						<dd>the dimensions of x as a tuple or an array of ints. If x is a list,
then this is the list of shapes. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y
						</dt>
						<dd>a tensor 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y_shape
						</dt>
						<dd>the dimensions of y as a tuple or an array of ints. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> x_init_value
						</dt>
						<dd>(optional) a numpy array of the same shape as "x"
representing the initial value of x. If x is a list, this should be a list
of numpy arrays.  If this is none, the function will pick a random tensor
as the initial value. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> delta
						</dt>
						<dd>(optional) the amount of perturbation. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> init_targets
						</dt>
						<dd>list of targets to run to initialize model params. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> extra_feed_dict
						</dt>
						<dd>dict that allows fixing specified tensor values
during the Jacobian calculation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.int">int</span></code>
					</dt>
					<dd>The maximum error in between the two Jacobians. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="compute_gradient_error" class="method">
		<h4>
			<span title="System.int">int</span> <strong>compute_gradient_error</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> x, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> x_shape, <span title="System.object">object</span> y, <span title="System.object">object</span> y_shape, <span title="System.object">object</span> x_init_value, <span title="System.double">double</span> delta, <span title="System.object">object</span> init_targets, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> extra_feed_dict)
		</h4>
		<div class="content">Computes the gradient error. (deprecated) <p></p> Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Use tf.test.compute_gradient in 2.0, which has better support for functions. Note that the two versions have different usage, so code change is needed. <p></p> Computes the maximum error for dy/dx between the computed Jacobian and the
numerically estimated Jacobian. <p></p> This function will modify the tensors passed in as it adds more operations
and hence changing the consumers of the operations of the input tensors. <p></p> This function adds operations to the current session. To compute the error
using a particular device, such as a GPU, use the standard methods for
setting a device (e.g. using with sess.graph.device() or setting a device
function in the session constructor). 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> x
						</dt>
						<dd>a tensor or list of tensors 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> x_shape
						</dt>
						<dd>the dimensions of x as a tuple or an array of ints. If x is a list,
then this is the list of shapes. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y
						</dt>
						<dd>a tensor 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y_shape
						</dt>
						<dd>the dimensions of y as a tuple or an array of ints. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> x_init_value
						</dt>
						<dd>(optional) a numpy array of the same shape as "x"
representing the initial value of x. If x is a list, this should be a list
of numpy arrays.  If this is none, the function will pick a random tensor
as the initial value. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> delta
						</dt>
						<dd>(optional) the amount of perturbation. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> init_targets
						</dt>
						<dd>list of targets to run to initialize model params. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> extra_feed_dict
						</dt>
						<dd>dict that allows fixing specified tensor values
during the Jacobian calculation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.int">int</span></code>
					</dt>
					<dd>The maximum error in between the two Jacobians. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="compute_gradient_error" class="method">
		<h4>
			<span title="System.int">int</span> <strong>compute_gradient_error</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> x, <span title="System.ValueTuple<int, object, int>">ValueTuple&lt;int, object, int&gt;</span> x_shape, <span title="System.object">object</span> y, <span title="System.object">object</span> y_shape, <span title="System.object">object</span> x_init_value, <span title="System.double">double</span> delta, <span title="System.object">object</span> init_targets, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> extra_feed_dict)
		</h4>
		<div class="content">Computes the gradient error. (deprecated) <p></p> Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Use tf.test.compute_gradient in 2.0, which has better support for functions. Note that the two versions have different usage, so code change is needed. <p></p> Computes the maximum error for dy/dx between the computed Jacobian and the
numerically estimated Jacobian. <p></p> This function will modify the tensors passed in as it adds more operations
and hence changing the consumers of the operations of the input tensors. <p></p> This function adds operations to the current session. To compute the error
using a particular device, such as a GPU, use the standard methods for
setting a device (e.g. using with sess.graph.device() or setting a device
function in the session constructor). 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> x
						</dt>
						<dd>a tensor or list of tensors 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<int, object, int>">ValueTuple&lt;int, object, int&gt;</span></code> x_shape
						</dt>
						<dd>the dimensions of x as a tuple or an array of ints. If x is a list,
then this is the list of shapes. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y
						</dt>
						<dd>a tensor 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y_shape
						</dt>
						<dd>the dimensions of y as a tuple or an array of ints. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> x_init_value
						</dt>
						<dd>(optional) a numpy array of the same shape as "x"
representing the initial value of x. If x is a list, this should be a list
of numpy arrays.  If this is none, the function will pick a random tensor
as the initial value. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> delta
						</dt>
						<dd>(optional) the amount of perturbation. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> init_targets
						</dt>
						<dd>list of targets to run to initialize model params. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> extra_feed_dict
						</dt>
						<dd>dict that allows fixing specified tensor values
during the Jacobian calculation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.int">int</span></code>
					</dt>
					<dd>The maximum error in between the two Jacobians. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="compute_gradient_error" class="method">
		<h4>
			<span title="System.int">int</span> <strong>compute_gradient_error</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> x, <a href="../tensorflow/TensorShape.htm">TensorShape</a> x_shape, <span title="System.object">object</span> y, <span title="System.object">object</span> y_shape, <span title="System.object">object</span> x_init_value, <span title="System.double">double</span> delta, <span title="System.object">object</span> init_targets, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> extra_feed_dict)
		</h4>
		<div class="content">Computes the gradient error. (deprecated) <p></p> Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Use tf.test.compute_gradient in 2.0, which has better support for functions. Note that the two versions have different usage, so code change is needed. <p></p> Computes the maximum error for dy/dx between the computed Jacobian and the
numerically estimated Jacobian. <p></p> This function will modify the tensors passed in as it adds more operations
and hence changing the consumers of the operations of the input tensors. <p></p> This function adds operations to the current session. To compute the error
using a particular device, such as a GPU, use the standard methods for
setting a device (e.g. using with sess.graph.device() or setting a device
function in the session constructor). 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> x
						</dt>
						<dd>a tensor or list of tensors 
						</dd>
						<dt>
							<code><a href="../tensorflow/TensorShape.htm">TensorShape</a></code> x_shape
						</dt>
						<dd>the dimensions of x as a tuple or an array of ints. If x is a list,
then this is the list of shapes. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y
						</dt>
						<dd>a tensor 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y_shape
						</dt>
						<dd>the dimensions of y as a tuple or an array of ints. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> x_init_value
						</dt>
						<dd>(optional) a numpy array of the same shape as "x"
representing the initial value of x. If x is a list, this should be a list
of numpy arrays.  If this is none, the function will pick a random tensor
as the initial value. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> delta
						</dt>
						<dd>(optional) the amount of perturbation. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> init_targets
						</dt>
						<dd>list of targets to run to initialize model params. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> extra_feed_dict
						</dt>
						<dd>dict that allows fixing specified tensor values
during the Jacobian calculation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.int">int</span></code>
					</dt>
					<dd>The maximum error in between the two Jacobians. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="compute_gradient_error" class="method">
		<h4>
			<span title="System.int">int</span> <strong>compute_gradient_error</strong>(<span title="System.ValueTuple<double, object>">ValueTuple&lt;double, object&gt;</span> x, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> x_shape, <span title="System.object">object</span> y, <span title="System.object">object</span> y_shape, <span title="System.object">object</span> x_init_value, <span title="System.double">double</span> delta, <span title="System.object">object</span> init_targets, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> extra_feed_dict)
		</h4>
		<div class="content">Computes the gradient error. (deprecated) <p></p> Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Use tf.test.compute_gradient in 2.0, which has better support for functions. Note that the two versions have different usage, so code change is needed. <p></p> Computes the maximum error for dy/dx between the computed Jacobian and the
numerically estimated Jacobian. <p></p> This function will modify the tensors passed in as it adds more operations
and hence changing the consumers of the operations of the input tensors. <p></p> This function adds operations to the current session. To compute the error
using a particular device, such as a GPU, use the standard methods for
setting a device (e.g. using with sess.graph.device() or setting a device
function in the session constructor). 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<double, object>">ValueTuple&lt;double, object&gt;</span></code> x
						</dt>
						<dd>a tensor or list of tensors 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> x_shape
						</dt>
						<dd>the dimensions of x as a tuple or an array of ints. If x is a list,
then this is the list of shapes. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y
						</dt>
						<dd>a tensor 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y_shape
						</dt>
						<dd>the dimensions of y as a tuple or an array of ints. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> x_init_value
						</dt>
						<dd>(optional) a numpy array of the same shape as "x"
representing the initial value of x. If x is a list, this should be a list
of numpy arrays.  If this is none, the function will pick a random tensor
as the initial value. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> delta
						</dt>
						<dd>(optional) the amount of perturbation. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> init_targets
						</dt>
						<dd>list of targets to run to initialize model params. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> extra_feed_dict
						</dt>
						<dd>dict that allows fixing specified tensor values
during the Jacobian calculation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.int">int</span></code>
					</dt>
					<dd>The maximum error in between the two Jacobians. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="compute_gradient_error" class="method">
		<h4>
			<span title="System.int">int</span> <strong>compute_gradient_error</strong>(<span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span> x, <a href="../tensorflow/TensorShape.htm">TensorShape</a> x_shape, <span title="System.object">object</span> y, <span title="System.object">object</span> y_shape, <span title="System.object">object</span> x_init_value, <span title="System.double">double</span> delta, <span title="System.object">object</span> init_targets, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> extra_feed_dict)
		</h4>
		<div class="content">Computes the gradient error. (deprecated) <p></p> Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Use tf.test.compute_gradient in 2.0, which has better support for functions. Note that the two versions have different usage, so code change is needed. <p></p> Computes the maximum error for dy/dx between the computed Jacobian and the
numerically estimated Jacobian. <p></p> This function will modify the tensors passed in as it adds more operations
and hence changing the consumers of the operations of the input tensors. <p></p> This function adds operations to the current session. To compute the error
using a particular device, such as a GPU, use the standard methods for
setting a device (e.g. using with sess.graph.device() or setting a device
function in the session constructor). 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span></code> x
						</dt>
						<dd>a tensor or list of tensors 
						</dd>
						<dt>
							<code><a href="../tensorflow/TensorShape.htm">TensorShape</a></code> x_shape
						</dt>
						<dd>the dimensions of x as a tuple or an array of ints. If x is a list,
then this is the list of shapes. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y
						</dt>
						<dd>a tensor 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y_shape
						</dt>
						<dd>the dimensions of y as a tuple or an array of ints. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> x_init_value
						</dt>
						<dd>(optional) a numpy array of the same shape as "x"
representing the initial value of x. If x is a list, this should be a list
of numpy arrays.  If this is none, the function will pick a random tensor
as the initial value. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> delta
						</dt>
						<dd>(optional) the amount of perturbation. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> init_targets
						</dt>
						<dd>list of targets to run to initialize model params. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> extra_feed_dict
						</dt>
						<dd>dict that allows fixing specified tensor values
during the Jacobian calculation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.int">int</span></code>
					</dt>
					<dd>The maximum error in between the two Jacobians. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="compute_gradient_error" class="method">
		<h4>
			<span title="System.int">int</span> <strong>compute_gradient_error</strong>(<span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> x, <a href="../tensorflow/TensorShape.htm">TensorShape</a> x_shape, <span title="System.object">object</span> y, <span title="System.object">object</span> y_shape, <span title="System.object">object</span> x_init_value, <span title="System.double">double</span> delta, <span title="System.object">object</span> init_targets, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> extra_feed_dict)
		</h4>
		<div class="content">Computes the gradient error. (deprecated) <p></p> Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Use tf.test.compute_gradient in 2.0, which has better support for functions. Note that the two versions have different usage, so code change is needed. <p></p> Computes the maximum error for dy/dx between the computed Jacobian and the
numerically estimated Jacobian. <p></p> This function will modify the tensors passed in as it adds more operations
and hence changing the consumers of the operations of the input tensors. <p></p> This function adds operations to the current session. To compute the error
using a particular device, such as a GPU, use the standard methods for
setting a device (e.g. using with sess.graph.device() or setting a device
function in the session constructor). 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> x
						</dt>
						<dd>a tensor or list of tensors 
						</dd>
						<dt>
							<code><a href="../tensorflow/TensorShape.htm">TensorShape</a></code> x_shape
						</dt>
						<dd>the dimensions of x as a tuple or an array of ints. If x is a list,
then this is the list of shapes. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y
						</dt>
						<dd>a tensor 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y_shape
						</dt>
						<dd>the dimensions of y as a tuple or an array of ints. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> x_init_value
						</dt>
						<dd>(optional) a numpy array of the same shape as "x"
representing the initial value of x. If x is a list, this should be a list
of numpy arrays.  If this is none, the function will pick a random tensor
as the initial value. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> delta
						</dt>
						<dd>(optional) the amount of perturbation. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> init_targets
						</dt>
						<dd>list of targets to run to initialize model params. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> extra_feed_dict
						</dt>
						<dd>dict that allows fixing specified tensor values
during the Jacobian calculation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.int">int</span></code>
					</dt>
					<dd>The maximum error in between the two Jacobians. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="compute_gradient_error" class="method">
		<h4>
			<span title="System.int">int</span> <strong>compute_gradient_error</strong>(<span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> x, <span title="System.ValueTuple<int, object, int>">ValueTuple&lt;int, object, int&gt;</span> x_shape, <span title="System.object">object</span> y, <span title="System.object">object</span> y_shape, <span title="System.object">object</span> x_init_value, <span title="System.double">double</span> delta, <span title="System.object">object</span> init_targets, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> extra_feed_dict)
		</h4>
		<div class="content">Computes the gradient error. (deprecated) <p></p> Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Use tf.test.compute_gradient in 2.0, which has better support for functions. Note that the two versions have different usage, so code change is needed. <p></p> Computes the maximum error for dy/dx between the computed Jacobian and the
numerically estimated Jacobian. <p></p> This function will modify the tensors passed in as it adds more operations
and hence changing the consumers of the operations of the input tensors. <p></p> This function adds operations to the current session. To compute the error
using a particular device, such as a GPU, use the standard methods for
setting a device (e.g. using with sess.graph.device() or setting a device
function in the session constructor). 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> x
						</dt>
						<dd>a tensor or list of tensors 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<int, object, int>">ValueTuple&lt;int, object, int&gt;</span></code> x_shape
						</dt>
						<dd>the dimensions of x as a tuple or an array of ints. If x is a list,
then this is the list of shapes. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y
						</dt>
						<dd>a tensor 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y_shape
						</dt>
						<dd>the dimensions of y as a tuple or an array of ints. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> x_init_value
						</dt>
						<dd>(optional) a numpy array of the same shape as "x"
representing the initial value of x. If x is a list, this should be a list
of numpy arrays.  If this is none, the function will pick a random tensor
as the initial value. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> delta
						</dt>
						<dd>(optional) the amount of perturbation. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> init_targets
						</dt>
						<dd>list of targets to run to initialize model params. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> extra_feed_dict
						</dt>
						<dd>dict that allows fixing specified tensor values
during the Jacobian calculation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.int">int</span></code>
					</dt>
					<dd>The maximum error in between the two Jacobians. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="compute_gradient_error" class="method">
		<h4>
			<span title="System.int">int</span> <strong>compute_gradient_error</strong>(<span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> x, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> x_shape, <span title="System.object">object</span> y, <span title="System.object">object</span> y_shape, <span title="System.object">object</span> x_init_value, <span title="System.double">double</span> delta, <span title="System.object">object</span> init_targets, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> extra_feed_dict)
		</h4>
		<div class="content">Computes the gradient error. (deprecated) <p></p> Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Use tf.test.compute_gradient in 2.0, which has better support for functions. Note that the two versions have different usage, so code change is needed. <p></p> Computes the maximum error for dy/dx between the computed Jacobian and the
numerically estimated Jacobian. <p></p> This function will modify the tensors passed in as it adds more operations
and hence changing the consumers of the operations of the input tensors. <p></p> This function adds operations to the current session. To compute the error
using a particular device, such as a GPU, use the standard methods for
setting a device (e.g. using with sess.graph.device() or setting a device
function in the session constructor). 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> x
						</dt>
						<dd>a tensor or list of tensors 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> x_shape
						</dt>
						<dd>the dimensions of x as a tuple or an array of ints. If x is a list,
then this is the list of shapes. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y
						</dt>
						<dd>a tensor 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y_shape
						</dt>
						<dd>the dimensions of y as a tuple or an array of ints. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> x_init_value
						</dt>
						<dd>(optional) a numpy array of the same shape as "x"
representing the initial value of x. If x is a list, this should be a list
of numpy arrays.  If this is none, the function will pick a random tensor
as the initial value. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> delta
						</dt>
						<dd>(optional) the amount of perturbation. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> init_targets
						</dt>
						<dd>list of targets to run to initialize model params. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> extra_feed_dict
						</dt>
						<dd>dict that allows fixing specified tensor values
during the Jacobian calculation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.int">int</span></code>
					</dt>
					<dd>The maximum error in between the two Jacobians. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="compute_gradient_error" class="method">
		<h4>
			<span title="System.int">int</span> <strong>compute_gradient_error</strong>(<a href="../numpy/ndarray.htm">ndarray</a> x, <a href="../tensorflow/TensorShape.htm">TensorShape</a> x_shape, <span title="System.object">object</span> y, <span title="System.object">object</span> y_shape, <span title="System.object">object</span> x_init_value, <span title="System.double">double</span> delta, <span title="System.object">object</span> init_targets, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> extra_feed_dict)
		</h4>
		<div class="content">Computes the gradient error. (deprecated) <p></p> Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Use tf.test.compute_gradient in 2.0, which has better support for functions. Note that the two versions have different usage, so code change is needed. <p></p> Computes the maximum error for dy/dx between the computed Jacobian and the
numerically estimated Jacobian. <p></p> This function will modify the tensors passed in as it adds more operations
and hence changing the consumers of the operations of the input tensors. <p></p> This function adds operations to the current session. To compute the error
using a particular device, such as a GPU, use the standard methods for
setting a device (e.g. using with sess.graph.device() or setting a device
function in the session constructor). 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> x
						</dt>
						<dd>a tensor or list of tensors 
						</dd>
						<dt>
							<code><a href="../tensorflow/TensorShape.htm">TensorShape</a></code> x_shape
						</dt>
						<dd>the dimensions of x as a tuple or an array of ints. If x is a list,
then this is the list of shapes. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y
						</dt>
						<dd>a tensor 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y_shape
						</dt>
						<dd>the dimensions of y as a tuple or an array of ints. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> x_init_value
						</dt>
						<dd>(optional) a numpy array of the same shape as "x"
representing the initial value of x. If x is a list, this should be a list
of numpy arrays.  If this is none, the function will pick a random tensor
as the initial value. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> delta
						</dt>
						<dd>(optional) the amount of perturbation. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> init_targets
						</dt>
						<dd>list of targets to run to initialize model params. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> extra_feed_dict
						</dt>
						<dd>dict that allows fixing specified tensor values
during the Jacobian calculation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.int">int</span></code>
					</dt>
					<dd>The maximum error in between the two Jacobians. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="compute_gradient_error" class="method">
		<h4>
			<span title="System.int">int</span> <strong>compute_gradient_error</strong>(<a href="../numpy/ndarray.htm">ndarray</a> x, <span title="System.ValueTuple<int, object, int>">ValueTuple&lt;int, object, int&gt;</span> x_shape, <span title="System.object">object</span> y, <span title="System.object">object</span> y_shape, <span title="System.object">object</span> x_init_value, <span title="System.double">double</span> delta, <span title="System.object">object</span> init_targets, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> extra_feed_dict)
		</h4>
		<div class="content">Computes the gradient error. (deprecated) <p></p> Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Use tf.test.compute_gradient in 2.0, which has better support for functions. Note that the two versions have different usage, so code change is needed. <p></p> Computes the maximum error for dy/dx between the computed Jacobian and the
numerically estimated Jacobian. <p></p> This function will modify the tensors passed in as it adds more operations
and hence changing the consumers of the operations of the input tensors. <p></p> This function adds operations to the current session. To compute the error
using a particular device, such as a GPU, use the standard methods for
setting a device (e.g. using with sess.graph.device() or setting a device
function in the session constructor). 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> x
						</dt>
						<dd>a tensor or list of tensors 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<int, object, int>">ValueTuple&lt;int, object, int&gt;</span></code> x_shape
						</dt>
						<dd>the dimensions of x as a tuple or an array of ints. If x is a list,
then this is the list of shapes. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y
						</dt>
						<dd>a tensor 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y_shape
						</dt>
						<dd>the dimensions of y as a tuple or an array of ints. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> x_init_value
						</dt>
						<dd>(optional) a numpy array of the same shape as "x"
representing the initial value of x. If x is a list, this should be a list
of numpy arrays.  If this is none, the function will pick a random tensor
as the initial value. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> delta
						</dt>
						<dd>(optional) the amount of perturbation. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> init_targets
						</dt>
						<dd>list of targets to run to initialize model params. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> extra_feed_dict
						</dt>
						<dd>dict that allows fixing specified tensor values
during the Jacobian calculation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.int">int</span></code>
					</dt>
					<dd>The maximum error in between the two Jacobians. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="compute_gradient_error" class="method">
		<h4>
			<span title="System.int">int</span> <strong>compute_gradient_error</strong>(<a href="../numpy/ndarray.htm">ndarray</a> x, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> x_shape, <span title="System.object">object</span> y, <span title="System.object">object</span> y_shape, <span title="System.object">object</span> x_init_value, <span title="System.double">double</span> delta, <span title="System.object">object</span> init_targets, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> extra_feed_dict)
		</h4>
		<div class="content">Computes the gradient error. (deprecated) <p></p> Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Use tf.test.compute_gradient in 2.0, which has better support for functions. Note that the two versions have different usage, so code change is needed. <p></p> Computes the maximum error for dy/dx between the computed Jacobian and the
numerically estimated Jacobian. <p></p> This function will modify the tensors passed in as it adds more operations
and hence changing the consumers of the operations of the input tensors. <p></p> This function adds operations to the current session. To compute the error
using a particular device, such as a GPU, use the standard methods for
setting a device (e.g. using with sess.graph.device() or setting a device
function in the session constructor). 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> x
						</dt>
						<dd>a tensor or list of tensors 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> x_shape
						</dt>
						<dd>the dimensions of x as a tuple or an array of ints. If x is a list,
then this is the list of shapes. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y
						</dt>
						<dd>a tensor 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y_shape
						</dt>
						<dd>the dimensions of y as a tuple or an array of ints. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> x_init_value
						</dt>
						<dd>(optional) a numpy array of the same shape as "x"
representing the initial value of x. If x is a list, this should be a list
of numpy arrays.  If this is none, the function will pick a random tensor
as the initial value. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> delta
						</dt>
						<dd>(optional) the amount of perturbation. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> init_targets
						</dt>
						<dd>list of targets to run to initialize model params. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> extra_feed_dict
						</dt>
						<dd>dict that allows fixing specified tensor values
during the Jacobian calculation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.int">int</span></code>
					</dt>
					<dd>The maximum error in between the two Jacobians. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="compute_gradient_error" class="method">
		<h4>
			<span title="System.int">int</span> <strong>compute_gradient_error</strong>(<span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span> x, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> x_shape, <span title="System.object">object</span> y, <span title="System.object">object</span> y_shape, <span title="System.object">object</span> x_init_value, <span title="System.double">double</span> delta, <span title="System.object">object</span> init_targets, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> extra_feed_dict)
		</h4>
		<div class="content">Computes the gradient error. (deprecated) <p></p> Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Use tf.test.compute_gradient in 2.0, which has better support for functions. Note that the two versions have different usage, so code change is needed. <p></p> Computes the maximum error for dy/dx between the computed Jacobian and the
numerically estimated Jacobian. <p></p> This function will modify the tensors passed in as it adds more operations
and hence changing the consumers of the operations of the input tensors. <p></p> This function adds operations to the current session. To compute the error
using a particular device, such as a GPU, use the standard methods for
setting a device (e.g. using with sess.graph.device() or setting a device
function in the session constructor). 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span></code> x
						</dt>
						<dd>a tensor or list of tensors 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> x_shape
						</dt>
						<dd>the dimensions of x as a tuple or an array of ints. If x is a list,
then this is the list of shapes. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y
						</dt>
						<dd>a tensor 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y_shape
						</dt>
						<dd>the dimensions of y as a tuple or an array of ints. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> x_init_value
						</dt>
						<dd>(optional) a numpy array of the same shape as "x"
representing the initial value of x. If x is a list, this should be a list
of numpy arrays.  If this is none, the function will pick a random tensor
as the initial value. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> delta
						</dt>
						<dd>(optional) the amount of perturbation. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> init_targets
						</dt>
						<dd>list of targets to run to initialize model params. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> extra_feed_dict
						</dt>
						<dd>dict that allows fixing specified tensor values
during the Jacobian calculation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.int">int</span></code>
					</dt>
					<dd>The maximum error in between the two Jacobians. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="compute_gradient_error_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>compute_gradient_error_dyn</strong>(<span title="System.object">object</span> x, <span title="System.object">object</span> x_shape, <span title="System.object">object</span> y, <span title="System.object">object</span> y_shape, <span title="System.object">object</span> x_init_value, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> delta, <span title="System.object">object</span> init_targets, <span title="System.object">object</span> extra_feed_dict)
		</h4>
		<div class="content">Computes the gradient error. (deprecated) <p></p> Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Use tf.test.compute_gradient in 2.0, which has better support for functions. Note that the two versions have different usage, so code change is needed. <p></p> Computes the maximum error for dy/dx between the computed Jacobian and the
numerically estimated Jacobian. <p></p> This function will modify the tensors passed in as it adds more operations
and hence changing the consumers of the operations of the input tensors. <p></p> This function adds operations to the current session. To compute the error
using a particular device, such as a GPU, use the standard methods for
setting a device (e.g. using with sess.graph.device() or setting a device
function in the session constructor). 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> x
						</dt>
						<dd>a tensor or list of tensors 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> x_shape
						</dt>
						<dd>the dimensions of x as a tuple or an array of ints. If x is a list,
then this is the list of shapes. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y
						</dt>
						<dd>a tensor 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> y_shape
						</dt>
						<dd>the dimensions of y as a tuple or an array of ints. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> x_init_value
						</dt>
						<dd>(optional) a numpy array of the same shape as "x"
representing the initial value of x. If x is a list, this should be a list
of numpy arrays.  If this is none, the function will pick a random tensor
as the initial value. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> delta
						</dt>
						<dd>(optional) the amount of perturbation. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> init_targets
						</dt>
						<dd>list of targets to run to initialize model params. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> extra_feed_dict
						</dt>
						<dd>dict that allows fixing specified tensor values
during the Jacobian calculation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>The maximum error in between the two Jacobians. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="create_local_cluster" class="method">
		<h4>
			<span title="System.ValueTuple<IList<Server>, object>">ValueTuple&lt;IList&lt;Server&gt;, object&gt;</span> <strong>create_local_cluster</strong>(<span title="System.int">int</span> num_workers, <span title="System.int">int</span> num_ps, <span title="System.string">string</span> protocol, <span title="System.object">object</span> worker_config, <span title="System.object">object</span> ps_config)
		</h4>
		<div class="content">Create and start local servers and return the associated `Server` objects. <p></p> "PS" stands for "parameter server": a task responsible for storing and
updating the model's parameters. Other tasks send updates to these parameters
as they work on optimizing the parameters. This particular division of labor
between tasks is not required, but is common for distributed training. <p></p> Read more at https://www.tensorflow.org/guide/extend/architecture <p></p> ![components](https://www.tensorflow.org/images/diag1.svg "components") <p></p> <p></p> Figure illustrates the interaction of these components.
"/job:worker/task:0" and "/job:ps/task:0" are both tasks with worker services. <p></p> <p></p> Example: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> num_workers
						</dt>
						<dd>Number of worker servers to start. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_ps
						</dt>
						<dd>Number of PS servers to start. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> protocol
						</dt>
						<dd>Communication protocol. Allowed values are documented in the
documentation of <a href="..\..\tf\distribute\Server.md"><code>tf.distribute.Server</code></a>. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> worker_config
						</dt>
						<dd>(optional) <a href="..\..\tf\ConfigProto.md"><code>tf.ConfigProto</code></a> to initialize workers. Can be
used to instantiate multiple devices etc. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> ps_config
						</dt>
						<dd>(optional) <a href="..\..\tf\ConfigProto.md"><code>tf.ConfigProto</code></a> to initialize PS servers. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<IList<Server>, object>">ValueTuple&lt;IList&lt;Server&gt;, object&gt;</span></code>
					</dt>
					<dd>A tuple `(worker_servers, ps_servers)`.  `worker_servers` is a list
of `num_workers` objects of type <a href="..\..\tf\distribute\Server.md"><code>tf.distribute.Server</code></a> (all running
locally);
and `ps_servers` is a list of `num_ps` objects of similar type. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>workers, _ = tf.test.create_local_cluster(num_workers=2, num_ps=2) <p></p> worker_sessions = [tf.compat.v1.Session(w.target) for w in workers] <p></p> with tf.device("/job:ps/task:0"):
 ...
with tf.device("/job:ps/task:1"):
 ...
with tf.device("/job:worker/task:0"):
 ...
with tf.device("/job:worker/task:1"):
 ... <p></p> worker_sessions[0].run(...) </pre>
</div>
		</div>
	</div>
	<div id="create_local_cluster_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>create_local_cluster_dyn</strong>(<span title="System.object">object</span> num_workers, <span title="System.object">object</span> num_ps, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> protocol, <span title="System.object">object</span> worker_config, <span title="System.object">object</span> ps_config)
		</h4>
		<div class="content">Create and start local servers and return the associated `Server` objects. <p></p> "PS" stands for "parameter server": a task responsible for storing and
updating the model's parameters. Other tasks send updates to these parameters
as they work on optimizing the parameters. This particular division of labor
between tasks is not required, but is common for distributed training. <p></p> Read more at https://www.tensorflow.org/guide/extend/architecture <p></p> ![components](https://www.tensorflow.org/images/diag1.svg "components") <p></p> <p></p> Figure illustrates the interaction of these components.
"/job:worker/task:0" and "/job:ps/task:0" are both tasks with worker services. <p></p> <p></p> Example: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> num_workers
						</dt>
						<dd>Number of worker servers to start. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> num_ps
						</dt>
						<dd>Number of PS servers to start. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> protocol
						</dt>
						<dd>Communication protocol. Allowed values are documented in the
documentation of <a href="..\..\tf\distribute\Server.md"><code>tf.distribute.Server</code></a>. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> worker_config
						</dt>
						<dd>(optional) <a href="..\..\tf\ConfigProto.md"><code>tf.ConfigProto</code></a> to initialize workers. Can be
used to instantiate multiple devices etc. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> ps_config
						</dt>
						<dd>(optional) <a href="..\..\tf\ConfigProto.md"><code>tf.ConfigProto</code></a> to initialize PS servers. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A tuple `(worker_servers, ps_servers)`.  `worker_servers` is a list
of `num_workers` objects of type <a href="..\..\tf\distribute\Server.md"><code>tf.distribute.Server</code></a> (all running
locally);
and `ps_servers` is a list of `num_ps` objects of similar type. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>workers, _ = tf.test.create_local_cluster(num_workers=2, num_ps=2) <p></p> worker_sessions = [tf.compat.v1.Session(w.target) for w in workers] <p></p> with tf.device("/job:ps/task:0"):
 ...
with tf.device("/job:ps/task:1"):
 ...
with tf.device("/job:worker/task:0"):
 ...
with tf.device("/job:worker/task:1"):
 ... <p></p> worker_sessions[0].run(...) </pre>
</div>
		</div>
	</div>
	<div id="gpu_device_name" class="method">
		<h4>
			<span title="System.string">string</span> <strong>gpu_device_name</strong>()
		</h4>
		<div class="content">Returns the name of a GPU device if available or the empty string. 




		</div>
	</div>
	<div id="gpu_device_name_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>gpu_device_name_dyn</strong>()
		</h4>
		<div class="content">Returns the name of a GPU device if available or the empty string. 




		</div>
	</div>
	<div id="is_built_with_cuda" class="method">
		<h4>
			<span title="System.object">object</span> <strong>is_built_with_cuda</strong>()
		</h4>
		<div class="content">Returns whether TensorFlow was built with CUDA (GPU) support. 




		</div>
	</div>
	<div id="is_built_with_cuda_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>is_built_with_cuda_dyn</strong>()
		</h4>
		<div class="content">Returns whether TensorFlow was built with CUDA (GPU) support. 




		</div>
	</div>
	<div id="is_built_with_gpu_support" class="method">
		<h4>
			<span title="System.object">object</span> <strong>is_built_with_gpu_support</strong>()
		</h4>
		<div class="content">Returns whether TensorFlow was built with GPU (i.e. CUDA or ROCm) support. 




		</div>
	</div>
	<div id="is_built_with_gpu_support_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>is_built_with_gpu_support_dyn</strong>()
		</h4>
		<div class="content">Returns whether TensorFlow was built with GPU (i.e. CUDA or ROCm) support. 




		</div>
	</div>
	<div id="is_built_with_rocm" class="method">
		<h4>
			<span title="System.object">object</span> <strong>is_built_with_rocm</strong>()
		</h4>
		<div class="content">Returns whether TensorFlow was built with ROCm (GPU) support. 




		</div>
	</div>
	<div id="is_built_with_rocm_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>is_built_with_rocm_dyn</strong>()
		</h4>
		<div class="content">Returns whether TensorFlow was built with ROCm (GPU) support. 




		</div>
	</div>
	<div id="is_gpu_available" class="method">
		<h4>
			<span title="System.bool">bool</span> <strong>is_gpu_available</strong>(<span title="System.bool">bool</span> cuda_only, <span title="System.Nullable<ValueTuple<int, int>>">Nullable&lt;ValueTuple&lt;int, int&gt;&gt;</span> min_cuda_compute_capability)
		</h4>
		<div class="content">Returns whether TensorFlow can access a GPU. <p></p> Warning: if a non-GPU version of the package is installed, the function would
also return False. Use <a href="..\..\tf\test\is_built_with_cuda.md"><code>tf.test.is_built_with_cuda</code></a> to validate if TensorFlow
was build with CUDA support. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.bool">bool</span></code> cuda_only
						</dt>
						<dd>limit the search to CUDA GPUs. 
						</dd>
						<dt>
							<code><span title="System.Nullable<ValueTuple<int, int>>">Nullable&lt;ValueTuple&lt;int, int&gt;&gt;</span></code> min_cuda_compute_capability
						</dt>
						<dd>a (major,minor) pair that indicates the minimum
CUDA compute capability required, or None if no requirement. <p></p> Note that the keyword arg name "cuda_only" is misleading (since routine will
return true when a GPU device is available irrespective of whether TF was
built with CUDA support or ROCm support. However no changes here because <p></p> ++ Changing the name "cuda_only" to something more generic would break
backward compatibility <p></p> ++ Adding an equivalent "rocm_only" would require the implementation check
the build type. This in turn would require doing the same for CUDA and thus
potentially break backward compatibility <p></p> ++ Adding a new "cuda_or_rocm_only" would not break backward compatibility,
but would require most (if not all) callers to update the call to use
"cuda_or_rocm_only" instead of "cuda_only" 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.bool">bool</span></code>
					</dt>
					<dd>True if a GPU device of the requested kind is available. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="is_gpu_available_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>is_gpu_available_dyn</strong>(<a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> cuda_only, <span title="System.object">object</span> min_cuda_compute_capability)
		</h4>
		<div class="content">Returns whether TensorFlow can access a GPU. <p></p> Warning: if a non-GPU version of the package is installed, the function would
also return False. Use <a href="..\..\tf\test\is_built_with_cuda.md"><code>tf.test.is_built_with_cuda</code></a> to validate if TensorFlow
was build with CUDA support. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> cuda_only
						</dt>
						<dd>limit the search to CUDA GPUs. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> min_cuda_compute_capability
						</dt>
						<dd>a (major,minor) pair that indicates the minimum
CUDA compute capability required, or None if no requirement. <p></p> Note that the keyword arg name "cuda_only" is misleading (since routine will
return true when a GPU device is available irrespective of whether TF was
built with CUDA support or ROCm support. However no changes here because <p></p> ++ Changing the name "cuda_only" to something more generic would break
backward compatibility <p></p> ++ Adding an equivalent "rocm_only" would require the implementation check
the build type. This in turn would require doing the same for CUDA and thus
potentially break backward compatibility <p></p> ++ Adding a new "cuda_or_rocm_only" would not break backward compatibility,
but would require most (if not all) callers to update the call to use
"cuda_or_rocm_only" instead of "cuda_only" 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>True if a GPU device of the requested kind is available. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	
	<h3 class="section">Public properties</h3>

	<div id="assert_equal_graph_def_fn_" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>assert_equal_graph_def_fn_</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="benchmark_config_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>benchmark_config_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="compute_gradient_error_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>compute_gradient_error_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="compute_gradient_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>compute_gradient_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="create_local_cluster_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>create_local_cluster_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="get_temp_dir_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>get_temp_dir_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="gpu_device_name_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>gpu_device_name_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="is_built_with_cuda_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>is_built_with_cuda_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="is_built_with_gpu_support_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>is_built_with_gpu_support_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="is_built_with_rocm_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>is_built_with_rocm_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="is_gpu_available_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>is_gpu_available_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="main_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>main_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="test_src_dir_path_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>test_src_dir_path_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	</section>
	</article><footer>
	<span id="version">Built from v1.15.0.0 of LostTech.TensorFlow</span>
	<span id="docu-link">
		Generated by <a href="http://docu.jagregory.com">docu</a>
	</span>
</footer>
  </body>
</html>