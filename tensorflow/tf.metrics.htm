<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
	<!--[if lt IE 9]>
	<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
    <title>tf.metrics - LostTech.TensorFlow Documentation</title>
    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"/>
    <link type="text/css" rel="stylesheet" href="../main.css"/>
    <script type="text/javascript" src="../js/jquery-1.3.2.min.js"></script>
    <script type="text/javascript" src="../js/jquery.scrollTo-min.js"></script>
    <script type="text/javascript" src="../js/navigation.js"></script>
    <script type="text/javascript" src="../js/example.js"></script>
  </head>
  <body>
  	<header><h1>LostTech.TensorFlow : API Documentation</h1>
	</header>

    <nav id="namespaces">
      <iframe src="../namespaces.htm"></iframe>
    </nav><nav id="types">
  <h2 class="fixed">Types in tensorflow</h2>
	<div class="scroll">
		<ul>
				<li>
            <a href="../tensorflow/AggregationMethod.htm">AggregationMethod</a>
        </li>
				<li>
            <a href="../tensorflow/ConditionalAccumulator.htm">ConditionalAccumulator</a>
        </li>
				<li>
            <a href="../tensorflow/ConditionalAccumulatorBase.htm">ConditionalAccumulatorBase</a>
        </li>
				<li>
            <a href="../tensorflow/constant_initializer.htm">constant_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/CriticalSection.htm">CriticalSection</a>
        </li>
				<li>
            <a href="../tensorflow/DeviceSpec.htm">DeviceSpec</a>
        </li>
				<li>
            <a href="../tensorflow/Dimension.htm">Dimension</a>
        </li>
				<li>
            <a href="../tensorflow/DType.htm">DType</a>
        </li>
				<li>
            <a href="../tensorflow/FIFOQueue.htm">FIFOQueue</a>
        </li>
				<li>
            <a href="../tensorflow/FixedLenFeature.htm">FixedLenFeature</a>
        </li>
				<li>
            <a href="../tensorflow/FixedLengthRecordReader.htm">FixedLengthRecordReader</a>
        </li>
				<li>
            <a href="../tensorflow/FixedLenSequenceFeature.htm">FixedLenSequenceFeature</a>
        </li>
				<li>
            <a href="../tensorflow/glorot_normal_initializer.htm">glorot_normal_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/glorot_uniform_initializer.htm">glorot_uniform_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/GradientTape.htm">GradientTape</a>
        </li>
				<li>
            <a href="../tensorflow/Graph.htm">Graph</a>
        </li>
				<li>
            <a href="../tensorflow/Graph._ControlDependenciesController.htm">Graph._ControlDependenciesController</a>
        </li>
				<li>
            <a href="../tensorflow/Graph.I_ControlDependenciesController.htm">Graph.I_ControlDependenciesController</a>
        </li>
				<li>
            <a href="../tensorflow/GraphKeys.htm">GraphKeys</a>
        </li>
				<li>
            <a href="../tensorflow/HeadingAxes.htm">HeadingAxes</a>
        </li>
				<li>
            <a href="../tensorflow/IAggregationMethod.htm">IAggregationMethod</a>
        </li>
				<li>
            <a href="../tensorflow/IConditionalAccumulator.htm">IConditionalAccumulator</a>
        </li>
				<li>
            <a href="../tensorflow/IConditionalAccumulatorBase.htm">IConditionalAccumulatorBase</a>
        </li>
				<li>
            <a href="../tensorflow/Iconstant_initializer.htm">Iconstant_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/ICriticalSection.htm">ICriticalSection</a>
        </li>
				<li>
            <a href="../tensorflow/IdentityReader.htm">IdentityReader</a>
        </li>
				<li>
            <a href="../tensorflow/IDeviceSpec.htm">IDeviceSpec</a>
        </li>
				<li>
            <a href="../tensorflow/IDimension.htm">IDimension</a>
        </li>
				<li>
            <a href="../tensorflow/IDType.htm">IDType</a>
        </li>
				<li>
            <a href="../tensorflow/IFIFOQueue.htm">IFIFOQueue</a>
        </li>
				<li>
            <a href="../tensorflow/IFixedLenFeature.htm">IFixedLenFeature</a>
        </li>
				<li>
            <a href="../tensorflow/IFixedLengthRecordReader.htm">IFixedLengthRecordReader</a>
        </li>
				<li>
            <a href="../tensorflow/IFixedLenSequenceFeature.htm">IFixedLenSequenceFeature</a>
        </li>
				<li>
            <a href="../tensorflow/Iglorot_normal_initializer.htm">Iglorot_normal_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/Iglorot_uniform_initializer.htm">Iglorot_uniform_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/IGradientTape.htm">IGradientTape</a>
        </li>
				<li>
            <a href="../tensorflow/IGraph.htm">IGraph</a>
        </li>
				<li>
            <a href="../tensorflow/IGraphKeys.htm">IGraphKeys</a>
        </li>
				<li>
            <a href="../tensorflow/IIdentityReader.htm">IIdentityReader</a>
        </li>
				<li>
            <a href="../tensorflow/IIndexedSlices.htm">IIndexedSlices</a>
        </li>
				<li>
            <a href="../tensorflow/IIndexedSlicesSpec.htm">IIndexedSlicesSpec</a>
        </li>
				<li>
            <a href="../tensorflow/IInteractiveSession.htm">IInteractiveSession</a>
        </li>
				<li>
            <a href="../tensorflow/ILazyLoader.htm">ILazyLoader</a>
        </li>
				<li>
            <a href="../tensorflow/ILMDBReader.htm">ILMDBReader</a>
        </li>
				<li>
            <a href="../tensorflow/IModule.htm">IModule</a>
        </li>
				<li>
            <a href="../tensorflow/Iname_scope.htm">Iname_scope</a>
        </li>
				<li>
            <a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a>
        </li>
				<li>
            <a href="../tensorflow/IndexedSlicesSpec.htm">IndexedSlicesSpec</a>
        </li>
				<li>
            <a href="../tensorflow/InteractiveSession.htm">InteractiveSession</a>
        </li>
				<li>
            <a href="../tensorflow/Iones_initializer.htm">Iones_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/IOperation.htm">IOperation</a>
        </li>
				<li>
            <a href="../tensorflow/IOpError.htm">IOpError</a>
        </li>
				<li>
            <a href="../tensorflow/IOptionalSpec.htm">IOptionalSpec</a>
        </li>
				<li>
            <a href="../tensorflow/Iorthogonal_initializer.htm">Iorthogonal_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/IPaddingFIFOQueue.htm">IPaddingFIFOQueue</a>
        </li>
				<li>
            <a href="../tensorflow/IPriorityQueue.htm">IPriorityQueue</a>
        </li>
				<li>
            <a href="../tensorflow/IQueueBase.htm">IQueueBase</a>
        </li>
				<li>
            <a href="../tensorflow/IRaggedTensor.htm">IRaggedTensor</a>
        </li>
				<li>
            <a href="../tensorflow/IRaggedTensorSpec.htm">IRaggedTensorSpec</a>
        </li>
				<li>
            <a href="../tensorflow/Irandom_normal_initializer.htm">Irandom_normal_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/Irandom_uniform_initializer.htm">Irandom_uniform_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/IRandomShuffleQueue.htm">IRandomShuffleQueue</a>
        </li>
				<li>
            <a href="../tensorflow/IReaderBase.htm">IReaderBase</a>
        </li>
				<li>
            <a href="../tensorflow/IRegisterGradient.htm">IRegisterGradient</a>
        </li>
				<li>
            <a href="../tensorflow/ISession.htm">ISession</a>
        </li>
				<li>
            <a href="../tensorflow/ISparseConditionalAccumulator.htm">ISparseConditionalAccumulator</a>
        </li>
				<li>
            <a href="../tensorflow/ISparseFeature.htm">ISparseFeature</a>
        </li>
				<li>
            <a href="../tensorflow/ISparseTensor.htm">ISparseTensor</a>
        </li>
				<li>
            <a href="../tensorflow/ISparseTensorSpec.htm">ISparseTensorSpec</a>
        </li>
				<li>
            <a href="../tensorflow/ISparseTensorValue.htm">ISparseTensorValue</a>
        </li>
				<li>
            <a href="../tensorflow/ITensor.htm">ITensor</a>
        </li>
				<li>
            <a href="../tensorflow/ITensorArray.htm">ITensorArray</a>
        </li>
				<li>
            <a href="../tensorflow/ITensorArraySpec.htm">ITensorArraySpec</a>
        </li>
				<li>
            <a href="../tensorflow/ITensorShape.htm">ITensorShape</a>
        </li>
				<li>
            <a href="../tensorflow/ITensorSpec.htm">ITensorSpec</a>
        </li>
				<li>
            <a href="../tensorflow/ITextLineReader.htm">ITextLineReader</a>
        </li>
				<li>
            <a href="../tensorflow/ITFRecordReader.htm">ITFRecordReader</a>
        </li>
				<li>
            <a href="../tensorflow/Itruncated_normal_initializer.htm">Itruncated_normal_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/ITypeSpec.htm">ITypeSpec</a>
        </li>
				<li>
            <a href="../tensorflow/IUnconnectedGradients.htm">IUnconnectedGradients</a>
        </li>
				<li>
            <a href="../tensorflow/Iuniform_unit_scaling_initializer.htm">Iuniform_unit_scaling_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/IVariable.htm">IVariable</a>
        </li>
				<li>
            <a href="../tensorflow/Ivariable_scope.htm">Ivariable_scope</a>
        </li>
				<li>
            <a href="../tensorflow/IVariableScope.htm">IVariableScope</a>
        </li>
				<li>
            <a href="../tensorflow/Ivariance_scaling_initializer.htm">Ivariance_scaling_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/IVarLenFeature.htm">IVarLenFeature</a>
        </li>
				<li>
            <a href="../tensorflow/IWholeFileReader.htm">IWholeFileReader</a>
        </li>
				<li>
            <a href="../tensorflow/Izeros_initializer.htm">Izeros_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/LazyLoader.htm">LazyLoader</a>
        </li>
				<li>
            <a href="../tensorflow/LMDBReader.htm">LMDBReader</a>
        </li>
				<li>
            <a href="../tensorflow/Module.htm">Module</a>
        </li>
				<li>
            <a href="../tensorflow/name_scope.htm">name_scope</a>
        </li>
				<li>
            <a href="../tensorflow/ones_initializer.htm">ones_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/Operation.htm">Operation</a>
        </li>
				<li>
            <a href="../tensorflow/Operation._InputList.htm">Operation._InputList</a>
        </li>
				<li>
            <a href="../tensorflow/Operation.I_InputList.htm">Operation.I_InputList</a>
        </li>
				<li>
            <a href="../tensorflow/OpError.htm">OpError</a>
        </li>
				<li>
            <a href="../tensorflow/OptionalSpec.htm">OptionalSpec</a>
        </li>
				<li>
            <a href="../tensorflow/orthogonal_initializer.htm">orthogonal_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/PaddingFIFOQueue.htm">PaddingFIFOQueue</a>
        </li>
				<li>
            <a href="../tensorflow/PriorityQueue.htm">PriorityQueue</a>
        </li>
				<li>
            <a href="../tensorflow/QueueBase.htm">QueueBase</a>
        </li>
				<li>
            <a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a>
        </li>
				<li>
            <a href="../tensorflow/RaggedTensorSpec.htm">RaggedTensorSpec</a>
        </li>
				<li>
            <a href="../tensorflow/random_normal_initializer.htm">random_normal_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/random_uniform_initializer.htm">random_uniform_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/RandomShuffleQueue.htm">RandomShuffleQueue</a>
        </li>
				<li>
            <a href="../tensorflow/ReaderBase.htm">ReaderBase</a>
        </li>
				<li>
            <a href="../tensorflow/RegisterGradient.htm">RegisterGradient</a>
        </li>
				<li>
            <a href="../tensorflow/Session.htm">Session</a>
        </li>
				<li>
            <a href="../tensorflow/SparseConditionalAccumulator.htm">SparseConditionalAccumulator</a>
        </li>
				<li>
            <a href="../tensorflow/SparseFeature.htm">SparseFeature</a>
        </li>
				<li>
            <a href="../tensorflow/SparseTensor.htm">SparseTensor</a>
        </li>
				<li>
            <a href="../tensorflow/SparseTensorSpec.htm">SparseTensorSpec</a>
        </li>
				<li>
            <a href="../tensorflow/SparseTensorValue.htm">SparseTensorValue</a>
        </li>
				<li>
            <a href="../tensorflow/Tensor.htm">Tensor</a>
        </li>
				<li>
            <a href="../tensorflow/Tensor`1.htm">Tensor&lt;T&gt;</a>
        </li>
				<li>
            <a href="../tensorflow/TensorArray.htm">TensorArray</a>
        </li>
				<li>
            <a href="../tensorflow/TensorArraySpec.htm">TensorArraySpec</a>
        </li>
				<li>
            <a href="../tensorflow/TensorDimension.htm">TensorDimension</a>
        </li>
				<li>
            <a href="../tensorflow/TensorDimensionSlice.htm">TensorDimensionSlice</a>
        </li>
				<li>
            <a href="../tensorflow/TensorShape.htm">TensorShape</a>
        </li>
				<li>
            <a href="../tensorflow/TensorSpec.htm">TensorSpec</a>
        </li>
				<li>
            <a href="../tensorflow/TextLineReader.htm">TextLineReader</a>
        </li>
				<li>
            <a href="../tensorflow/tf.htm">tf</a>
        </li>
				<li>
            <a href="../tensorflow/tf.audio.htm">tf.audio</a>
        </li>
				<li>
            <a href="../tensorflow/tf.autograph.htm">tf.autograph</a>
        </li>
				<li>
            <a href="../tensorflow/tf.autograph.experimental.htm">tf.autograph.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.bitwise.htm">tf.bitwise</a>
        </li>
				<li>
            <a href="../tensorflow/tf.compat.htm">tf.compat</a>
        </li>
				<li>
            <a href="../tensorflow/tf.config.htm">tf.config</a>
        </li>
				<li>
            <a href="../tensorflow/tf.config.experimental.htm">tf.config.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.config.optimizer.htm">tf.config.optimizer</a>
        </li>
				<li>
            <a href="../tensorflow/tf.config.threading.htm">tf.config.threading</a>
        </li>
				<li>
            <a href="../tensorflow/tf.data.htm">tf.data</a>
        </li>
				<li>
            <a href="../tensorflow/tf.data.experimental.htm">tf.data.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.debugging.htm">tf.debugging</a>
        </li>
				<li>
            <a href="../tensorflow/tf.distribute.htm">tf.distribute</a>
        </li>
				<li>
            <a href="../tensorflow/tf.distributions.htm">tf.distributions</a>
        </li>
				<li>
            <a href="../tensorflow/tf.errors.htm">tf.errors</a>
        </li>
				<li>
            <a href="../tensorflow/tf.estimator.htm">tf.estimator</a>
        </li>
				<li>
            <a href="../tensorflow/tf.estimator.experimental.htm">tf.estimator.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.estimator.export.htm">tf.estimator.export</a>
        </li>
				<li>
            <a href="../tensorflow/tf.estimator.inputs.htm">tf.estimator.inputs</a>
        </li>
				<li>
            <a href="../tensorflow/tf.experimental.htm">tf.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.feature_column.htm">tf.feature_column</a>
        </li>
				<li>
            <a href="../tensorflow/tf.gfile.htm">tf.gfile</a>
        </li>
				<li>
            <a href="../tensorflow/tf.graph_util.htm">tf.graph_util</a>
        </li>
				<li>
            <a href="../tensorflow/tf.image.htm">tf.image</a>
        </li>
				<li>
            <a href="../tensorflow/tf.initializers.htm">tf.initializers</a>
        </li>
				<li>
            <a href="../tensorflow/tf.io.htm">tf.io</a>
        </li>
				<li>
            <a href="../tensorflow/tf.io.gfile.htm">tf.io.gfile</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.htm">tf.keras</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.activations.htm">tf.keras.activations</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.htm">tf.keras.applications</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.densenet.htm">tf.keras.applications.densenet</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.imagenet_utils.htm">tf.keras.applications.imagenet_utils</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.inception_resnet_v2.htm">tf.keras.applications.inception_resnet_v2</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.inception_v3.htm">tf.keras.applications.inception_v3</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.mobilenet.htm">tf.keras.applications.mobilenet</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.mobilenet_v2.htm">tf.keras.applications.mobilenet_v2</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.nasnet.htm">tf.keras.applications.nasnet</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.resnet.htm">tf.keras.applications.resnet</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.resnet_v2.htm">tf.keras.applications.resnet_v2</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.vgg16.htm">tf.keras.applications.vgg16</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.vgg19.htm">tf.keras.applications.vgg19</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.xception.htm">tf.keras.applications.xception</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.backend.htm">tf.keras.backend</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.constraints.htm">tf.keras.constraints</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.datasets.htm">tf.keras.datasets</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.datasets.boston_housing.htm">tf.keras.datasets.boston_housing</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.datasets.cifar10.htm">tf.keras.datasets.cifar10</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.datasets.cifar100.htm">tf.keras.datasets.cifar100</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.datasets.fashion_mnist.htm">tf.keras.datasets.fashion_mnist</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.datasets.imdb.htm">tf.keras.datasets.imdb</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.datasets.mnist.htm">tf.keras.datasets.mnist</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.datasets.reuters.htm">tf.keras.datasets.reuters</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.estimator.htm">tf.keras.estimator</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.experimental.htm">tf.keras.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.initializers.htm">tf.keras.initializers</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.layers.htm">tf.keras.layers</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.losses.htm">tf.keras.losses</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.metrics.htm">tf.keras.metrics</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.mixed_precision.htm">tf.keras.mixed_precision</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.mixed_precision.experimental.htm">tf.keras.mixed_precision.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.models.htm">tf.keras.models</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.optimizers.htm">tf.keras.optimizers</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.optimizers.schedules.htm">tf.keras.optimizers.schedules</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.preprocessing.htm">tf.keras.preprocessing</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.preprocessing.image.htm">tf.keras.preprocessing.image</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.regularizers.htm">tf.keras.regularizers</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.utils.htm">tf.keras.utils</a>
        </li>
				<li>
            <a href="../tensorflow/tf.layers.htm">tf.layers</a>
        </li>
				<li>
            <a href="../tensorflow/tf.layers.experimental.htm">tf.layers.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.linalg.htm">tf.linalg</a>
        </li>
				<li>
            <a href="../tensorflow/tf.lite.htm">tf.lite</a>
        </li>
				<li>
            <a href="../tensorflow/tf.lite.experimental.htm">tf.lite.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.lite.experimental.microfrontend.htm">tf.lite.experimental.microfrontend</a>
        </li>
				<li>
            <a href="../tensorflow/tf.lite.experimental.microfrontend.python.htm">tf.lite.experimental.microfrontend.python</a>
        </li>
				<li>
            <a href="../tensorflow/tf.lite.experimental.microfrontend.python.ops.htm">tf.lite.experimental.microfrontend.python.ops</a>
        </li>
				<li>
            <a href="../tensorflow/tf.lite.experimental.nn.htm">tf.lite.experimental.nn</a>
        </li>
				<li>
            <a href="../tensorflow/tf.logging.htm">tf.logging</a>
        </li>
				<li>
            <a href="../tensorflow/tf.losses.htm">tf.losses</a>
        </li>
				<li>
            <a href="../tensorflow/tf.math.htm">tf.math</a>
        </li>
				<li>
            <a href="../tensorflow/tf.metrics.htm" class="current">tf.metrics</a>
        </li>
				<li>
            <a href="../tensorflow/tf.nest.htm">tf.nest</a>
        </li>
				<li>
            <a href="../tensorflow/tf.nn.htm">tf.nn</a>
        </li>
				<li>
            <a href="../tensorflow/tf.profiler.htm">tf.profiler</a>
        </li>
				<li>
            <a href="../tensorflow/tf.quantization.htm">tf.quantization</a>
        </li>
				<li>
            <a href="../tensorflow/tf.ragged.htm">tf.ragged</a>
        </li>
				<li>
            <a href="../tensorflow/tf.random.htm">tf.random</a>
        </li>
				<li>
            <a href="../tensorflow/tf.random.experimental.htm">tf.random.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.resource_loader.htm">tf.resource_loader</a>
        </li>
				<li>
            <a href="../tensorflow/tf.saved_model.htm">tf.saved_model</a>
        </li>
				<li>
            <a href="../tensorflow/tf.saved_model.main_op.htm">tf.saved_model.main_op</a>
        </li>
				<li>
            <a href="../tensorflow/tf.sets.htm">tf.sets</a>
        </li>
				<li>
            <a href="../tensorflow/tf.signal.htm">tf.signal</a>
        </li>
				<li>
            <a href="../tensorflow/tf.sparse.htm">tf.sparse</a>
        </li>
				<li>
            <a href="../tensorflow/tf.strings.htm">tf.strings</a>
        </li>
				<li>
            <a href="../tensorflow/tf.summary.htm">tf.summary</a>
        </li>
				<li>
            <a href="../tensorflow/tf.summary.experimental.htm">tf.summary.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.sysconfig.htm">tf.sysconfig</a>
        </li>
				<li>
            <a href="../tensorflow/tf.test.htm">tf.test</a>
        </li>
				<li>
            <a href="../tensorflow/tf.tpu.htm">tf.tpu</a>
        </li>
				<li>
            <a href="../tensorflow/tf.tpu.experimental.htm">tf.tpu.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.train.htm">tf.train</a>
        </li>
				<li>
            <a href="../tensorflow/tf.train.experimental.htm">tf.train.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.user_ops.htm">tf.user_ops</a>
        </li>
				<li>
            <a href="../tensorflow/tf.xla.htm">tf.xla</a>
        </li>
				<li>
            <a href="../tensorflow/tf.xla.experimental.htm">tf.xla.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/TFRecordReader.htm">TFRecordReader</a>
        </li>
				<li>
            <a href="../tensorflow/truncated_normal_initializer.htm">truncated_normal_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/TypeSpec.htm">TypeSpec</a>
        </li>
				<li>
            <a href="../tensorflow/UnconnectedGradients.htm">UnconnectedGradients</a>
        </li>
				<li>
            <a href="../tensorflow/uniform_unit_scaling_initializer.htm">uniform_unit_scaling_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/Variable.htm">Variable</a>
        </li>
				<li>
            <a href="../tensorflow/variable_scope.htm">variable_scope</a>
        </li>
				<li>
            <a href="../tensorflow/VariableAggregation.htm">VariableAggregation</a>
        </li>
				<li>
            <a href="../tensorflow/VariableScope.htm">VariableScope</a>
        </li>
				<li>
            <a href="../tensorflow/VariableSynchronization.htm">VariableSynchronization</a>
        </li>
				<li>
            <a href="../tensorflow/variance_scaling_initializer.htm">variance_scaling_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/VarLenFeature.htm">VarLenFeature</a>
        </li>
				<li>
            <a href="../tensorflow/WholeFileReader.htm">WholeFileReader</a>
        </li>
				<li>
            <a href="../tensorflow/zeros_initializer.htm">zeros_initializer</a>
        </li>
		</ul>
	</div>
</nav>
	<article>
    <header>
		<p class="class"><strong>Type</strong> tf.metrics</p>
	</header>
	<section>
		<header>
		<p><strong>Namespace</strong> tensorflow</p>
		</header>
    <div class="sub-header">
		
		
			<h3 class="section">Methods</h3>
			<ul>
				<li><a href="../tensorflow/tf.metrics.htm#accuracy">accuracy</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#accuracy">accuracy</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#accuracy">accuracy</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#accuracy">accuracy</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#accuracy">accuracy</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#accuracy">accuracy</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#accuracy">accuracy</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#accuracy">accuracy</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#accuracy">accuracy</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#accuracy">accuracy</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#accuracy">accuracy</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#accuracy">accuracy</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#accuracy">accuracy</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#accuracy">accuracy</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#accuracy">accuracy</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#accuracy">accuracy</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#accuracy">accuracy</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#accuracy">accuracy</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#accuracy">accuracy</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#accuracy">accuracy</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#accuracy">accuracy</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#accuracy">accuracy</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#accuracy">accuracy</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#accuracy">accuracy</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#accuracy">accuracy</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#accuracy">accuracy</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#accuracy">accuracy</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#accuracy">accuracy</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#accuracy">accuracy</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#accuracy">accuracy</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#accuracy">accuracy</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#accuracy">accuracy</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#accuracy_dyn">accuracy_dyn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#auc">auc</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#auc">auc</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#auc">auc</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#auc">auc</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#auc">auc</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#auc">auc</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#auc">auc</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#auc">auc</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#auc">auc</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#auc">auc</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#auc">auc</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#auc">auc</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#auc">auc</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#auc">auc</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#auc">auc</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#auc">auc</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#auc">auc</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#auc">auc</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#auc">auc</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#auc">auc</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#auc">auc</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#auc">auc</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#auc">auc</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#auc">auc</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#auc_dyn">auc_dyn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#average_precision_at_k">average_precision_at_k</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#average_precision_at_k">average_precision_at_k</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#average_precision_at_k">average_precision_at_k</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#average_precision_at_k">average_precision_at_k</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#average_precision_at_k">average_precision_at_k</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#average_precision_at_k">average_precision_at_k</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#average_precision_at_k">average_precision_at_k</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#average_precision_at_k">average_precision_at_k</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#average_precision_at_k_dyn">average_precision_at_k_dyn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#false_negatives">false_negatives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#false_negatives">false_negatives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#false_negatives">false_negatives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#false_negatives">false_negatives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#false_negatives">false_negatives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#false_negatives">false_negatives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#false_negatives">false_negatives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#false_negatives">false_negatives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#false_negatives">false_negatives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#false_negatives">false_negatives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#false_negatives">false_negatives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#false_negatives">false_negatives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#false_negatives">false_negatives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#false_negatives">false_negatives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#false_negatives">false_negatives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#false_negatives">false_negatives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#false_negatives">false_negatives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#false_negatives">false_negatives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#false_negatives">false_negatives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#false_negatives">false_negatives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#false_negatives">false_negatives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#false_negatives">false_negatives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#false_negatives">false_negatives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#false_negatives">false_negatives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#false_negatives">false_negatives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#false_negatives">false_negatives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#false_negatives">false_negatives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#false_negatives">false_negatives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#false_negatives_at_thresholds">false_negatives_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#false_negatives_at_thresholds_dyn">false_negatives_at_thresholds_dyn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#false_negatives_dyn">false_negatives_dyn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#false_positives">false_positives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#false_positives">false_positives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#false_positives">false_positives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#false_positives">false_positives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#false_positives">false_positives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#false_positives">false_positives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#false_positives">false_positives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#false_positives">false_positives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#false_positives">false_positives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#false_positives">false_positives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#false_positives">false_positives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#false_positives">false_positives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#false_positives">false_positives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#false_positives">false_positives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#false_positives_at_thresholds">false_positives_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#false_positives_at_thresholds_dyn">false_positives_at_thresholds_dyn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#false_positives_dyn">false_positives_dyn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#mean">mean</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#mean">mean</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#mean">mean</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#mean">mean</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#mean_absolute_error">mean_absolute_error</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#mean_absolute_error_dyn">mean_absolute_error_dyn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#mean_cosine_distance">mean_cosine_distance</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#mean_cosine_distance_dyn">mean_cosine_distance_dyn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#mean_dyn">mean_dyn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#mean_iou">mean_iou</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#mean_iou">mean_iou</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#mean_iou">mean_iou</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#mean_iou">mean_iou</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#mean_iou">mean_iou</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#mean_iou">mean_iou</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#mean_iou">mean_iou</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#mean_iou">mean_iou</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#mean_iou_dyn">mean_iou_dyn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#mean_per_class_accuracy">mean_per_class_accuracy</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#mean_per_class_accuracy">mean_per_class_accuracy</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#mean_per_class_accuracy">mean_per_class_accuracy</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#mean_per_class_accuracy">mean_per_class_accuracy</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#mean_per_class_accuracy">mean_per_class_accuracy</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#mean_per_class_accuracy">mean_per_class_accuracy</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#mean_per_class_accuracy">mean_per_class_accuracy</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#mean_per_class_accuracy">mean_per_class_accuracy</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#mean_per_class_accuracy">mean_per_class_accuracy</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#mean_per_class_accuracy">mean_per_class_accuracy</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#mean_per_class_accuracy">mean_per_class_accuracy</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#mean_per_class_accuracy">mean_per_class_accuracy</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#mean_per_class_accuracy">mean_per_class_accuracy</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#mean_per_class_accuracy">mean_per_class_accuracy</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#mean_per_class_accuracy">mean_per_class_accuracy</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#mean_per_class_accuracy">mean_per_class_accuracy</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#mean_per_class_accuracy_dyn">mean_per_class_accuracy_dyn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#mean_relative_error">mean_relative_error</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#mean_relative_error_dyn">mean_relative_error_dyn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#mean_squared_error">mean_squared_error</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#mean_squared_error_dyn">mean_squared_error_dyn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#mean_tensor">mean_tensor</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#mean_tensor">mean_tensor</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#mean_tensor">mean_tensor</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#mean_tensor">mean_tensor</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#mean_tensor_dyn">mean_tensor_dyn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#percentage_below">percentage_below</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#percentage_below_dyn">percentage_below_dyn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision">precision</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision">precision</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision">precision</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision">precision</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision">precision</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision">precision</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision">precision</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision">precision</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision">precision</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision">precision</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision">precision</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision">precision</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision">precision</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision">precision</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision">precision</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision">precision</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision">precision</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision">precision</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision">precision</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision">precision</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision">precision</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision">precision</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision">precision</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision">precision</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision">precision</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision">precision</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision">precision</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision">precision</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision">precision</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision">precision</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision">precision</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision">precision</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision_at_k">precision_at_k</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision_at_k">precision_at_k</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision_at_k">precision_at_k</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision_at_k">precision_at_k</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision_at_k_dyn">precision_at_k_dyn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision_at_thresholds">precision_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision_at_thresholds">precision_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision_at_thresholds">precision_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision_at_thresholds">precision_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision_at_thresholds">precision_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision_at_thresholds">precision_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision_at_thresholds">precision_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision_at_thresholds">precision_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision_at_thresholds">precision_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision_at_thresholds">precision_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision_at_thresholds">precision_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision_at_thresholds">precision_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision_at_thresholds">precision_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision_at_thresholds">precision_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision_at_thresholds">precision_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision_at_thresholds">precision_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision_at_thresholds">precision_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision_at_thresholds">precision_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision_at_thresholds">precision_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision_at_thresholds">precision_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision_at_thresholds">precision_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision_at_thresholds">precision_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision_at_thresholds">precision_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision_at_thresholds">precision_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision_at_thresholds">precision_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision_at_thresholds">precision_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision_at_thresholds">precision_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision_at_thresholds">precision_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision_at_thresholds">precision_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision_at_thresholds">precision_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision_at_thresholds">precision_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision_at_thresholds">precision_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision_at_thresholds_dyn">precision_at_thresholds_dyn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision_at_top_k">precision_at_top_k</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision_at_top_k">precision_at_top_k</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision_at_top_k">precision_at_top_k</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision_at_top_k">precision_at_top_k</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision_at_top_k">precision_at_top_k</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision_at_top_k">precision_at_top_k</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision_at_top_k">precision_at_top_k</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision_at_top_k">precision_at_top_k</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision_at_top_k_dyn">precision_at_top_k_dyn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision_dyn">precision_dyn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall">recall</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall">recall</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall">recall</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall">recall</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall">recall</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall">recall</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall">recall</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall">recall</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall">recall</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall">recall</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall">recall</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall">recall</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall">recall</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall">recall</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall">recall</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall">recall</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_at_k">recall_at_k</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_at_k">recall_at_k</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_at_k">recall_at_k</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_at_k">recall_at_k</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_at_k">recall_at_k</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_at_k">recall_at_k</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_at_k">recall_at_k</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_at_k">recall_at_k</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_at_k">recall_at_k</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_at_k_dyn">recall_at_k_dyn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_at_thresholds">recall_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_at_thresholds">recall_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_at_thresholds">recall_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_at_thresholds">recall_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_at_thresholds">recall_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_at_thresholds">recall_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_at_thresholds">recall_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_at_thresholds">recall_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_at_thresholds">recall_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_at_thresholds">recall_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_at_thresholds">recall_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_at_thresholds">recall_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_at_thresholds">recall_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_at_thresholds">recall_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_at_thresholds">recall_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_at_thresholds">recall_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_at_thresholds">recall_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_at_thresholds">recall_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_at_thresholds">recall_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_at_thresholds">recall_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_at_thresholds">recall_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_at_thresholds">recall_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_at_thresholds">recall_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_at_thresholds">recall_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_at_thresholds">recall_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_at_thresholds">recall_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_at_thresholds">recall_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_at_thresholds">recall_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_at_thresholds">recall_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_at_thresholds">recall_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_at_thresholds">recall_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_at_thresholds">recall_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_at_thresholds_dyn">recall_at_thresholds_dyn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_at_top_k">recall_at_top_k</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_at_top_k">recall_at_top_k</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_at_top_k">recall_at_top_k</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_at_top_k">recall_at_top_k</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_at_top_k">recall_at_top_k</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_at_top_k">recall_at_top_k</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_at_top_k">recall_at_top_k</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_at_top_k">recall_at_top_k</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_at_top_k">recall_at_top_k</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_at_top_k">recall_at_top_k</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_at_top_k">recall_at_top_k</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_at_top_k">recall_at_top_k</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_at_top_k_dyn">recall_at_top_k_dyn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_dyn">recall_dyn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#root_mean_squared_error">root_mean_squared_error</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#root_mean_squared_error_dyn">root_mean_squared_error_dyn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#sensitivity_at_specificity">sensitivity_at_specificity</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#sensitivity_at_specificity">sensitivity_at_specificity</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#sensitivity_at_specificity">sensitivity_at_specificity</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#sensitivity_at_specificity">sensitivity_at_specificity</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#sensitivity_at_specificity_dyn">sensitivity_at_specificity_dyn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#sparse_average_precision_at_k">sparse_average_precision_at_k</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#sparse_average_precision_at_k_dyn">sparse_average_precision_at_k_dyn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#sparse_precision_at_k">sparse_precision_at_k</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#sparse_precision_at_k_dyn">sparse_precision_at_k_dyn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#specificity_at_sensitivity">specificity_at_sensitivity</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#specificity_at_sensitivity">specificity_at_sensitivity</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#specificity_at_sensitivity">specificity_at_sensitivity</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#specificity_at_sensitivity">specificity_at_sensitivity</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#specificity_at_sensitivity_dyn">specificity_at_sensitivity_dyn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#true_negatives">true_negatives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#true_negatives">true_negatives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#true_negatives">true_negatives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#true_negatives">true_negatives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#true_negatives">true_negatives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#true_negatives">true_negatives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#true_negatives">true_negatives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#true_negatives">true_negatives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#true_negatives">true_negatives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#true_negatives">true_negatives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#true_negatives">true_negatives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#true_negatives">true_negatives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#true_negatives">true_negatives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#true_negatives">true_negatives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#true_negatives">true_negatives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#true_negatives">true_negatives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#true_negatives">true_negatives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#true_negatives">true_negatives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#true_negatives">true_negatives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#true_negatives">true_negatives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#true_negatives">true_negatives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#true_negatives">true_negatives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#true_negatives">true_negatives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#true_negatives">true_negatives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#true_negatives">true_negatives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#true_negatives">true_negatives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#true_negatives">true_negatives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#true_negatives">true_negatives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#true_negatives">true_negatives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#true_negatives">true_negatives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#true_negatives_at_thresholds">true_negatives_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#true_negatives_at_thresholds_dyn">true_negatives_at_thresholds_dyn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#true_negatives_dyn">true_negatives_dyn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#true_positives">true_positives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#true_positives">true_positives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#true_positives">true_positives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#true_positives">true_positives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#true_positives">true_positives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#true_positives">true_positives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#true_positives">true_positives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#true_positives">true_positives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#true_positives">true_positives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#true_positives">true_positives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#true_positives">true_positives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#true_positives">true_positives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#true_positives">true_positives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#true_positives">true_positives</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#true_positives_at_thresholds">true_positives_at_thresholds</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#true_positives_at_thresholds_dyn">true_positives_at_thresholds_dyn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#true_positives_dyn">true_positives_dyn</a></li>
			</ul>
		
			<h3 class="section">Properties</h3>
			<ul>
				<li><a href="../tensorflow/tf.metrics.htm#accuracy_fn">accuracy_fn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#auc_fn">auc_fn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#average_precision_at_k_fn">average_precision_at_k_fn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#false_negatives_at_thresholds_fn">false_negatives_at_thresholds_fn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#false_negatives_fn">false_negatives_fn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#false_positives_at_thresholds_fn">false_positives_at_thresholds_fn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#false_positives_fn">false_positives_fn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#mean_absolute_error_fn">mean_absolute_error_fn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#mean_cosine_distance_fn">mean_cosine_distance_fn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#mean_fn">mean_fn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#mean_iou_fn">mean_iou_fn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#mean_per_class_accuracy_fn">mean_per_class_accuracy_fn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#mean_relative_error_fn">mean_relative_error_fn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#mean_squared_error_fn">mean_squared_error_fn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#mean_tensor_fn">mean_tensor_fn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#percentage_below_fn">percentage_below_fn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision_at_k_fn">precision_at_k_fn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision_at_thresholds_fn">precision_at_thresholds_fn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision_at_top_k_fn">precision_at_top_k_fn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#precision_fn">precision_fn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_at_k_fn">recall_at_k_fn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_at_thresholds_fn">recall_at_thresholds_fn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_at_top_k_fn">recall_at_top_k_fn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#recall_fn">recall_fn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#root_mean_squared_error_fn">root_mean_squared_error_fn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#sensitivity_at_specificity_fn">sensitivity_at_specificity_fn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#sparse_average_precision_at_k_fn">sparse_average_precision_at_k_fn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#sparse_precision_at_k_fn">sparse_precision_at_k_fn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#specificity_at_sensitivity_fn">specificity_at_sensitivity_fn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#true_negatives_at_thresholds_fn">true_negatives_at_thresholds_fn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#true_negatives_fn">true_negatives_fn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#true_positives_at_thresholds_fn">true_positives_at_thresholds_fn</a></li>
				<li><a href="../tensorflow/tf.metrics.htm#true_positives_fn">true_positives_fn</a></li>
			</ul>
		
	</div>
	
	
	<h3 class="section">Public static methods</h3>

	<div id="accuracy" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>accuracy</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> predictions, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> name)
		</h4>
		<div class="content">Calculates how often `predictions` matches `labels`. <p></p> The `accuracy` function creates two local variables, `total` and
`count` that are used to compute the frequency with which `predictions`
matches `labels`. This frequency is ultimately returned as `accuracy`: an
idempotent operation that simply divides `total` by `count`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `accuracy`.
Internally, an `is_correct` operation computes a `Tensor` with elements 1.0
where the corresponding elements of `predictions` and `labels` match and 0.0
otherwise. Then `update_op` increments `total` with the reduced sum of the
product of `weights` and `is_correct`, and it increments `count` with the
reduced sum of `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose shape matches
`predictions`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of any shape. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `accuracy` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="accuracy" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>accuracy</strong>(<a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> name)
		</h4>
		<div class="content">Calculates how often `predictions` matches `labels`. <p></p> The `accuracy` function creates two local variables, `total` and
`count` that are used to compute the frequency with which `predictions`
matches `labels`. This frequency is ultimately returned as `accuracy`: an
idempotent operation that simply divides `total` by `count`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `accuracy`.
Internally, an `is_correct` operation computes a `Tensor` with elements 1.0
where the corresponding elements of `predictions` and `labels` match and 0.0
otherwise. Then `update_op` increments `total` with the reduced sum of the
product of `weights` and `is_correct`, and it increments `count` with the
reduced sum of `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose shape matches
`predictions`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of any shape. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `accuracy` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="accuracy" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>accuracy</strong>(<a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> labels, <span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> predictions, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Calculates how often `predictions` matches `labels`. <p></p> The `accuracy` function creates two local variables, `total` and
`count` that are used to compute the frequency with which `predictions`
matches `labels`. This frequency is ultimately returned as `accuracy`: an
idempotent operation that simply divides `total` by `count`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `accuracy`.
Internally, an `is_correct` operation computes a `Tensor` with elements 1.0
where the corresponding elements of `predictions` and `labels` match and 0.0
otherwise. Then `update_op` increments `total` with the reduced sum of the
product of `weights` and `is_correct`, and it increments `count` with the
reduced sum of `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose shape matches
`predictions`. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of any shape. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `accuracy` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="accuracy" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>accuracy</strong>(<a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> labels, <a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> predictions, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> name)
		</h4>
		<div class="content">Calculates how often `predictions` matches `labels`. <p></p> The `accuracy` function creates two local variables, `total` and
`count` that are used to compute the frequency with which `predictions`
matches `labels`. This frequency is ultimately returned as `accuracy`: an
idempotent operation that simply divides `total` by `count`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `accuracy`.
Internally, an `is_correct` operation computes a `Tensor` with elements 1.0
where the corresponding elements of `predictions` and `labels` match and 0.0
otherwise. Then `update_op` increments `total` with the reduced sum of the
product of `weights` and `is_correct`, and it increments `count` with the
reduced sum of `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose shape matches
`predictions`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of any shape. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `accuracy` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="accuracy" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>accuracy</strong>(<a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> labels, <a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> predictions, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Calculates how often `predictions` matches `labels`. <p></p> The `accuracy` function creates two local variables, `total` and
`count` that are used to compute the frequency with which `predictions`
matches `labels`. This frequency is ultimately returned as `accuracy`: an
idempotent operation that simply divides `total` by `count`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `accuracy`.
Internally, an `is_correct` operation computes a `Tensor` with elements 1.0
where the corresponding elements of `predictions` and `labels` match and 0.0
otherwise. Then `update_op` increments `total` with the reduced sum of the
product of `weights` and `is_correct`, and it increments `count` with the
reduced sum of `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose shape matches
`predictions`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of any shape. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `accuracy` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="accuracy" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>accuracy</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Calculates how often `predictions` matches `labels`. <p></p> The `accuracy` function creates two local variables, `total` and
`count` that are used to compute the frequency with which `predictions`
matches `labels`. This frequency is ultimately returned as `accuracy`: an
idempotent operation that simply divides `total` by `count`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `accuracy`.
Internally, an `is_correct` operation computes a `Tensor` with elements 1.0
where the corresponding elements of `predictions` and `labels` match and 0.0
otherwise. Then `update_op` increments `total` with the reduced sum of the
product of `weights` and `is_correct`, and it increments `count` with the
reduced sum of `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose shape matches
`predictions`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of any shape. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `accuracy` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="accuracy" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>accuracy</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> name)
		</h4>
		<div class="content">Calculates how often `predictions` matches `labels`. <p></p> The `accuracy` function creates two local variables, `total` and
`count` that are used to compute the frequency with which `predictions`
matches `labels`. This frequency is ultimately returned as `accuracy`: an
idempotent operation that simply divides `total` by `count`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `accuracy`.
Internally, an `is_correct` operation computes a `Tensor` with elements 1.0
where the corresponding elements of `predictions` and `labels` match and 0.0
otherwise. Then `update_op` increments `total` with the reduced sum of the
product of `weights` and `is_correct`, and it increments `count` with the
reduced sum of `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose shape matches
`predictions`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of any shape. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `accuracy` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="accuracy" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>accuracy</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> predictions, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Calculates how often `predictions` matches `labels`. <p></p> The `accuracy` function creates two local variables, `total` and
`count` that are used to compute the frequency with which `predictions`
matches `labels`. This frequency is ultimately returned as `accuracy`: an
idempotent operation that simply divides `total` by `count`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `accuracy`.
Internally, an `is_correct` operation computes a `Tensor` with elements 1.0
where the corresponding elements of `predictions` and `labels` match and 0.0
otherwise. Then `update_op` increments `total` with the reduced sum of the
product of `weights` and `is_correct`, and it increments `count` with the
reduced sum of `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose shape matches
`predictions`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of any shape. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `accuracy` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="accuracy" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>accuracy</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> predictions, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Calculates how often `predictions` matches `labels`. <p></p> The `accuracy` function creates two local variables, `total` and
`count` that are used to compute the frequency with which `predictions`
matches `labels`. This frequency is ultimately returned as `accuracy`: an
idempotent operation that simply divides `total` by `count`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `accuracy`.
Internally, an `is_correct` operation computes a `Tensor` with elements 1.0
where the corresponding elements of `predictions` and `labels` match and 0.0
otherwise. Then `update_op` increments `total` with the reduced sum of the
product of `weights` and `is_correct`, and it increments `count` with the
reduced sum of `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose shape matches
`predictions`. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of any shape. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `accuracy` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="accuracy" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>accuracy</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> predictions, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> name)
		</h4>
		<div class="content">Calculates how often `predictions` matches `labels`. <p></p> The `accuracy` function creates two local variables, `total` and
`count` that are used to compute the frequency with which `predictions`
matches `labels`. This frequency is ultimately returned as `accuracy`: an
idempotent operation that simply divides `total` by `count`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `accuracy`.
Internally, an `is_correct` operation computes a `Tensor` with elements 1.0
where the corresponding elements of `predictions` and `labels` match and 0.0
otherwise. Then `update_op` increments `total` with the reduced sum of the
product of `weights` and `is_correct`, and it increments `count` with the
reduced sum of `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose shape matches
`predictions`. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of any shape. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `accuracy` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="accuracy" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>accuracy</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> predictions, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Calculates how often `predictions` matches `labels`. <p></p> The `accuracy` function creates two local variables, `total` and
`count` that are used to compute the frequency with which `predictions`
matches `labels`. This frequency is ultimately returned as `accuracy`: an
idempotent operation that simply divides `total` by `count`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `accuracy`.
Internally, an `is_correct` operation computes a `Tensor` with elements 1.0
where the corresponding elements of `predictions` and `labels` match and 0.0
otherwise. Then `update_op` increments `total` with the reduced sum of the
product of `weights` and `is_correct`, and it increments `count` with the
reduced sum of `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose shape matches
`predictions`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of any shape. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `accuracy` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="accuracy" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>accuracy</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> predictions, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> name)
		</h4>
		<div class="content">Calculates how often `predictions` matches `labels`. <p></p> The `accuracy` function creates two local variables, `total` and
`count` that are used to compute the frequency with which `predictions`
matches `labels`. This frequency is ultimately returned as `accuracy`: an
idempotent operation that simply divides `total` by `count`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `accuracy`.
Internally, an `is_correct` operation computes a `Tensor` with elements 1.0
where the corresponding elements of `predictions` and `labels` match and 0.0
otherwise. Then `update_op` increments `total` with the reduced sum of the
product of `weights` and `is_correct`, and it increments `count` with the
reduced sum of `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose shape matches
`predictions`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of any shape. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `accuracy` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="accuracy" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>accuracy</strong>(<span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> labels, <span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> predictions, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Calculates how often `predictions` matches `labels`. <p></p> The `accuracy` function creates two local variables, `total` and
`count` that are used to compute the frequency with which `predictions`
matches `labels`. This frequency is ultimately returned as `accuracy`: an
idempotent operation that simply divides `total` by `count`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `accuracy`.
Internally, an `is_correct` operation computes a `Tensor` with elements 1.0
where the corresponding elements of `predictions` and `labels` match and 0.0
otherwise. Then `update_op` increments `total` with the reduced sum of the
product of `weights` and `is_correct`, and it increments `count` with the
reduced sum of `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose shape matches
`predictions`. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of any shape. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `accuracy` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="accuracy" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>accuracy</strong>(<span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> labels, <span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> predictions, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> name)
		</h4>
		<div class="content">Calculates how often `predictions` matches `labels`. <p></p> The `accuracy` function creates two local variables, `total` and
`count` that are used to compute the frequency with which `predictions`
matches `labels`. This frequency is ultimately returned as `accuracy`: an
idempotent operation that simply divides `total` by `count`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `accuracy`.
Internally, an `is_correct` operation computes a `Tensor` with elements 1.0
where the corresponding elements of `predictions` and `labels` match and 0.0
otherwise. Then `update_op` increments `total` with the reduced sum of the
product of `weights` and `is_correct`, and it increments `count` with the
reduced sum of `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose shape matches
`predictions`. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of any shape. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `accuracy` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="accuracy" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>accuracy</strong>(<span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> labels, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> predictions, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Calculates how often `predictions` matches `labels`. <p></p> The `accuracy` function creates two local variables, `total` and
`count` that are used to compute the frequency with which `predictions`
matches `labels`. This frequency is ultimately returned as `accuracy`: an
idempotent operation that simply divides `total` by `count`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `accuracy`.
Internally, an `is_correct` operation computes a `Tensor` with elements 1.0
where the corresponding elements of `predictions` and `labels` match and 0.0
otherwise. Then `update_op` increments `total` with the reduced sum of the
product of `weights` and `is_correct`, and it increments `count` with the
reduced sum of `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose shape matches
`predictions`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of any shape. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `accuracy` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="accuracy" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>accuracy</strong>(<span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> labels, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> predictions, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> name)
		</h4>
		<div class="content">Calculates how often `predictions` matches `labels`. <p></p> The `accuracy` function creates two local variables, `total` and
`count` that are used to compute the frequency with which `predictions`
matches `labels`. This frequency is ultimately returned as `accuracy`: an
idempotent operation that simply divides `total` by `count`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `accuracy`.
Internally, an `is_correct` operation computes a `Tensor` with elements 1.0
where the corresponding elements of `predictions` and `labels` match and 0.0
otherwise. Then `update_op` increments `total` with the reduced sum of the
product of `weights` and `is_correct`, and it increments `count` with the
reduced sum of `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose shape matches
`predictions`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of any shape. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `accuracy` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="accuracy" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>accuracy</strong>(<a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> labels, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> predictions, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Calculates how often `predictions` matches `labels`. <p></p> The `accuracy` function creates two local variables, `total` and
`count` that are used to compute the frequency with which `predictions`
matches `labels`. This frequency is ultimately returned as `accuracy`: an
idempotent operation that simply divides `total` by `count`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `accuracy`.
Internally, an `is_correct` operation computes a `Tensor` with elements 1.0
where the corresponding elements of `predictions` and `labels` match and 0.0
otherwise. Then `update_op` increments `total` with the reduced sum of the
product of `weights` and `is_correct`, and it increments `count` with the
reduced sum of `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose shape matches
`predictions`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of any shape. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `accuracy` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="accuracy" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>accuracy</strong>(<a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> labels, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> predictions, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> name)
		</h4>
		<div class="content">Calculates how often `predictions` matches `labels`. <p></p> The `accuracy` function creates two local variables, `total` and
`count` that are used to compute the frequency with which `predictions`
matches `labels`. This frequency is ultimately returned as `accuracy`: an
idempotent operation that simply divides `total` by `count`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `accuracy`.
Internally, an `is_correct` operation computes a `Tensor` with elements 1.0
where the corresponding elements of `predictions` and `labels` match and 0.0
otherwise. Then `update_op` increments `total` with the reduced sum of the
product of `weights` and `is_correct`, and it increments `count` with the
reduced sum of `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose shape matches
`predictions`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of any shape. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `accuracy` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="accuracy" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>accuracy</strong>(<a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> labels, <span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> predictions, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> name)
		</h4>
		<div class="content">Calculates how often `predictions` matches `labels`. <p></p> The `accuracy` function creates two local variables, `total` and
`count` that are used to compute the frequency with which `predictions`
matches `labels`. This frequency is ultimately returned as `accuracy`: an
idempotent operation that simply divides `total` by `count`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `accuracy`.
Internally, an `is_correct` operation computes a `Tensor` with elements 1.0
where the corresponding elements of `predictions` and `labels` match and 0.0
otherwise. Then `update_op` increments `total` with the reduced sum of the
product of `weights` and `is_correct`, and it increments `count` with the
reduced sum of `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose shape matches
`predictions`. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of any shape. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `accuracy` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="accuracy" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>accuracy</strong>(<a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Calculates how often `predictions` matches `labels`. <p></p> The `accuracy` function creates two local variables, `total` and
`count` that are used to compute the frequency with which `predictions`
matches `labels`. This frequency is ultimately returned as `accuracy`: an
idempotent operation that simply divides `total` by `count`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `accuracy`.
Internally, an `is_correct` operation computes a `Tensor` with elements 1.0
where the corresponding elements of `predictions` and `labels` match and 0.0
otherwise. Then `update_op` increments `total` with the reduced sum of the
product of `weights` and `is_correct`, and it increments `count` with the
reduced sum of `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose shape matches
`predictions`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of any shape. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `accuracy` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="accuracy" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>accuracy</strong>(<span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> name)
		</h4>
		<div class="content">Calculates how often `predictions` matches `labels`. <p></p> The `accuracy` function creates two local variables, `total` and
`count` that are used to compute the frequency with which `predictions`
matches `labels`. This frequency is ultimately returned as `accuracy`: an
idempotent operation that simply divides `total` by `count`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `accuracy`.
Internally, an `is_correct` operation computes a `Tensor` with elements 1.0
where the corresponding elements of `predictions` and `labels` match and 0.0
otherwise. Then `update_op` increments `total` with the reduced sum of the
product of `weights` and `is_correct`, and it increments `count` with the
reduced sum of `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose shape matches
`predictions`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of any shape. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `accuracy` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="accuracy" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>accuracy</strong>(<span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> labels, <a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> predictions, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> name)
		</h4>
		<div class="content">Calculates how often `predictions` matches `labels`. <p></p> The `accuracy` function creates two local variables, `total` and
`count` that are used to compute the frequency with which `predictions`
matches `labels`. This frequency is ultimately returned as `accuracy`: an
idempotent operation that simply divides `total` by `count`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `accuracy`.
Internally, an `is_correct` operation computes a `Tensor` with elements 1.0
where the corresponding elements of `predictions` and `labels` match and 0.0
otherwise. Then `update_op` increments `total` with the reduced sum of the
product of `weights` and `is_correct`, and it increments `count` with the
reduced sum of `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose shape matches
`predictions`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of any shape. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `accuracy` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="accuracy" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>accuracy</strong>(<span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> labels, <a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> predictions, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Calculates how often `predictions` matches `labels`. <p></p> The `accuracy` function creates two local variables, `total` and
`count` that are used to compute the frequency with which `predictions`
matches `labels`. This frequency is ultimately returned as `accuracy`: an
idempotent operation that simply divides `total` by `count`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `accuracy`.
Internally, an `is_correct` operation computes a `Tensor` with elements 1.0
where the corresponding elements of `predictions` and `labels` match and 0.0
otherwise. Then `update_op` increments `total` with the reduced sum of the
product of `weights` and `is_correct`, and it increments `count` with the
reduced sum of `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose shape matches
`predictions`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of any shape. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `accuracy` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="accuracy" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>accuracy</strong>(<span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> labels, <a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> predictions, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Calculates how often `predictions` matches `labels`. <p></p> The `accuracy` function creates two local variables, `total` and
`count` that are used to compute the frequency with which `predictions`
matches `labels`. This frequency is ultimately returned as `accuracy`: an
idempotent operation that simply divides `total` by `count`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `accuracy`.
Internally, an `is_correct` operation computes a `Tensor` with elements 1.0
where the corresponding elements of `predictions` and `labels` match and 0.0
otherwise. Then `update_op` increments `total` with the reduced sum of the
product of `weights` and `is_correct`, and it increments `count` with the
reduced sum of `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose shape matches
`predictions`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of any shape. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `accuracy` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="accuracy" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>accuracy</strong>(<span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> labels, <a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> predictions, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> name)
		</h4>
		<div class="content">Calculates how often `predictions` matches `labels`. <p></p> The `accuracy` function creates two local variables, `total` and
`count` that are used to compute the frequency with which `predictions`
matches `labels`. This frequency is ultimately returned as `accuracy`: an
idempotent operation that simply divides `total` by `count`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `accuracy`.
Internally, an `is_correct` operation computes a `Tensor` with elements 1.0
where the corresponding elements of `predictions` and `labels` match and 0.0
otherwise. Then `update_op` increments `total` with the reduced sum of the
product of `weights` and `is_correct`, and it increments `count` with the
reduced sum of `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose shape matches
`predictions`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of any shape. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `accuracy` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="accuracy" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>accuracy</strong>(<span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> name)
		</h4>
		<div class="content">Calculates how often `predictions` matches `labels`. <p></p> The `accuracy` function creates two local variables, `total` and
`count` that are used to compute the frequency with which `predictions`
matches `labels`. This frequency is ultimately returned as `accuracy`: an
idempotent operation that simply divides `total` by `count`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `accuracy`.
Internally, an `is_correct` operation computes a `Tensor` with elements 1.0
where the corresponding elements of `predictions` and `labels` match and 0.0
otherwise. Then `update_op` increments `total` with the reduced sum of the
product of `weights` and `is_correct`, and it increments `count` with the
reduced sum of `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose shape matches
`predictions`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of any shape. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `accuracy` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="accuracy" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>accuracy</strong>(<span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Calculates how often `predictions` matches `labels`. <p></p> The `accuracy` function creates two local variables, `total` and
`count` that are used to compute the frequency with which `predictions`
matches `labels`. This frequency is ultimately returned as `accuracy`: an
idempotent operation that simply divides `total` by `count`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `accuracy`.
Internally, an `is_correct` operation computes a `Tensor` with elements 1.0
where the corresponding elements of `predictions` and `labels` match and 0.0
otherwise. Then `update_op` increments `total` with the reduced sum of the
product of `weights` and `is_correct`, and it increments `count` with the
reduced sum of `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose shape matches
`predictions`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of any shape. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `accuracy` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="accuracy" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>accuracy</strong>(<span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> labels, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> predictions, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> name)
		</h4>
		<div class="content">Calculates how often `predictions` matches `labels`. <p></p> The `accuracy` function creates two local variables, `total` and
`count` that are used to compute the frequency with which `predictions`
matches `labels`. This frequency is ultimately returned as `accuracy`: an
idempotent operation that simply divides `total` by `count`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `accuracy`.
Internally, an `is_correct` operation computes a `Tensor` with elements 1.0
where the corresponding elements of `predictions` and `labels` match and 0.0
otherwise. Then `update_op` increments `total` with the reduced sum of the
product of `weights` and `is_correct`, and it increments `count` with the
reduced sum of `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose shape matches
`predictions`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of any shape. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `accuracy` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="accuracy" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>accuracy</strong>(<span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> labels, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> predictions, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Calculates how often `predictions` matches `labels`. <p></p> The `accuracy` function creates two local variables, `total` and
`count` that are used to compute the frequency with which `predictions`
matches `labels`. This frequency is ultimately returned as `accuracy`: an
idempotent operation that simply divides `total` by `count`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `accuracy`.
Internally, an `is_correct` operation computes a `Tensor` with elements 1.0
where the corresponding elements of `predictions` and `labels` match and 0.0
otherwise. Then `update_op` increments `total` with the reduced sum of the
product of `weights` and `is_correct`, and it increments `count` with the
reduced sum of `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose shape matches
`predictions`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of any shape. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `accuracy` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="accuracy" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>accuracy</strong>(<span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> labels, <span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> predictions, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> name)
		</h4>
		<div class="content">Calculates how often `predictions` matches `labels`. <p></p> The `accuracy` function creates two local variables, `total` and
`count` that are used to compute the frequency with which `predictions`
matches `labels`. This frequency is ultimately returned as `accuracy`: an
idempotent operation that simply divides `total` by `count`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `accuracy`.
Internally, an `is_correct` operation computes a `Tensor` with elements 1.0
where the corresponding elements of `predictions` and `labels` match and 0.0
otherwise. Then `update_op` increments `total` with the reduced sum of the
product of `weights` and `is_correct`, and it increments `count` with the
reduced sum of `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose shape matches
`predictions`. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of any shape. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `accuracy` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="accuracy" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>accuracy</strong>(<span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Calculates how often `predictions` matches `labels`. <p></p> The `accuracy` function creates two local variables, `total` and
`count` that are used to compute the frequency with which `predictions`
matches `labels`. This frequency is ultimately returned as `accuracy`: an
idempotent operation that simply divides `total` by `count`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `accuracy`.
Internally, an `is_correct` operation computes a `Tensor` with elements 1.0
where the corresponding elements of `predictions` and `labels` match and 0.0
otherwise. Then `update_op` increments `total` with the reduced sum of the
product of `weights` and `is_correct`, and it increments `count` with the
reduced sum of `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose shape matches
`predictions`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of any shape. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `accuracy` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="accuracy" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>accuracy</strong>(<span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> labels, <span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> predictions, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Calculates how often `predictions` matches `labels`. <p></p> The `accuracy` function creates two local variables, `total` and
`count` that are used to compute the frequency with which `predictions`
matches `labels`. This frequency is ultimately returned as `accuracy`: an
idempotent operation that simply divides `total` by `count`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `accuracy`.
Internally, an `is_correct` operation computes a `Tensor` with elements 1.0
where the corresponding elements of `predictions` and `labels` match and 0.0
otherwise. Then `update_op` increments `total` with the reduced sum of the
product of `weights` and `is_correct`, and it increments `count` with the
reduced sum of `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose shape matches
`predictions`. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of any shape. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `accuracy` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="accuracy_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>accuracy_dyn</strong>(<span title="System.object">object</span> labels, <span title="System.object">object</span> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Calculates how often `predictions` matches `labels`. <p></p> The `accuracy` function creates two local variables, `total` and
`count` that are used to compute the frequency with which `predictions`
matches `labels`. This frequency is ultimately returned as `accuracy`: an
idempotent operation that simply divides `total` by `count`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `accuracy`.
Internally, an `is_correct` operation computes a `Tensor` with elements 1.0
where the corresponding elements of `predictions` and `labels` match and 0.0
otherwise. Then `update_op` increments `total` with the reduced sum of the
product of `weights` and `is_correct`, and it increments `count` with the
reduced sum of `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose shape matches
`predictions`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of any shape. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `accuracy` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="auc" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>auc</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> predictions, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> weights, <span title="System.int">int</span> num_thresholds, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> curve, <span title="System.string">string</span> name, <span title="System.string">string</span> summation_method, <span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span> thresholds)
		</h4>
		<div class="content">Computes the approximate AUC via a Riemann sum. <p></p> The `auc` function creates four local variables, `true_positives`,
`true_negatives`, `false_positives` and `false_negatives` that are used to
compute the AUC. To discretize the AUC curve, a linearly spaced set of
thresholds is used to compute pairs of recall and precision values. The area
under the ROC-curve is therefore computed using the height of the recall
values by the false positive rate, while the area under the PR-curve is the
computed using the height of the precision values by the recall. <p></p> This value is ultimately returned as `auc`, an idempotent operation that
computes the area under a discretized curve of precision versus recall values
(computed using the aforementioned variables). The `num_thresholds` variable
controls the degree of discretization with larger numbers of thresholds more
closely approximating the true AUC. The quality of the approximation may vary
dramatically depending on `num_thresholds`. <p></p> For best results, `predictions` should be distributed approximately uniformly
in the range [0, 1] and not peaked around 0 or 1. The quality of the AUC
approximation may be poor if this is not the case. Setting `summation_method`
to 'minoring' or 'majoring' can help quantify the error in the approximation
by providing lower or upper bound estimate of the AUC. The `thresholds`
parameter can be used to manually specify thresholds which split the
predictions more evenly. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `auc`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>A `Tensor` whose shape matches `predictions`. Will be cast to
`bool`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_thresholds
						</dt>
						<dd>The number of thresholds to use when discretizing the roc
curve. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `auc` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> curve
						</dt>
						<dd>Specifies the name of the curve to be computed, 'ROC' [default] or
'PR' for the Precision-Recall-curve. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> summation_method
						</dt>
						<dd>Specifies the Riemann summation method used
(https://en.wikipedia.org/wiki/Riemann_sum): 'trapezoidal' [default] that
applies the trapezoidal rule; 'careful_interpolation', a variant of it
differing only by a more correct interpolation scheme for PR-AUC -
interpolating (true/false) positives but not the ratio that is precision;
'minoring' that applies left summation for increasing intervals and right
summation for decreasing intervals; 'majoring' that does the opposite.
Note that 'careful_interpolation' is strictly preferred to 'trapezoidal'
(to be deprecated soon) as it applies the same method for ROC, and a
better one (see Davis & Goadrich 2006 for details) for the PR curve. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span></code> thresholds
						</dt>
						<dd>An optional list of floating point values to use as the
thresholds for discretizing the curve. If set, the `num_thresholds`
parameter is ignored. Values should be in [0, 1]. Endpoint thresholds
equal to {-epsilon, 1+epsilon} for a small positive epsilon value will be
automatically included with these to correctly handle predictions equal to
exactly 0 or 1. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="auc" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>auc</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> predictions, <a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> weights, <span title="System.int">int</span> num_thresholds, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> curve, <span title="System.string">string</span> name, <span title="System.string">string</span> summation_method, <span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span> thresholds)
		</h4>
		<div class="content">Computes the approximate AUC via a Riemann sum. <p></p> The `auc` function creates four local variables, `true_positives`,
`true_negatives`, `false_positives` and `false_negatives` that are used to
compute the AUC. To discretize the AUC curve, a linearly spaced set of
thresholds is used to compute pairs of recall and precision values. The area
under the ROC-curve is therefore computed using the height of the recall
values by the false positive rate, while the area under the PR-curve is the
computed using the height of the precision values by the recall. <p></p> This value is ultimately returned as `auc`, an idempotent operation that
computes the area under a discretized curve of precision versus recall values
(computed using the aforementioned variables). The `num_thresholds` variable
controls the degree of discretization with larger numbers of thresholds more
closely approximating the true AUC. The quality of the approximation may vary
dramatically depending on `num_thresholds`. <p></p> For best results, `predictions` should be distributed approximately uniformly
in the range [0, 1] and not peaked around 0 or 1. The quality of the AUC
approximation may be poor if this is not the case. Setting `summation_method`
to 'minoring' or 'majoring' can help quantify the error in the approximation
by providing lower or upper bound estimate of the AUC. The `thresholds`
parameter can be used to manually specify thresholds which split the
predictions more evenly. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `auc`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>A `Tensor` whose shape matches `predictions`. Will be cast to
`bool`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_thresholds
						</dt>
						<dd>The number of thresholds to use when discretizing the roc
curve. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `auc` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> curve
						</dt>
						<dd>Specifies the name of the curve to be computed, 'ROC' [default] or
'PR' for the Precision-Recall-curve. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> summation_method
						</dt>
						<dd>Specifies the Riemann summation method used
(https://en.wikipedia.org/wiki/Riemann_sum): 'trapezoidal' [default] that
applies the trapezoidal rule; 'careful_interpolation', a variant of it
differing only by a more correct interpolation scheme for PR-AUC -
interpolating (true/false) positives but not the ratio that is precision;
'minoring' that applies left summation for increasing intervals and right
summation for decreasing intervals; 'majoring' that does the opposite.
Note that 'careful_interpolation' is strictly preferred to 'trapezoidal'
(to be deprecated soon) as it applies the same method for ROC, and a
better one (see Davis & Goadrich 2006 for details) for the PR curve. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span></code> thresholds
						</dt>
						<dd>An optional list of floating point values to use as the
thresholds for discretizing the curve. If set, the `num_thresholds`
parameter is ignored. Values should be in [0, 1]. Endpoint thresholds
equal to {-epsilon, 1+epsilon} for a small positive epsilon value will be
automatically included with these to correctly handle predictions equal to
exactly 0 or 1. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="auc" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>auc</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <span title="System.Collections.Generic.IEnumerable<PythonClassContainer>">IEnumerable&lt;PythonClassContainer&gt;</span> predictions, <span title="System.Collections.Generic.IEnumerable<PythonClassContainer>">IEnumerable&lt;PythonClassContainer&gt;</span> weights, <span title="System.int">int</span> num_thresholds, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> curve, <span title="System.string">string</span> name, <span title="System.string">string</span> summation_method, <span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span> thresholds)
		</h4>
		<div class="content">Computes the approximate AUC via a Riemann sum. <p></p> The `auc` function creates four local variables, `true_positives`,
`true_negatives`, `false_positives` and `false_negatives` that are used to
compute the AUC. To discretize the AUC curve, a linearly spaced set of
thresholds is used to compute pairs of recall and precision values. The area
under the ROC-curve is therefore computed using the height of the recall
values by the false positive rate, while the area under the PR-curve is the
computed using the height of the precision values by the recall. <p></p> This value is ultimately returned as `auc`, an idempotent operation that
computes the area under a discretized curve of precision versus recall values
(computed using the aforementioned variables). The `num_thresholds` variable
controls the degree of discretization with larger numbers of thresholds more
closely approximating the true AUC. The quality of the approximation may vary
dramatically depending on `num_thresholds`. <p></p> For best results, `predictions` should be distributed approximately uniformly
in the range [0, 1] and not peaked around 0 or 1. The quality of the AUC
approximation may be poor if this is not the case. Setting `summation_method`
to 'minoring' or 'majoring' can help quantify the error in the approximation
by providing lower or upper bound estimate of the AUC. The `thresholds`
parameter can be used to manually specify thresholds which split the
predictions more evenly. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `auc`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>A `Tensor` whose shape matches `predictions`. Will be cast to
`bool`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<PythonClassContainer>">IEnumerable&lt;PythonClassContainer&gt;</span></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<PythonClassContainer>">IEnumerable&lt;PythonClassContainer&gt;</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_thresholds
						</dt>
						<dd>The number of thresholds to use when discretizing the roc
curve. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `auc` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> curve
						</dt>
						<dd>Specifies the name of the curve to be computed, 'ROC' [default] or
'PR' for the Precision-Recall-curve. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> summation_method
						</dt>
						<dd>Specifies the Riemann summation method used
(https://en.wikipedia.org/wiki/Riemann_sum): 'trapezoidal' [default] that
applies the trapezoidal rule; 'careful_interpolation', a variant of it
differing only by a more correct interpolation scheme for PR-AUC -
interpolating (true/false) positives but not the ratio that is precision;
'minoring' that applies left summation for increasing intervals and right
summation for decreasing intervals; 'majoring' that does the opposite.
Note that 'careful_interpolation' is strictly preferred to 'trapezoidal'
(to be deprecated soon) as it applies the same method for ROC, and a
better one (see Davis & Goadrich 2006 for details) for the PR curve. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span></code> thresholds
						</dt>
						<dd>An optional list of floating point values to use as the
thresholds for discretizing the curve. If set, the `num_thresholds`
parameter is ignored. Values should be in [0, 1]. Endpoint thresholds
equal to {-epsilon, 1+epsilon} for a small positive epsilon value will be
automatically included with these to correctly handle predictions equal to
exactly 0 or 1. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="auc" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>auc</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <span title="System.Collections.Generic.IEnumerable<PythonClassContainer>">IEnumerable&lt;PythonClassContainer&gt;</span> predictions, <a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> weights, <span title="System.int">int</span> num_thresholds, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> curve, <span title="System.string">string</span> name, <span title="System.string">string</span> summation_method, <span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span> thresholds)
		</h4>
		<div class="content">Computes the approximate AUC via a Riemann sum. <p></p> The `auc` function creates four local variables, `true_positives`,
`true_negatives`, `false_positives` and `false_negatives` that are used to
compute the AUC. To discretize the AUC curve, a linearly spaced set of
thresholds is used to compute pairs of recall and precision values. The area
under the ROC-curve is therefore computed using the height of the recall
values by the false positive rate, while the area under the PR-curve is the
computed using the height of the precision values by the recall. <p></p> This value is ultimately returned as `auc`, an idempotent operation that
computes the area under a discretized curve of precision versus recall values
(computed using the aforementioned variables). The `num_thresholds` variable
controls the degree of discretization with larger numbers of thresholds more
closely approximating the true AUC. The quality of the approximation may vary
dramatically depending on `num_thresholds`. <p></p> For best results, `predictions` should be distributed approximately uniformly
in the range [0, 1] and not peaked around 0 or 1. The quality of the AUC
approximation may be poor if this is not the case. Setting `summation_method`
to 'minoring' or 'majoring' can help quantify the error in the approximation
by providing lower or upper bound estimate of the AUC. The `thresholds`
parameter can be used to manually specify thresholds which split the
predictions more evenly. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `auc`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>A `Tensor` whose shape matches `predictions`. Will be cast to
`bool`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<PythonClassContainer>">IEnumerable&lt;PythonClassContainer&gt;</span></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_thresholds
						</dt>
						<dd>The number of thresholds to use when discretizing the roc
curve. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `auc` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> curve
						</dt>
						<dd>Specifies the name of the curve to be computed, 'ROC' [default] or
'PR' for the Precision-Recall-curve. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> summation_method
						</dt>
						<dd>Specifies the Riemann summation method used
(https://en.wikipedia.org/wiki/Riemann_sum): 'trapezoidal' [default] that
applies the trapezoidal rule; 'careful_interpolation', a variant of it
differing only by a more correct interpolation scheme for PR-AUC -
interpolating (true/false) positives but not the ratio that is precision;
'minoring' that applies left summation for increasing intervals and right
summation for decreasing intervals; 'majoring' that does the opposite.
Note that 'careful_interpolation' is strictly preferred to 'trapezoidal'
(to be deprecated soon) as it applies the same method for ROC, and a
better one (see Davis & Goadrich 2006 for details) for the PR curve. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span></code> thresholds
						</dt>
						<dd>An optional list of floating point values to use as the
thresholds for discretizing the curve. If set, the `num_thresholds`
parameter is ignored. Values should be in [0, 1]. Endpoint thresholds
equal to {-epsilon, 1+epsilon} for a small positive epsilon value will be
automatically included with these to correctly handle predictions equal to
exactly 0 or 1. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="auc" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>auc</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> predictions, <span title="System.string">string</span> weights, <span title="System.int">int</span> num_thresholds, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> curve, <span title="System.string">string</span> name, <span title="System.string">string</span> summation_method, <span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span> thresholds)
		</h4>
		<div class="content">Computes the approximate AUC via a Riemann sum. <p></p> The `auc` function creates four local variables, `true_positives`,
`true_negatives`, `false_positives` and `false_negatives` that are used to
compute the AUC. To discretize the AUC curve, a linearly spaced set of
thresholds is used to compute pairs of recall and precision values. The area
under the ROC-curve is therefore computed using the height of the recall
values by the false positive rate, while the area under the PR-curve is the
computed using the height of the precision values by the recall. <p></p> This value is ultimately returned as `auc`, an idempotent operation that
computes the area under a discretized curve of precision versus recall values
(computed using the aforementioned variables). The `num_thresholds` variable
controls the degree of discretization with larger numbers of thresholds more
closely approximating the true AUC. The quality of the approximation may vary
dramatically depending on `num_thresholds`. <p></p> For best results, `predictions` should be distributed approximately uniformly
in the range [0, 1] and not peaked around 0 or 1. The quality of the AUC
approximation may be poor if this is not the case. Setting `summation_method`
to 'minoring' or 'majoring' can help quantify the error in the approximation
by providing lower or upper bound estimate of the AUC. The `thresholds`
parameter can be used to manually specify thresholds which split the
predictions more evenly. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `auc`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>A `Tensor` whose shape matches `predictions`. Will be cast to
`bool`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_thresholds
						</dt>
						<dd>The number of thresholds to use when discretizing the roc
curve. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `auc` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> curve
						</dt>
						<dd>Specifies the name of the curve to be computed, 'ROC' [default] or
'PR' for the Precision-Recall-curve. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> summation_method
						</dt>
						<dd>Specifies the Riemann summation method used
(https://en.wikipedia.org/wiki/Riemann_sum): 'trapezoidal' [default] that
applies the trapezoidal rule; 'careful_interpolation', a variant of it
differing only by a more correct interpolation scheme for PR-AUC -
interpolating (true/false) positives but not the ratio that is precision;
'minoring' that applies left summation for increasing intervals and right
summation for decreasing intervals; 'majoring' that does the opposite.
Note that 'careful_interpolation' is strictly preferred to 'trapezoidal'
(to be deprecated soon) as it applies the same method for ROC, and a
better one (see Davis & Goadrich 2006 for details) for the PR curve. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span></code> thresholds
						</dt>
						<dd>An optional list of floating point values to use as the
thresholds for discretizing the curve. If set, the `num_thresholds`
parameter is ignored. Values should be in [0, 1]. Endpoint thresholds
equal to {-epsilon, 1+epsilon} for a small positive epsilon value will be
automatically included with these to correctly handle predictions equal to
exactly 0 or 1. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="auc" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>auc</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <span title="System.Collections.Generic.IEnumerable<PythonClassContainer>">IEnumerable&lt;PythonClassContainer&gt;</span> predictions, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.int">int</span> num_thresholds, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> curve, <span title="System.string">string</span> name, <span title="System.string">string</span> summation_method, <span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span> thresholds)
		</h4>
		<div class="content">Computes the approximate AUC via a Riemann sum. <p></p> The `auc` function creates four local variables, `true_positives`,
`true_negatives`, `false_positives` and `false_negatives` that are used to
compute the AUC. To discretize the AUC curve, a linearly spaced set of
thresholds is used to compute pairs of recall and precision values. The area
under the ROC-curve is therefore computed using the height of the recall
values by the false positive rate, while the area under the PR-curve is the
computed using the height of the precision values by the recall. <p></p> This value is ultimately returned as `auc`, an idempotent operation that
computes the area under a discretized curve of precision versus recall values
(computed using the aforementioned variables). The `num_thresholds` variable
controls the degree of discretization with larger numbers of thresholds more
closely approximating the true AUC. The quality of the approximation may vary
dramatically depending on `num_thresholds`. <p></p> For best results, `predictions` should be distributed approximately uniformly
in the range [0, 1] and not peaked around 0 or 1. The quality of the AUC
approximation may be poor if this is not the case. Setting `summation_method`
to 'minoring' or 'majoring' can help quantify the error in the approximation
by providing lower or upper bound estimate of the AUC. The `thresholds`
parameter can be used to manually specify thresholds which split the
predictions more evenly. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `auc`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>A `Tensor` whose shape matches `predictions`. Will be cast to
`bool`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<PythonClassContainer>">IEnumerable&lt;PythonClassContainer&gt;</span></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_thresholds
						</dt>
						<dd>The number of thresholds to use when discretizing the roc
curve. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `auc` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> curve
						</dt>
						<dd>Specifies the name of the curve to be computed, 'ROC' [default] or
'PR' for the Precision-Recall-curve. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> summation_method
						</dt>
						<dd>Specifies the Riemann summation method used
(https://en.wikipedia.org/wiki/Riemann_sum): 'trapezoidal' [default] that
applies the trapezoidal rule; 'careful_interpolation', a variant of it
differing only by a more correct interpolation scheme for PR-AUC -
interpolating (true/false) positives but not the ratio that is precision;
'minoring' that applies left summation for increasing intervals and right
summation for decreasing intervals; 'majoring' that does the opposite.
Note that 'careful_interpolation' is strictly preferred to 'trapezoidal'
(to be deprecated soon) as it applies the same method for ROC, and a
better one (see Davis & Goadrich 2006 for details) for the PR curve. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span></code> thresholds
						</dt>
						<dd>An optional list of floating point values to use as the
thresholds for discretizing the curve. If set, the `num_thresholds`
parameter is ignored. Values should be in [0, 1]. Endpoint thresholds
equal to {-epsilon, 1+epsilon} for a small positive epsilon value will be
automatically included with these to correctly handle predictions equal to
exactly 0 or 1. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="auc" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>auc</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <span title="System.Collections.Generic.IEnumerable<PythonClassContainer>">IEnumerable&lt;PythonClassContainer&gt;</span> predictions, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> weights, <span title="System.int">int</span> num_thresholds, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> curve, <span title="System.string">string</span> name, <span title="System.string">string</span> summation_method, <span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span> thresholds)
		</h4>
		<div class="content">Computes the approximate AUC via a Riemann sum. <p></p> The `auc` function creates four local variables, `true_positives`,
`true_negatives`, `false_positives` and `false_negatives` that are used to
compute the AUC. To discretize the AUC curve, a linearly spaced set of
thresholds is used to compute pairs of recall and precision values. The area
under the ROC-curve is therefore computed using the height of the recall
values by the false positive rate, while the area under the PR-curve is the
computed using the height of the precision values by the recall. <p></p> This value is ultimately returned as `auc`, an idempotent operation that
computes the area under a discretized curve of precision versus recall values
(computed using the aforementioned variables). The `num_thresholds` variable
controls the degree of discretization with larger numbers of thresholds more
closely approximating the true AUC. The quality of the approximation may vary
dramatically depending on `num_thresholds`. <p></p> For best results, `predictions` should be distributed approximately uniformly
in the range [0, 1] and not peaked around 0 or 1. The quality of the AUC
approximation may be poor if this is not the case. Setting `summation_method`
to 'minoring' or 'majoring' can help quantify the error in the approximation
by providing lower or upper bound estimate of the AUC. The `thresholds`
parameter can be used to manually specify thresholds which split the
predictions more evenly. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `auc`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>A `Tensor` whose shape matches `predictions`. Will be cast to
`bool`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<PythonClassContainer>">IEnumerable&lt;PythonClassContainer&gt;</span></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_thresholds
						</dt>
						<dd>The number of thresholds to use when discretizing the roc
curve. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `auc` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> curve
						</dt>
						<dd>Specifies the name of the curve to be computed, 'ROC' [default] or
'PR' for the Precision-Recall-curve. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> summation_method
						</dt>
						<dd>Specifies the Riemann summation method used
(https://en.wikipedia.org/wiki/Riemann_sum): 'trapezoidal' [default] that
applies the trapezoidal rule; 'careful_interpolation', a variant of it
differing only by a more correct interpolation scheme for PR-AUC -
interpolating (true/false) positives but not the ratio that is precision;
'minoring' that applies left summation for increasing intervals and right
summation for decreasing intervals; 'majoring' that does the opposite.
Note that 'careful_interpolation' is strictly preferred to 'trapezoidal'
(to be deprecated soon) as it applies the same method for ROC, and a
better one (see Davis & Goadrich 2006 for details) for the PR curve. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span></code> thresholds
						</dt>
						<dd>An optional list of floating point values to use as the
thresholds for discretizing the curve. If set, the `num_thresholds`
parameter is ignored. Values should be in [0, 1]. Endpoint thresholds
equal to {-epsilon, 1+epsilon} for a small positive epsilon value will be
automatically included with these to correctly handle predictions equal to
exactly 0 or 1. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="auc" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>auc</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> predictions, <span title="System.Collections.Generic.IEnumerable<PythonClassContainer>">IEnumerable&lt;PythonClassContainer&gt;</span> weights, <span title="System.int">int</span> num_thresholds, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> curve, <span title="System.string">string</span> name, <span title="System.string">string</span> summation_method, <span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span> thresholds)
		</h4>
		<div class="content">Computes the approximate AUC via a Riemann sum. <p></p> The `auc` function creates four local variables, `true_positives`,
`true_negatives`, `false_positives` and `false_negatives` that are used to
compute the AUC. To discretize the AUC curve, a linearly spaced set of
thresholds is used to compute pairs of recall and precision values. The area
under the ROC-curve is therefore computed using the height of the recall
values by the false positive rate, while the area under the PR-curve is the
computed using the height of the precision values by the recall. <p></p> This value is ultimately returned as `auc`, an idempotent operation that
computes the area under a discretized curve of precision versus recall values
(computed using the aforementioned variables). The `num_thresholds` variable
controls the degree of discretization with larger numbers of thresholds more
closely approximating the true AUC. The quality of the approximation may vary
dramatically depending on `num_thresholds`. <p></p> For best results, `predictions` should be distributed approximately uniformly
in the range [0, 1] and not peaked around 0 or 1. The quality of the AUC
approximation may be poor if this is not the case. Setting `summation_method`
to 'minoring' or 'majoring' can help quantify the error in the approximation
by providing lower or upper bound estimate of the AUC. The `thresholds`
parameter can be used to manually specify thresholds which split the
predictions more evenly. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `auc`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>A `Tensor` whose shape matches `predictions`. Will be cast to
`bool`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<PythonClassContainer>">IEnumerable&lt;PythonClassContainer&gt;</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_thresholds
						</dt>
						<dd>The number of thresholds to use when discretizing the roc
curve. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `auc` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> curve
						</dt>
						<dd>Specifies the name of the curve to be computed, 'ROC' [default] or
'PR' for the Precision-Recall-curve. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> summation_method
						</dt>
						<dd>Specifies the Riemann summation method used
(https://en.wikipedia.org/wiki/Riemann_sum): 'trapezoidal' [default] that
applies the trapezoidal rule; 'careful_interpolation', a variant of it
differing only by a more correct interpolation scheme for PR-AUC -
interpolating (true/false) positives but not the ratio that is precision;
'minoring' that applies left summation for increasing intervals and right
summation for decreasing intervals; 'majoring' that does the opposite.
Note that 'careful_interpolation' is strictly preferred to 'trapezoidal'
(to be deprecated soon) as it applies the same method for ROC, and a
better one (see Davis & Goadrich 2006 for details) for the PR curve. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span></code> thresholds
						</dt>
						<dd>An optional list of floating point values to use as the
thresholds for discretizing the curve. If set, the `num_thresholds`
parameter is ignored. Values should be in [0, 1]. Endpoint thresholds
equal to {-epsilon, 1+epsilon} for a small positive epsilon value will be
automatically included with these to correctly handle predictions equal to
exactly 0 or 1. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="auc" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>auc</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <span title="System.Collections.Generic.IEnumerable<PythonClassContainer>">IEnumerable&lt;PythonClassContainer&gt;</span> predictions, <span title="System.string">string</span> weights, <span title="System.int">int</span> num_thresholds, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> curve, <span title="System.string">string</span> name, <span title="System.string">string</span> summation_method, <span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span> thresholds)
		</h4>
		<div class="content">Computes the approximate AUC via a Riemann sum. <p></p> The `auc` function creates four local variables, `true_positives`,
`true_negatives`, `false_positives` and `false_negatives` that are used to
compute the AUC. To discretize the AUC curve, a linearly spaced set of
thresholds is used to compute pairs of recall and precision values. The area
under the ROC-curve is therefore computed using the height of the recall
values by the false positive rate, while the area under the PR-curve is the
computed using the height of the precision values by the recall. <p></p> This value is ultimately returned as `auc`, an idempotent operation that
computes the area under a discretized curve of precision versus recall values
(computed using the aforementioned variables). The `num_thresholds` variable
controls the degree of discretization with larger numbers of thresholds more
closely approximating the true AUC. The quality of the approximation may vary
dramatically depending on `num_thresholds`. <p></p> For best results, `predictions` should be distributed approximately uniformly
in the range [0, 1] and not peaked around 0 or 1. The quality of the AUC
approximation may be poor if this is not the case. Setting `summation_method`
to 'minoring' or 'majoring' can help quantify the error in the approximation
by providing lower or upper bound estimate of the AUC. The `thresholds`
parameter can be used to manually specify thresholds which split the
predictions more evenly. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `auc`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>A `Tensor` whose shape matches `predictions`. Will be cast to
`bool`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<PythonClassContainer>">IEnumerable&lt;PythonClassContainer&gt;</span></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_thresholds
						</dt>
						<dd>The number of thresholds to use when discretizing the roc
curve. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `auc` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> curve
						</dt>
						<dd>Specifies the name of the curve to be computed, 'ROC' [default] or
'PR' for the Precision-Recall-curve. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> summation_method
						</dt>
						<dd>Specifies the Riemann summation method used
(https://en.wikipedia.org/wiki/Riemann_sum): 'trapezoidal' [default] that
applies the trapezoidal rule; 'careful_interpolation', a variant of it
differing only by a more correct interpolation scheme for PR-AUC -
interpolating (true/false) positives but not the ratio that is precision;
'minoring' that applies left summation for increasing intervals and right
summation for decreasing intervals; 'majoring' that does the opposite.
Note that 'careful_interpolation' is strictly preferred to 'trapezoidal'
(to be deprecated soon) as it applies the same method for ROC, and a
better one (see Davis & Goadrich 2006 for details) for the PR curve. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span></code> thresholds
						</dt>
						<dd>An optional list of floating point values to use as the
thresholds for discretizing the curve. If set, the `num_thresholds`
parameter is ignored. Values should be in [0, 1]. Endpoint thresholds
equal to {-epsilon, 1+epsilon} for a small positive epsilon value will be
automatically included with these to correctly handle predictions equal to
exactly 0 or 1. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="auc" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>auc</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> predictions, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.int">int</span> num_thresholds, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> curve, <span title="System.string">string</span> name, <span title="System.string">string</span> summation_method, <span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span> thresholds)
		</h4>
		<div class="content">Computes the approximate AUC via a Riemann sum. <p></p> The `auc` function creates four local variables, `true_positives`,
`true_negatives`, `false_positives` and `false_negatives` that are used to
compute the AUC. To discretize the AUC curve, a linearly spaced set of
thresholds is used to compute pairs of recall and precision values. The area
under the ROC-curve is therefore computed using the height of the recall
values by the false positive rate, while the area under the PR-curve is the
computed using the height of the precision values by the recall. <p></p> This value is ultimately returned as `auc`, an idempotent operation that
computes the area under a discretized curve of precision versus recall values
(computed using the aforementioned variables). The `num_thresholds` variable
controls the degree of discretization with larger numbers of thresholds more
closely approximating the true AUC. The quality of the approximation may vary
dramatically depending on `num_thresholds`. <p></p> For best results, `predictions` should be distributed approximately uniformly
in the range [0, 1] and not peaked around 0 or 1. The quality of the AUC
approximation may be poor if this is not the case. Setting `summation_method`
to 'minoring' or 'majoring' can help quantify the error in the approximation
by providing lower or upper bound estimate of the AUC. The `thresholds`
parameter can be used to manually specify thresholds which split the
predictions more evenly. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `auc`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>A `Tensor` whose shape matches `predictions`. Will be cast to
`bool`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_thresholds
						</dt>
						<dd>The number of thresholds to use when discretizing the roc
curve. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `auc` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> curve
						</dt>
						<dd>Specifies the name of the curve to be computed, 'ROC' [default] or
'PR' for the Precision-Recall-curve. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> summation_method
						</dt>
						<dd>Specifies the Riemann summation method used
(https://en.wikipedia.org/wiki/Riemann_sum): 'trapezoidal' [default] that
applies the trapezoidal rule; 'careful_interpolation', a variant of it
differing only by a more correct interpolation scheme for PR-AUC -
interpolating (true/false) positives but not the ratio that is precision;
'minoring' that applies left summation for increasing intervals and right
summation for decreasing intervals; 'majoring' that does the opposite.
Note that 'careful_interpolation' is strictly preferred to 'trapezoidal'
(to be deprecated soon) as it applies the same method for ROC, and a
better one (see Davis & Goadrich 2006 for details) for the PR curve. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span></code> thresholds
						</dt>
						<dd>An optional list of floating point values to use as the
thresholds for discretizing the curve. If set, the `num_thresholds`
parameter is ignored. Values should be in [0, 1]. Endpoint thresholds
equal to {-epsilon, 1+epsilon} for a small positive epsilon value will be
automatically included with these to correctly handle predictions equal to
exactly 0 or 1. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="auc" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>auc</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <span title="System.Collections.Generic.IEnumerable<PythonClassContainer>">IEnumerable&lt;PythonClassContainer&gt;</span> predictions, <span title="System.object">object</span> weights, <span title="System.int">int</span> num_thresholds, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> curve, <span title="System.string">string</span> name, <span title="System.string">string</span> summation_method, <span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span> thresholds)
		</h4>
		<div class="content">Computes the approximate AUC via a Riemann sum. <p></p> The `auc` function creates four local variables, `true_positives`,
`true_negatives`, `false_positives` and `false_negatives` that are used to
compute the AUC. To discretize the AUC curve, a linearly spaced set of
thresholds is used to compute pairs of recall and precision values. The area
under the ROC-curve is therefore computed using the height of the recall
values by the false positive rate, while the area under the PR-curve is the
computed using the height of the precision values by the recall. <p></p> This value is ultimately returned as `auc`, an idempotent operation that
computes the area under a discretized curve of precision versus recall values
(computed using the aforementioned variables). The `num_thresholds` variable
controls the degree of discretization with larger numbers of thresholds more
closely approximating the true AUC. The quality of the approximation may vary
dramatically depending on `num_thresholds`. <p></p> For best results, `predictions` should be distributed approximately uniformly
in the range [0, 1] and not peaked around 0 or 1. The quality of the AUC
approximation may be poor if this is not the case. Setting `summation_method`
to 'minoring' or 'majoring' can help quantify the error in the approximation
by providing lower or upper bound estimate of the AUC. The `thresholds`
parameter can be used to manually specify thresholds which split the
predictions more evenly. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `auc`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>A `Tensor` whose shape matches `predictions`. Will be cast to
`bool`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<PythonClassContainer>">IEnumerable&lt;PythonClassContainer&gt;</span></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_thresholds
						</dt>
						<dd>The number of thresholds to use when discretizing the roc
curve. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `auc` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> curve
						</dt>
						<dd>Specifies the name of the curve to be computed, 'ROC' [default] or
'PR' for the Precision-Recall-curve. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> summation_method
						</dt>
						<dd>Specifies the Riemann summation method used
(https://en.wikipedia.org/wiki/Riemann_sum): 'trapezoidal' [default] that
applies the trapezoidal rule; 'careful_interpolation', a variant of it
differing only by a more correct interpolation scheme for PR-AUC -
interpolating (true/false) positives but not the ratio that is precision;
'minoring' that applies left summation for increasing intervals and right
summation for decreasing intervals; 'majoring' that does the opposite.
Note that 'careful_interpolation' is strictly preferred to 'trapezoidal'
(to be deprecated soon) as it applies the same method for ROC, and a
better one (see Davis & Goadrich 2006 for details) for the PR curve. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span></code> thresholds
						</dt>
						<dd>An optional list of floating point values to use as the
thresholds for discretizing the curve. If set, the `num_thresholds`
parameter is ignored. Values should be in [0, 1]. Endpoint thresholds
equal to {-epsilon, 1+epsilon} for a small positive epsilon value will be
automatically included with these to correctly handle predictions equal to
exactly 0 or 1. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="auc" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>auc</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> weights, <span title="System.int">int</span> num_thresholds, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> curve, <span title="System.string">string</span> name, <span title="System.string">string</span> summation_method, <span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span> thresholds)
		</h4>
		<div class="content">Computes the approximate AUC via a Riemann sum. <p></p> The `auc` function creates four local variables, `true_positives`,
`true_negatives`, `false_positives` and `false_negatives` that are used to
compute the AUC. To discretize the AUC curve, a linearly spaced set of
thresholds is used to compute pairs of recall and precision values. The area
under the ROC-curve is therefore computed using the height of the recall
values by the false positive rate, while the area under the PR-curve is the
computed using the height of the precision values by the recall. <p></p> This value is ultimately returned as `auc`, an idempotent operation that
computes the area under a discretized curve of precision versus recall values
(computed using the aforementioned variables). The `num_thresholds` variable
controls the degree of discretization with larger numbers of thresholds more
closely approximating the true AUC. The quality of the approximation may vary
dramatically depending on `num_thresholds`. <p></p> For best results, `predictions` should be distributed approximately uniformly
in the range [0, 1] and not peaked around 0 or 1. The quality of the AUC
approximation may be poor if this is not the case. Setting `summation_method`
to 'minoring' or 'majoring' can help quantify the error in the approximation
by providing lower or upper bound estimate of the AUC. The `thresholds`
parameter can be used to manually specify thresholds which split the
predictions more evenly. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `auc`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>A `Tensor` whose shape matches `predictions`. Will be cast to
`bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_thresholds
						</dt>
						<dd>The number of thresholds to use when discretizing the roc
curve. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `auc` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> curve
						</dt>
						<dd>Specifies the name of the curve to be computed, 'ROC' [default] or
'PR' for the Precision-Recall-curve. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> summation_method
						</dt>
						<dd>Specifies the Riemann summation method used
(https://en.wikipedia.org/wiki/Riemann_sum): 'trapezoidal' [default] that
applies the trapezoidal rule; 'careful_interpolation', a variant of it
differing only by a more correct interpolation scheme for PR-AUC -
interpolating (true/false) positives but not the ratio that is precision;
'minoring' that applies left summation for increasing intervals and right
summation for decreasing intervals; 'majoring' that does the opposite.
Note that 'careful_interpolation' is strictly preferred to 'trapezoidal'
(to be deprecated soon) as it applies the same method for ROC, and a
better one (see Davis & Goadrich 2006 for details) for the PR curve. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span></code> thresholds
						</dt>
						<dd>An optional list of floating point values to use as the
thresholds for discretizing the curve. If set, the `num_thresholds`
parameter is ignored. Values should be in [0, 1]. Endpoint thresholds
equal to {-epsilon, 1+epsilon} for a small positive epsilon value will be
automatically included with these to correctly handle predictions equal to
exactly 0 or 1. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="auc" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>auc</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> predictions, <span title="System.object">object</span> weights, <span title="System.int">int</span> num_thresholds, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> curve, <span title="System.string">string</span> name, <span title="System.string">string</span> summation_method, <span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span> thresholds)
		</h4>
		<div class="content">Computes the approximate AUC via a Riemann sum. <p></p> The `auc` function creates four local variables, `true_positives`,
`true_negatives`, `false_positives` and `false_negatives` that are used to
compute the AUC. To discretize the AUC curve, a linearly spaced set of
thresholds is used to compute pairs of recall and precision values. The area
under the ROC-curve is therefore computed using the height of the recall
values by the false positive rate, while the area under the PR-curve is the
computed using the height of the precision values by the recall. <p></p> This value is ultimately returned as `auc`, an idempotent operation that
computes the area under a discretized curve of precision versus recall values
(computed using the aforementioned variables). The `num_thresholds` variable
controls the degree of discretization with larger numbers of thresholds more
closely approximating the true AUC. The quality of the approximation may vary
dramatically depending on `num_thresholds`. <p></p> For best results, `predictions` should be distributed approximately uniformly
in the range [0, 1] and not peaked around 0 or 1. The quality of the AUC
approximation may be poor if this is not the case. Setting `summation_method`
to 'minoring' or 'majoring' can help quantify the error in the approximation
by providing lower or upper bound estimate of the AUC. The `thresholds`
parameter can be used to manually specify thresholds which split the
predictions more evenly. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `auc`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>A `Tensor` whose shape matches `predictions`. Will be cast to
`bool`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_thresholds
						</dt>
						<dd>The number of thresholds to use when discretizing the roc
curve. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `auc` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> curve
						</dt>
						<dd>Specifies the name of the curve to be computed, 'ROC' [default] or
'PR' for the Precision-Recall-curve. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> summation_method
						</dt>
						<dd>Specifies the Riemann summation method used
(https://en.wikipedia.org/wiki/Riemann_sum): 'trapezoidal' [default] that
applies the trapezoidal rule; 'careful_interpolation', a variant of it
differing only by a more correct interpolation scheme for PR-AUC -
interpolating (true/false) positives but not the ratio that is precision;
'minoring' that applies left summation for increasing intervals and right
summation for decreasing intervals; 'majoring' that does the opposite.
Note that 'careful_interpolation' is strictly preferred to 'trapezoidal'
(to be deprecated soon) as it applies the same method for ROC, and a
better one (see Davis & Goadrich 2006 for details) for the PR curve. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span></code> thresholds
						</dt>
						<dd>An optional list of floating point values to use as the
thresholds for discretizing the curve. If set, the `num_thresholds`
parameter is ignored. Values should be in [0, 1]. Endpoint thresholds
equal to {-epsilon, 1+epsilon} for a small positive epsilon value will be
automatically included with these to correctly handle predictions equal to
exactly 0 or 1. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="auc" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>auc</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> predictions, <span title="System.string">string</span> weights, <span title="System.int">int</span> num_thresholds, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> curve, <span title="System.string">string</span> name, <span title="System.string">string</span> summation_method, <span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span> thresholds)
		</h4>
		<div class="content">Computes the approximate AUC via a Riemann sum. <p></p> The `auc` function creates four local variables, `true_positives`,
`true_negatives`, `false_positives` and `false_negatives` that are used to
compute the AUC. To discretize the AUC curve, a linearly spaced set of
thresholds is used to compute pairs of recall and precision values. The area
under the ROC-curve is therefore computed using the height of the recall
values by the false positive rate, while the area under the PR-curve is the
computed using the height of the precision values by the recall. <p></p> This value is ultimately returned as `auc`, an idempotent operation that
computes the area under a discretized curve of precision versus recall values
(computed using the aforementioned variables). The `num_thresholds` variable
controls the degree of discretization with larger numbers of thresholds more
closely approximating the true AUC. The quality of the approximation may vary
dramatically depending on `num_thresholds`. <p></p> For best results, `predictions` should be distributed approximately uniformly
in the range [0, 1] and not peaked around 0 or 1. The quality of the AUC
approximation may be poor if this is not the case. Setting `summation_method`
to 'minoring' or 'majoring' can help quantify the error in the approximation
by providing lower or upper bound estimate of the AUC. The `thresholds`
parameter can be used to manually specify thresholds which split the
predictions more evenly. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `auc`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>A `Tensor` whose shape matches `predictions`. Will be cast to
`bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_thresholds
						</dt>
						<dd>The number of thresholds to use when discretizing the roc
curve. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `auc` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> curve
						</dt>
						<dd>Specifies the name of the curve to be computed, 'ROC' [default] or
'PR' for the Precision-Recall-curve. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> summation_method
						</dt>
						<dd>Specifies the Riemann summation method used
(https://en.wikipedia.org/wiki/Riemann_sum): 'trapezoidal' [default] that
applies the trapezoidal rule; 'careful_interpolation', a variant of it
differing only by a more correct interpolation scheme for PR-AUC -
interpolating (true/false) positives but not the ratio that is precision;
'minoring' that applies left summation for increasing intervals and right
summation for decreasing intervals; 'majoring' that does the opposite.
Note that 'careful_interpolation' is strictly preferred to 'trapezoidal'
(to be deprecated soon) as it applies the same method for ROC, and a
better one (see Davis & Goadrich 2006 for details) for the PR curve. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span></code> thresholds
						</dt>
						<dd>An optional list of floating point values to use as the
thresholds for discretizing the curve. If set, the `num_thresholds`
parameter is ignored. Values should be in [0, 1]. Endpoint thresholds
equal to {-epsilon, 1+epsilon} for a small positive epsilon value will be
automatically included with these to correctly handle predictions equal to
exactly 0 or 1. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="auc" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>auc</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.Collections.Generic.IEnumerable<PythonClassContainer>">IEnumerable&lt;PythonClassContainer&gt;</span> weights, <span title="System.int">int</span> num_thresholds, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> curve, <span title="System.string">string</span> name, <span title="System.string">string</span> summation_method, <span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span> thresholds)
		</h4>
		<div class="content">Computes the approximate AUC via a Riemann sum. <p></p> The `auc` function creates four local variables, `true_positives`,
`true_negatives`, `false_positives` and `false_negatives` that are used to
compute the AUC. To discretize the AUC curve, a linearly spaced set of
thresholds is used to compute pairs of recall and precision values. The area
under the ROC-curve is therefore computed using the height of the recall
values by the false positive rate, while the area under the PR-curve is the
computed using the height of the precision values by the recall. <p></p> This value is ultimately returned as `auc`, an idempotent operation that
computes the area under a discretized curve of precision versus recall values
(computed using the aforementioned variables). The `num_thresholds` variable
controls the degree of discretization with larger numbers of thresholds more
closely approximating the true AUC. The quality of the approximation may vary
dramatically depending on `num_thresholds`. <p></p> For best results, `predictions` should be distributed approximately uniformly
in the range [0, 1] and not peaked around 0 or 1. The quality of the AUC
approximation may be poor if this is not the case. Setting `summation_method`
to 'minoring' or 'majoring' can help quantify the error in the approximation
by providing lower or upper bound estimate of the AUC. The `thresholds`
parameter can be used to manually specify thresholds which split the
predictions more evenly. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `auc`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>A `Tensor` whose shape matches `predictions`. Will be cast to
`bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<PythonClassContainer>">IEnumerable&lt;PythonClassContainer&gt;</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_thresholds
						</dt>
						<dd>The number of thresholds to use when discretizing the roc
curve. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `auc` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> curve
						</dt>
						<dd>Specifies the name of the curve to be computed, 'ROC' [default] or
'PR' for the Precision-Recall-curve. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> summation_method
						</dt>
						<dd>Specifies the Riemann summation method used
(https://en.wikipedia.org/wiki/Riemann_sum): 'trapezoidal' [default] that
applies the trapezoidal rule; 'careful_interpolation', a variant of it
differing only by a more correct interpolation scheme for PR-AUC -
interpolating (true/false) positives but not the ratio that is precision;
'minoring' that applies left summation for increasing intervals and right
summation for decreasing intervals; 'majoring' that does the opposite.
Note that 'careful_interpolation' is strictly preferred to 'trapezoidal'
(to be deprecated soon) as it applies the same method for ROC, and a
better one (see Davis & Goadrich 2006 for details) for the PR curve. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span></code> thresholds
						</dt>
						<dd>An optional list of floating point values to use as the
thresholds for discretizing the curve. If set, the `num_thresholds`
parameter is ignored. Values should be in [0, 1]. Endpoint thresholds
equal to {-epsilon, 1+epsilon} for a small positive epsilon value will be
automatically included with these to correctly handle predictions equal to
exactly 0 or 1. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="auc" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>auc</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> predictions, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> weights, <span title="System.int">int</span> num_thresholds, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> curve, <span title="System.string">string</span> name, <span title="System.string">string</span> summation_method, <span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span> thresholds)
		</h4>
		<div class="content">Computes the approximate AUC via a Riemann sum. <p></p> The `auc` function creates four local variables, `true_positives`,
`true_negatives`, `false_positives` and `false_negatives` that are used to
compute the AUC. To discretize the AUC curve, a linearly spaced set of
thresholds is used to compute pairs of recall and precision values. The area
under the ROC-curve is therefore computed using the height of the recall
values by the false positive rate, while the area under the PR-curve is the
computed using the height of the precision values by the recall. <p></p> This value is ultimately returned as `auc`, an idempotent operation that
computes the area under a discretized curve of precision versus recall values
(computed using the aforementioned variables). The `num_thresholds` variable
controls the degree of discretization with larger numbers of thresholds more
closely approximating the true AUC. The quality of the approximation may vary
dramatically depending on `num_thresholds`. <p></p> For best results, `predictions` should be distributed approximately uniformly
in the range [0, 1] and not peaked around 0 or 1. The quality of the AUC
approximation may be poor if this is not the case. Setting `summation_method`
to 'minoring' or 'majoring' can help quantify the error in the approximation
by providing lower or upper bound estimate of the AUC. The `thresholds`
parameter can be used to manually specify thresholds which split the
predictions more evenly. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `auc`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>A `Tensor` whose shape matches `predictions`. Will be cast to
`bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_thresholds
						</dt>
						<dd>The number of thresholds to use when discretizing the roc
curve. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `auc` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> curve
						</dt>
						<dd>Specifies the name of the curve to be computed, 'ROC' [default] or
'PR' for the Precision-Recall-curve. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> summation_method
						</dt>
						<dd>Specifies the Riemann summation method used
(https://en.wikipedia.org/wiki/Riemann_sum): 'trapezoidal' [default] that
applies the trapezoidal rule; 'careful_interpolation', a variant of it
differing only by a more correct interpolation scheme for PR-AUC -
interpolating (true/false) positives but not the ratio that is precision;
'minoring' that applies left summation for increasing intervals and right
summation for decreasing intervals; 'majoring' that does the opposite.
Note that 'careful_interpolation' is strictly preferred to 'trapezoidal'
(to be deprecated soon) as it applies the same method for ROC, and a
better one (see Davis & Goadrich 2006 for details) for the PR curve. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span></code> thresholds
						</dt>
						<dd>An optional list of floating point values to use as the
thresholds for discretizing the curve. If set, the `num_thresholds`
parameter is ignored. Values should be in [0, 1]. Endpoint thresholds
equal to {-epsilon, 1+epsilon} for a small positive epsilon value will be
automatically included with these to correctly handle predictions equal to
exactly 0 or 1. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="auc" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>auc</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> predictions, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.int">int</span> num_thresholds, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> curve, <span title="System.string">string</span> name, <span title="System.string">string</span> summation_method, <span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span> thresholds)
		</h4>
		<div class="content">Computes the approximate AUC via a Riemann sum. <p></p> The `auc` function creates four local variables, `true_positives`,
`true_negatives`, `false_positives` and `false_negatives` that are used to
compute the AUC. To discretize the AUC curve, a linearly spaced set of
thresholds is used to compute pairs of recall and precision values. The area
under the ROC-curve is therefore computed using the height of the recall
values by the false positive rate, while the area under the PR-curve is the
computed using the height of the precision values by the recall. <p></p> This value is ultimately returned as `auc`, an idempotent operation that
computes the area under a discretized curve of precision versus recall values
(computed using the aforementioned variables). The `num_thresholds` variable
controls the degree of discretization with larger numbers of thresholds more
closely approximating the true AUC. The quality of the approximation may vary
dramatically depending on `num_thresholds`. <p></p> For best results, `predictions` should be distributed approximately uniformly
in the range [0, 1] and not peaked around 0 or 1. The quality of the AUC
approximation may be poor if this is not the case. Setting `summation_method`
to 'minoring' or 'majoring' can help quantify the error in the approximation
by providing lower or upper bound estimate of the AUC. The `thresholds`
parameter can be used to manually specify thresholds which split the
predictions more evenly. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `auc`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>A `Tensor` whose shape matches `predictions`. Will be cast to
`bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_thresholds
						</dt>
						<dd>The number of thresholds to use when discretizing the roc
curve. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `auc` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> curve
						</dt>
						<dd>Specifies the name of the curve to be computed, 'ROC' [default] or
'PR' for the Precision-Recall-curve. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> summation_method
						</dt>
						<dd>Specifies the Riemann summation method used
(https://en.wikipedia.org/wiki/Riemann_sum): 'trapezoidal' [default] that
applies the trapezoidal rule; 'careful_interpolation', a variant of it
differing only by a more correct interpolation scheme for PR-AUC -
interpolating (true/false) positives but not the ratio that is precision;
'minoring' that applies left summation for increasing intervals and right
summation for decreasing intervals; 'majoring' that does the opposite.
Note that 'careful_interpolation' is strictly preferred to 'trapezoidal'
(to be deprecated soon) as it applies the same method for ROC, and a
better one (see Davis & Goadrich 2006 for details) for the PR curve. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span></code> thresholds
						</dt>
						<dd>An optional list of floating point values to use as the
thresholds for discretizing the curve. If set, the `num_thresholds`
parameter is ignored. Values should be in [0, 1]. Endpoint thresholds
equal to {-epsilon, 1+epsilon} for a small positive epsilon value will be
automatically included with these to correctly handle predictions equal to
exactly 0 or 1. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="auc" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>auc</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> predictions, <a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> weights, <span title="System.int">int</span> num_thresholds, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> curve, <span title="System.string">string</span> name, <span title="System.string">string</span> summation_method, <span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span> thresholds)
		</h4>
		<div class="content">Computes the approximate AUC via a Riemann sum. <p></p> The `auc` function creates four local variables, `true_positives`,
`true_negatives`, `false_positives` and `false_negatives` that are used to
compute the AUC. To discretize the AUC curve, a linearly spaced set of
thresholds is used to compute pairs of recall and precision values. The area
under the ROC-curve is therefore computed using the height of the recall
values by the false positive rate, while the area under the PR-curve is the
computed using the height of the precision values by the recall. <p></p> This value is ultimately returned as `auc`, an idempotent operation that
computes the area under a discretized curve of precision versus recall values
(computed using the aforementioned variables). The `num_thresholds` variable
controls the degree of discretization with larger numbers of thresholds more
closely approximating the true AUC. The quality of the approximation may vary
dramatically depending on `num_thresholds`. <p></p> For best results, `predictions` should be distributed approximately uniformly
in the range [0, 1] and not peaked around 0 or 1. The quality of the AUC
approximation may be poor if this is not the case. Setting `summation_method`
to 'minoring' or 'majoring' can help quantify the error in the approximation
by providing lower or upper bound estimate of the AUC. The `thresholds`
parameter can be used to manually specify thresholds which split the
predictions more evenly. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `auc`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>A `Tensor` whose shape matches `predictions`. Will be cast to
`bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_thresholds
						</dt>
						<dd>The number of thresholds to use when discretizing the roc
curve. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `auc` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> curve
						</dt>
						<dd>Specifies the name of the curve to be computed, 'ROC' [default] or
'PR' for the Precision-Recall-curve. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> summation_method
						</dt>
						<dd>Specifies the Riemann summation method used
(https://en.wikipedia.org/wiki/Riemann_sum): 'trapezoidal' [default] that
applies the trapezoidal rule; 'careful_interpolation', a variant of it
differing only by a more correct interpolation scheme for PR-AUC -
interpolating (true/false) positives but not the ratio that is precision;
'minoring' that applies left summation for increasing intervals and right
summation for decreasing intervals; 'majoring' that does the opposite.
Note that 'careful_interpolation' is strictly preferred to 'trapezoidal'
(to be deprecated soon) as it applies the same method for ROC, and a
better one (see Davis & Goadrich 2006 for details) for the PR curve. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span></code> thresholds
						</dt>
						<dd>An optional list of floating point values to use as the
thresholds for discretizing the curve. If set, the `num_thresholds`
parameter is ignored. Values should be in [0, 1]. Endpoint thresholds
equal to {-epsilon, 1+epsilon} for a small positive epsilon value will be
automatically included with these to correctly handle predictions equal to
exactly 0 or 1. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="auc" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>auc</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> predictions, <span title="System.object">object</span> weights, <span title="System.int">int</span> num_thresholds, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> curve, <span title="System.string">string</span> name, <span title="System.string">string</span> summation_method, <span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span> thresholds)
		</h4>
		<div class="content">Computes the approximate AUC via a Riemann sum. <p></p> The `auc` function creates four local variables, `true_positives`,
`true_negatives`, `false_positives` and `false_negatives` that are used to
compute the AUC. To discretize the AUC curve, a linearly spaced set of
thresholds is used to compute pairs of recall and precision values. The area
under the ROC-curve is therefore computed using the height of the recall
values by the false positive rate, while the area under the PR-curve is the
computed using the height of the precision values by the recall. <p></p> This value is ultimately returned as `auc`, an idempotent operation that
computes the area under a discretized curve of precision versus recall values
(computed using the aforementioned variables). The `num_thresholds` variable
controls the degree of discretization with larger numbers of thresholds more
closely approximating the true AUC. The quality of the approximation may vary
dramatically depending on `num_thresholds`. <p></p> For best results, `predictions` should be distributed approximately uniformly
in the range [0, 1] and not peaked around 0 or 1. The quality of the AUC
approximation may be poor if this is not the case. Setting `summation_method`
to 'minoring' or 'majoring' can help quantify the error in the approximation
by providing lower or upper bound estimate of the AUC. The `thresholds`
parameter can be used to manually specify thresholds which split the
predictions more evenly. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `auc`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>A `Tensor` whose shape matches `predictions`. Will be cast to
`bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_thresholds
						</dt>
						<dd>The number of thresholds to use when discretizing the roc
curve. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `auc` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> curve
						</dt>
						<dd>Specifies the name of the curve to be computed, 'ROC' [default] or
'PR' for the Precision-Recall-curve. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> summation_method
						</dt>
						<dd>Specifies the Riemann summation method used
(https://en.wikipedia.org/wiki/Riemann_sum): 'trapezoidal' [default] that
applies the trapezoidal rule; 'careful_interpolation', a variant of it
differing only by a more correct interpolation scheme for PR-AUC -
interpolating (true/false) positives but not the ratio that is precision;
'minoring' that applies left summation for increasing intervals and right
summation for decreasing intervals; 'majoring' that does the opposite.
Note that 'careful_interpolation' is strictly preferred to 'trapezoidal'
(to be deprecated soon) as it applies the same method for ROC, and a
better one (see Davis & Goadrich 2006 for details) for the PR curve. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span></code> thresholds
						</dt>
						<dd>An optional list of floating point values to use as the
thresholds for discretizing the curve. If set, the `num_thresholds`
parameter is ignored. Values should be in [0, 1]. Endpoint thresholds
equal to {-epsilon, 1+epsilon} for a small positive epsilon value will be
automatically included with these to correctly handle predictions equal to
exactly 0 or 1. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="auc" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>auc</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.string">string</span> weights, <span title="System.int">int</span> num_thresholds, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> curve, <span title="System.string">string</span> name, <span title="System.string">string</span> summation_method, <span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span> thresholds)
		</h4>
		<div class="content">Computes the approximate AUC via a Riemann sum. <p></p> The `auc` function creates four local variables, `true_positives`,
`true_negatives`, `false_positives` and `false_negatives` that are used to
compute the AUC. To discretize the AUC curve, a linearly spaced set of
thresholds is used to compute pairs of recall and precision values. The area
under the ROC-curve is therefore computed using the height of the recall
values by the false positive rate, while the area under the PR-curve is the
computed using the height of the precision values by the recall. <p></p> This value is ultimately returned as `auc`, an idempotent operation that
computes the area under a discretized curve of precision versus recall values
(computed using the aforementioned variables). The `num_thresholds` variable
controls the degree of discretization with larger numbers of thresholds more
closely approximating the true AUC. The quality of the approximation may vary
dramatically depending on `num_thresholds`. <p></p> For best results, `predictions` should be distributed approximately uniformly
in the range [0, 1] and not peaked around 0 or 1. The quality of the AUC
approximation may be poor if this is not the case. Setting `summation_method`
to 'minoring' or 'majoring' can help quantify the error in the approximation
by providing lower or upper bound estimate of the AUC. The `thresholds`
parameter can be used to manually specify thresholds which split the
predictions more evenly. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `auc`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>A `Tensor` whose shape matches `predictions`. Will be cast to
`bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_thresholds
						</dt>
						<dd>The number of thresholds to use when discretizing the roc
curve. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `auc` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> curve
						</dt>
						<dd>Specifies the name of the curve to be computed, 'ROC' [default] or
'PR' for the Precision-Recall-curve. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> summation_method
						</dt>
						<dd>Specifies the Riemann summation method used
(https://en.wikipedia.org/wiki/Riemann_sum): 'trapezoidal' [default] that
applies the trapezoidal rule; 'careful_interpolation', a variant of it
differing only by a more correct interpolation scheme for PR-AUC -
interpolating (true/false) positives but not the ratio that is precision;
'minoring' that applies left summation for increasing intervals and right
summation for decreasing intervals; 'majoring' that does the opposite.
Note that 'careful_interpolation' is strictly preferred to 'trapezoidal'
(to be deprecated soon) as it applies the same method for ROC, and a
better one (see Davis & Goadrich 2006 for details) for the PR curve. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span></code> thresholds
						</dt>
						<dd>An optional list of floating point values to use as the
thresholds for discretizing the curve. If set, the `num_thresholds`
parameter is ignored. Values should be in [0, 1]. Endpoint thresholds
equal to {-epsilon, 1+epsilon} for a small positive epsilon value will be
automatically included with these to correctly handle predictions equal to
exactly 0 or 1. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="auc" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>auc</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> predictions, <span title="System.Collections.Generic.IEnumerable<PythonClassContainer>">IEnumerable&lt;PythonClassContainer&gt;</span> weights, <span title="System.int">int</span> num_thresholds, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> curve, <span title="System.string">string</span> name, <span title="System.string">string</span> summation_method, <span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span> thresholds)
		</h4>
		<div class="content">Computes the approximate AUC via a Riemann sum. <p></p> The `auc` function creates four local variables, `true_positives`,
`true_negatives`, `false_positives` and `false_negatives` that are used to
compute the AUC. To discretize the AUC curve, a linearly spaced set of
thresholds is used to compute pairs of recall and precision values. The area
under the ROC-curve is therefore computed using the height of the recall
values by the false positive rate, while the area under the PR-curve is the
computed using the height of the precision values by the recall. <p></p> This value is ultimately returned as `auc`, an idempotent operation that
computes the area under a discretized curve of precision versus recall values
(computed using the aforementioned variables). The `num_thresholds` variable
controls the degree of discretization with larger numbers of thresholds more
closely approximating the true AUC. The quality of the approximation may vary
dramatically depending on `num_thresholds`. <p></p> For best results, `predictions` should be distributed approximately uniformly
in the range [0, 1] and not peaked around 0 or 1. The quality of the AUC
approximation may be poor if this is not the case. Setting `summation_method`
to 'minoring' or 'majoring' can help quantify the error in the approximation
by providing lower or upper bound estimate of the AUC. The `thresholds`
parameter can be used to manually specify thresholds which split the
predictions more evenly. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `auc`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>A `Tensor` whose shape matches `predictions`. Will be cast to
`bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<PythonClassContainer>">IEnumerable&lt;PythonClassContainer&gt;</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_thresholds
						</dt>
						<dd>The number of thresholds to use when discretizing the roc
curve. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `auc` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> curve
						</dt>
						<dd>Specifies the name of the curve to be computed, 'ROC' [default] or
'PR' for the Precision-Recall-curve. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> summation_method
						</dt>
						<dd>Specifies the Riemann summation method used
(https://en.wikipedia.org/wiki/Riemann_sum): 'trapezoidal' [default] that
applies the trapezoidal rule; 'careful_interpolation', a variant of it
differing only by a more correct interpolation scheme for PR-AUC -
interpolating (true/false) positives but not the ratio that is precision;
'minoring' that applies left summation for increasing intervals and right
summation for decreasing intervals; 'majoring' that does the opposite.
Note that 'careful_interpolation' is strictly preferred to 'trapezoidal'
(to be deprecated soon) as it applies the same method for ROC, and a
better one (see Davis & Goadrich 2006 for details) for the PR curve. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span></code> thresholds
						</dt>
						<dd>An optional list of floating point values to use as the
thresholds for discretizing the curve. If set, the `num_thresholds`
parameter is ignored. Values should be in [0, 1]. Endpoint thresholds
equal to {-epsilon, 1+epsilon} for a small positive epsilon value will be
automatically included with these to correctly handle predictions equal to
exactly 0 or 1. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="auc" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>auc</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.object">object</span> weights, <span title="System.int">int</span> num_thresholds, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> curve, <span title="System.string">string</span> name, <span title="System.string">string</span> summation_method, <span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span> thresholds)
		</h4>
		<div class="content">Computes the approximate AUC via a Riemann sum. <p></p> The `auc` function creates four local variables, `true_positives`,
`true_negatives`, `false_positives` and `false_negatives` that are used to
compute the AUC. To discretize the AUC curve, a linearly spaced set of
thresholds is used to compute pairs of recall and precision values. The area
under the ROC-curve is therefore computed using the height of the recall
values by the false positive rate, while the area under the PR-curve is the
computed using the height of the precision values by the recall. <p></p> This value is ultimately returned as `auc`, an idempotent operation that
computes the area under a discretized curve of precision versus recall values
(computed using the aforementioned variables). The `num_thresholds` variable
controls the degree of discretization with larger numbers of thresholds more
closely approximating the true AUC. The quality of the approximation may vary
dramatically depending on `num_thresholds`. <p></p> For best results, `predictions` should be distributed approximately uniformly
in the range [0, 1] and not peaked around 0 or 1. The quality of the AUC
approximation may be poor if this is not the case. Setting `summation_method`
to 'minoring' or 'majoring' can help quantify the error in the approximation
by providing lower or upper bound estimate of the AUC. The `thresholds`
parameter can be used to manually specify thresholds which split the
predictions more evenly. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `auc`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>A `Tensor` whose shape matches `predictions`. Will be cast to
`bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_thresholds
						</dt>
						<dd>The number of thresholds to use when discretizing the roc
curve. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `auc` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> curve
						</dt>
						<dd>Specifies the name of the curve to be computed, 'ROC' [default] or
'PR' for the Precision-Recall-curve. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> summation_method
						</dt>
						<dd>Specifies the Riemann summation method used
(https://en.wikipedia.org/wiki/Riemann_sum): 'trapezoidal' [default] that
applies the trapezoidal rule; 'careful_interpolation', a variant of it
differing only by a more correct interpolation scheme for PR-AUC -
interpolating (true/false) positives but not the ratio that is precision;
'minoring' that applies left summation for increasing intervals and right
summation for decreasing intervals; 'majoring' that does the opposite.
Note that 'careful_interpolation' is strictly preferred to 'trapezoidal'
(to be deprecated soon) as it applies the same method for ROC, and a
better one (see Davis & Goadrich 2006 for details) for the PR curve. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span></code> thresholds
						</dt>
						<dd>An optional list of floating point values to use as the
thresholds for discretizing the curve. If set, the `num_thresholds`
parameter is ignored. Values should be in [0, 1]. Endpoint thresholds
equal to {-epsilon, 1+epsilon} for a small positive epsilon value will be
automatically included with these to correctly handle predictions equal to
exactly 0 or 1. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="auc" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>auc</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.int">int</span> num_thresholds, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> curve, <span title="System.string">string</span> name, <span title="System.string">string</span> summation_method, <span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span> thresholds)
		</h4>
		<div class="content">Computes the approximate AUC via a Riemann sum. <p></p> The `auc` function creates four local variables, `true_positives`,
`true_negatives`, `false_positives` and `false_negatives` that are used to
compute the AUC. To discretize the AUC curve, a linearly spaced set of
thresholds is used to compute pairs of recall and precision values. The area
under the ROC-curve is therefore computed using the height of the recall
values by the false positive rate, while the area under the PR-curve is the
computed using the height of the precision values by the recall. <p></p> This value is ultimately returned as `auc`, an idempotent operation that
computes the area under a discretized curve of precision versus recall values
(computed using the aforementioned variables). The `num_thresholds` variable
controls the degree of discretization with larger numbers of thresholds more
closely approximating the true AUC. The quality of the approximation may vary
dramatically depending on `num_thresholds`. <p></p> For best results, `predictions` should be distributed approximately uniformly
in the range [0, 1] and not peaked around 0 or 1. The quality of the AUC
approximation may be poor if this is not the case. Setting `summation_method`
to 'minoring' or 'majoring' can help quantify the error in the approximation
by providing lower or upper bound estimate of the AUC. The `thresholds`
parameter can be used to manually specify thresholds which split the
predictions more evenly. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `auc`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>A `Tensor` whose shape matches `predictions`. Will be cast to
`bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_thresholds
						</dt>
						<dd>The number of thresholds to use when discretizing the roc
curve. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `auc` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> curve
						</dt>
						<dd>Specifies the name of the curve to be computed, 'ROC' [default] or
'PR' for the Precision-Recall-curve. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> summation_method
						</dt>
						<dd>Specifies the Riemann summation method used
(https://en.wikipedia.org/wiki/Riemann_sum): 'trapezoidal' [default] that
applies the trapezoidal rule; 'careful_interpolation', a variant of it
differing only by a more correct interpolation scheme for PR-AUC -
interpolating (true/false) positives but not the ratio that is precision;
'minoring' that applies left summation for increasing intervals and right
summation for decreasing intervals; 'majoring' that does the opposite.
Note that 'careful_interpolation' is strictly preferred to 'trapezoidal'
(to be deprecated soon) as it applies the same method for ROC, and a
better one (see Davis & Goadrich 2006 for details) for the PR curve. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span></code> thresholds
						</dt>
						<dd>An optional list of floating point values to use as the
thresholds for discretizing the curve. If set, the `num_thresholds`
parameter is ignored. Values should be in [0, 1]. Endpoint thresholds
equal to {-epsilon, 1+epsilon} for a small positive epsilon value will be
automatically included with these to correctly handle predictions equal to
exactly 0 or 1. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="auc" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>auc</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> weights, <span title="System.int">int</span> num_thresholds, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> curve, <span title="System.string">string</span> name, <span title="System.string">string</span> summation_method, <span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span> thresholds)
		</h4>
		<div class="content">Computes the approximate AUC via a Riemann sum. <p></p> The `auc` function creates four local variables, `true_positives`,
`true_negatives`, `false_positives` and `false_negatives` that are used to
compute the AUC. To discretize the AUC curve, a linearly spaced set of
thresholds is used to compute pairs of recall and precision values. The area
under the ROC-curve is therefore computed using the height of the recall
values by the false positive rate, while the area under the PR-curve is the
computed using the height of the precision values by the recall. <p></p> This value is ultimately returned as `auc`, an idempotent operation that
computes the area under a discretized curve of precision versus recall values
(computed using the aforementioned variables). The `num_thresholds` variable
controls the degree of discretization with larger numbers of thresholds more
closely approximating the true AUC. The quality of the approximation may vary
dramatically depending on `num_thresholds`. <p></p> For best results, `predictions` should be distributed approximately uniformly
in the range [0, 1] and not peaked around 0 or 1. The quality of the AUC
approximation may be poor if this is not the case. Setting `summation_method`
to 'minoring' or 'majoring' can help quantify the error in the approximation
by providing lower or upper bound estimate of the AUC. The `thresholds`
parameter can be used to manually specify thresholds which split the
predictions more evenly. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `auc`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>A `Tensor` whose shape matches `predictions`. Will be cast to
`bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_thresholds
						</dt>
						<dd>The number of thresholds to use when discretizing the roc
curve. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `auc` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> curve
						</dt>
						<dd>Specifies the name of the curve to be computed, 'ROC' [default] or
'PR' for the Precision-Recall-curve. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> summation_method
						</dt>
						<dd>Specifies the Riemann summation method used
(https://en.wikipedia.org/wiki/Riemann_sum): 'trapezoidal' [default] that
applies the trapezoidal rule; 'careful_interpolation', a variant of it
differing only by a more correct interpolation scheme for PR-AUC -
interpolating (true/false) positives but not the ratio that is precision;
'minoring' that applies left summation for increasing intervals and right
summation for decreasing intervals; 'majoring' that does the opposite.
Note that 'careful_interpolation' is strictly preferred to 'trapezoidal'
(to be deprecated soon) as it applies the same method for ROC, and a
better one (see Davis & Goadrich 2006 for details) for the PR curve. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span></code> thresholds
						</dt>
						<dd>An optional list of floating point values to use as the
thresholds for discretizing the curve. If set, the `num_thresholds`
parameter is ignored. Values should be in [0, 1]. Endpoint thresholds
equal to {-epsilon, 1+epsilon} for a small positive epsilon value will be
automatically included with these to correctly handle predictions equal to
exactly 0 or 1. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="auc_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>auc_dyn</strong>(<span title="System.object">object</span> labels, <span title="System.object">object</span> predictions, <span title="System.object">object</span> weights, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> num_thresholds, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> curve, <span title="System.object">object</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> summation_method, <span title="System.object">object</span> thresholds)
		</h4>
		<div class="content">Computes the approximate AUC via a Riemann sum. <p></p> The `auc` function creates four local variables, `true_positives`,
`true_negatives`, `false_positives` and `false_negatives` that are used to
compute the AUC. To discretize the AUC curve, a linearly spaced set of
thresholds is used to compute pairs of recall and precision values. The area
under the ROC-curve is therefore computed using the height of the recall
values by the false positive rate, while the area under the PR-curve is the
computed using the height of the precision values by the recall. <p></p> This value is ultimately returned as `auc`, an idempotent operation that
computes the area under a discretized curve of precision versus recall values
(computed using the aforementioned variables). The `num_thresholds` variable
controls the degree of discretization with larger numbers of thresholds more
closely approximating the true AUC. The quality of the approximation may vary
dramatically depending on `num_thresholds`. <p></p> For best results, `predictions` should be distributed approximately uniformly
in the range [0, 1] and not peaked around 0 or 1. The quality of the AUC
approximation may be poor if this is not the case. Setting `summation_method`
to 'minoring' or 'majoring' can help quantify the error in the approximation
by providing lower or upper bound estimate of the AUC. The `thresholds`
parameter can be used to manually specify thresholds which split the
predictions more evenly. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `auc`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>A `Tensor` whose shape matches `predictions`. Will be cast to
`bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> num_thresholds
						</dt>
						<dd>The number of thresholds to use when discretizing the roc
curve. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `auc` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> curve
						</dt>
						<dd>Specifies the name of the curve to be computed, 'ROC' [default] or
'PR' for the Precision-Recall-curve. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> summation_method
						</dt>
						<dd>Specifies the Riemann summation method used
(https://en.wikipedia.org/wiki/Riemann_sum): 'trapezoidal' [default] that
applies the trapezoidal rule; 'careful_interpolation', a variant of it
differing only by a more correct interpolation scheme for PR-AUC -
interpolating (true/false) positives but not the ratio that is precision;
'minoring' that applies left summation for increasing intervals and right
summation for decreasing intervals; 'majoring' that does the opposite.
Note that 'careful_interpolation' is strictly preferred to 'trapezoidal'
(to be deprecated soon) as it applies the same method for ROC, and a
better one (see Davis & Goadrich 2006 for details) for the PR curve. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> thresholds
						</dt>
						<dd>An optional list of floating point values to use as the
thresholds for discretizing the curve. If set, the `num_thresholds`
parameter is ignored. Values should be in [0, 1]. Endpoint thresholds
equal to {-epsilon, 1+epsilon} for a small positive epsilon value will be
automatically included with these to correctly handle predictions equal to
exactly 0 or 1. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="average_precision_at_k" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>average_precision_at_k</strong>(<a href="../numpy/ndarray.htm">ndarray</a> labels, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> predictions, <span title="System.int">int</span> k, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes average precision@k of predictions with respect to sparse labels. <p></p> `average_precision_at_k` creates two local variables,
`average_precision_at_<k>/total` and `average_precision_at_<k>/max`, that
are used to compute the frequency. This frequency is ultimately returned as
`average_precision_at_<k>`: an idempotent operation that simply divides
`average_precision_at_<k>/total` by `average_precision_at_<k>/max`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision_at_<k>`. Internally, a `top_k` operation computes a `Tensor`
indicating the top `k` `predictions`. Set operations applied to `top_k` and
`labels` calculate the true positives and false positives weighted by
`weights`. Then `update_op` increments `true_positive_at_<k>` and
`false_positive_at_<k>` using these values. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> labels
						</dt>
						<dd>`int64` `Tensor` or `SparseTensor` with shape
[D1,... DN, num_labels] or [D1,... DN], where the latter implies
num_labels=1. N >= 1 and num_labels is the number of target classes for
the associated prediction. Commonly, N=1 and `labels` has shape
[batch_size, num_labels]. [D1,... DN] must match `predictions`. Values
should be in range [0, num_classes), where num_classes is the last
dimension of `predictions`. Values outside this range are ignored. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> predictions
						</dt>
						<dd>Float `Tensor` with shape [D1,... DN, num_classes] where
N >= 1. Commonly, N=1 and `predictions` has shape
[batch size, num_classes]. The final dimension contains the logit values
for each class. [D1,... DN] must match `labels`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> k
						</dt>
						<dd>Integer, k for @k metric. This will calculate an average precision for
range `[1,k]`, as documented above. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>`Tensor` whose rank is either 0, or n-1, where n is the rank of
`labels`. If the latter, it must be broadcastable to `labels` (i.e., all
dimensions must be either `1`, or the same as the corresponding `labels`
dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that values should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that updates should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>Name of new update operation, and namespace for other dependent ops. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="average_precision_at_k" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>average_precision_at_k</strong>(<span title="System.object">object</span> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.int">int</span> k, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes average precision@k of predictions with respect to sparse labels. <p></p> `average_precision_at_k` creates two local variables,
`average_precision_at_<k>/total` and `average_precision_at_<k>/max`, that
are used to compute the frequency. This frequency is ultimately returned as
`average_precision_at_<k>`: an idempotent operation that simply divides
`average_precision_at_<k>/total` by `average_precision_at_<k>/max`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision_at_<k>`. Internally, a `top_k` operation computes a `Tensor`
indicating the top `k` `predictions`. Set operations applied to `top_k` and
`labels` calculate the true positives and false positives weighted by
`weights`. Then `update_op` increments `true_positive_at_<k>` and
`false_positive_at_<k>` using these values. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>`int64` `Tensor` or `SparseTensor` with shape
[D1,... DN, num_labels] or [D1,... DN], where the latter implies
num_labels=1. N >= 1 and num_labels is the number of target classes for
the associated prediction. Commonly, N=1 and `labels` has shape
[batch_size, num_labels]. [D1,... DN] must match `predictions`. Values
should be in range [0, num_classes), where num_classes is the last
dimension of `predictions`. Values outside this range are ignored. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>Float `Tensor` with shape [D1,... DN, num_classes] where
N >= 1. Commonly, N=1 and `predictions` has shape
[batch size, num_classes]. The final dimension contains the logit values
for each class. [D1,... DN] must match `labels`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> k
						</dt>
						<dd>Integer, k for @k metric. This will calculate an average precision for
range `[1,k]`, as documented above. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>`Tensor` whose rank is either 0, or n-1, where n is the rank of
`labels`. If the latter, it must be broadcastable to `labels` (i.e., all
dimensions must be either `1`, or the same as the corresponding `labels`
dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that values should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that updates should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>Name of new update operation, and namespace for other dependent ops. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="average_precision_at_k" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>average_precision_at_k</strong>(<span title="System.object">object</span> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.int">int</span> k, <span title="System.ValueTuple<double, object>">ValueTuple&lt;double, object&gt;</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes average precision@k of predictions with respect to sparse labels. <p></p> `average_precision_at_k` creates two local variables,
`average_precision_at_<k>/total` and `average_precision_at_<k>/max`, that
are used to compute the frequency. This frequency is ultimately returned as
`average_precision_at_<k>`: an idempotent operation that simply divides
`average_precision_at_<k>/total` by `average_precision_at_<k>/max`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision_at_<k>`. Internally, a `top_k` operation computes a `Tensor`
indicating the top `k` `predictions`. Set operations applied to `top_k` and
`labels` calculate the true positives and false positives weighted by
`weights`. Then `update_op` increments `true_positive_at_<k>` and
`false_positive_at_<k>` using these values. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>`int64` `Tensor` or `SparseTensor` with shape
[D1,... DN, num_labels] or [D1,... DN], where the latter implies
num_labels=1. N >= 1 and num_labels is the number of target classes for
the associated prediction. Commonly, N=1 and `labels` has shape
[batch_size, num_labels]. [D1,... DN] must match `predictions`. Values
should be in range [0, num_classes), where num_classes is the last
dimension of `predictions`. Values outside this range are ignored. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>Float `Tensor` with shape [D1,... DN, num_classes] where
N >= 1. Commonly, N=1 and `predictions` has shape
[batch size, num_classes]. The final dimension contains the logit values
for each class. [D1,... DN] must match `labels`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> k
						</dt>
						<dd>Integer, k for @k metric. This will calculate an average precision for
range `[1,k]`, as documented above. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<double, object>">ValueTuple&lt;double, object&gt;</span></code> weights
						</dt>
						<dd>`Tensor` whose rank is either 0, or n-1, where n is the rank of
`labels`. If the latter, it must be broadcastable to `labels` (i.e., all
dimensions must be either `1`, or the same as the corresponding `labels`
dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that values should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that updates should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>Name of new update operation, and namespace for other dependent ops. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="average_precision_at_k" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>average_precision_at_k</strong>(<span title="System.object">object</span> labels, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> predictions, <span title="System.int">int</span> k, <span title="System.ValueTuple<double, object>">ValueTuple&lt;double, object&gt;</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes average precision@k of predictions with respect to sparse labels. <p></p> `average_precision_at_k` creates two local variables,
`average_precision_at_<k>/total` and `average_precision_at_<k>/max`, that
are used to compute the frequency. This frequency is ultimately returned as
`average_precision_at_<k>`: an idempotent operation that simply divides
`average_precision_at_<k>/total` by `average_precision_at_<k>/max`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision_at_<k>`. Internally, a `top_k` operation computes a `Tensor`
indicating the top `k` `predictions`. Set operations applied to `top_k` and
`labels` calculate the true positives and false positives weighted by
`weights`. Then `update_op` increments `true_positive_at_<k>` and
`false_positive_at_<k>` using these values. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>`int64` `Tensor` or `SparseTensor` with shape
[D1,... DN, num_labels] or [D1,... DN], where the latter implies
num_labels=1. N >= 1 and num_labels is the number of target classes for
the associated prediction. Commonly, N=1 and `labels` has shape
[batch_size, num_labels]. [D1,... DN] must match `predictions`. Values
should be in range [0, num_classes), where num_classes is the last
dimension of `predictions`. Values outside this range are ignored. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> predictions
						</dt>
						<dd>Float `Tensor` with shape [D1,... DN, num_classes] where
N >= 1. Commonly, N=1 and `predictions` has shape
[batch size, num_classes]. The final dimension contains the logit values
for each class. [D1,... DN] must match `labels`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> k
						</dt>
						<dd>Integer, k for @k metric. This will calculate an average precision for
range `[1,k]`, as documented above. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<double, object>">ValueTuple&lt;double, object&gt;</span></code> weights
						</dt>
						<dd>`Tensor` whose rank is either 0, or n-1, where n is the rank of
`labels`. If the latter, it must be broadcastable to `labels` (i.e., all
dimensions must be either `1`, or the same as the corresponding `labels`
dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that values should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that updates should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>Name of new update operation, and namespace for other dependent ops. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="average_precision_at_k" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>average_precision_at_k</strong>(<a href="../numpy/ndarray.htm">ndarray</a> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.int">int</span> k, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes average precision@k of predictions with respect to sparse labels. <p></p> `average_precision_at_k` creates two local variables,
`average_precision_at_<k>/total` and `average_precision_at_<k>/max`, that
are used to compute the frequency. This frequency is ultimately returned as
`average_precision_at_<k>`: an idempotent operation that simply divides
`average_precision_at_<k>/total` by `average_precision_at_<k>/max`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision_at_<k>`. Internally, a `top_k` operation computes a `Tensor`
indicating the top `k` `predictions`. Set operations applied to `top_k` and
`labels` calculate the true positives and false positives weighted by
`weights`. Then `update_op` increments `true_positive_at_<k>` and
`false_positive_at_<k>` using these values. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> labels
						</dt>
						<dd>`int64` `Tensor` or `SparseTensor` with shape
[D1,... DN, num_labels] or [D1,... DN], where the latter implies
num_labels=1. N >= 1 and num_labels is the number of target classes for
the associated prediction. Commonly, N=1 and `labels` has shape
[batch_size, num_labels]. [D1,... DN] must match `predictions`. Values
should be in range [0, num_classes), where num_classes is the last
dimension of `predictions`. Values outside this range are ignored. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>Float `Tensor` with shape [D1,... DN, num_classes] where
N >= 1. Commonly, N=1 and `predictions` has shape
[batch size, num_classes]. The final dimension contains the logit values
for each class. [D1,... DN] must match `labels`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> k
						</dt>
						<dd>Integer, k for @k metric. This will calculate an average precision for
range `[1,k]`, as documented above. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>`Tensor` whose rank is either 0, or n-1, where n is the rank of
`labels`. If the latter, it must be broadcastable to `labels` (i.e., all
dimensions must be either `1`, or the same as the corresponding `labels`
dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that values should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that updates should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>Name of new update operation, and namespace for other dependent ops. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="average_precision_at_k" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>average_precision_at_k</strong>(<a href="../numpy/ndarray.htm">ndarray</a> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.int">int</span> k, <span title="System.ValueTuple<double, object>">ValueTuple&lt;double, object&gt;</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes average precision@k of predictions with respect to sparse labels. <p></p> `average_precision_at_k` creates two local variables,
`average_precision_at_<k>/total` and `average_precision_at_<k>/max`, that
are used to compute the frequency. This frequency is ultimately returned as
`average_precision_at_<k>`: an idempotent operation that simply divides
`average_precision_at_<k>/total` by `average_precision_at_<k>/max`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision_at_<k>`. Internally, a `top_k` operation computes a `Tensor`
indicating the top `k` `predictions`. Set operations applied to `top_k` and
`labels` calculate the true positives and false positives weighted by
`weights`. Then `update_op` increments `true_positive_at_<k>` and
`false_positive_at_<k>` using these values. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> labels
						</dt>
						<dd>`int64` `Tensor` or `SparseTensor` with shape
[D1,... DN, num_labels] or [D1,... DN], where the latter implies
num_labels=1. N >= 1 and num_labels is the number of target classes for
the associated prediction. Commonly, N=1 and `labels` has shape
[batch_size, num_labels]. [D1,... DN] must match `predictions`. Values
should be in range [0, num_classes), where num_classes is the last
dimension of `predictions`. Values outside this range are ignored. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>Float `Tensor` with shape [D1,... DN, num_classes] where
N >= 1. Commonly, N=1 and `predictions` has shape
[batch size, num_classes]. The final dimension contains the logit values
for each class. [D1,... DN] must match `labels`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> k
						</dt>
						<dd>Integer, k for @k metric. This will calculate an average precision for
range `[1,k]`, as documented above. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<double, object>">ValueTuple&lt;double, object&gt;</span></code> weights
						</dt>
						<dd>`Tensor` whose rank is either 0, or n-1, where n is the rank of
`labels`. If the latter, it must be broadcastable to `labels` (i.e., all
dimensions must be either `1`, or the same as the corresponding `labels`
dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that values should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that updates should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>Name of new update operation, and namespace for other dependent ops. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="average_precision_at_k" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>average_precision_at_k</strong>(<a href="../numpy/ndarray.htm">ndarray</a> labels, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> predictions, <span title="System.int">int</span> k, <span title="System.ValueTuple<double, object>">ValueTuple&lt;double, object&gt;</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes average precision@k of predictions with respect to sparse labels. <p></p> `average_precision_at_k` creates two local variables,
`average_precision_at_<k>/total` and `average_precision_at_<k>/max`, that
are used to compute the frequency. This frequency is ultimately returned as
`average_precision_at_<k>`: an idempotent operation that simply divides
`average_precision_at_<k>/total` by `average_precision_at_<k>/max`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision_at_<k>`. Internally, a `top_k` operation computes a `Tensor`
indicating the top `k` `predictions`. Set operations applied to `top_k` and
`labels` calculate the true positives and false positives weighted by
`weights`. Then `update_op` increments `true_positive_at_<k>` and
`false_positive_at_<k>` using these values. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> labels
						</dt>
						<dd>`int64` `Tensor` or `SparseTensor` with shape
[D1,... DN, num_labels] or [D1,... DN], where the latter implies
num_labels=1. N >= 1 and num_labels is the number of target classes for
the associated prediction. Commonly, N=1 and `labels` has shape
[batch_size, num_labels]. [D1,... DN] must match `predictions`. Values
should be in range [0, num_classes), where num_classes is the last
dimension of `predictions`. Values outside this range are ignored. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> predictions
						</dt>
						<dd>Float `Tensor` with shape [D1,... DN, num_classes] where
N >= 1. Commonly, N=1 and `predictions` has shape
[batch size, num_classes]. The final dimension contains the logit values
for each class. [D1,... DN] must match `labels`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> k
						</dt>
						<dd>Integer, k for @k metric. This will calculate an average precision for
range `[1,k]`, as documented above. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<double, object>">ValueTuple&lt;double, object&gt;</span></code> weights
						</dt>
						<dd>`Tensor` whose rank is either 0, or n-1, where n is the rank of
`labels`. If the latter, it must be broadcastable to `labels` (i.e., all
dimensions must be either `1`, or the same as the corresponding `labels`
dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that values should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that updates should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>Name of new update operation, and namespace for other dependent ops. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="average_precision_at_k" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>average_precision_at_k</strong>(<span title="System.object">object</span> labels, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> predictions, <span title="System.int">int</span> k, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes average precision@k of predictions with respect to sparse labels. <p></p> `average_precision_at_k` creates two local variables,
`average_precision_at_<k>/total` and `average_precision_at_<k>/max`, that
are used to compute the frequency. This frequency is ultimately returned as
`average_precision_at_<k>`: an idempotent operation that simply divides
`average_precision_at_<k>/total` by `average_precision_at_<k>/max`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision_at_<k>`. Internally, a `top_k` operation computes a `Tensor`
indicating the top `k` `predictions`. Set operations applied to `top_k` and
`labels` calculate the true positives and false positives weighted by
`weights`. Then `update_op` increments `true_positive_at_<k>` and
`false_positive_at_<k>` using these values. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>`int64` `Tensor` or `SparseTensor` with shape
[D1,... DN, num_labels] or [D1,... DN], where the latter implies
num_labels=1. N >= 1 and num_labels is the number of target classes for
the associated prediction. Commonly, N=1 and `labels` has shape
[batch_size, num_labels]. [D1,... DN] must match `predictions`. Values
should be in range [0, num_classes), where num_classes is the last
dimension of `predictions`. Values outside this range are ignored. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> predictions
						</dt>
						<dd>Float `Tensor` with shape [D1,... DN, num_classes] where
N >= 1. Commonly, N=1 and `predictions` has shape
[batch size, num_classes]. The final dimension contains the logit values
for each class. [D1,... DN] must match `labels`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> k
						</dt>
						<dd>Integer, k for @k metric. This will calculate an average precision for
range `[1,k]`, as documented above. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>`Tensor` whose rank is either 0, or n-1, where n is the rank of
`labels`. If the latter, it must be broadcastable to `labels` (i.e., all
dimensions must be either `1`, or the same as the corresponding `labels`
dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that values should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that updates should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>Name of new update operation, and namespace for other dependent ops. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="average_precision_at_k_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>average_precision_at_k_dyn</strong>(<span title="System.object">object</span> labels, <span title="System.object">object</span> predictions, <span title="System.object">object</span> k, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Computes average precision@k of predictions with respect to sparse labels. <p></p> `average_precision_at_k` creates two local variables,
`average_precision_at_<k>/total` and `average_precision_at_<k>/max`, that
are used to compute the frequency. This frequency is ultimately returned as
`average_precision_at_<k>`: an idempotent operation that simply divides
`average_precision_at_<k>/total` by `average_precision_at_<k>/max`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision_at_<k>`. Internally, a `top_k` operation computes a `Tensor`
indicating the top `k` `predictions`. Set operations applied to `top_k` and
`labels` calculate the true positives and false positives weighted by
`weights`. Then `update_op` increments `true_positive_at_<k>` and
`false_positive_at_<k>` using these values. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>`int64` `Tensor` or `SparseTensor` with shape
[D1,... DN, num_labels] or [D1,... DN], where the latter implies
num_labels=1. N >= 1 and num_labels is the number of target classes for
the associated prediction. Commonly, N=1 and `labels` has shape
[batch_size, num_labels]. [D1,... DN] must match `predictions`. Values
should be in range [0, num_classes), where num_classes is the last
dimension of `predictions`. Values outside this range are ignored. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>Float `Tensor` with shape [D1,... DN, num_classes] where
N >= 1. Commonly, N=1 and `predictions` has shape
[batch size, num_classes]. The final dimension contains the logit values
for each class. [D1,... DN] must match `labels`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> k
						</dt>
						<dd>Integer, k for @k metric. This will calculate an average precision for
range `[1,k]`, as documented above. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>`Tensor` whose rank is either 0, or n-1, where n is the rank of
`labels`. If the latter, it must be broadcastable to `labels` (i.e., all
dimensions must be either `1`, or the same as the corresponding `labels`
dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that values should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that updates should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>Name of new update operation, and namespace for other dependent ops. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="false_negatives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>false_negatives</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <span title="System.object">object</span> predictions, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the total number of false negatives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="false_negatives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>false_negatives</strong>(<span title="System.object">object</span> labels, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> predictions, <span title="System.ValueTuple<object, object, object>">ValueTuple&lt;object, object, object&gt;</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the total number of false negatives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<object, object, object>">ValueTuple&lt;object, object, object&gt;</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="false_negatives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>false_negatives</strong>(<span title="System.object">object</span> labels, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> predictions, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the total number of false negatives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="false_negatives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>false_negatives</strong>(<span title="System.object">object</span> labels, <span title="System.object">object</span> predictions, <span title="System.ValueTuple<object, object, object>">ValueTuple&lt;object, object, object&gt;</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the total number of false negatives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<object, object, object>">ValueTuple&lt;object, object, object&gt;</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="false_negatives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>false_negatives</strong>(<span title="System.object">object</span> labels, <span title="System.object">object</span> predictions, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the total number of false negatives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="false_negatives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>false_negatives</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> predictions, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the total number of false negatives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="false_negatives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>false_negatives</strong>(<span title="System.double">double</span> labels, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> predictions, <span title="System.ValueTuple<object, object, object>">ValueTuple&lt;object, object, object&gt;</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the total number of false negatives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.double">double</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<object, object, object>">ValueTuple&lt;object, object, object&gt;</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="false_negatives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>false_negatives</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <span title="System.object">object</span> predictions, <span title="System.ValueTuple<object, object, object>">ValueTuple&lt;object, object, object&gt;</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the total number of false negatives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<object, object, object>">ValueTuple&lt;object, object, object&gt;</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="false_negatives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>false_negatives</strong>(<span title="System.double">double</span> labels, <span title="System.object">object</span> predictions, <span title="System.ValueTuple<object, object, object>">ValueTuple&lt;object, object, object&gt;</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the total number of false negatives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.double">double</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<object, object, object>">ValueTuple&lt;object, object, object&gt;</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="false_negatives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>false_negatives</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> labels, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> predictions, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the total number of false negatives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="false_negatives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>false_negatives</strong>(<a href="../numpy/ndarray.htm">ndarray</a> labels, <span title="System.object">object</span> predictions, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the total number of false negatives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="false_negatives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>false_negatives</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> labels, <span title="System.object">object</span> predictions, <span title="System.ValueTuple<object, object, object>">ValueTuple&lt;object, object, object&gt;</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the total number of false negatives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<object, object, object>">ValueTuple&lt;object, object, object&gt;</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="false_negatives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>false_negatives</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> labels, <span title="System.object">object</span> predictions, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the total number of false negatives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="false_negatives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>false_negatives</strong>(<span title="System.double">double</span> labels, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> predictions, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the total number of false negatives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.double">double</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="false_negatives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>false_negatives</strong>(<a href="../numpy/ndarray.htm">ndarray</a> labels, <span title="System.object">object</span> predictions, <span title="System.ValueTuple<object, object, object>">ValueTuple&lt;object, object, object&gt;</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the total number of false negatives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<object, object, object>">ValueTuple&lt;object, object, object&gt;</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="false_negatives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>false_negatives</strong>(<a href="../numpy/ndarray.htm">ndarray</a> labels, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> predictions, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the total number of false negatives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="false_negatives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>false_negatives</strong>(<a href="../numpy/ndarray.htm">ndarray</a> labels, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> predictions, <span title="System.ValueTuple<object, object, object>">ValueTuple&lt;object, object, object&gt;</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the total number of false negatives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<object, object, object>">ValueTuple&lt;object, object, object&gt;</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="false_negatives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>false_negatives</strong>(<span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> labels, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> predictions, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the total number of false negatives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="false_negatives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>false_negatives</strong>(<span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> labels, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> predictions, <span title="System.ValueTuple<object, object, object>">ValueTuple&lt;object, object, object&gt;</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the total number of false negatives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<object, object, object>">ValueTuple&lt;object, object, object&gt;</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="false_negatives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>false_negatives</strong>(<span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> labels, <span title="System.object">object</span> predictions, <span title="System.ValueTuple<object, object, object>">ValueTuple&lt;object, object, object&gt;</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the total number of false negatives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<object, object, object>">ValueTuple&lt;object, object, object&gt;</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="false_negatives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>false_negatives</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> predictions, <span title="System.ValueTuple<object, object, object>">ValueTuple&lt;object, object, object&gt;</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the total number of false negatives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<object, object, object>">ValueTuple&lt;object, object, object&gt;</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="false_negatives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>false_negatives</strong>(<a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> labels, <span title="System.object">object</span> predictions, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the total number of false negatives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="false_negatives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>false_negatives</strong>(<a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> labels, <span title="System.object">object</span> predictions, <span title="System.ValueTuple<object, object, object>">ValueTuple&lt;object, object, object&gt;</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the total number of false negatives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<object, object, object>">ValueTuple&lt;object, object, object&gt;</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="false_negatives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>false_negatives</strong>(<span title="System.double">double</span> labels, <span title="System.object">object</span> predictions, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the total number of false negatives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.double">double</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="false_negatives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>false_negatives</strong>(<a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> labels, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> predictions, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the total number of false negatives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="false_negatives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>false_negatives</strong>(<a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> labels, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> predictions, <span title="System.ValueTuple<object, object, object>">ValueTuple&lt;object, object, object&gt;</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the total number of false negatives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<object, object, object>">ValueTuple&lt;object, object, object&gt;</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="false_negatives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>false_negatives</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> labels, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> predictions, <span title="System.ValueTuple<object, object, object>">ValueTuple&lt;object, object, object&gt;</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the total number of false negatives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<object, object, object>">ValueTuple&lt;object, object, object&gt;</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="false_negatives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>false_negatives</strong>(<span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> labels, <span title="System.object">object</span> predictions, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the total number of false negatives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="false_negatives_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>false_negatives_at_thresholds</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span> thresholds, <span title="System.Nullable<ValueTuple<object, object, object>>">Nullable&lt;ValueTuple&lt;object, object, object&gt;&gt;</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes false negatives at provided threshold values. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>A `Tensor` whose shape matches `predictions`. Will be cast to
`bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.Nullable<ValueTuple<object, object, object>>">Nullable&lt;ValueTuple&lt;object, object, object&gt;&gt;</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `false_negatives`
should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="false_negatives_at_thresholds_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>false_negatives_at_thresholds_dyn</strong>(<span title="System.object">object</span> labels, <span title="System.object">object</span> predictions, <span title="System.object">object</span> thresholds, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Computes false negatives at provided threshold values. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>A `Tensor` whose shape matches `predictions`. Will be cast to
`bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `false_negatives`
should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="false_negatives_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>false_negatives_dyn</strong>(<span title="System.object">object</span> labels, <span title="System.object">object</span> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Computes the total number of false negatives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="false_positives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>false_positives</strong>(<a href="../numpy/ndarray.htm">ndarray</a> labels, <span title="System.object">object</span> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Sum the weights of false positives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="false_positives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>false_positives</strong>(<a href="../numpy/ndarray.htm">ndarray</a> labels, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Sum the weights of false positives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="false_positives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>false_positives</strong>(<span title="System.double">double</span> labels, <span title="System.object">object</span> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Sum the weights of false positives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.double">double</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="false_positives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>false_positives</strong>(<span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> labels, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Sum the weights of false positives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="false_positives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>false_positives</strong>(<span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> labels, <span title="System.object">object</span> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Sum the weights of false positives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="false_positives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>false_positives</strong>(<a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> labels, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Sum the weights of false positives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="false_positives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>false_positives</strong>(<a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> labels, <span title="System.object">object</span> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Sum the weights of false positives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="false_positives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>false_positives</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Sum the weights of false positives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="false_positives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>false_positives</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> labels, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Sum the weights of false positives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="false_positives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>false_positives</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> labels, <span title="System.object">object</span> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Sum the weights of false positives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="false_positives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>false_positives</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <span title="System.object">object</span> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Sum the weights of false positives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="false_positives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>false_positives</strong>(<span title="System.object">object</span> labels, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Sum the weights of false positives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="false_positives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>false_positives</strong>(<span title="System.object">object</span> labels, <span title="System.object">object</span> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Sum the weights of false positives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="false_positives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>false_positives</strong>(<span title="System.double">double</span> labels, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Sum the weights of false positives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.double">double</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="false_positives_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>false_positives_at_thresholds</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span> thresholds, <span title="System.Nullable<ValueTuple<object, object, object>>">Nullable&lt;ValueTuple&lt;object, object, object&gt;&gt;</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes false positives at provided threshold values. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>A `Tensor` whose shape matches `predictions`. Will be cast to
`bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.Nullable<ValueTuple<object, object, object>>">Nullable&lt;ValueTuple&lt;object, object, object&gt;&gt;</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `false_positives`
should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="false_positives_at_thresholds_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>false_positives_at_thresholds_dyn</strong>(<span title="System.object">object</span> labels, <span title="System.object">object</span> predictions, <span title="System.object">object</span> thresholds, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Computes false positives at provided threshold values. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>A `Tensor` whose shape matches `predictions`. Will be cast to
`bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `false_positives`
should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="false_positives_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>false_positives_dyn</strong>(<span title="System.object">object</span> labels, <span title="System.object">object</span> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Sum the weights of false positives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="mean" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>mean</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> values, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> name)
		</h4>
		<div class="content">Computes the (weighted) mean of the given values. <p></p> The `mean` function creates two local variables, `total` and `count`
that are used to compute the average of `values`. This average is ultimately
returned as `mean` which is an idempotent operation that simply divides
`total` by `count`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `mean`.
`update_op` increments `total` with the reduced sum of the product of `values`
and `weights`, and it increments `count` with the reduced sum of `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> values
						</dt>
						<dd>A `Tensor` of arbitrary dimensions. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`values`, and must be broadcastable to `values` (i.e., all dimensions must
be either `1`, or the same as the corresponding `values` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `mean`
should be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op`
should be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="mean" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>mean</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> values, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the (weighted) mean of the given values. <p></p> The `mean` function creates two local variables, `total` and `count`
that are used to compute the average of `values`. This average is ultimately
returned as `mean` which is an idempotent operation that simply divides
`total` by `count`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `mean`.
`update_op` increments `total` with the reduced sum of the product of `values`
and `weights`, and it increments `count` with the reduced sum of `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> values
						</dt>
						<dd>A `Tensor` of arbitrary dimensions. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`values`, and must be broadcastable to `values` (i.e., all dimensions must
be either `1`, or the same as the corresponding `values` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `mean`
should be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op`
should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="mean" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>mean</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> values, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the (weighted) mean of the given values. <p></p> The `mean` function creates two local variables, `total` and `count`
that are used to compute the average of `values`. This average is ultimately
returned as `mean` which is an idempotent operation that simply divides
`total` by `count`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `mean`.
`update_op` increments `total` with the reduced sum of the product of `values`
and `weights`, and it increments `count` with the reduced sum of `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> values
						</dt>
						<dd>A `Tensor` of arbitrary dimensions. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`values`, and must be broadcastable to `values` (i.e., all dimensions must
be either `1`, or the same as the corresponding `values` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `mean`
should be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op`
should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="mean" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>mean</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> values, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> name)
		</h4>
		<div class="content">Computes the (weighted) mean of the given values. <p></p> The `mean` function creates two local variables, `total` and `count`
that are used to compute the average of `values`. This average is ultimately
returned as `mean` which is an idempotent operation that simply divides
`total` by `count`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `mean`.
`update_op` increments `total` with the reduced sum of the product of `values`
and `weights`, and it increments `count` with the reduced sum of `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> values
						</dt>
						<dd>A `Tensor` of arbitrary dimensions. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`values`, and must be broadcastable to `values` (i.e., all dimensions must
be either `1`, or the same as the corresponding `values` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `mean`
should be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op`
should be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="mean_absolute_error" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>mean_absolute_error</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the mean absolute error between the labels and predictions. <p></p> The `mean_absolute_error` function creates two local variables,
`total` and `count` that are used to compute the mean absolute error. This
average is weighted by `weights`, and it is ultimately returned as
`mean_absolute_error`: an idempotent operation that simply divides `total` by
`count`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`mean_absolute_error`. Internally, an `absolute_errors` operation computes the
absolute value of the differences between `predictions` and `labels`. Then
`update_op` increments `total` with the reduced sum of the product of
`weights` and `absolute_errors`, and it increments `count` with the reduced
sum of `weights` <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>A `Tensor` of the same shape as `predictions`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A `Tensor` of arbitrary shape. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that
`mean_absolute_error` should be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="mean_absolute_error_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>mean_absolute_error_dyn</strong>(<span title="System.object">object</span> labels, <span title="System.object">object</span> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Computes the mean absolute error between the labels and predictions. <p></p> The `mean_absolute_error` function creates two local variables,
`total` and `count` that are used to compute the mean absolute error. This
average is weighted by `weights`, and it is ultimately returned as
`mean_absolute_error`: an idempotent operation that simply divides `total` by
`count`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`mean_absolute_error`. Internally, an `absolute_errors` operation computes the
absolute value of the differences between `predictions` and `labels`. Then
`update_op` increments `total` with the reduced sum of the product of
`weights` and `absolute_errors`, and it increments `count` with the reduced
sum of `weights` <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>A `Tensor` of the same shape as `predictions`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>A `Tensor` of arbitrary shape. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that
`mean_absolute_error` should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="mean_cosine_distance" class="method">
		<h4>
			<span title="System.object">object</span> <strong>mean_cosine_distance</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.int">int</span> dim, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the cosine distance between the labels and predictions. <p></p> The `mean_cosine_distance` function creates two local variables,
`total` and `count` that are used to compute the average cosine distance
between `predictions` and `labels`. This average is weighted by `weights`,
and it is ultimately returned as `mean_distance`, which is an idempotent
operation that simply divides `total` by `count`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`mean_distance`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>A `Tensor` of arbitrary shape. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A `Tensor` of the same shape as `labels`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> dim
						</dt>
						<dd>The dimension along which the cosine distance is computed. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). Also,
dimension `dim` must be `1`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="mean_cosine_distance_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>mean_cosine_distance_dyn</strong>(<span title="System.object">object</span> labels, <span title="System.object">object</span> predictions, <span title="System.object">object</span> dim, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Computes the cosine distance between the labels and predictions. <p></p> The `mean_cosine_distance` function creates two local variables,
`total` and `count` that are used to compute the average cosine distance
between `predictions` and `labels`. This average is weighted by `weights`,
and it is ultimately returned as `mean_distance`, which is an idempotent
operation that simply divides `total` by `count`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`mean_distance`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>A `Tensor` of arbitrary shape. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>A `Tensor` of the same shape as `labels`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> dim
						</dt>
						<dd>The dimension along which the cosine distance is computed. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). Also,
dimension `dim` must be `1`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="mean_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>mean_dyn</strong>(<span title="System.object">object</span> values, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Computes the (weighted) mean of the given values. <p></p> The `mean` function creates two local variables, `total` and `count`
that are used to compute the average of `values`. This average is ultimately
returned as `mean` which is an idempotent operation that simply divides
`total` by `count`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `mean`.
`update_op` increments `total` with the reduced sum of the product of `values`
and `weights`, and it increments `count` with the reduced sum of `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> values
						</dt>
						<dd>A `Tensor` of arbitrary dimensions. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`values`, and must be broadcastable to `values` (i.e., all dimensions must
be either `1`, or the same as the corresponding `values` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `mean`
should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op`
should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="mean_iou" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>mean_iou</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.int">int</span> num_classes, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Calculate per-step mean Intersection-Over-Union (mIOU). <p></p> Mean Intersection-Over-Union is a common evaluation metric for
semantic image segmentation, which first computes the IOU for each
semantic class and then computes the average over classes.
IOU is defined as follows:
IOU = true_positive / (true_positive + false_positive + false_negative).
The predictions are accumulated in a confusion matrix, weighted by `weights`,
and mIOU is then calculated from it. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `mean_iou`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>A `Tensor` of ground truth labels with shape [batch size] and of
type `int32` or `int64`. The tensor will be flattened if its rank > 1. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A `Tensor` of prediction results for semantic labels, whose
shape is [batch size] and type `int32` or `int64`. The tensor will be
flattened if its rank > 1. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_classes
						</dt>
						<dd>The possible number of labels the prediction task can
have. This value must be provided, since a confusion matrix of
dimension = [num_classes, num_classes] will be allocated. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `mean_iou`
should be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections `update_op` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="mean_iou" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>mean_iou</strong>(<span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> labels, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> predictions, <span title="System.int">int</span> num_classes, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Calculate per-step mean Intersection-Over-Union (mIOU). <p></p> Mean Intersection-Over-Union is a common evaluation metric for
semantic image segmentation, which first computes the IOU for each
semantic class and then computes the average over classes.
IOU is defined as follows:
IOU = true_positive / (true_positive + false_positive + false_negative).
The predictions are accumulated in a confusion matrix, weighted by `weights`,
and mIOU is then calculated from it. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `mean_iou`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> labels
						</dt>
						<dd>A `Tensor` of ground truth labels with shape [batch size] and of
type `int32` or `int64`. The tensor will be flattened if its rank > 1. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> predictions
						</dt>
						<dd>A `Tensor` of prediction results for semantic labels, whose
shape is [batch size] and type `int32` or `int64`. The tensor will be
flattened if its rank > 1. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_classes
						</dt>
						<dd>The possible number of labels the prediction task can
have. This value must be provided, since a confusion matrix of
dimension = [num_classes, num_classes] will be allocated. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `mean_iou`
should be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections `update_op` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="mean_iou" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>mean_iou</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> predictions, <span title="System.int">int</span> num_classes, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Calculate per-step mean Intersection-Over-Union (mIOU). <p></p> Mean Intersection-Over-Union is a common evaluation metric for
semantic image segmentation, which first computes the IOU for each
semantic class and then computes the average over classes.
IOU is defined as follows:
IOU = true_positive / (true_positive + false_positive + false_negative).
The predictions are accumulated in a confusion matrix, weighted by `weights`,
and mIOU is then calculated from it. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `mean_iou`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>A `Tensor` of ground truth labels with shape [batch size] and of
type `int32` or `int64`. The tensor will be flattened if its rank > 1. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> predictions
						</dt>
						<dd>A `Tensor` of prediction results for semantic labels, whose
shape is [batch size] and type `int32` or `int64`. The tensor will be
flattened if its rank > 1. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_classes
						</dt>
						<dd>The possible number of labels the prediction task can
have. This value must be provided, since a confusion matrix of
dimension = [num_classes, num_classes] will be allocated. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `mean_iou`
should be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections `update_op` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="mean_iou" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>mean_iou</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> predictions, <span title="System.int">int</span> num_classes, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Calculate per-step mean Intersection-Over-Union (mIOU). <p></p> Mean Intersection-Over-Union is a common evaluation metric for
semantic image segmentation, which first computes the IOU for each
semantic class and then computes the average over classes.
IOU is defined as follows:
IOU = true_positive / (true_positive + false_positive + false_negative).
The predictions are accumulated in a confusion matrix, weighted by `weights`,
and mIOU is then calculated from it. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `mean_iou`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>A `Tensor` of ground truth labels with shape [batch size] and of
type `int32` or `int64`. The tensor will be flattened if its rank > 1. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> predictions
						</dt>
						<dd>A `Tensor` of prediction results for semantic labels, whose
shape is [batch size] and type `int32` or `int64`. The tensor will be
flattened if its rank > 1. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_classes
						</dt>
						<dd>The possible number of labels the prediction task can
have. This value must be provided, since a confusion matrix of
dimension = [num_classes, num_classes] will be allocated. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `mean_iou`
should be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections `update_op` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="mean_iou" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>mean_iou</strong>(<span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.int">int</span> num_classes, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Calculate per-step mean Intersection-Over-Union (mIOU). <p></p> Mean Intersection-Over-Union is a common evaluation metric for
semantic image segmentation, which first computes the IOU for each
semantic class and then computes the average over classes.
IOU is defined as follows:
IOU = true_positive / (true_positive + false_positive + false_negative).
The predictions are accumulated in a confusion matrix, weighted by `weights`,
and mIOU is then calculated from it. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `mean_iou`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> labels
						</dt>
						<dd>A `Tensor` of ground truth labels with shape [batch size] and of
type `int32` or `int64`. The tensor will be flattened if its rank > 1. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A `Tensor` of prediction results for semantic labels, whose
shape is [batch size] and type `int32` or `int64`. The tensor will be
flattened if its rank > 1. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_classes
						</dt>
						<dd>The possible number of labels the prediction task can
have. This value must be provided, since a confusion matrix of
dimension = [num_classes, num_classes] will be allocated. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `mean_iou`
should be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections `update_op` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="mean_iou" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>mean_iou</strong>(<span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> labels, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> predictions, <span title="System.int">int</span> num_classes, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Calculate per-step mean Intersection-Over-Union (mIOU). <p></p> Mean Intersection-Over-Union is a common evaluation metric for
semantic image segmentation, which first computes the IOU for each
semantic class and then computes the average over classes.
IOU is defined as follows:
IOU = true_positive / (true_positive + false_positive + false_negative).
The predictions are accumulated in a confusion matrix, weighted by `weights`,
and mIOU is then calculated from it. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `mean_iou`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> labels
						</dt>
						<dd>A `Tensor` of ground truth labels with shape [batch size] and of
type `int32` or `int64`. The tensor will be flattened if its rank > 1. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> predictions
						</dt>
						<dd>A `Tensor` of prediction results for semantic labels, whose
shape is [batch size] and type `int32` or `int64`. The tensor will be
flattened if its rank > 1. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_classes
						</dt>
						<dd>The possible number of labels the prediction task can
have. This value must be provided, since a confusion matrix of
dimension = [num_classes, num_classes] will be allocated. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `mean_iou`
should be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections `update_op` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="mean_iou" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>mean_iou</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.int">int</span> num_classes, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Calculate per-step mean Intersection-Over-Union (mIOU). <p></p> Mean Intersection-Over-Union is a common evaluation metric for
semantic image segmentation, which first computes the IOU for each
semantic class and then computes the average over classes.
IOU is defined as follows:
IOU = true_positive / (true_positive + false_positive + false_negative).
The predictions are accumulated in a confusion matrix, weighted by `weights`,
and mIOU is then calculated from it. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `mean_iou`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>A `Tensor` of ground truth labels with shape [batch size] and of
type `int32` or `int64`. The tensor will be flattened if its rank > 1. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A `Tensor` of prediction results for semantic labels, whose
shape is [batch size] and type `int32` or `int64`. The tensor will be
flattened if its rank > 1. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_classes
						</dt>
						<dd>The possible number of labels the prediction task can
have. This value must be provided, since a confusion matrix of
dimension = [num_classes, num_classes] will be allocated. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `mean_iou`
should be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections `update_op` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="mean_iou" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>mean_iou</strong>(<span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.int">int</span> num_classes, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Calculate per-step mean Intersection-Over-Union (mIOU). <p></p> Mean Intersection-Over-Union is a common evaluation metric for
semantic image segmentation, which first computes the IOU for each
semantic class and then computes the average over classes.
IOU is defined as follows:
IOU = true_positive / (true_positive + false_positive + false_negative).
The predictions are accumulated in a confusion matrix, weighted by `weights`,
and mIOU is then calculated from it. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `mean_iou`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> labels
						</dt>
						<dd>A `Tensor` of ground truth labels with shape [batch size] and of
type `int32` or `int64`. The tensor will be flattened if its rank > 1. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A `Tensor` of prediction results for semantic labels, whose
shape is [batch size] and type `int32` or `int64`. The tensor will be
flattened if its rank > 1. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_classes
						</dt>
						<dd>The possible number of labels the prediction task can
have. This value must be provided, since a confusion matrix of
dimension = [num_classes, num_classes] will be allocated. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `mean_iou`
should be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections `update_op` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="mean_iou_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>mean_iou_dyn</strong>(<span title="System.object">object</span> labels, <span title="System.object">object</span> predictions, <span title="System.object">object</span> num_classes, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Calculate per-step mean Intersection-Over-Union (mIOU). <p></p> Mean Intersection-Over-Union is a common evaluation metric for
semantic image segmentation, which first computes the IOU for each
semantic class and then computes the average over classes.
IOU is defined as follows:
IOU = true_positive / (true_positive + false_positive + false_negative).
The predictions are accumulated in a confusion matrix, weighted by `weights`,
and mIOU is then calculated from it. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `mean_iou`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>A `Tensor` of ground truth labels with shape [batch size] and of
type `int32` or `int64`. The tensor will be flattened if its rank > 1. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>A `Tensor` of prediction results for semantic labels, whose
shape is [batch size] and type `int32` or `int64`. The tensor will be
flattened if its rank > 1. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> num_classes
						</dt>
						<dd>The possible number of labels the prediction task can
have. This value must be provided, since a confusion matrix of
dimension = [num_classes, num_classes] will be allocated. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `mean_iou`
should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections `update_op` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="mean_per_class_accuracy" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>mean_per_class_accuracy</strong>(<span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.int">int</span> num_classes, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Calculates the mean of the per-class accuracies. <p></p> Calculates the accuracy for each class, then takes the mean of that. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates the accuracy of each class and returns
them. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> labels
						</dt>
						<dd>A `Tensor` of ground truth labels with shape [batch size] and of
type `int32` or `int64`. The tensor will be flattened if its rank > 1. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A `Tensor` of prediction results for semantic labels, whose
shape is [batch size] and type `int32` or `int64`. The tensor will be
flattened if its rank > 1. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_classes
						</dt>
						<dd>The possible number of labels the prediction task can
have. This value must be provided, since two variables with shape =
[num_classes] will be allocated. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that
`mean_per_class_accuracy'
should be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections `update_op` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="mean_per_class_accuracy" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>mean_per_class_accuracy</strong>(<a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.int">int</span> num_classes, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Calculates the mean of the per-class accuracies. <p></p> Calculates the accuracy for each class, then takes the mean of that. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates the accuracy of each class and returns
them. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> labels
						</dt>
						<dd>A `Tensor` of ground truth labels with shape [batch size] and of
type `int32` or `int64`. The tensor will be flattened if its rank > 1. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A `Tensor` of prediction results for semantic labels, whose
shape is [batch size] and type `int32` or `int64`. The tensor will be
flattened if its rank > 1. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_classes
						</dt>
						<dd>The possible number of labels the prediction task can
have. This value must be provided, since two variables with shape =
[num_classes] will be allocated. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that
`mean_per_class_accuracy'
should be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections `update_op` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="mean_per_class_accuracy" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>mean_per_class_accuracy</strong>(<a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> labels, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> predictions, <span title="System.int">int</span> num_classes, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Calculates the mean of the per-class accuracies. <p></p> Calculates the accuracy for each class, then takes the mean of that. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates the accuracy of each class and returns
them. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> labels
						</dt>
						<dd>A `Tensor` of ground truth labels with shape [batch size] and of
type `int32` or `int64`. The tensor will be flattened if its rank > 1. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> predictions
						</dt>
						<dd>A `Tensor` of prediction results for semantic labels, whose
shape is [batch size] and type `int32` or `int64`. The tensor will be
flattened if its rank > 1. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_classes
						</dt>
						<dd>The possible number of labels the prediction task can
have. This value must be provided, since two variables with shape =
[num_classes] will be allocated. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that
`mean_per_class_accuracy'
should be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections `update_op` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="mean_per_class_accuracy" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>mean_per_class_accuracy</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> predictions, <span title="System.int">int</span> num_classes, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Calculates the mean of the per-class accuracies. <p></p> Calculates the accuracy for each class, then takes the mean of that. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates the accuracy of each class and returns
them. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>A `Tensor` of ground truth labels with shape [batch size] and of
type `int32` or `int64`. The tensor will be flattened if its rank > 1. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> predictions
						</dt>
						<dd>A `Tensor` of prediction results for semantic labels, whose
shape is [batch size] and type `int32` or `int64`. The tensor will be
flattened if its rank > 1. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_classes
						</dt>
						<dd>The possible number of labels the prediction task can
have. This value must be provided, since two variables with shape =
[num_classes] will be allocated. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that
`mean_per_class_accuracy'
should be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections `update_op` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="mean_per_class_accuracy" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>mean_per_class_accuracy</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> predictions, <span title="System.int">int</span> num_classes, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Calculates the mean of the per-class accuracies. <p></p> Calculates the accuracy for each class, then takes the mean of that. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates the accuracy of each class and returns
them. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>A `Tensor` of ground truth labels with shape [batch size] and of
type `int32` or `int64`. The tensor will be flattened if its rank > 1. 
						</dd>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> predictions
						</dt>
						<dd>A `Tensor` of prediction results for semantic labels, whose
shape is [batch size] and type `int32` or `int64`. The tensor will be
flattened if its rank > 1. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_classes
						</dt>
						<dd>The possible number of labels the prediction task can
have. This value must be provided, since two variables with shape =
[num_classes] will be allocated. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that
`mean_per_class_accuracy'
should be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections `update_op` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="mean_per_class_accuracy" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>mean_per_class_accuracy</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.int">int</span> num_classes, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Calculates the mean of the per-class accuracies. <p></p> Calculates the accuracy for each class, then takes the mean of that. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates the accuracy of each class and returns
them. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>A `Tensor` of ground truth labels with shape [batch size] and of
type `int32` or `int64`. The tensor will be flattened if its rank > 1. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A `Tensor` of prediction results for semantic labels, whose
shape is [batch size] and type `int32` or `int64`. The tensor will be
flattened if its rank > 1. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_classes
						</dt>
						<dd>The possible number of labels the prediction task can
have. This value must be provided, since two variables with shape =
[num_classes] will be allocated. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that
`mean_per_class_accuracy'
should be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections `update_op` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="mean_per_class_accuracy" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>mean_per_class_accuracy</strong>(<a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> labels, <a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> predictions, <span title="System.int">int</span> num_classes, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Calculates the mean of the per-class accuracies. <p></p> Calculates the accuracy for each class, then takes the mean of that. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates the accuracy of each class and returns
them. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> labels
						</dt>
						<dd>A `Tensor` of ground truth labels with shape [batch size] and of
type `int32` or `int64`. The tensor will be flattened if its rank > 1. 
						</dd>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> predictions
						</dt>
						<dd>A `Tensor` of prediction results for semantic labels, whose
shape is [batch size] and type `int32` or `int64`. The tensor will be
flattened if its rank > 1. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_classes
						</dt>
						<dd>The possible number of labels the prediction task can
have. This value must be provided, since two variables with shape =
[num_classes] will be allocated. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that
`mean_per_class_accuracy'
should be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections `update_op` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="mean_per_class_accuracy" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>mean_per_class_accuracy</strong>(<span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> labels, <span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> predictions, <span title="System.int">int</span> num_classes, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Calculates the mean of the per-class accuracies. <p></p> Calculates the accuracy for each class, then takes the mean of that. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates the accuracy of each class and returns
them. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> labels
						</dt>
						<dd>A `Tensor` of ground truth labels with shape [batch size] and of
type `int32` or `int64`. The tensor will be flattened if its rank > 1. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> predictions
						</dt>
						<dd>A `Tensor` of prediction results for semantic labels, whose
shape is [batch size] and type `int32` or `int64`. The tensor will be
flattened if its rank > 1. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_classes
						</dt>
						<dd>The possible number of labels the prediction task can
have. This value must be provided, since two variables with shape =
[num_classes] will be allocated. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that
`mean_per_class_accuracy'
should be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections `update_op` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="mean_per_class_accuracy" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>mean_per_class_accuracy</strong>(<span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> labels, <a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> predictions, <span title="System.int">int</span> num_classes, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Calculates the mean of the per-class accuracies. <p></p> Calculates the accuracy for each class, then takes the mean of that. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates the accuracy of each class and returns
them. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> labels
						</dt>
						<dd>A `Tensor` of ground truth labels with shape [batch size] and of
type `int32` or `int64`. The tensor will be flattened if its rank > 1. 
						</dd>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> predictions
						</dt>
						<dd>A `Tensor` of prediction results for semantic labels, whose
shape is [batch size] and type `int32` or `int64`. The tensor will be
flattened if its rank > 1. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_classes
						</dt>
						<dd>The possible number of labels the prediction task can
have. This value must be provided, since two variables with shape =
[num_classes] will be allocated. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that
`mean_per_class_accuracy'
should be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections `update_op` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="mean_per_class_accuracy" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>mean_per_class_accuracy</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> predictions, <span title="System.int">int</span> num_classes, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Calculates the mean of the per-class accuracies. <p></p> Calculates the accuracy for each class, then takes the mean of that. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates the accuracy of each class and returns
them. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>A `Tensor` of ground truth labels with shape [batch size] and of
type `int32` or `int64`. The tensor will be flattened if its rank > 1. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> predictions
						</dt>
						<dd>A `Tensor` of prediction results for semantic labels, whose
shape is [batch size] and type `int32` or `int64`. The tensor will be
flattened if its rank > 1. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_classes
						</dt>
						<dd>The possible number of labels the prediction task can
have. This value must be provided, since two variables with shape =
[num_classes] will be allocated. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that
`mean_per_class_accuracy'
should be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections `update_op` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="mean_per_class_accuracy" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>mean_per_class_accuracy</strong>(<a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> labels, <span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> predictions, <span title="System.int">int</span> num_classes, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Calculates the mean of the per-class accuracies. <p></p> Calculates the accuracy for each class, then takes the mean of that. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates the accuracy of each class and returns
them. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> labels
						</dt>
						<dd>A `Tensor` of ground truth labels with shape [batch size] and of
type `int32` or `int64`. The tensor will be flattened if its rank > 1. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> predictions
						</dt>
						<dd>A `Tensor` of prediction results for semantic labels, whose
shape is [batch size] and type `int32` or `int64`. The tensor will be
flattened if its rank > 1. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_classes
						</dt>
						<dd>The possible number of labels the prediction task can
have. This value must be provided, since two variables with shape =
[num_classes] will be allocated. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that
`mean_per_class_accuracy'
should be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections `update_op` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="mean_per_class_accuracy" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>mean_per_class_accuracy</strong>(<span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> labels, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> predictions, <span title="System.int">int</span> num_classes, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Calculates the mean of the per-class accuracies. <p></p> Calculates the accuracy for each class, then takes the mean of that. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates the accuracy of each class and returns
them. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> labels
						</dt>
						<dd>A `Tensor` of ground truth labels with shape [batch size] and of
type `int32` or `int64`. The tensor will be flattened if its rank > 1. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> predictions
						</dt>
						<dd>A `Tensor` of prediction results for semantic labels, whose
shape is [batch size] and type `int32` or `int64`. The tensor will be
flattened if its rank > 1. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_classes
						</dt>
						<dd>The possible number of labels the prediction task can
have. This value must be provided, since two variables with shape =
[num_classes] will be allocated. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that
`mean_per_class_accuracy'
should be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections `update_op` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="mean_per_class_accuracy" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>mean_per_class_accuracy</strong>(<span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> labels, <a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> predictions, <span title="System.int">int</span> num_classes, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Calculates the mean of the per-class accuracies. <p></p> Calculates the accuracy for each class, then takes the mean of that. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates the accuracy of each class and returns
them. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> labels
						</dt>
						<dd>A `Tensor` of ground truth labels with shape [batch size] and of
type `int32` or `int64`. The tensor will be flattened if its rank > 1. 
						</dd>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> predictions
						</dt>
						<dd>A `Tensor` of prediction results for semantic labels, whose
shape is [batch size] and type `int32` or `int64`. The tensor will be
flattened if its rank > 1. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_classes
						</dt>
						<dd>The possible number of labels the prediction task can
have. This value must be provided, since two variables with shape =
[num_classes] will be allocated. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that
`mean_per_class_accuracy'
should be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections `update_op` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="mean_per_class_accuracy" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>mean_per_class_accuracy</strong>(<span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> labels, <span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> predictions, <span title="System.int">int</span> num_classes, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Calculates the mean of the per-class accuracies. <p></p> Calculates the accuracy for each class, then takes the mean of that. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates the accuracy of each class and returns
them. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> labels
						</dt>
						<dd>A `Tensor` of ground truth labels with shape [batch size] and of
type `int32` or `int64`. The tensor will be flattened if its rank > 1. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> predictions
						</dt>
						<dd>A `Tensor` of prediction results for semantic labels, whose
shape is [batch size] and type `int32` or `int64`. The tensor will be
flattened if its rank > 1. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_classes
						</dt>
						<dd>The possible number of labels the prediction task can
have. This value must be provided, since two variables with shape =
[num_classes] will be allocated. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that
`mean_per_class_accuracy'
should be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections `update_op` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="mean_per_class_accuracy" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>mean_per_class_accuracy</strong>(<span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> labels, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> predictions, <span title="System.int">int</span> num_classes, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Calculates the mean of the per-class accuracies. <p></p> Calculates the accuracy for each class, then takes the mean of that. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates the accuracy of each class and returns
them. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> labels
						</dt>
						<dd>A `Tensor` of ground truth labels with shape [batch size] and of
type `int32` or `int64`. The tensor will be flattened if its rank > 1. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> predictions
						</dt>
						<dd>A `Tensor` of prediction results for semantic labels, whose
shape is [batch size] and type `int32` or `int64`. The tensor will be
flattened if its rank > 1. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_classes
						</dt>
						<dd>The possible number of labels the prediction task can
have. This value must be provided, since two variables with shape =
[num_classes] will be allocated. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that
`mean_per_class_accuracy'
should be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections `update_op` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="mean_per_class_accuracy" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>mean_per_class_accuracy</strong>(<span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.int">int</span> num_classes, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Calculates the mean of the per-class accuracies. <p></p> Calculates the accuracy for each class, then takes the mean of that. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates the accuracy of each class and returns
them. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> labels
						</dt>
						<dd>A `Tensor` of ground truth labels with shape [batch size] and of
type `int32` or `int64`. The tensor will be flattened if its rank > 1. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A `Tensor` of prediction results for semantic labels, whose
shape is [batch size] and type `int32` or `int64`. The tensor will be
flattened if its rank > 1. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_classes
						</dt>
						<dd>The possible number of labels the prediction task can
have. This value must be provided, since two variables with shape =
[num_classes] will be allocated. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that
`mean_per_class_accuracy'
should be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections `update_op` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="mean_per_class_accuracy_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>mean_per_class_accuracy_dyn</strong>(<span title="System.object">object</span> labels, <span title="System.object">object</span> predictions, <span title="System.object">object</span> num_classes, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Calculates the mean of the per-class accuracies. <p></p> Calculates the accuracy for each class, then takes the mean of that. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates the accuracy of each class and returns
them. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>A `Tensor` of ground truth labels with shape [batch size] and of
type `int32` or `int64`. The tensor will be flattened if its rank > 1. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>A `Tensor` of prediction results for semantic labels, whose
shape is [batch size] and type `int32` or `int64`. The tensor will be
flattened if its rank > 1. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> num_classes
						</dt>
						<dd>The possible number of labels the prediction task can
have. This value must be provided, since two variables with shape =
[num_classes] will be allocated. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that
`mean_per_class_accuracy'
should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections `update_op` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="mean_relative_error" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>mean_relative_error</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> normalizer, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the mean relative error by normalizing with the given values. <p></p> The `mean_relative_error` function creates two local variables,
`total` and `count` that are used to compute the mean relative absolute error.
This average is weighted by `weights`, and it is ultimately returned as
`mean_relative_error`: an idempotent operation that simply divides `total` by
`count`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`mean_reative_error`. Internally, a `relative_errors` operation divides the
absolute value of the differences between `predictions` and `labels` by the
`normalizer`. Then `update_op` increments `total` with the reduced sum of the
product of `weights` and `relative_errors`, and it increments `count` with the
reduced sum of `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>A `Tensor` of the same shape as `predictions`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A `Tensor` of arbitrary shape. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> normalizer
						</dt>
						<dd>A `Tensor` of the same shape as `predictions`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that
`mean_relative_error` should be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="mean_relative_error_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>mean_relative_error_dyn</strong>(<span title="System.object">object</span> labels, <span title="System.object">object</span> predictions, <span title="System.object">object</span> normalizer, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Computes the mean relative error by normalizing with the given values. <p></p> The `mean_relative_error` function creates two local variables,
`total` and `count` that are used to compute the mean relative absolute error.
This average is weighted by `weights`, and it is ultimately returned as
`mean_relative_error`: an idempotent operation that simply divides `total` by
`count`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`mean_reative_error`. Internally, a `relative_errors` operation divides the
absolute value of the differences between `predictions` and `labels` by the
`normalizer`. Then `update_op` increments `total` with the reduced sum of the
product of `weights` and `relative_errors`, and it increments `count` with the
reduced sum of `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>A `Tensor` of the same shape as `predictions`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>A `Tensor` of arbitrary shape. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> normalizer
						</dt>
						<dd>A `Tensor` of the same shape as `predictions`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that
`mean_relative_error` should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="mean_squared_error" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>mean_squared_error</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the mean squared error between the labels and predictions. <p></p> The `mean_squared_error` function creates two local variables,
`total` and `count` that are used to compute the mean squared error.
This average is weighted by `weights`, and it is ultimately returned as
`mean_squared_error`: an idempotent operation that simply divides `total` by
`count`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`mean_squared_error`. Internally, a `squared_error` operation computes the
element-wise square of the difference between `predictions` and `labels`. Then
`update_op` increments `total` with the reduced sum of the product of
`weights` and `squared_error`, and it increments `count` with the reduced sum
of `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>A `Tensor` of the same shape as `predictions`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A `Tensor` of arbitrary shape. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that
`mean_squared_error` should be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="mean_squared_error_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>mean_squared_error_dyn</strong>(<span title="System.object">object</span> labels, <span title="System.object">object</span> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Computes the mean squared error between the labels and predictions. <p></p> The `mean_squared_error` function creates two local variables,
`total` and `count` that are used to compute the mean squared error.
This average is weighted by `weights`, and it is ultimately returned as
`mean_squared_error`: an idempotent operation that simply divides `total` by
`count`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`mean_squared_error`. Internally, a `squared_error` operation computes the
element-wise square of the difference between `predictions` and `labels`. Then
`update_op` increments `total` with the reduced sum of the product of
`weights` and `squared_error`, and it increments `count` with the reduced sum
of `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>A `Tensor` of the same shape as `predictions`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>A `Tensor` of arbitrary shape. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that
`mean_squared_error` should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="mean_tensor" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>mean_tensor</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> values, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the element-wise (weighted) mean of the given tensors. <p></p> In contrast to the `mean` function which returns a scalar with the
mean,  this function returns an average tensor with the same shape as the
input tensors. <p></p> The `mean_tensor` function creates two local variables,
`total_tensor` and `count_tensor` that are used to compute the average of
`values`. This average is ultimately returned as `mean` which is an idempotent
operation that simply divides `total` by `count`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `mean`.
`update_op` increments `total` with the reduced sum of the product of `values`
and `weights`, and it increments `count` with the reduced sum of `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> values
						</dt>
						<dd>A `Tensor` of arbitrary dimensions. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`values`, and must be broadcastable to `values` (i.e., all dimensions must
be either `1`, or the same as the corresponding `values` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `mean`
should be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op`
should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="mean_tensor" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>mean_tensor</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> values, <span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the element-wise (weighted) mean of the given tensors. <p></p> In contrast to the `mean` function which returns a scalar with the
mean,  this function returns an average tensor with the same shape as the
input tensors. <p></p> The `mean_tensor` function creates two local variables,
`total_tensor` and `count_tensor` that are used to compute the average of
`values`. This average is ultimately returned as `mean` which is an idempotent
operation that simply divides `total` by `count`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `mean`.
`update_op` increments `total` with the reduced sum of the product of `values`
and `weights`, and it increments `count` with the reduced sum of `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> values
						</dt>
						<dd>A `Tensor` of arbitrary dimensions. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`values`, and must be broadcastable to `values` (i.e., all dimensions must
be either `1`, or the same as the corresponding `values` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `mean`
should be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op`
should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="mean_tensor" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>mean_tensor</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> values, <a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the element-wise (weighted) mean of the given tensors. <p></p> In contrast to the `mean` function which returns a scalar with the
mean,  this function returns an average tensor with the same shape as the
input tensors. <p></p> The `mean_tensor` function creates two local variables,
`total_tensor` and `count_tensor` that are used to compute the average of
`values`. This average is ultimately returned as `mean` which is an idempotent
operation that simply divides `total` by `count`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `mean`.
`update_op` increments `total` with the reduced sum of the product of `values`
and `weights`, and it increments `count` with the reduced sum of `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> values
						</dt>
						<dd>A `Tensor` of arbitrary dimensions. 
						</dd>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`values`, and must be broadcastable to `values` (i.e., all dimensions must
be either `1`, or the same as the corresponding `values` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `mean`
should be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op`
should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="mean_tensor" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>mean_tensor</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> values, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the element-wise (weighted) mean of the given tensors. <p></p> In contrast to the `mean` function which returns a scalar with the
mean,  this function returns an average tensor with the same shape as the
input tensors. <p></p> The `mean_tensor` function creates two local variables,
`total_tensor` and `count_tensor` that are used to compute the average of
`values`. This average is ultimately returned as `mean` which is an idempotent
operation that simply divides `total` by `count`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `mean`.
`update_op` increments `total` with the reduced sum of the product of `values`
and `weights`, and it increments `count` with the reduced sum of `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> values
						</dt>
						<dd>A `Tensor` of arbitrary dimensions. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`values`, and must be broadcastable to `values` (i.e., all dimensions must
be either `1`, or the same as the corresponding `values` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `mean`
should be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op`
should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="mean_tensor_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>mean_tensor_dyn</strong>(<span title="System.object">object</span> values, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Computes the element-wise (weighted) mean of the given tensors. <p></p> In contrast to the `mean` function which returns a scalar with the
mean,  this function returns an average tensor with the same shape as the
input tensors. <p></p> The `mean_tensor` function creates two local variables,
`total_tensor` and `count_tensor` that are used to compute the average of
`values`. This average is ultimately returned as `mean` which is an idempotent
operation that simply divides `total` by `count`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `mean`.
`update_op` increments `total` with the reduced sum of the product of `values`
and `weights`, and it increments `count` with the reduced sum of `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> values
						</dt>
						<dd>A `Tensor` of arbitrary dimensions. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`values`, and must be broadcastable to `values` (i.e., all dimensions must
be either `1`, or the same as the corresponding `values` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `mean`
should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op`
should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="percentage_below" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>percentage_below</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> values, <span title="System.int">int</span> threshold, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the percentage of values less than the given threshold. <p></p> The `percentage_below` function creates two local variables,
`total` and `count` that are used to compute the percentage of `values` that
fall below `threshold`. This rate is weighted by `weights`, and it is
ultimately returned as `percentage` which is an idempotent operation that
simply divides `total` by `count`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`percentage`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> values
						</dt>
						<dd>A numeric `Tensor` of arbitrary size. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> threshold
						</dt>
						<dd>A scalar threshold. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`values`, and must be broadcastable to `values` (i.e., all dimensions must
be either `1`, or the same as the corresponding `values` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="percentage_below_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>percentage_below_dyn</strong>(<span title="System.object">object</span> values, <span title="System.object">object</span> threshold, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Computes the percentage of values less than the given threshold. <p></p> The `percentage_below` function creates two local variables,
`total` and `count` that are used to compute the percentage of `values` that
fall below `threshold`. This rate is weighted by `weights`, and it is
ultimately returned as `percentage` which is an idempotent operation that
simply divides `total` by `count`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`percentage`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> values
						</dt>
						<dd>A numeric `Tensor` of arbitrary size. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> threshold
						</dt>
						<dd>A scalar threshold. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`values`, and must be broadcastable to `values` (i.e., all dimensions must
be either `1`, or the same as the corresponding `values` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> labels, <span title="System.object">object</span> predictions, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the precision of the predictions with respect to the labels. <p></p> The `precision` function creates two local variables,
`true_positives` and `false_positives`, that are used to compute the
precision. This value is ultimately returned as `precision`, an idempotent
operation that simply divides `true_positives` by the sum of `true_positives`
and `false_positives`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. `update_op` weights each prediction by the corresponding value in
`weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `precision` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision</strong>(<a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> labels, <span title="System.object">object</span> predictions, <span title="System.int">int</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the precision of the predictions with respect to the labels. <p></p> The `precision` function creates two local variables,
`true_positives` and `false_positives`, that are used to compute the
precision. This value is ultimately returned as `precision`, an idempotent
operation that simply divides `true_positives` by the sum of `true_positives`
and `false_positives`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. `update_op` weights each prediction by the corresponding value in
`weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `precision` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision</strong>(<span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> labels, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> predictions, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the precision of the predictions with respect to the labels. <p></p> The `precision` function creates two local variables,
`true_positives` and `false_positives`, that are used to compute the
precision. This value is ultimately returned as `precision`, an idempotent
operation that simply divides `true_positives` by the sum of `true_positives`
and `false_positives`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. `update_op` weights each prediction by the corresponding value in
`weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `precision` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision</strong>(<span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> labels, <span title="System.object">object</span> predictions, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the precision of the predictions with respect to the labels. <p></p> The `precision` function creates two local variables,
`true_positives` and `false_positives`, that are used to compute the
precision. This value is ultimately returned as `precision`, an idempotent
operation that simply divides `true_positives` by the sum of `true_positives`
and `false_positives`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. `update_op` weights each prediction by the corresponding value in
`weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `precision` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision</strong>(<span title="System.object">object</span> labels, <span title="System.object">object</span> predictions, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the precision of the predictions with respect to the labels. <p></p> The `precision` function creates two local variables,
`true_positives` and `false_positives`, that are used to compute the
precision. This value is ultimately returned as `precision`, an idempotent
operation that simply divides `true_positives` by the sum of `true_positives`
and `false_positives`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. `update_op` weights each prediction by the corresponding value in
`weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `precision` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision</strong>(<span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> labels, <span title="System.object">object</span> predictions, <span title="System.int">int</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the precision of the predictions with respect to the labels. <p></p> The `precision` function creates two local variables,
`true_positives` and `false_positives`, that are used to compute the
precision. This value is ultimately returned as `precision`, an idempotent
operation that simply divides `true_positives` by the sum of `true_positives`
and `false_positives`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. `update_op` weights each prediction by the corresponding value in
`weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `precision` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision</strong>(<a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> labels, <span title="System.object">object</span> predictions, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the precision of the predictions with respect to the labels. <p></p> The `precision` function creates two local variables,
`true_positives` and `false_positives`, that are used to compute the
precision. This value is ultimately returned as `precision`, an idempotent
operation that simply divides `true_positives` by the sum of `true_positives`
and `false_positives`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. `update_op` weights each prediction by the corresponding value in
`weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `precision` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision</strong>(<span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> labels, <span title="System.object">object</span> predictions, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the precision of the predictions with respect to the labels. <p></p> The `precision` function creates two local variables,
`true_positives` and `false_positives`, that are used to compute the
precision. This value is ultimately returned as `precision`, an idempotent
operation that simply divides `true_positives` by the sum of `true_positives`
and `false_positives`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. `update_op` weights each prediction by the corresponding value in
`weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `precision` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision</strong>(<span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> labels, <span title="System.object">object</span> predictions, <span title="System.int">int</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the precision of the predictions with respect to the labels. <p></p> The `precision` function creates two local variables,
`true_positives` and `false_positives`, that are used to compute the
precision. This value is ultimately returned as `precision`, an idempotent
operation that simply divides `true_positives` by the sum of `true_positives`
and `false_positives`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. `update_op` weights each prediction by the corresponding value in
`weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `precision` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision</strong>(<span title="System.object">object</span> labels, <span title="System.object">object</span> predictions, <span title="System.int">int</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the precision of the predictions with respect to the labels. <p></p> The `precision` function creates two local variables,
`true_positives` and `false_positives`, that are used to compute the
precision. This value is ultimately returned as `precision`, an idempotent
operation that simply divides `true_positives` by the sum of `true_positives`
and `false_positives`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. `update_op` weights each prediction by the corresponding value in
`weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `precision` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision</strong>(<span title="System.object">object</span> labels, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> predictions, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the precision of the predictions with respect to the labels. <p></p> The `precision` function creates two local variables,
`true_positives` and `false_positives`, that are used to compute the
precision. This value is ultimately returned as `precision`, an idempotent
operation that simply divides `true_positives` by the sum of `true_positives`
and `false_positives`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. `update_op` weights each prediction by the corresponding value in
`weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `precision` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision</strong>(<span title="System.object">object</span> labels, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> predictions, <span title="System.int">int</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the precision of the predictions with respect to the labels. <p></p> The `precision` function creates two local variables,
`true_positives` and `false_positives`, that are used to compute the
precision. This value is ultimately returned as `precision`, an idempotent
operation that simply divides `true_positives` by the sum of `true_positives`
and `false_positives`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. `update_op` weights each prediction by the corresponding value in
`weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `precision` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <span title="System.object">object</span> predictions, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the precision of the predictions with respect to the labels. <p></p> The `precision` function creates two local variables,
`true_positives` and `false_positives`, that are used to compute the
precision. This value is ultimately returned as `precision`, an idempotent
operation that simply divides `true_positives` by the sum of `true_positives`
and `false_positives`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. `update_op` weights each prediction by the corresponding value in
`weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `precision` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision</strong>(<span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> labels, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> predictions, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the precision of the predictions with respect to the labels. <p></p> The `precision` function creates two local variables,
`true_positives` and `false_positives`, that are used to compute the
precision. This value is ultimately returned as `precision`, an idempotent
operation that simply divides `true_positives` by the sum of `true_positives`
and `false_positives`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. `update_op` weights each prediction by the corresponding value in
`weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `precision` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> labels, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> predictions, <span title="System.int">int</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the precision of the predictions with respect to the labels. <p></p> The `precision` function creates two local variables,
`true_positives` and `false_positives`, that are used to compute the
precision. This value is ultimately returned as `precision`, an idempotent
operation that simply divides `true_positives` by the sum of `true_positives`
and `false_positives`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. `update_op` weights each prediction by the corresponding value in
`weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `precision` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <span title="System.object">object</span> predictions, <span title="System.int">int</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the precision of the predictions with respect to the labels. <p></p> The `precision` function creates two local variables,
`true_positives` and `false_positives`, that are used to compute the
precision. This value is ultimately returned as `precision`, an idempotent
operation that simply divides `true_positives` by the sum of `true_positives`
and `false_positives`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. `update_op` weights each prediction by the corresponding value in
`weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `precision` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision</strong>(<span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> labels, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> predictions, <span title="System.int">int</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the precision of the predictions with respect to the labels. <p></p> The `precision` function creates two local variables,
`true_positives` and `false_positives`, that are used to compute the
precision. This value is ultimately returned as `precision`, an idempotent
operation that simply divides `true_positives` by the sum of `true_positives`
and `false_positives`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. `update_op` weights each prediction by the corresponding value in
`weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `precision` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> labels, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> predictions, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the precision of the predictions with respect to the labels. <p></p> The `precision` function creates two local variables,
`true_positives` and `false_positives`, that are used to compute the
precision. This value is ultimately returned as `precision`, an idempotent
operation that simply divides `true_positives` by the sum of `true_positives`
and `false_positives`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. `update_op` weights each prediction by the corresponding value in
`weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `precision` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> predictions, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the precision of the predictions with respect to the labels. <p></p> The `precision` function creates two local variables,
`true_positives` and `false_positives`, that are used to compute the
precision. This value is ultimately returned as `precision`, an idempotent
operation that simply divides `true_positives` by the sum of `true_positives`
and `false_positives`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. `update_op` weights each prediction by the corresponding value in
`weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `precision` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> labels, <span title="System.object">object</span> predictions, <span title="System.int">int</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the precision of the predictions with respect to the labels. <p></p> The `precision` function creates two local variables,
`true_positives` and `false_positives`, that are used to compute the
precision. This value is ultimately returned as `precision`, an idempotent
operation that simply divides `true_positives` by the sum of `true_positives`
and `false_positives`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. `update_op` weights each prediction by the corresponding value in
`weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `precision` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> predictions, <span title="System.int">int</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the precision of the predictions with respect to the labels. <p></p> The `precision` function creates two local variables,
`true_positives` and `false_positives`, that are used to compute the
precision. This value is ultimately returned as `precision`, an idempotent
operation that simply divides `true_positives` by the sum of `true_positives`
and `false_positives`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. `update_op` weights each prediction by the corresponding value in
`weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `precision` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision</strong>(<span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> labels, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> predictions, <span title="System.int">int</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the precision of the predictions with respect to the labels. <p></p> The `precision` function creates two local variables,
`true_positives` and `false_positives`, that are used to compute the
precision. This value is ultimately returned as `precision`, an idempotent
operation that simply divides `true_positives` by the sum of `true_positives`
and `false_positives`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. `update_op` weights each prediction by the corresponding value in
`weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `precision` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision</strong>(<a href="../numpy/ndarray.htm">ndarray</a> labels, <span title="System.object">object</span> predictions, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the precision of the predictions with respect to the labels. <p></p> The `precision` function creates two local variables,
`true_positives` and `false_positives`, that are used to compute the
precision. This value is ultimately returned as `precision`, an idempotent
operation that simply divides `true_positives` by the sum of `true_positives`
and `false_positives`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. `update_op` weights each prediction by the corresponding value in
`weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `precision` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision</strong>(<span title="System.double">double</span> labels, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> predictions, <span title="System.int">int</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the precision of the predictions with respect to the labels. <p></p> The `precision` function creates two local variables,
`true_positives` and `false_positives`, that are used to compute the
precision. This value is ultimately returned as `precision`, an idempotent
operation that simply divides `true_positives` by the sum of `true_positives`
and `false_positives`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. `update_op` weights each prediction by the corresponding value in
`weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.double">double</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `precision` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision</strong>(<a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> labels, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> predictions, <span title="System.int">int</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the precision of the predictions with respect to the labels. <p></p> The `precision` function creates two local variables,
`true_positives` and `false_positives`, that are used to compute the
precision. This value is ultimately returned as `precision`, an idempotent
operation that simply divides `true_positives` by the sum of `true_positives`
and `false_positives`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. `update_op` weights each prediction by the corresponding value in
`weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `precision` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision</strong>(<span title="System.double">double</span> labels, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> predictions, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the precision of the predictions with respect to the labels. <p></p> The `precision` function creates two local variables,
`true_positives` and `false_positives`, that are used to compute the
precision. This value is ultimately returned as `precision`, an idempotent
operation that simply divides `true_positives` by the sum of `true_positives`
and `false_positives`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. `update_op` weights each prediction by the corresponding value in
`weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.double">double</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `precision` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision</strong>(<span title="System.double">double</span> labels, <span title="System.object">object</span> predictions, <span title="System.int">int</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the precision of the predictions with respect to the labels. <p></p> The `precision` function creates two local variables,
`true_positives` and `false_positives`, that are used to compute the
precision. This value is ultimately returned as `precision`, an idempotent
operation that simply divides `true_positives` by the sum of `true_positives`
and `false_positives`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. `update_op` weights each prediction by the corresponding value in
`weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.double">double</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `precision` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision</strong>(<span title="System.double">double</span> labels, <span title="System.object">object</span> predictions, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the precision of the predictions with respect to the labels. <p></p> The `precision` function creates two local variables,
`true_positives` and `false_positives`, that are used to compute the
precision. This value is ultimately returned as `precision`, an idempotent
operation that simply divides `true_positives` by the sum of `true_positives`
and `false_positives`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. `update_op` weights each prediction by the corresponding value in
`weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.double">double</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `precision` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision</strong>(<a href="../numpy/ndarray.htm">ndarray</a> labels, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> predictions, <span title="System.int">int</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the precision of the predictions with respect to the labels. <p></p> The `precision` function creates two local variables,
`true_positives` and `false_positives`, that are used to compute the
precision. This value is ultimately returned as `precision`, an idempotent
operation that simply divides `true_positives` by the sum of `true_positives`
and `false_positives`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. `update_op` weights each prediction by the corresponding value in
`weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `precision` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision</strong>(<a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> labels, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> predictions, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the precision of the predictions with respect to the labels. <p></p> The `precision` function creates two local variables,
`true_positives` and `false_positives`, that are used to compute the
precision. This value is ultimately returned as `precision`, an idempotent
operation that simply divides `true_positives` by the sum of `true_positives`
and `false_positives`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. `update_op` weights each prediction by the corresponding value in
`weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `precision` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision</strong>(<a href="../numpy/ndarray.htm">ndarray</a> labels, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> predictions, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the precision of the predictions with respect to the labels. <p></p> The `precision` function creates two local variables,
`true_positives` and `false_positives`, that are used to compute the
precision. This value is ultimately returned as `precision`, an idempotent
operation that simply divides `true_positives` by the sum of `true_positives`
and `false_positives`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. `update_op` weights each prediction by the corresponding value in
`weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `precision` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision</strong>(<a href="../numpy/ndarray.htm">ndarray</a> labels, <span title="System.object">object</span> predictions, <span title="System.int">int</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the precision of the predictions with respect to the labels. <p></p> The `precision` function creates two local variables,
`true_positives` and `false_positives`, that are used to compute the
precision. This value is ultimately returned as `precision`, an idempotent
operation that simply divides `true_positives` by the sum of `true_positives`
and `false_positives`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. `update_op` weights each prediction by the corresponding value in
`weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `precision` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision_at_k" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>precision_at_k</strong>(<span title="System.object">object</span> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.int">int</span> k, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> class_id, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes precision@k of the predictions with respect to sparse labels. <p></p> If `class_id` is specified, we calculate precision by considering only the
entries in the batch for which `class_id` is in the top-k highest
`predictions`, and computing the fraction of them for which `class_id` is
indeed a correct label.
If `class_id` is not specified, we'll calculate precision as how often on
average a class among the top-k classes with the highest predicted values
of a batch entry is correct and can be found in the label for that entry. <p></p> `precision_at_k` creates two local variables,
`true_positive_at_<k>` and `false_positive_at_<k>`, that are used to compute
the precision@k frequency. This frequency is ultimately returned as
`precision_at_<k>`: an idempotent operation that simply divides
`true_positive_at_<k>` by total (`true_positive_at_<k>` +
`false_positive_at_<k>`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision_at_<k>`. Internally, a `top_k` operation computes a `Tensor`
indicating the top `k` `predictions`. Set operations applied to `top_k` and
`labels` calculate the true positives and false positives weighted by
`weights`. Then `update_op` increments `true_positive_at_<k>` and
`false_positive_at_<k>` using these values. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>`int64` `Tensor` or `SparseTensor` with shape
[D1,... DN, num_labels] or [D1,... DN], where the latter implies
num_labels=1. N >= 1 and num_labels is the number of target classes for
the associated prediction. Commonly, N=1 and `labels` has shape
[batch_size, num_labels]. [D1,... DN] must match `predictions`. Values
should be in range [0, num_classes), where num_classes is the last
dimension of `predictions`. Values outside this range are ignored. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>Float `Tensor` with shape [D1,... DN, num_classes] where
N >= 1. Commonly, N=1 and predictions has shape [batch size, num_classes].
The final dimension contains the logit values for each class. [D1,... DN]
must match `labels`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> k
						</dt>
						<dd>Integer, k for @k metric. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> class_id
						</dt>
						<dd>Integer class ID for which we want binary metrics. This should be
in range [0, num_classes], where num_classes is the last dimension of
`predictions`. If `class_id` is outside this range, the method returns
NAN. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>`Tensor` whose rank is either 0, or n-1, where n is the rank of
`labels`. If the latter, it must be broadcastable to `labels` (i.e., all
dimensions must be either `1`, or the same as the corresponding `labels`
dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that values should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that updates should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>Name of new update operation, and namespace for other dependent ops. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision_at_k" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>precision_at_k</strong>(<span title="System.object">object</span> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.int">int</span> k, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> class_id, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes precision@k of the predictions with respect to sparse labels. <p></p> If `class_id` is specified, we calculate precision by considering only the
entries in the batch for which `class_id` is in the top-k highest
`predictions`, and computing the fraction of them for which `class_id` is
indeed a correct label.
If `class_id` is not specified, we'll calculate precision as how often on
average a class among the top-k classes with the highest predicted values
of a batch entry is correct and can be found in the label for that entry. <p></p> `precision_at_k` creates two local variables,
`true_positive_at_<k>` and `false_positive_at_<k>`, that are used to compute
the precision@k frequency. This frequency is ultimately returned as
`precision_at_<k>`: an idempotent operation that simply divides
`true_positive_at_<k>` by total (`true_positive_at_<k>` +
`false_positive_at_<k>`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision_at_<k>`. Internally, a `top_k` operation computes a `Tensor`
indicating the top `k` `predictions`. Set operations applied to `top_k` and
`labels` calculate the true positives and false positives weighted by
`weights`. Then `update_op` increments `true_positive_at_<k>` and
`false_positive_at_<k>` using these values. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>`int64` `Tensor` or `SparseTensor` with shape
[D1,... DN, num_labels] or [D1,... DN], where the latter implies
num_labels=1. N >= 1 and num_labels is the number of target classes for
the associated prediction. Commonly, N=1 and `labels` has shape
[batch_size, num_labels]. [D1,... DN] must match `predictions`. Values
should be in range [0, num_classes), where num_classes is the last
dimension of `predictions`. Values outside this range are ignored. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>Float `Tensor` with shape [D1,... DN, num_classes] where
N >= 1. Commonly, N=1 and predictions has shape [batch size, num_classes].
The final dimension contains the logit values for each class. [D1,... DN]
must match `labels`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> k
						</dt>
						<dd>Integer, k for @k metric. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> class_id
						</dt>
						<dd>Integer class ID for which we want binary metrics. This should be
in range [0, num_classes], where num_classes is the last dimension of
`predictions`. If `class_id` is outside this range, the method returns
NAN. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> weights
						</dt>
						<dd>`Tensor` whose rank is either 0, or n-1, where n is the rank of
`labels`. If the latter, it must be broadcastable to `labels` (i.e., all
dimensions must be either `1`, or the same as the corresponding `labels`
dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that values should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that updates should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>Name of new update operation, and namespace for other dependent ops. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision_at_k" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>precision_at_k</strong>(<a href="../numpy/ndarray.htm">ndarray</a> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.int">int</span> k, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> class_id, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes precision@k of the predictions with respect to sparse labels. <p></p> If `class_id` is specified, we calculate precision by considering only the
entries in the batch for which `class_id` is in the top-k highest
`predictions`, and computing the fraction of them for which `class_id` is
indeed a correct label.
If `class_id` is not specified, we'll calculate precision as how often on
average a class among the top-k classes with the highest predicted values
of a batch entry is correct and can be found in the label for that entry. <p></p> `precision_at_k` creates two local variables,
`true_positive_at_<k>` and `false_positive_at_<k>`, that are used to compute
the precision@k frequency. This frequency is ultimately returned as
`precision_at_<k>`: an idempotent operation that simply divides
`true_positive_at_<k>` by total (`true_positive_at_<k>` +
`false_positive_at_<k>`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision_at_<k>`. Internally, a `top_k` operation computes a `Tensor`
indicating the top `k` `predictions`. Set operations applied to `top_k` and
`labels` calculate the true positives and false positives weighted by
`weights`. Then `update_op` increments `true_positive_at_<k>` and
`false_positive_at_<k>` using these values. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> labels
						</dt>
						<dd>`int64` `Tensor` or `SparseTensor` with shape
[D1,... DN, num_labels] or [D1,... DN], where the latter implies
num_labels=1. N >= 1 and num_labels is the number of target classes for
the associated prediction. Commonly, N=1 and `labels` has shape
[batch_size, num_labels]. [D1,... DN] must match `predictions`. Values
should be in range [0, num_classes), where num_classes is the last
dimension of `predictions`. Values outside this range are ignored. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>Float `Tensor` with shape [D1,... DN, num_classes] where
N >= 1. Commonly, N=1 and predictions has shape [batch size, num_classes].
The final dimension contains the logit values for each class. [D1,... DN]
must match `labels`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> k
						</dt>
						<dd>Integer, k for @k metric. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> class_id
						</dt>
						<dd>Integer class ID for which we want binary metrics. This should be
in range [0, num_classes], where num_classes is the last dimension of
`predictions`. If `class_id` is outside this range, the method returns
NAN. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>`Tensor` whose rank is either 0, or n-1, where n is the rank of
`labels`. If the latter, it must be broadcastable to `labels` (i.e., all
dimensions must be either `1`, or the same as the corresponding `labels`
dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that values should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that updates should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>Name of new update operation, and namespace for other dependent ops. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision_at_k" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>precision_at_k</strong>(<a href="../numpy/ndarray.htm">ndarray</a> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.int">int</span> k, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> class_id, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes precision@k of the predictions with respect to sparse labels. <p></p> If `class_id` is specified, we calculate precision by considering only the
entries in the batch for which `class_id` is in the top-k highest
`predictions`, and computing the fraction of them for which `class_id` is
indeed a correct label.
If `class_id` is not specified, we'll calculate precision as how often on
average a class among the top-k classes with the highest predicted values
of a batch entry is correct and can be found in the label for that entry. <p></p> `precision_at_k` creates two local variables,
`true_positive_at_<k>` and `false_positive_at_<k>`, that are used to compute
the precision@k frequency. This frequency is ultimately returned as
`precision_at_<k>`: an idempotent operation that simply divides
`true_positive_at_<k>` by total (`true_positive_at_<k>` +
`false_positive_at_<k>`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision_at_<k>`. Internally, a `top_k` operation computes a `Tensor`
indicating the top `k` `predictions`. Set operations applied to `top_k` and
`labels` calculate the true positives and false positives weighted by
`weights`. Then `update_op` increments `true_positive_at_<k>` and
`false_positive_at_<k>` using these values. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> labels
						</dt>
						<dd>`int64` `Tensor` or `SparseTensor` with shape
[D1,... DN, num_labels] or [D1,... DN], where the latter implies
num_labels=1. N >= 1 and num_labels is the number of target classes for
the associated prediction. Commonly, N=1 and `labels` has shape
[batch_size, num_labels]. [D1,... DN] must match `predictions`. Values
should be in range [0, num_classes), where num_classes is the last
dimension of `predictions`. Values outside this range are ignored. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>Float `Tensor` with shape [D1,... DN, num_classes] where
N >= 1. Commonly, N=1 and predictions has shape [batch size, num_classes].
The final dimension contains the logit values for each class. [D1,... DN]
must match `labels`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> k
						</dt>
						<dd>Integer, k for @k metric. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> class_id
						</dt>
						<dd>Integer class ID for which we want binary metrics. This should be
in range [0, num_classes], where num_classes is the last dimension of
`predictions`. If `class_id` is outside this range, the method returns
NAN. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> weights
						</dt>
						<dd>`Tensor` whose rank is either 0, or n-1, where n is the rank of
`labels`. If the latter, it must be broadcastable to `labels` (i.e., all
dimensions must be either `1`, or the same as the corresponding `labels`
dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that values should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that updates should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>Name of new update operation, and namespace for other dependent ops. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision_at_k_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>precision_at_k_dyn</strong>(<span title="System.object">object</span> labels, <span title="System.object">object</span> predictions, <span title="System.object">object</span> k, <span title="System.object">object</span> class_id, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Computes precision@k of the predictions with respect to sparse labels. <p></p> If `class_id` is specified, we calculate precision by considering only the
entries in the batch for which `class_id` is in the top-k highest
`predictions`, and computing the fraction of them for which `class_id` is
indeed a correct label.
If `class_id` is not specified, we'll calculate precision as how often on
average a class among the top-k classes with the highest predicted values
of a batch entry is correct and can be found in the label for that entry. <p></p> `precision_at_k` creates two local variables,
`true_positive_at_<k>` and `false_positive_at_<k>`, that are used to compute
the precision@k frequency. This frequency is ultimately returned as
`precision_at_<k>`: an idempotent operation that simply divides
`true_positive_at_<k>` by total (`true_positive_at_<k>` +
`false_positive_at_<k>`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision_at_<k>`. Internally, a `top_k` operation computes a `Tensor`
indicating the top `k` `predictions`. Set operations applied to `top_k` and
`labels` calculate the true positives and false positives weighted by
`weights`. Then `update_op` increments `true_positive_at_<k>` and
`false_positive_at_<k>` using these values. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>`int64` `Tensor` or `SparseTensor` with shape
[D1,... DN, num_labels] or [D1,... DN], where the latter implies
num_labels=1. N >= 1 and num_labels is the number of target classes for
the associated prediction. Commonly, N=1 and `labels` has shape
[batch_size, num_labels]. [D1,... DN] must match `predictions`. Values
should be in range [0, num_classes), where num_classes is the last
dimension of `predictions`. Values outside this range are ignored. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>Float `Tensor` with shape [D1,... DN, num_classes] where
N >= 1. Commonly, N=1 and predictions has shape [batch size, num_classes].
The final dimension contains the logit values for each class. [D1,... DN]
must match `labels`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> k
						</dt>
						<dd>Integer, k for @k metric. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> class_id
						</dt>
						<dd>Integer class ID for which we want binary metrics. This should be
in range [0, num_classes], where num_classes is the last dimension of
`predictions`. If `class_id` is outside this range, the method returns
NAN. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>`Tensor` whose rank is either 0, or n-1, where n is the rank of
`labels`. If the latter, it must be broadcastable to `labels` (i.e., all
dimensions must be either `1`, or the same as the corresponding `labels`
dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that values should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that updates should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>Name of new update operation, and namespace for other dependent ops. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision_at_thresholds</strong>(<span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> labels, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> predictions, <span title="System.object">object</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes precision values for different `thresholds` on `predictions`. <p></p> The `precision_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `precision[i]` is defined as the total
weight of values in `predictions` above `thresholds[i]` whose corresponding
entry in `labels` is `True`, divided by the total weight of values in
`predictions` above `thresholds[i]` (`true_positives[i] / (true_positives[i] +
false_positives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `auc` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision_at_thresholds</strong>(<a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> labels, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> predictions, <span title="System.object">object</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes precision values for different `thresholds` on `predictions`. <p></p> The `precision_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `precision[i]` is defined as the total
weight of values in `predictions` above `thresholds[i]` whose corresponding
entry in `labels` is `True`, divided by the total weight of values in
`predictions` above `thresholds[i]` (`true_positives[i] / (true_positives[i] +
false_positives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `auc` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision_at_thresholds</strong>(<span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> labels, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> predictions, <span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes precision values for different `thresholds` on `predictions`. <p></p> The `precision_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `precision[i]` is defined as the total
weight of values in `predictions` above `thresholds[i]` whose corresponding
entry in `labels` is `True`, divided by the total weight of values in
`predictions` above `thresholds[i]` (`true_positives[i] / (true_positives[i] +
false_positives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `auc` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision_at_thresholds</strong>(<a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> labels, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> predictions, <span title="System.object">object</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> name)
		</h4>
		<div class="content">Computes precision values for different `thresholds` on `predictions`. <p></p> The `precision_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `precision[i]` is defined as the total
weight of values in `predictions` above `thresholds[i]` whose corresponding
entry in `labels` is `True`, divided by the total weight of values in
`predictions` above `thresholds[i]` (`true_positives[i] / (true_positives[i] +
false_positives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `auc` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision_at_thresholds</strong>(<span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> labels, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> predictions, <span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes precision values for different `thresholds` on `predictions`. <p></p> The `precision_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `precision[i]` is defined as the total
weight of values in `predictions` above `thresholds[i]` whose corresponding
entry in `labels` is `True`, divided by the total weight of values in
`predictions` above `thresholds[i]` (`true_positives[i] / (true_positives[i] +
false_positives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `auc` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision_at_thresholds</strong>(<a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> labels, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> predictions, <span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes precision values for different `thresholds` on `predictions`. <p></p> The `precision_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `precision[i]` is defined as the total
weight of values in `predictions` above `thresholds[i]` whose corresponding
entry in `labels` is `True`, divided by the total weight of values in
`predictions` above `thresholds[i]` (`true_positives[i] / (true_positives[i] +
false_positives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `auc` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision_at_thresholds</strong>(<a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> labels, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> predictions, <span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> name)
		</h4>
		<div class="content">Computes precision values for different `thresholds` on `predictions`. <p></p> The `precision_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `precision[i]` is defined as the total
weight of values in `predictions` above `thresholds[i]` whose corresponding
entry in `labels` is `True`, divided by the total weight of values in
`predictions` above `thresholds[i]` (`true_positives[i] / (true_positives[i] +
false_positives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `auc` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision_at_thresholds</strong>(<span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> labels, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> predictions, <span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> name)
		</h4>
		<div class="content">Computes precision values for different `thresholds` on `predictions`. <p></p> The `precision_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `precision[i]` is defined as the total
weight of values in `predictions` above `thresholds[i]` whose corresponding
entry in `labels` is `True`, divided by the total weight of values in
`predictions` above `thresholds[i]` (`true_positives[i] / (true_positives[i] +
false_positives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `auc` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision_at_thresholds</strong>(<span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.object">object</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes precision values for different `thresholds` on `predictions`. <p></p> The `precision_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `precision[i]` is defined as the total
weight of values in `predictions` above `thresholds[i]` whose corresponding
entry in `labels` is `True`, divided by the total weight of values in
`predictions` above `thresholds[i]` (`true_positives[i] / (true_positives[i] +
false_positives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `auc` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision_at_thresholds</strong>(<span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.object">object</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes precision values for different `thresholds` on `predictions`. <p></p> The `precision_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `precision[i]` is defined as the total
weight of values in `predictions` above `thresholds[i]` whose corresponding
entry in `labels` is `True`, divided by the total weight of values in
`predictions` above `thresholds[i]` (`true_positives[i] / (true_positives[i] +
false_positives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `auc` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision_at_thresholds</strong>(<span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.object">object</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> name)
		</h4>
		<div class="content">Computes precision values for different `thresholds` on `predictions`. <p></p> The `precision_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `precision[i]` is defined as the total
weight of values in `predictions` above `thresholds[i]` whose corresponding
entry in `labels` is `True`, divided by the total weight of values in
`predictions` above `thresholds[i]` (`true_positives[i] / (true_positives[i] +
false_positives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `auc` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision_at_thresholds</strong>(<span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> labels, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> predictions, <span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> name)
		</h4>
		<div class="content">Computes precision values for different `thresholds` on `predictions`. <p></p> The `precision_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `precision[i]` is defined as the total
weight of values in `predictions` above `thresholds[i]` whose corresponding
entry in `labels` is `True`, divided by the total weight of values in
`predictions` above `thresholds[i]` (`true_positives[i] / (true_positives[i] +
false_positives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `auc` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision_at_thresholds</strong>(<span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes precision values for different `thresholds` on `predictions`. <p></p> The `precision_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `precision[i]` is defined as the total
weight of values in `predictions` above `thresholds[i]` whose corresponding
entry in `labels` is `True`, divided by the total weight of values in
`predictions` above `thresholds[i]` (`true_positives[i] / (true_positives[i] +
false_positives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `auc` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision_at_thresholds</strong>(<span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.object">object</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> name)
		</h4>
		<div class="content">Computes precision values for different `thresholds` on `predictions`. <p></p> The `precision_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `precision[i]` is defined as the total
weight of values in `predictions` above `thresholds[i]` whose corresponding
entry in `labels` is `True`, divided by the total weight of values in
`predictions` above `thresholds[i]` (`true_positives[i] / (true_positives[i] +
false_positives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `auc` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision_at_thresholds</strong>(<span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> name)
		</h4>
		<div class="content">Computes precision values for different `thresholds` on `predictions`. <p></p> The `precision_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `precision[i]` is defined as the total
weight of values in `predictions` above `thresholds[i]` whose corresponding
entry in `labels` is `True`, divided by the total weight of values in
`predictions` above `thresholds[i]` (`true_positives[i] / (true_positives[i] +
false_positives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `auc` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision_at_thresholds</strong>(<span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> labels, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> predictions, <span title="System.object">object</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> name)
		</h4>
		<div class="content">Computes precision values for different `thresholds` on `predictions`. <p></p> The `precision_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `precision[i]` is defined as the total
weight of values in `predictions` above `thresholds[i]` whose corresponding
entry in `labels` is `True`, divided by the total weight of values in
`predictions` above `thresholds[i]` (`true_positives[i] / (true_positives[i] +
false_positives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `auc` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision_at_thresholds</strong>(<span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes precision values for different `thresholds` on `predictions`. <p></p> The `precision_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `precision[i]` is defined as the total
weight of values in `predictions` above `thresholds[i]` whose corresponding
entry in `labels` is `True`, divided by the total weight of values in
`predictions` above `thresholds[i]` (`true_positives[i] / (true_positives[i] +
false_positives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `auc` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision_at_thresholds</strong>(<span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> labels, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> predictions, <span title="System.object">object</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> name)
		</h4>
		<div class="content">Computes precision values for different `thresholds` on `predictions`. <p></p> The `precision_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `precision[i]` is defined as the total
weight of values in `predictions` above `thresholds[i]` whose corresponding
entry in `labels` is `True`, divided by the total weight of values in
`predictions` above `thresholds[i]` (`true_positives[i] / (true_positives[i] +
false_positives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `auc` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision_at_thresholds</strong>(<span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> name)
		</h4>
		<div class="content">Computes precision values for different `thresholds` on `predictions`. <p></p> The `precision_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `precision[i]` is defined as the total
weight of values in `predictions` above `thresholds[i]` whose corresponding
entry in `labels` is `True`, divided by the total weight of values in
`predictions` above `thresholds[i]` (`true_positives[i] / (true_positives[i] +
false_positives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `auc` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision_at_thresholds</strong>(<span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> labels, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> predictions, <span title="System.object">object</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes precision values for different `thresholds` on `predictions`. <p></p> The `precision_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `precision[i]` is defined as the total
weight of values in `predictions` above `thresholds[i]` whose corresponding
entry in `labels` is `True`, divided by the total weight of values in
`predictions` above `thresholds[i]` (`true_positives[i] / (true_positives[i] +
false_positives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `auc` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision_at_thresholds</strong>(<a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> name)
		</h4>
		<div class="content">Computes precision values for different `thresholds` on `predictions`. <p></p> The `precision_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `precision[i]` is defined as the total
weight of values in `predictions` above `thresholds[i]` whose corresponding
entry in `labels` is `True`, divided by the total weight of values in
`predictions` above `thresholds[i]` (`true_positives[i] / (true_positives[i] +
false_positives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `auc` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision_at_thresholds</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.object">object</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes precision values for different `thresholds` on `predictions`. <p></p> The `precision_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `precision[i]` is defined as the total
weight of values in `predictions` above `thresholds[i]` whose corresponding
entry in `labels` is `True`, divided by the total weight of values in
`predictions` above `thresholds[i]` (`true_positives[i] / (true_positives[i] +
false_positives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `auc` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision_at_thresholds</strong>(<a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes precision values for different `thresholds` on `predictions`. <p></p> The `precision_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `precision[i]` is defined as the total
weight of values in `predictions` above `thresholds[i]` whose corresponding
entry in `labels` is `True`, divided by the total weight of values in
`predictions` above `thresholds[i]` (`true_positives[i] / (true_positives[i] +
false_positives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `auc` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision_at_thresholds</strong>(<a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.object">object</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> name)
		</h4>
		<div class="content">Computes precision values for different `thresholds` on `predictions`. <p></p> The `precision_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `precision[i]` is defined as the total
weight of values in `predictions` above `thresholds[i]` whose corresponding
entry in `labels` is `True`, divided by the total weight of values in
`predictions` above `thresholds[i]` (`true_positives[i] / (true_positives[i] +
false_positives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `auc` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision_at_thresholds</strong>(<a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.object">object</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes precision values for different `thresholds` on `predictions`. <p></p> The `precision_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `precision[i]` is defined as the total
weight of values in `predictions` above `thresholds[i]` whose corresponding
entry in `labels` is `True`, divided by the total weight of values in
`predictions` above `thresholds[i]` (`true_positives[i] / (true_positives[i] +
false_positives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `auc` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision_at_thresholds</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> predictions, <span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> name)
		</h4>
		<div class="content">Computes precision values for different `thresholds` on `predictions`. <p></p> The `precision_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `precision[i]` is defined as the total
weight of values in `predictions` above `thresholds[i]` whose corresponding
entry in `labels` is `True`, divided by the total weight of values in
`predictions` above `thresholds[i]` (`true_positives[i] / (true_positives[i] +
false_positives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `auc` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision_at_thresholds</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> predictions, <span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes precision values for different `thresholds` on `predictions`. <p></p> The `precision_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `precision[i]` is defined as the total
weight of values in `predictions` above `thresholds[i]` whose corresponding
entry in `labels` is `True`, divided by the total weight of values in
`predictions` above `thresholds[i]` (`true_positives[i] / (true_positives[i] +
false_positives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `auc` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision_at_thresholds</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> predictions, <span title="System.object">object</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> name)
		</h4>
		<div class="content">Computes precision values for different `thresholds` on `predictions`. <p></p> The `precision_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `precision[i]` is defined as the total
weight of values in `predictions` above `thresholds[i]` whose corresponding
entry in `labels` is `True`, divided by the total weight of values in
`predictions` above `thresholds[i]` (`true_positives[i] / (true_positives[i] +
false_positives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `auc` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision_at_thresholds</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> predictions, <span title="System.object">object</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes precision values for different `thresholds` on `predictions`. <p></p> The `precision_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `precision[i]` is defined as the total
weight of values in `predictions` above `thresholds[i]` whose corresponding
entry in `labels` is `True`, divided by the total weight of values in
`predictions` above `thresholds[i]` (`true_positives[i] / (true_positives[i] +
false_positives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `auc` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision_at_thresholds</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> name)
		</h4>
		<div class="content">Computes precision values for different `thresholds` on `predictions`. <p></p> The `precision_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `precision[i]` is defined as the total
weight of values in `predictions` above `thresholds[i]` whose corresponding
entry in `labels` is `True`, divided by the total weight of values in
`predictions` above `thresholds[i]` (`true_positives[i] / (true_positives[i] +
false_positives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `auc` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision_at_thresholds</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes precision values for different `thresholds` on `predictions`. <p></p> The `precision_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `precision[i]` is defined as the total
weight of values in `predictions` above `thresholds[i]` whose corresponding
entry in `labels` is `True`, divided by the total weight of values in
`predictions` above `thresholds[i]` (`true_positives[i] / (true_positives[i] +
false_positives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `auc` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>precision_at_thresholds</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.object">object</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> name)
		</h4>
		<div class="content">Computes precision values for different `thresholds` on `predictions`. <p></p> The `precision_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `precision[i]` is defined as the total
weight of values in `predictions` above `thresholds[i]` whose corresponding
entry in `labels` is `True`, divided by the total weight of values in
`predictions` above `thresholds[i]` (`true_positives[i] / (true_positives[i] +
false_positives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `auc` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision_at_thresholds_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>precision_at_thresholds_dyn</strong>(<span title="System.object">object</span> labels, <span title="System.object">object</span> predictions, <span title="System.object">object</span> thresholds, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Computes precision values for different `thresholds` on `predictions`. <p></p> The `precision_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `precision[i]` is defined as the total
weight of values in `predictions` above `thresholds[i]` whose corresponding
entry in `labels` is `True`, divided by the total weight of values in
`predictions` above `thresholds[i]` (`true_positives[i] / (true_positives[i] +
false_positives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `auc` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision_at_top_k" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>precision_at_top_k</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions_idx, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> k, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> class_id, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes precision@k of the predictions with respect to sparse labels. <p></p> Differs from `sparse_precision_at_k` in that predictions must be in the form
of top `k` class indices, whereas `sparse_precision_at_k` expects logits.
Refer to `sparse_precision_at_k` for more details. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> labels
						</dt>
						<dd>`int64` `Tensor` or `SparseTensor` with shape
[D1,... DN, num_labels] or [D1,... DN], where the latter implies
num_labels=1. N >= 1 and num_labels is the number of target classes for
the associated prediction. Commonly, N=1 and `labels` has shape
[batch_size, num_labels]. [D1,... DN] must match `predictions`. Values
should be in range [0, num_classes), where num_classes is the last
dimension of `predictions`. Values outside this range are ignored. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions_idx
						</dt>
						<dd>Integer `Tensor` with shape [D1,... DN, k] where
N >= 1. Commonly, N=1 and predictions has shape [batch size, k].
The final dimension contains the top `k` predicted class indices.
[D1,... DN] must match `labels`. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> k
						</dt>
						<dd>Integer, k for @k metric. Only used for the default op name. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> class_id
						</dt>
						<dd>Integer class ID for which we want binary metrics. This should be
in range [0, num_classes], where num_classes is the last dimension of
`predictions`. If `class_id` is outside this range, the method returns
NAN. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> weights
						</dt>
						<dd>`Tensor` whose rank is either 0, or n-1, where n is the rank of
`labels`. If the latter, it must be broadcastable to `labels` (i.e., all
dimensions must be either `1`, or the same as the corresponding `labels`
dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that values should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that updates should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>Name of new update operation, and namespace for other dependent ops. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision_at_top_k" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>precision_at_top_k</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions_idx, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> k, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> class_id, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes precision@k of the predictions with respect to sparse labels. <p></p> Differs from `sparse_precision_at_k` in that predictions must be in the form
of top `k` class indices, whereas `sparse_precision_at_k` expects logits.
Refer to `sparse_precision_at_k` for more details. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> labels
						</dt>
						<dd>`int64` `Tensor` or `SparseTensor` with shape
[D1,... DN, num_labels] or [D1,... DN], where the latter implies
num_labels=1. N >= 1 and num_labels is the number of target classes for
the associated prediction. Commonly, N=1 and `labels` has shape
[batch_size, num_labels]. [D1,... DN] must match `predictions`. Values
should be in range [0, num_classes), where num_classes is the last
dimension of `predictions`. Values outside this range are ignored. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions_idx
						</dt>
						<dd>Integer `Tensor` with shape [D1,... DN, k] where
N >= 1. Commonly, N=1 and predictions has shape [batch size, k].
The final dimension contains the top `k` predicted class indices.
[D1,... DN] must match `labels`. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> k
						</dt>
						<dd>Integer, k for @k metric. Only used for the default op name. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> class_id
						</dt>
						<dd>Integer class ID for which we want binary metrics. This should be
in range [0, num_classes], where num_classes is the last dimension of
`predictions`. If `class_id` is outside this range, the method returns
NAN. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>`Tensor` whose rank is either 0, or n-1, where n is the rank of
`labels`. If the latter, it must be broadcastable to `labels` (i.e., all
dimensions must be either `1`, or the same as the corresponding `labels`
dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that values should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that updates should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>Name of new update operation, and namespace for other dependent ops. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision_at_top_k" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>precision_at_top_k</strong>(<span title="System.object">object</span> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions_idx, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> k, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> class_id, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> name)
		</h4>
		<div class="content">Computes precision@k of the predictions with respect to sparse labels. <p></p> Differs from `sparse_precision_at_k` in that predictions must be in the form
of top `k` class indices, whereas `sparse_precision_at_k` expects logits.
Refer to `sparse_precision_at_k` for more details. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>`int64` `Tensor` or `SparseTensor` with shape
[D1,... DN, num_labels] or [D1,... DN], where the latter implies
num_labels=1. N >= 1 and num_labels is the number of target classes for
the associated prediction. Commonly, N=1 and `labels` has shape
[batch_size, num_labels]. [D1,... DN] must match `predictions`. Values
should be in range [0, num_classes), where num_classes is the last
dimension of `predictions`. Values outside this range are ignored. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions_idx
						</dt>
						<dd>Integer `Tensor` with shape [D1,... DN, k] where
N >= 1. Commonly, N=1 and predictions has shape [batch size, k].
The final dimension contains the top `k` predicted class indices.
[D1,... DN] must match `labels`. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> k
						</dt>
						<dd>Integer, k for @k metric. Only used for the default op name. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> class_id
						</dt>
						<dd>Integer class ID for which we want binary metrics. This should be
in range [0, num_classes], where num_classes is the last dimension of
`predictions`. If `class_id` is outside this range, the method returns
NAN. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> weights
						</dt>
						<dd>`Tensor` whose rank is either 0, or n-1, where n is the rank of
`labels`. If the latter, it must be broadcastable to `labels` (i.e., all
dimensions must be either `1`, or the same as the corresponding `labels`
dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that values should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that updates should
be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> name
						</dt>
						<dd>Name of new update operation, and namespace for other dependent ops. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision_at_top_k" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>precision_at_top_k</strong>(<span title="System.object">object</span> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions_idx, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> k, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> class_id, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes precision@k of the predictions with respect to sparse labels. <p></p> Differs from `sparse_precision_at_k` in that predictions must be in the form
of top `k` class indices, whereas `sparse_precision_at_k` expects logits.
Refer to `sparse_precision_at_k` for more details. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>`int64` `Tensor` or `SparseTensor` with shape
[D1,... DN, num_labels] or [D1,... DN], where the latter implies
num_labels=1. N >= 1 and num_labels is the number of target classes for
the associated prediction. Commonly, N=1 and `labels` has shape
[batch_size, num_labels]. [D1,... DN] must match `predictions`. Values
should be in range [0, num_classes), where num_classes is the last
dimension of `predictions`. Values outside this range are ignored. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions_idx
						</dt>
						<dd>Integer `Tensor` with shape [D1,... DN, k] where
N >= 1. Commonly, N=1 and predictions has shape [batch size, k].
The final dimension contains the top `k` predicted class indices.
[D1,... DN] must match `labels`. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> k
						</dt>
						<dd>Integer, k for @k metric. Only used for the default op name. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> class_id
						</dt>
						<dd>Integer class ID for which we want binary metrics. This should be
in range [0, num_classes], where num_classes is the last dimension of
`predictions`. If `class_id` is outside this range, the method returns
NAN. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> weights
						</dt>
						<dd>`Tensor` whose rank is either 0, or n-1, where n is the rank of
`labels`. If the latter, it must be broadcastable to `labels` (i.e., all
dimensions must be either `1`, or the same as the corresponding `labels`
dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that values should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that updates should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>Name of new update operation, and namespace for other dependent ops. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision_at_top_k" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>precision_at_top_k</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions_idx, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> k, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> class_id, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> name)
		</h4>
		<div class="content">Computes precision@k of the predictions with respect to sparse labels. <p></p> Differs from `sparse_precision_at_k` in that predictions must be in the form
of top `k` class indices, whereas `sparse_precision_at_k` expects logits.
Refer to `sparse_precision_at_k` for more details. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> labels
						</dt>
						<dd>`int64` `Tensor` or `SparseTensor` with shape
[D1,... DN, num_labels] or [D1,... DN], where the latter implies
num_labels=1. N >= 1 and num_labels is the number of target classes for
the associated prediction. Commonly, N=1 and `labels` has shape
[batch_size, num_labels]. [D1,... DN] must match `predictions`. Values
should be in range [0, num_classes), where num_classes is the last
dimension of `predictions`. Values outside this range are ignored. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions_idx
						</dt>
						<dd>Integer `Tensor` with shape [D1,... DN, k] where
N >= 1. Commonly, N=1 and predictions has shape [batch size, k].
The final dimension contains the top `k` predicted class indices.
[D1,... DN] must match `labels`. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> k
						</dt>
						<dd>Integer, k for @k metric. Only used for the default op name. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> class_id
						</dt>
						<dd>Integer class ID for which we want binary metrics. This should be
in range [0, num_classes], where num_classes is the last dimension of
`predictions`. If `class_id` is outside this range, the method returns
NAN. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> weights
						</dt>
						<dd>`Tensor` whose rank is either 0, or n-1, where n is the rank of
`labels`. If the latter, it must be broadcastable to `labels` (i.e., all
dimensions must be either `1`, or the same as the corresponding `labels`
dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that values should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that updates should
be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> name
						</dt>
						<dd>Name of new update operation, and namespace for other dependent ops. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision_at_top_k" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>precision_at_top_k</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions_idx, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> k, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> class_id, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> name)
		</h4>
		<div class="content">Computes precision@k of the predictions with respect to sparse labels. <p></p> Differs from `sparse_precision_at_k` in that predictions must be in the form
of top `k` class indices, whereas `sparse_precision_at_k` expects logits.
Refer to `sparse_precision_at_k` for more details. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> labels
						</dt>
						<dd>`int64` `Tensor` or `SparseTensor` with shape
[D1,... DN, num_labels] or [D1,... DN], where the latter implies
num_labels=1. N >= 1 and num_labels is the number of target classes for
the associated prediction. Commonly, N=1 and `labels` has shape
[batch_size, num_labels]. [D1,... DN] must match `predictions`. Values
should be in range [0, num_classes), where num_classes is the last
dimension of `predictions`. Values outside this range are ignored. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions_idx
						</dt>
						<dd>Integer `Tensor` with shape [D1,... DN, k] where
N >= 1. Commonly, N=1 and predictions has shape [batch size, k].
The final dimension contains the top `k` predicted class indices.
[D1,... DN] must match `labels`. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> k
						</dt>
						<dd>Integer, k for @k metric. Only used for the default op name. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> class_id
						</dt>
						<dd>Integer class ID for which we want binary metrics. This should be
in range [0, num_classes], where num_classes is the last dimension of
`predictions`. If `class_id` is outside this range, the method returns
NAN. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>`Tensor` whose rank is either 0, or n-1, where n is the rank of
`labels`. If the latter, it must be broadcastable to `labels` (i.e., all
dimensions must be either `1`, or the same as the corresponding `labels`
dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that values should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that updates should
be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> name
						</dt>
						<dd>Name of new update operation, and namespace for other dependent ops. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision_at_top_k" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>precision_at_top_k</strong>(<span title="System.object">object</span> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions_idx, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> k, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> class_id, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes precision@k of the predictions with respect to sparse labels. <p></p> Differs from `sparse_precision_at_k` in that predictions must be in the form
of top `k` class indices, whereas `sparse_precision_at_k` expects logits.
Refer to `sparse_precision_at_k` for more details. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>`int64` `Tensor` or `SparseTensor` with shape
[D1,... DN, num_labels] or [D1,... DN], where the latter implies
num_labels=1. N >= 1 and num_labels is the number of target classes for
the associated prediction. Commonly, N=1 and `labels` has shape
[batch_size, num_labels]. [D1,... DN] must match `predictions`. Values
should be in range [0, num_classes), where num_classes is the last
dimension of `predictions`. Values outside this range are ignored. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions_idx
						</dt>
						<dd>Integer `Tensor` with shape [D1,... DN, k] where
N >= 1. Commonly, N=1 and predictions has shape [batch size, k].
The final dimension contains the top `k` predicted class indices.
[D1,... DN] must match `labels`. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> k
						</dt>
						<dd>Integer, k for @k metric. Only used for the default op name. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> class_id
						</dt>
						<dd>Integer class ID for which we want binary metrics. This should be
in range [0, num_classes], where num_classes is the last dimension of
`predictions`. If `class_id` is outside this range, the method returns
NAN. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>`Tensor` whose rank is either 0, or n-1, where n is the rank of
`labels`. If the latter, it must be broadcastable to `labels` (i.e., all
dimensions must be either `1`, or the same as the corresponding `labels`
dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that values should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that updates should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>Name of new update operation, and namespace for other dependent ops. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision_at_top_k" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>precision_at_top_k</strong>(<span title="System.object">object</span> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions_idx, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> k, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> class_id, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> name)
		</h4>
		<div class="content">Computes precision@k of the predictions with respect to sparse labels. <p></p> Differs from `sparse_precision_at_k` in that predictions must be in the form
of top `k` class indices, whereas `sparse_precision_at_k` expects logits.
Refer to `sparse_precision_at_k` for more details. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>`int64` `Tensor` or `SparseTensor` with shape
[D1,... DN, num_labels] or [D1,... DN], where the latter implies
num_labels=1. N >= 1 and num_labels is the number of target classes for
the associated prediction. Commonly, N=1 and `labels` has shape
[batch_size, num_labels]. [D1,... DN] must match `predictions`. Values
should be in range [0, num_classes), where num_classes is the last
dimension of `predictions`. Values outside this range are ignored. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions_idx
						</dt>
						<dd>Integer `Tensor` with shape [D1,... DN, k] where
N >= 1. Commonly, N=1 and predictions has shape [batch size, k].
The final dimension contains the top `k` predicted class indices.
[D1,... DN] must match `labels`. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> k
						</dt>
						<dd>Integer, k for @k metric. Only used for the default op name. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> class_id
						</dt>
						<dd>Integer class ID for which we want binary metrics. This should be
in range [0, num_classes], where num_classes is the last dimension of
`predictions`. If `class_id` is outside this range, the method returns
NAN. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>`Tensor` whose rank is either 0, or n-1, where n is the rank of
`labels`. If the latter, it must be broadcastable to `labels` (i.e., all
dimensions must be either `1`, or the same as the corresponding `labels`
dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that values should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that updates should
be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> name
						</dt>
						<dd>Name of new update operation, and namespace for other dependent ops. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision_at_top_k_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>precision_at_top_k_dyn</strong>(<span title="System.object">object</span> labels, <span title="System.object">object</span> predictions_idx, <span title="System.object">object</span> k, <span title="System.object">object</span> class_id, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Computes precision@k of the predictions with respect to sparse labels. <p></p> Differs from `sparse_precision_at_k` in that predictions must be in the form
of top `k` class indices, whereas `sparse_precision_at_k` expects logits.
Refer to `sparse_precision_at_k` for more details. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>`int64` `Tensor` or `SparseTensor` with shape
[D1,... DN, num_labels] or [D1,... DN], where the latter implies
num_labels=1. N >= 1 and num_labels is the number of target classes for
the associated prediction. Commonly, N=1 and `labels` has shape
[batch_size, num_labels]. [D1,... DN] must match `predictions`. Values
should be in range [0, num_classes), where num_classes is the last
dimension of `predictions`. Values outside this range are ignored. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions_idx
						</dt>
						<dd>Integer `Tensor` with shape [D1,... DN, k] where
N >= 1. Commonly, N=1 and predictions has shape [batch size, k].
The final dimension contains the top `k` predicted class indices.
[D1,... DN] must match `labels`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> k
						</dt>
						<dd>Integer, k for @k metric. Only used for the default op name. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> class_id
						</dt>
						<dd>Integer class ID for which we want binary metrics. This should be
in range [0, num_classes], where num_classes is the last dimension of
`predictions`. If `class_id` is outside this range, the method returns
NAN. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>`Tensor` whose rank is either 0, or n-1, where n is the rank of
`labels`. If the latter, it must be broadcastable to `labels` (i.e., all
dimensions must be either `1`, or the same as the corresponding `labels`
dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that values should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that updates should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>Name of new update operation, and namespace for other dependent ops. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="precision_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>precision_dyn</strong>(<span title="System.object">object</span> labels, <span title="System.object">object</span> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Computes the precision of the predictions with respect to the labels. <p></p> The `precision` function creates two local variables,
`true_positives` and `false_positives`, that are used to compute the
precision. This value is ultimately returned as `precision`, an idempotent
operation that simply divides `true_positives` by the sum of `true_positives`
and `false_positives`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`precision`. `update_op` weights each prediction by the corresponding value in
`weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `precision` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>recall</strong>(<span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> labels, <span title="System.object">object</span> predictions, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the recall of the predictions with respect to the labels. <p></p> The `recall` function creates two local variables, `true_positives`
and `false_negatives`, that are used to compute the recall. This value is
ultimately returned as `recall`, an idempotent operation that simply divides
`true_positives` by the sum of `true_positives` and `false_negatives`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` that updates these variables and returns the `recall`. `update_op`
weights each prediction by the corresponding value in `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `recall` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>recall</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> labels, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> predictions, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the recall of the predictions with respect to the labels. <p></p> The `recall` function creates two local variables, `true_positives`
and `false_negatives`, that are used to compute the recall. This value is
ultimately returned as `recall`, an idempotent operation that simply divides
`true_positives` by the sum of `true_positives` and `false_negatives`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` that updates these variables and returns the `recall`. `update_op`
weights each prediction by the corresponding value in `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `recall` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>recall</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> predictions, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the recall of the predictions with respect to the labels. <p></p> The `recall` function creates two local variables, `true_positives`
and `false_negatives`, that are used to compute the recall. This value is
ultimately returned as `recall`, an idempotent operation that simply divides
`true_positives` by the sum of `true_positives` and `false_negatives`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` that updates these variables and returns the `recall`. `update_op`
weights each prediction by the corresponding value in `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `recall` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>recall</strong>(<span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> labels, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> predictions, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the recall of the predictions with respect to the labels. <p></p> The `recall` function creates two local variables, `true_positives`
and `false_negatives`, that are used to compute the recall. This value is
ultimately returned as `recall`, an idempotent operation that simply divides
`true_positives` by the sum of `true_positives` and `false_negatives`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` that updates these variables and returns the `recall`. `update_op`
weights each prediction by the corresponding value in `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `recall` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>recall</strong>(<span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> labels, <span title="System.object">object</span> predictions, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the recall of the predictions with respect to the labels. <p></p> The `recall` function creates two local variables, `true_positives`
and `false_negatives`, that are used to compute the recall. This value is
ultimately returned as `recall`, an idempotent operation that simply divides
`true_positives` by the sum of `true_positives` and `false_negatives`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` that updates these variables and returns the `recall`. `update_op`
weights each prediction by the corresponding value in `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `recall` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>recall</strong>(<a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> labels, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> predictions, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the recall of the predictions with respect to the labels. <p></p> The `recall` function creates two local variables, `true_positives`
and `false_negatives`, that are used to compute the recall. This value is
ultimately returned as `recall`, an idempotent operation that simply divides
`true_positives` by the sum of `true_positives` and `false_negatives`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` that updates these variables and returns the `recall`. `update_op`
weights each prediction by the corresponding value in `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `recall` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>recall</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> labels, <span title="System.object">object</span> predictions, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the recall of the predictions with respect to the labels. <p></p> The `recall` function creates two local variables, `true_positives`
and `false_negatives`, that are used to compute the recall. This value is
ultimately returned as `recall`, an idempotent operation that simply divides
`true_positives` by the sum of `true_positives` and `false_negatives`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` that updates these variables and returns the `recall`. `update_op`
weights each prediction by the corresponding value in `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `recall` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>recall</strong>(<span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> labels, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> predictions, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the recall of the predictions with respect to the labels. <p></p> The `recall` function creates two local variables, `true_positives`
and `false_negatives`, that are used to compute the recall. This value is
ultimately returned as `recall`, an idempotent operation that simply divides
`true_positives` by the sum of `true_positives` and `false_negatives`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` that updates these variables and returns the `recall`. `update_op`
weights each prediction by the corresponding value in `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `recall` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>recall</strong>(<a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> labels, <span title="System.object">object</span> predictions, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the recall of the predictions with respect to the labels. <p></p> The `recall` function creates two local variables, `true_positives`
and `false_negatives`, that are used to compute the recall. This value is
ultimately returned as `recall`, an idempotent operation that simply divides
`true_positives` by the sum of `true_positives` and `false_negatives`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` that updates these variables and returns the `recall`. `update_op`
weights each prediction by the corresponding value in `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `recall` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>recall</strong>(<span title="System.double">double</span> labels, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> predictions, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the recall of the predictions with respect to the labels. <p></p> The `recall` function creates two local variables, `true_positives`
and `false_negatives`, that are used to compute the recall. This value is
ultimately returned as `recall`, an idempotent operation that simply divides
`true_positives` by the sum of `true_positives` and `false_negatives`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` that updates these variables and returns the `recall`. `update_op`
weights each prediction by the corresponding value in `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.double">double</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `recall` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>recall</strong>(<span title="System.double">double</span> labels, <span title="System.object">object</span> predictions, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the recall of the predictions with respect to the labels. <p></p> The `recall` function creates two local variables, `true_positives`
and `false_negatives`, that are used to compute the recall. This value is
ultimately returned as `recall`, an idempotent operation that simply divides
`true_positives` by the sum of `true_positives` and `false_negatives`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` that updates these variables and returns the `recall`. `update_op`
weights each prediction by the corresponding value in `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.double">double</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `recall` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>recall</strong>(<a href="../numpy/ndarray.htm">ndarray</a> labels, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> predictions, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the recall of the predictions with respect to the labels. <p></p> The `recall` function creates two local variables, `true_positives`
and `false_negatives`, that are used to compute the recall. This value is
ultimately returned as `recall`, an idempotent operation that simply divides
`true_positives` by the sum of `true_positives` and `false_negatives`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` that updates these variables and returns the `recall`. `update_op`
weights each prediction by the corresponding value in `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `recall` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>recall</strong>(<a href="../numpy/ndarray.htm">ndarray</a> labels, <span title="System.object">object</span> predictions, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the recall of the predictions with respect to the labels. <p></p> The `recall` function creates two local variables, `true_positives`
and `false_negatives`, that are used to compute the recall. This value is
ultimately returned as `recall`, an idempotent operation that simply divides
`true_positives` by the sum of `true_positives` and `false_negatives`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` that updates these variables and returns the `recall`. `update_op`
weights each prediction by the corresponding value in `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `recall` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>recall</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <span title="System.object">object</span> predictions, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the recall of the predictions with respect to the labels. <p></p> The `recall` function creates two local variables, `true_positives`
and `false_negatives`, that are used to compute the recall. This value is
ultimately returned as `recall`, an idempotent operation that simply divides
`true_positives` by the sum of `true_positives` and `false_negatives`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` that updates these variables and returns the `recall`. `update_op`
weights each prediction by the corresponding value in `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `recall` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>recall</strong>(<span title="System.object">object</span> labels, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> predictions, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the recall of the predictions with respect to the labels. <p></p> The `recall` function creates two local variables, `true_positives`
and `false_negatives`, that are used to compute the recall. This value is
ultimately returned as `recall`, an idempotent operation that simply divides
`true_positives` by the sum of `true_positives` and `false_negatives`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` that updates these variables and returns the `recall`. `update_op`
weights each prediction by the corresponding value in `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `recall` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>recall</strong>(<span title="System.object">object</span> labels, <span title="System.object">object</span> predictions, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the recall of the predictions with respect to the labels. <p></p> The `recall` function creates two local variables, `true_positives`
and `false_negatives`, that are used to compute the recall. This value is
ultimately returned as `recall`, an idempotent operation that simply divides
`true_positives` by the sum of `true_positives` and `false_negatives`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` that updates these variables and returns the `recall`. `update_op`
weights each prediction by the corresponding value in `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `recall` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall_at_k" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>recall_at_k</strong>(<span title="System.object">object</span> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.int">int</span> k, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> class_id, <span title="System.ValueTuple<double>">ValueTuple&lt;double&gt;</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes recall@k of the predictions with respect to sparse labels. <p></p> If `class_id` is specified, we calculate recall by considering only the
entries in the batch for which `class_id` is in the label, and computing
the fraction of them for which `class_id` is in the top-k `predictions`.
If `class_id` is not specified, we'll calculate recall as how often on
average a class among the labels of a batch entry is in the top-k
`predictions`. <p></p> `sparse_recall_at_k` creates two local variables,
`true_positive_at_<k>` and `false_negative_at_<k>`, that are used to compute
the recall_at_k frequency. This frequency is ultimately returned as
`recall_at_<k>`: an idempotent operation that simply divides
`true_positive_at_<k>` by total (`true_positive_at_<k>` +
`false_negative_at_<k>`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`recall_at_<k>`. Internally, a `top_k` operation computes a `Tensor`
indicating the top `k` `predictions`. Set operations applied to `top_k` and
`labels` calculate the true positives and false negatives weighted by
`weights`. Then `update_op` increments `true_positive_at_<k>` and
`false_negative_at_<k>` using these values. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>`int64` `Tensor` or `SparseTensor` with shape
[D1,... DN, num_labels] or [D1,... DN], where the latter implies
num_labels=1. N >= 1 and num_labels is the number of target classes for
the associated prediction. Commonly, N=1 and `labels` has shape
[batch_size, num_labels]. [D1,... DN] must match `predictions`. Values
should be in range [0, num_classes), where num_classes is the last
dimension of `predictions`. Values outside this range always count
towards `false_negative_at_<k>`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>Float `Tensor` with shape [D1,... DN, num_classes] where
N >= 1. Commonly, N=1 and predictions has shape [batch size, num_classes].
The final dimension contains the logit values for each class. [D1,... DN]
must match `labels`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> k
						</dt>
						<dd>Integer, k for @k metric. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> class_id
						</dt>
						<dd>Integer class ID for which we want binary metrics. This should be
in range [0, num_classes), where num_classes is the last dimension of
`predictions`. If class_id is outside this range, the method returns NAN. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<double>">ValueTuple&lt;double&gt;</span></code> weights
						</dt>
						<dd>`Tensor` whose rank is either 0, or n-1, where n is the rank of
`labels`. If the latter, it must be broadcastable to `labels` (i.e., all
dimensions must be either `1`, or the same as the corresponding `labels`
dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that values should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that updates should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>Name of new update operation, and namespace for other dependent ops. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall_at_k" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>recall_at_k</strong>(<span title="System.object">object</span> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.int">int</span> k, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> class_id, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes recall@k of the predictions with respect to sparse labels. <p></p> If `class_id` is specified, we calculate recall by considering only the
entries in the batch for which `class_id` is in the label, and computing
the fraction of them for which `class_id` is in the top-k `predictions`.
If `class_id` is not specified, we'll calculate recall as how often on
average a class among the labels of a batch entry is in the top-k
`predictions`. <p></p> `sparse_recall_at_k` creates two local variables,
`true_positive_at_<k>` and `false_negative_at_<k>`, that are used to compute
the recall_at_k frequency. This frequency is ultimately returned as
`recall_at_<k>`: an idempotent operation that simply divides
`true_positive_at_<k>` by total (`true_positive_at_<k>` +
`false_negative_at_<k>`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`recall_at_<k>`. Internally, a `top_k` operation computes a `Tensor`
indicating the top `k` `predictions`. Set operations applied to `top_k` and
`labels` calculate the true positives and false negatives weighted by
`weights`. Then `update_op` increments `true_positive_at_<k>` and
`false_negative_at_<k>` using these values. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>`int64` `Tensor` or `SparseTensor` with shape
[D1,... DN, num_labels] or [D1,... DN], where the latter implies
num_labels=1. N >= 1 and num_labels is the number of target classes for
the associated prediction. Commonly, N=1 and `labels` has shape
[batch_size, num_labels]. [D1,... DN] must match `predictions`. Values
should be in range [0, num_classes), where num_classes is the last
dimension of `predictions`. Values outside this range always count
towards `false_negative_at_<k>`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>Float `Tensor` with shape [D1,... DN, num_classes] where
N >= 1. Commonly, N=1 and predictions has shape [batch size, num_classes].
The final dimension contains the logit values for each class. [D1,... DN]
must match `labels`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> k
						</dt>
						<dd>Integer, k for @k metric. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> class_id
						</dt>
						<dd>Integer class ID for which we want binary metrics. This should be
in range [0, num_classes), where num_classes is the last dimension of
`predictions`. If class_id is outside this range, the method returns NAN. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> weights
						</dt>
						<dd>`Tensor` whose rank is either 0, or n-1, where n is the rank of
`labels`. If the latter, it must be broadcastable to `labels` (i.e., all
dimensions must be either `1`, or the same as the corresponding `labels`
dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that values should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that updates should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>Name of new update operation, and namespace for other dependent ops. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall_at_k" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>recall_at_k</strong>(<a href="../numpy/ndarray.htm">ndarray</a> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.int">int</span> k, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> class_id, <span title="System.ValueTuple<double>">ValueTuple&lt;double&gt;</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes recall@k of the predictions with respect to sparse labels. <p></p> If `class_id` is specified, we calculate recall by considering only the
entries in the batch for which `class_id` is in the label, and computing
the fraction of them for which `class_id` is in the top-k `predictions`.
If `class_id` is not specified, we'll calculate recall as how often on
average a class among the labels of a batch entry is in the top-k
`predictions`. <p></p> `sparse_recall_at_k` creates two local variables,
`true_positive_at_<k>` and `false_negative_at_<k>`, that are used to compute
the recall_at_k frequency. This frequency is ultimately returned as
`recall_at_<k>`: an idempotent operation that simply divides
`true_positive_at_<k>` by total (`true_positive_at_<k>` +
`false_negative_at_<k>`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`recall_at_<k>`. Internally, a `top_k` operation computes a `Tensor`
indicating the top `k` `predictions`. Set operations applied to `top_k` and
`labels` calculate the true positives and false negatives weighted by
`weights`. Then `update_op` increments `true_positive_at_<k>` and
`false_negative_at_<k>` using these values. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> labels
						</dt>
						<dd>`int64` `Tensor` or `SparseTensor` with shape
[D1,... DN, num_labels] or [D1,... DN], where the latter implies
num_labels=1. N >= 1 and num_labels is the number of target classes for
the associated prediction. Commonly, N=1 and `labels` has shape
[batch_size, num_labels]. [D1,... DN] must match `predictions`. Values
should be in range [0, num_classes), where num_classes is the last
dimension of `predictions`. Values outside this range always count
towards `false_negative_at_<k>`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>Float `Tensor` with shape [D1,... DN, num_classes] where
N >= 1. Commonly, N=1 and predictions has shape [batch size, num_classes].
The final dimension contains the logit values for each class. [D1,... DN]
must match `labels`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> k
						</dt>
						<dd>Integer, k for @k metric. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> class_id
						</dt>
						<dd>Integer class ID for which we want binary metrics. This should be
in range [0, num_classes), where num_classes is the last dimension of
`predictions`. If class_id is outside this range, the method returns NAN. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<double>">ValueTuple&lt;double&gt;</span></code> weights
						</dt>
						<dd>`Tensor` whose rank is either 0, or n-1, where n is the rank of
`labels`. If the latter, it must be broadcastable to `labels` (i.e., all
dimensions must be either `1`, or the same as the corresponding `labels`
dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that values should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that updates should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>Name of new update operation, and namespace for other dependent ops. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall_at_k" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>recall_at_k</strong>(<a href="../numpy/ndarray.htm">ndarray</a> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.int">int</span> k, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> class_id, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes recall@k of the predictions with respect to sparse labels. <p></p> If `class_id` is specified, we calculate recall by considering only the
entries in the batch for which `class_id` is in the label, and computing
the fraction of them for which `class_id` is in the top-k `predictions`.
If `class_id` is not specified, we'll calculate recall as how often on
average a class among the labels of a batch entry is in the top-k
`predictions`. <p></p> `sparse_recall_at_k` creates two local variables,
`true_positive_at_<k>` and `false_negative_at_<k>`, that are used to compute
the recall_at_k frequency. This frequency is ultimately returned as
`recall_at_<k>`: an idempotent operation that simply divides
`true_positive_at_<k>` by total (`true_positive_at_<k>` +
`false_negative_at_<k>`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`recall_at_<k>`. Internally, a `top_k` operation computes a `Tensor`
indicating the top `k` `predictions`. Set operations applied to `top_k` and
`labels` calculate the true positives and false negatives weighted by
`weights`. Then `update_op` increments `true_positive_at_<k>` and
`false_negative_at_<k>` using these values. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> labels
						</dt>
						<dd>`int64` `Tensor` or `SparseTensor` with shape
[D1,... DN, num_labels] or [D1,... DN], where the latter implies
num_labels=1. N >= 1 and num_labels is the number of target classes for
the associated prediction. Commonly, N=1 and `labels` has shape
[batch_size, num_labels]. [D1,... DN] must match `predictions`. Values
should be in range [0, num_classes), where num_classes is the last
dimension of `predictions`. Values outside this range always count
towards `false_negative_at_<k>`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>Float `Tensor` with shape [D1,... DN, num_classes] where
N >= 1. Commonly, N=1 and predictions has shape [batch size, num_classes].
The final dimension contains the logit values for each class. [D1,... DN]
must match `labels`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> k
						</dt>
						<dd>Integer, k for @k metric. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> class_id
						</dt>
						<dd>Integer class ID for which we want binary metrics. This should be
in range [0, num_classes), where num_classes is the last dimension of
`predictions`. If class_id is outside this range, the method returns NAN. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> weights
						</dt>
						<dd>`Tensor` whose rank is either 0, or n-1, where n is the rank of
`labels`. If the latter, it must be broadcastable to `labels` (i.e., all
dimensions must be either `1`, or the same as the corresponding `labels`
dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that values should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that updates should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>Name of new update operation, and namespace for other dependent ops. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall_at_k" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>recall_at_k</strong>(<a href="../numpy/ndarray.htm">ndarray</a> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.int">int</span> k, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> class_id, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes recall@k of the predictions with respect to sparse labels. <p></p> If `class_id` is specified, we calculate recall by considering only the
entries in the batch for which `class_id` is in the label, and computing
the fraction of them for which `class_id` is in the top-k `predictions`.
If `class_id` is not specified, we'll calculate recall as how often on
average a class among the labels of a batch entry is in the top-k
`predictions`. <p></p> `sparse_recall_at_k` creates two local variables,
`true_positive_at_<k>` and `false_negative_at_<k>`, that are used to compute
the recall_at_k frequency. This frequency is ultimately returned as
`recall_at_<k>`: an idempotent operation that simply divides
`true_positive_at_<k>` by total (`true_positive_at_<k>` +
`false_negative_at_<k>`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`recall_at_<k>`. Internally, a `top_k` operation computes a `Tensor`
indicating the top `k` `predictions`. Set operations applied to `top_k` and
`labels` calculate the true positives and false negatives weighted by
`weights`. Then `update_op` increments `true_positive_at_<k>` and
`false_negative_at_<k>` using these values. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> labels
						</dt>
						<dd>`int64` `Tensor` or `SparseTensor` with shape
[D1,... DN, num_labels] or [D1,... DN], where the latter implies
num_labels=1. N >= 1 and num_labels is the number of target classes for
the associated prediction. Commonly, N=1 and `labels` has shape
[batch_size, num_labels]. [D1,... DN] must match `predictions`. Values
should be in range [0, num_classes), where num_classes is the last
dimension of `predictions`. Values outside this range always count
towards `false_negative_at_<k>`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>Float `Tensor` with shape [D1,... DN, num_classes] where
N >= 1. Commonly, N=1 and predictions has shape [batch size, num_classes].
The final dimension contains the logit values for each class. [D1,... DN]
must match `labels`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> k
						</dt>
						<dd>Integer, k for @k metric. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> class_id
						</dt>
						<dd>Integer class ID for which we want binary metrics. This should be
in range [0, num_classes), where num_classes is the last dimension of
`predictions`. If class_id is outside this range, the method returns NAN. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>`Tensor` whose rank is either 0, or n-1, where n is the rank of
`labels`. If the latter, it must be broadcastable to `labels` (i.e., all
dimensions must be either `1`, or the same as the corresponding `labels`
dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that values should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that updates should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>Name of new update operation, and namespace for other dependent ops. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall_at_k" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>recall_at_k</strong>(<span title="System.object">object</span> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.int">int</span> k, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> class_id, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes recall@k of the predictions with respect to sparse labels. <p></p> If `class_id` is specified, we calculate recall by considering only the
entries in the batch for which `class_id` is in the label, and computing
the fraction of them for which `class_id` is in the top-k `predictions`.
If `class_id` is not specified, we'll calculate recall as how often on
average a class among the labels of a batch entry is in the top-k
`predictions`. <p></p> `sparse_recall_at_k` creates two local variables,
`true_positive_at_<k>` and `false_negative_at_<k>`, that are used to compute
the recall_at_k frequency. This frequency is ultimately returned as
`recall_at_<k>`: an idempotent operation that simply divides
`true_positive_at_<k>` by total (`true_positive_at_<k>` +
`false_negative_at_<k>`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`recall_at_<k>`. Internally, a `top_k` operation computes a `Tensor`
indicating the top `k` `predictions`. Set operations applied to `top_k` and
`labels` calculate the true positives and false negatives weighted by
`weights`. Then `update_op` increments `true_positive_at_<k>` and
`false_negative_at_<k>` using these values. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>`int64` `Tensor` or `SparseTensor` with shape
[D1,... DN, num_labels] or [D1,... DN], where the latter implies
num_labels=1. N >= 1 and num_labels is the number of target classes for
the associated prediction. Commonly, N=1 and `labels` has shape
[batch_size, num_labels]. [D1,... DN] must match `predictions`. Values
should be in range [0, num_classes), where num_classes is the last
dimension of `predictions`. Values outside this range always count
towards `false_negative_at_<k>`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>Float `Tensor` with shape [D1,... DN, num_classes] where
N >= 1. Commonly, N=1 and predictions has shape [batch size, num_classes].
The final dimension contains the logit values for each class. [D1,... DN]
must match `labels`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> k
						</dt>
						<dd>Integer, k for @k metric. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> class_id
						</dt>
						<dd>Integer class ID for which we want binary metrics. This should be
in range [0, num_classes), where num_classes is the last dimension of
`predictions`. If class_id is outside this range, the method returns NAN. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>`Tensor` whose rank is either 0, or n-1, where n is the rank of
`labels`. If the latter, it must be broadcastable to `labels` (i.e., all
dimensions must be either `1`, or the same as the corresponding `labels`
dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that values should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that updates should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>Name of new update operation, and namespace for other dependent ops. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall_at_k" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>recall_at_k</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.int">int</span> k, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> class_id, <span title="System.ValueTuple<double>">ValueTuple&lt;double&gt;</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes recall@k of the predictions with respect to sparse labels. <p></p> If `class_id` is specified, we calculate recall by considering only the
entries in the batch for which `class_id` is in the label, and computing
the fraction of them for which `class_id` is in the top-k `predictions`.
If `class_id` is not specified, we'll calculate recall as how often on
average a class among the labels of a batch entry is in the top-k
`predictions`. <p></p> `sparse_recall_at_k` creates two local variables,
`true_positive_at_<k>` and `false_negative_at_<k>`, that are used to compute
the recall_at_k frequency. This frequency is ultimately returned as
`recall_at_<k>`: an idempotent operation that simply divides
`true_positive_at_<k>` by total (`true_positive_at_<k>` +
`false_negative_at_<k>`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`recall_at_<k>`. Internally, a `top_k` operation computes a `Tensor`
indicating the top `k` `predictions`. Set operations applied to `top_k` and
`labels` calculate the true positives and false negatives weighted by
`weights`. Then `update_op` increments `true_positive_at_<k>` and
`false_negative_at_<k>` using these values. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>`int64` `Tensor` or `SparseTensor` with shape
[D1,... DN, num_labels] or [D1,... DN], where the latter implies
num_labels=1. N >= 1 and num_labels is the number of target classes for
the associated prediction. Commonly, N=1 and `labels` has shape
[batch_size, num_labels]. [D1,... DN] must match `predictions`. Values
should be in range [0, num_classes), where num_classes is the last
dimension of `predictions`. Values outside this range always count
towards `false_negative_at_<k>`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>Float `Tensor` with shape [D1,... DN, num_classes] where
N >= 1. Commonly, N=1 and predictions has shape [batch size, num_classes].
The final dimension contains the logit values for each class. [D1,... DN]
must match `labels`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> k
						</dt>
						<dd>Integer, k for @k metric. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> class_id
						</dt>
						<dd>Integer class ID for which we want binary metrics. This should be
in range [0, num_classes), where num_classes is the last dimension of
`predictions`. If class_id is outside this range, the method returns NAN. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<double>">ValueTuple&lt;double&gt;</span></code> weights
						</dt>
						<dd>`Tensor` whose rank is either 0, or n-1, where n is the rank of
`labels`. If the latter, it must be broadcastable to `labels` (i.e., all
dimensions must be either `1`, or the same as the corresponding `labels`
dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that values should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that updates should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>Name of new update operation, and namespace for other dependent ops. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall_at_k" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>recall_at_k</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.int">int</span> k, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> class_id, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes recall@k of the predictions with respect to sparse labels. <p></p> If `class_id` is specified, we calculate recall by considering only the
entries in the batch for which `class_id` is in the label, and computing
the fraction of them for which `class_id` is in the top-k `predictions`.
If `class_id` is not specified, we'll calculate recall as how often on
average a class among the labels of a batch entry is in the top-k
`predictions`. <p></p> `sparse_recall_at_k` creates two local variables,
`true_positive_at_<k>` and `false_negative_at_<k>`, that are used to compute
the recall_at_k frequency. This frequency is ultimately returned as
`recall_at_<k>`: an idempotent operation that simply divides
`true_positive_at_<k>` by total (`true_positive_at_<k>` +
`false_negative_at_<k>`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`recall_at_<k>`. Internally, a `top_k` operation computes a `Tensor`
indicating the top `k` `predictions`. Set operations applied to `top_k` and
`labels` calculate the true positives and false negatives weighted by
`weights`. Then `update_op` increments `true_positive_at_<k>` and
`false_negative_at_<k>` using these values. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>`int64` `Tensor` or `SparseTensor` with shape
[D1,... DN, num_labels] or [D1,... DN], where the latter implies
num_labels=1. N >= 1 and num_labels is the number of target classes for
the associated prediction. Commonly, N=1 and `labels` has shape
[batch_size, num_labels]. [D1,... DN] must match `predictions`. Values
should be in range [0, num_classes), where num_classes is the last
dimension of `predictions`. Values outside this range always count
towards `false_negative_at_<k>`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>Float `Tensor` with shape [D1,... DN, num_classes] where
N >= 1. Commonly, N=1 and predictions has shape [batch size, num_classes].
The final dimension contains the logit values for each class. [D1,... DN]
must match `labels`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> k
						</dt>
						<dd>Integer, k for @k metric. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> class_id
						</dt>
						<dd>Integer class ID for which we want binary metrics. This should be
in range [0, num_classes), where num_classes is the last dimension of
`predictions`. If class_id is outside this range, the method returns NAN. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>`Tensor` whose rank is either 0, or n-1, where n is the rank of
`labels`. If the latter, it must be broadcastable to `labels` (i.e., all
dimensions must be either `1`, or the same as the corresponding `labels`
dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that values should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that updates should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>Name of new update operation, and namespace for other dependent ops. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall_at_k" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>recall_at_k</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.int">int</span> k, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> class_id, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes recall@k of the predictions with respect to sparse labels. <p></p> If `class_id` is specified, we calculate recall by considering only the
entries in the batch for which `class_id` is in the label, and computing
the fraction of them for which `class_id` is in the top-k `predictions`.
If `class_id` is not specified, we'll calculate recall as how often on
average a class among the labels of a batch entry is in the top-k
`predictions`. <p></p> `sparse_recall_at_k` creates two local variables,
`true_positive_at_<k>` and `false_negative_at_<k>`, that are used to compute
the recall_at_k frequency. This frequency is ultimately returned as
`recall_at_<k>`: an idempotent operation that simply divides
`true_positive_at_<k>` by total (`true_positive_at_<k>` +
`false_negative_at_<k>`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`recall_at_<k>`. Internally, a `top_k` operation computes a `Tensor`
indicating the top `k` `predictions`. Set operations applied to `top_k` and
`labels` calculate the true positives and false negatives weighted by
`weights`. Then `update_op` increments `true_positive_at_<k>` and
`false_negative_at_<k>` using these values. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>`int64` `Tensor` or `SparseTensor` with shape
[D1,... DN, num_labels] or [D1,... DN], where the latter implies
num_labels=1. N >= 1 and num_labels is the number of target classes for
the associated prediction. Commonly, N=1 and `labels` has shape
[batch_size, num_labels]. [D1,... DN] must match `predictions`. Values
should be in range [0, num_classes), where num_classes is the last
dimension of `predictions`. Values outside this range always count
towards `false_negative_at_<k>`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>Float `Tensor` with shape [D1,... DN, num_classes] where
N >= 1. Commonly, N=1 and predictions has shape [batch size, num_classes].
The final dimension contains the logit values for each class. [D1,... DN]
must match `labels`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> k
						</dt>
						<dd>Integer, k for @k metric. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> class_id
						</dt>
						<dd>Integer class ID for which we want binary metrics. This should be
in range [0, num_classes), where num_classes is the last dimension of
`predictions`. If class_id is outside this range, the method returns NAN. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> weights
						</dt>
						<dd>`Tensor` whose rank is either 0, or n-1, where n is the rank of
`labels`. If the latter, it must be broadcastable to `labels` (i.e., all
dimensions must be either `1`, or the same as the corresponding `labels`
dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that values should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that updates should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>Name of new update operation, and namespace for other dependent ops. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall_at_k_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>recall_at_k_dyn</strong>(<span title="System.object">object</span> labels, <span title="System.object">object</span> predictions, <span title="System.object">object</span> k, <span title="System.object">object</span> class_id, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Computes recall@k of the predictions with respect to sparse labels. <p></p> If `class_id` is specified, we calculate recall by considering only the
entries in the batch for which `class_id` is in the label, and computing
the fraction of them for which `class_id` is in the top-k `predictions`.
If `class_id` is not specified, we'll calculate recall as how often on
average a class among the labels of a batch entry is in the top-k
`predictions`. <p></p> `sparse_recall_at_k` creates two local variables,
`true_positive_at_<k>` and `false_negative_at_<k>`, that are used to compute
the recall_at_k frequency. This frequency is ultimately returned as
`recall_at_<k>`: an idempotent operation that simply divides
`true_positive_at_<k>` by total (`true_positive_at_<k>` +
`false_negative_at_<k>`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`recall_at_<k>`. Internally, a `top_k` operation computes a `Tensor`
indicating the top `k` `predictions`. Set operations applied to `top_k` and
`labels` calculate the true positives and false negatives weighted by
`weights`. Then `update_op` increments `true_positive_at_<k>` and
`false_negative_at_<k>` using these values. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>`int64` `Tensor` or `SparseTensor` with shape
[D1,... DN, num_labels] or [D1,... DN], where the latter implies
num_labels=1. N >= 1 and num_labels is the number of target classes for
the associated prediction. Commonly, N=1 and `labels` has shape
[batch_size, num_labels]. [D1,... DN] must match `predictions`. Values
should be in range [0, num_classes), where num_classes is the last
dimension of `predictions`. Values outside this range always count
towards `false_negative_at_<k>`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>Float `Tensor` with shape [D1,... DN, num_classes] where
N >= 1. Commonly, N=1 and predictions has shape [batch size, num_classes].
The final dimension contains the logit values for each class. [D1,... DN]
must match `labels`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> k
						</dt>
						<dd>Integer, k for @k metric. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> class_id
						</dt>
						<dd>Integer class ID for which we want binary metrics. This should be
in range [0, num_classes), where num_classes is the last dimension of
`predictions`. If class_id is outside this range, the method returns NAN. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>`Tensor` whose rank is either 0, or n-1, where n is the rank of
`labels`. If the latter, it must be broadcastable to `labels` (i.e., all
dimensions must be either `1`, or the same as the corresponding `labels`
dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that values should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that updates should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>Name of new update operation, and namespace for other dependent ops. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>recall_at_thresholds</strong>(<span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> labels, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> predictions, <span title="System.object">object</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> name)
		</h4>
		<div class="content">Computes various recall values for different `thresholds` on `predictions`. <p></p> The `recall_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `recall[i]` is defined as the total weight
of values in `predictions` above `thresholds[i]` whose corresponding entry in
`labels` is `True`, divided by the total weight of `True` values in `labels`
(`true_positives[i] / (true_positives[i] + false_negatives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `recall`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `recall` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>recall_at_thresholds</strong>(<span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.object">object</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> name)
		</h4>
		<div class="content">Computes various recall values for different `thresholds` on `predictions`. <p></p> The `recall_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `recall[i]` is defined as the total weight
of values in `predictions` above `thresholds[i]` whose corresponding entry in
`labels` is `True`, divided by the total weight of `True` values in `labels`
(`true_positives[i] / (true_positives[i] + false_negatives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `recall`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `recall` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>recall_at_thresholds</strong>(<span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> labels, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> predictions, <span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes various recall values for different `thresholds` on `predictions`. <p></p> The `recall_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `recall[i]` is defined as the total weight
of values in `predictions` above `thresholds[i]` whose corresponding entry in
`labels` is `True`, divided by the total weight of `True` values in `labels`
(`true_positives[i] / (true_positives[i] + false_negatives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `recall`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `recall` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>recall_at_thresholds</strong>(<span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> labels, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> predictions, <span title="System.object">object</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes various recall values for different `thresholds` on `predictions`. <p></p> The `recall_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `recall[i]` is defined as the total weight
of values in `predictions` above `thresholds[i]` whose corresponding entry in
`labels` is `True`, divided by the total weight of `True` values in `labels`
(`true_positives[i] / (true_positives[i] + false_negatives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `recall`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `recall` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>recall_at_thresholds</strong>(<span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> labels, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> predictions, <span title="System.object">object</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> name)
		</h4>
		<div class="content">Computes various recall values for different `thresholds` on `predictions`. <p></p> The `recall_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `recall[i]` is defined as the total weight
of values in `predictions` above `thresholds[i]` whose corresponding entry in
`labels` is `True`, divided by the total weight of `True` values in `labels`
(`true_positives[i] / (true_positives[i] + false_negatives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `recall`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `recall` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>recall_at_thresholds</strong>(<span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> labels, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> predictions, <span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> name)
		</h4>
		<div class="content">Computes various recall values for different `thresholds` on `predictions`. <p></p> The `recall_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `recall[i]` is defined as the total weight
of values in `predictions` above `thresholds[i]` whose corresponding entry in
`labels` is `True`, divided by the total weight of `True` values in `labels`
(`true_positives[i] / (true_positives[i] + false_negatives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `recall`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `recall` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>recall_at_thresholds</strong>(<span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> labels, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> predictions, <span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> name)
		</h4>
		<div class="content">Computes various recall values for different `thresholds` on `predictions`. <p></p> The `recall_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `recall[i]` is defined as the total weight
of values in `predictions` above `thresholds[i]` whose corresponding entry in
`labels` is `True`, divided by the total weight of `True` values in `labels`
(`true_positives[i] / (true_positives[i] + false_negatives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `recall`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `recall` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>recall_at_thresholds</strong>(<span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> labels, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> predictions, <span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes various recall values for different `thresholds` on `predictions`. <p></p> The `recall_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `recall[i]` is defined as the total weight
of values in `predictions` above `thresholds[i]` whose corresponding entry in
`labels` is `True`, divided by the total weight of `True` values in `labels`
(`true_positives[i] / (true_positives[i] + false_negatives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `recall`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `recall` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>recall_at_thresholds</strong>(<span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> name)
		</h4>
		<div class="content">Computes various recall values for different `thresholds` on `predictions`. <p></p> The `recall_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `recall[i]` is defined as the total weight
of values in `predictions` above `thresholds[i]` whose corresponding entry in
`labels` is `True`, divided by the total weight of `True` values in `labels`
(`true_positives[i] / (true_positives[i] + false_negatives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `recall`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `recall` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>recall_at_thresholds</strong>(<span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes various recall values for different `thresholds` on `predictions`. <p></p> The `recall_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `recall[i]` is defined as the total weight
of values in `predictions` above `thresholds[i]` whose corresponding entry in
`labels` is `True`, divided by the total weight of `True` values in `labels`
(`true_positives[i] / (true_positives[i] + false_negatives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `recall`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `recall` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>recall_at_thresholds</strong>(<span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.object">object</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes various recall values for different `thresholds` on `predictions`. <p></p> The `recall_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `recall[i]` is defined as the total weight
of values in `predictions` above `thresholds[i]` whose corresponding entry in
`labels` is `True`, divided by the total weight of `True` values in `labels`
(`true_positives[i] / (true_positives[i] + false_negatives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `recall`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `recall` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>recall_at_thresholds</strong>(<span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.object">object</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes various recall values for different `thresholds` on `predictions`. <p></p> The `recall_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `recall[i]` is defined as the total weight
of values in `predictions` above `thresholds[i]` whose corresponding entry in
`labels` is `True`, divided by the total weight of `True` values in `labels`
(`true_positives[i] / (true_positives[i] + false_negatives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `recall`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `recall` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>recall_at_thresholds</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> predictions, <span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes various recall values for different `thresholds` on `predictions`. <p></p> The `recall_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `recall[i]` is defined as the total weight
of values in `predictions` above `thresholds[i]` whose corresponding entry in
`labels` is `True`, divided by the total weight of `True` values in `labels`
(`true_positives[i] / (true_positives[i] + false_negatives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `recall`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `recall` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>recall_at_thresholds</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.object">object</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes various recall values for different `thresholds` on `predictions`. <p></p> The `recall_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `recall[i]` is defined as the total weight
of values in `predictions` above `thresholds[i]` whose corresponding entry in
`labels` is `True`, divided by the total weight of `True` values in `labels`
(`true_positives[i] / (true_positives[i] + false_negatives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `recall`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `recall` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>recall_at_thresholds</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.object">object</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> name)
		</h4>
		<div class="content">Computes various recall values for different `thresholds` on `predictions`. <p></p> The `recall_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `recall[i]` is defined as the total weight
of values in `predictions` above `thresholds[i]` whose corresponding entry in
`labels` is `True`, divided by the total weight of `True` values in `labels`
(`true_positives[i] / (true_positives[i] + false_negatives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `recall`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `recall` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>recall_at_thresholds</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes various recall values for different `thresholds` on `predictions`. <p></p> The `recall_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `recall[i]` is defined as the total weight
of values in `predictions` above `thresholds[i]` whose corresponding entry in
`labels` is `True`, divided by the total weight of `True` values in `labels`
(`true_positives[i] / (true_positives[i] + false_negatives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `recall`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `recall` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>recall_at_thresholds</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> name)
		</h4>
		<div class="content">Computes various recall values for different `thresholds` on `predictions`. <p></p> The `recall_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `recall[i]` is defined as the total weight
of values in `predictions` above `thresholds[i]` whose corresponding entry in
`labels` is `True`, divided by the total weight of `True` values in `labels`
(`true_positives[i] / (true_positives[i] + false_negatives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `recall`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `recall` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>recall_at_thresholds</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> predictions, <span title="System.object">object</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes various recall values for different `thresholds` on `predictions`. <p></p> The `recall_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `recall[i]` is defined as the total weight
of values in `predictions` above `thresholds[i]` whose corresponding entry in
`labels` is `True`, divided by the total weight of `True` values in `labels`
(`true_positives[i] / (true_positives[i] + false_negatives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `recall`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `recall` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>recall_at_thresholds</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> predictions, <span title="System.object">object</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> name)
		</h4>
		<div class="content">Computes various recall values for different `thresholds` on `predictions`. <p></p> The `recall_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `recall[i]` is defined as the total weight
of values in `predictions` above `thresholds[i]` whose corresponding entry in
`labels` is `True`, divided by the total weight of `True` values in `labels`
(`true_positives[i] / (true_positives[i] + false_negatives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `recall`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `recall` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>recall_at_thresholds</strong>(<span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> labels, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> predictions, <span title="System.object">object</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes various recall values for different `thresholds` on `predictions`. <p></p> The `recall_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `recall[i]` is defined as the total weight
of values in `predictions` above `thresholds[i]` whose corresponding entry in
`labels` is `True`, divided by the total weight of `True` values in `labels`
(`true_positives[i] / (true_positives[i] + false_negatives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `recall`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `recall` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>recall_at_thresholds</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> predictions, <span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> name)
		</h4>
		<div class="content">Computes various recall values for different `thresholds` on `predictions`. <p></p> The `recall_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `recall[i]` is defined as the total weight
of values in `predictions` above `thresholds[i]` whose corresponding entry in
`labels` is `True`, divided by the total weight of `True` values in `labels`
(`true_positives[i] / (true_positives[i] + false_negatives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `recall`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `recall` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>recall_at_thresholds</strong>(<a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.object">object</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> name)
		</h4>
		<div class="content">Computes various recall values for different `thresholds` on `predictions`. <p></p> The `recall_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `recall[i]` is defined as the total weight
of values in `predictions` above `thresholds[i]` whose corresponding entry in
`labels` is `True`, divided by the total weight of `True` values in `labels`
(`true_positives[i] / (true_positives[i] + false_negatives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `recall`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `recall` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>recall_at_thresholds</strong>(<a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.object">object</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes various recall values for different `thresholds` on `predictions`. <p></p> The `recall_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `recall[i]` is defined as the total weight
of values in `predictions` above `thresholds[i]` whose corresponding entry in
`labels` is `True`, divided by the total weight of `True` values in `labels`
(`true_positives[i] / (true_positives[i] + false_negatives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `recall`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `recall` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>recall_at_thresholds</strong>(<a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> name)
		</h4>
		<div class="content">Computes various recall values for different `thresholds` on `predictions`. <p></p> The `recall_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `recall[i]` is defined as the total weight
of values in `predictions` above `thresholds[i]` whose corresponding entry in
`labels` is `True`, divided by the total weight of `True` values in `labels`
(`true_positives[i] / (true_positives[i] + false_negatives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `recall`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `recall` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>recall_at_thresholds</strong>(<a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> labels, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> predictions, <span title="System.object">object</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes various recall values for different `thresholds` on `predictions`. <p></p> The `recall_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `recall[i]` is defined as the total weight
of values in `predictions` above `thresholds[i]` whose corresponding entry in
`labels` is `True`, divided by the total weight of `True` values in `labels`
(`true_positives[i] / (true_positives[i] + false_negatives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `recall`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `recall` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>recall_at_thresholds</strong>(<a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> labels, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> predictions, <span title="System.object">object</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> name)
		</h4>
		<div class="content">Computes various recall values for different `thresholds` on `predictions`. <p></p> The `recall_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `recall[i]` is defined as the total weight
of values in `predictions` above `thresholds[i]` whose corresponding entry in
`labels` is `True`, divided by the total weight of `True` values in `labels`
(`true_positives[i] / (true_positives[i] + false_negatives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `recall`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `recall` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>recall_at_thresholds</strong>(<a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> labels, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> predictions, <span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> name)
		</h4>
		<div class="content">Computes various recall values for different `thresholds` on `predictions`. <p></p> The `recall_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `recall[i]` is defined as the total weight
of values in `predictions` above `thresholds[i]` whose corresponding entry in
`labels` is `True`, divided by the total weight of `True` values in `labels`
(`true_positives[i] / (true_positives[i] + false_negatives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `recall`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `recall` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>recall_at_thresholds</strong>(<span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.object">object</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> name)
		</h4>
		<div class="content">Computes various recall values for different `thresholds` on `predictions`. <p></p> The `recall_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `recall[i]` is defined as the total weight
of values in `predictions` above `thresholds[i]` whose corresponding entry in
`labels` is `True`, divided by the total weight of `True` values in `labels`
(`true_positives[i] / (true_positives[i] + false_negatives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `recall`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `recall` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>recall_at_thresholds</strong>(<span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes various recall values for different `thresholds` on `predictions`. <p></p> The `recall_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `recall[i]` is defined as the total weight
of values in `predictions` above `thresholds[i]` whose corresponding entry in
`labels` is `True`, divided by the total weight of `True` values in `labels`
(`true_positives[i] / (true_positives[i] + false_negatives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `recall`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `recall` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>recall_at_thresholds</strong>(<span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> name)
		</h4>
		<div class="content">Computes various recall values for different `thresholds` on `predictions`. <p></p> The `recall_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `recall[i]` is defined as the total weight
of values in `predictions` above `thresholds[i]` whose corresponding entry in
`labels` is `True`, divided by the total weight of `True` values in `labels`
(`true_positives[i] / (true_positives[i] + false_negatives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `recall`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `recall` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>recall_at_thresholds</strong>(<a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> labels, <span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span> predictions, <span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes various recall values for different `thresholds` on `predictions`. <p></p> The `recall_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `recall[i]` is defined as the total weight
of values in `predictions` above `thresholds[i]` whose corresponding entry in
`labels` is `True`, divided by the total weight of `True` values in `labels`
(`true_positives[i] / (true_positives[i] + false_negatives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `recall`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<object, object>">IDictionary&lt;object, object&gt;</span></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `recall` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>recall_at_thresholds</strong>(<a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span> thresholds, <span title="System.object">object</span> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes various recall values for different `thresholds` on `predictions`. <p></p> The `recall_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `recall[i]` is defined as the total weight
of values in `predictions` above `thresholds[i]` whose corresponding entry in
`labels` is `True`, divided by the total weight of `True` values in `labels`
(`true_positives[i] / (true_positives[i] + false_negatives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `recall`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `recall` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall_at_thresholds_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>recall_at_thresholds_dyn</strong>(<span title="System.object">object</span> labels, <span title="System.object">object</span> predictions, <span title="System.object">object</span> thresholds, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Computes various recall values for different `thresholds` on `predictions`. <p></p> The `recall_at_thresholds` function creates four local variables,
`true_positives`, `true_negatives`, `false_positives` and `false_negatives`
for various values of thresholds. `recall[i]` is defined as the total weight
of values in `predictions` above `thresholds[i]` whose corresponding entry in
`labels` is `True`, divided by the total weight of `True` values in `labels`
(`true_positives[i] / (true_positives[i] + false_negatives[i])`). <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the `recall`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `recall` should be
added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall_at_top_k" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>recall_at_top_k</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions_idx, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> k, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> class_id, <span title="System.ValueTuple<double>">ValueTuple&lt;double&gt;</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes recall@k of top-k predictions with respect to sparse labels. <p></p> Differs from `recall_at_k` in that predictions must be in the form of top `k`
class indices, whereas `recall_at_k` expects logits. Refer to `recall_at_k`
for more details. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> labels
						</dt>
						<dd>`int64` `Tensor` or `SparseTensor` with shape
[D1,... DN, num_labels] or [D1,... DN], where the latter implies
num_labels=1. N >= 1 and num_labels is the number of target classes for
the associated prediction. Commonly, N=1 and `labels` has shape
[batch_size, num_labels]. [D1,... DN] must match `predictions`. Values
should be in range [0, num_classes), where num_classes is the last
dimension of `predictions`. Values outside this range always count
towards `false_negative_at_<k>`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions_idx
						</dt>
						<dd>Integer `Tensor` with shape [D1,... DN, k] where N >= 1.
Commonly, N=1 and predictions has shape [batch size, k]. The final
dimension contains the top `k` predicted class indices. [D1,... DN] must
match `labels`. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> k
						</dt>
						<dd>Integer, k for @k metric. Only used for the default op name. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> class_id
						</dt>
						<dd>Integer class ID for which we want binary metrics. This should be
in range [0, num_classes), where num_classes is the last dimension of
`predictions`. If class_id is outside this range, the method returns NAN. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<double>">ValueTuple&lt;double&gt;</span></code> weights
						</dt>
						<dd>`Tensor` whose rank is either 0, or n-1, where n is the rank of
`labels`. If the latter, it must be broadcastable to `labels` (i.e., all
dimensions must be either `1`, or the same as the corresponding `labels`
dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that values should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that updates should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>Name of new update operation, and namespace for other dependent ops. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall_at_top_k" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>recall_at_top_k</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions_idx, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> k, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> class_id, <span title="System.ValueTuple<double>">ValueTuple&lt;double&gt;</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> name)
		</h4>
		<div class="content">Computes recall@k of top-k predictions with respect to sparse labels. <p></p> Differs from `recall_at_k` in that predictions must be in the form of top `k`
class indices, whereas `recall_at_k` expects logits. Refer to `recall_at_k`
for more details. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> labels
						</dt>
						<dd>`int64` `Tensor` or `SparseTensor` with shape
[D1,... DN, num_labels] or [D1,... DN], where the latter implies
num_labels=1. N >= 1 and num_labels is the number of target classes for
the associated prediction. Commonly, N=1 and `labels` has shape
[batch_size, num_labels]. [D1,... DN] must match `predictions`. Values
should be in range [0, num_classes), where num_classes is the last
dimension of `predictions`. Values outside this range always count
towards `false_negative_at_<k>`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions_idx
						</dt>
						<dd>Integer `Tensor` with shape [D1,... DN, k] where N >= 1.
Commonly, N=1 and predictions has shape [batch size, k]. The final
dimension contains the top `k` predicted class indices. [D1,... DN] must
match `labels`. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> k
						</dt>
						<dd>Integer, k for @k metric. Only used for the default op name. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> class_id
						</dt>
						<dd>Integer class ID for which we want binary metrics. This should be
in range [0, num_classes), where num_classes is the last dimension of
`predictions`. If class_id is outside this range, the method returns NAN. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<double>">ValueTuple&lt;double&gt;</span></code> weights
						</dt>
						<dd>`Tensor` whose rank is either 0, or n-1, where n is the rank of
`labels`. If the latter, it must be broadcastable to `labels` (i.e., all
dimensions must be either `1`, or the same as the corresponding `labels`
dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that values should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that updates should
be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> name
						</dt>
						<dd>Name of new update operation, and namespace for other dependent ops. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall_at_top_k" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>recall_at_top_k</strong>(<span title="System.object">object</span> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions_idx, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> k, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> class_id, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> name)
		</h4>
		<div class="content">Computes recall@k of top-k predictions with respect to sparse labels. <p></p> Differs from `recall_at_k` in that predictions must be in the form of top `k`
class indices, whereas `recall_at_k` expects logits. Refer to `recall_at_k`
for more details. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>`int64` `Tensor` or `SparseTensor` with shape
[D1,... DN, num_labels] or [D1,... DN], where the latter implies
num_labels=1. N >= 1 and num_labels is the number of target classes for
the associated prediction. Commonly, N=1 and `labels` has shape
[batch_size, num_labels]. [D1,... DN] must match `predictions`. Values
should be in range [0, num_classes), where num_classes is the last
dimension of `predictions`. Values outside this range always count
towards `false_negative_at_<k>`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions_idx
						</dt>
						<dd>Integer `Tensor` with shape [D1,... DN, k] where N >= 1.
Commonly, N=1 and predictions has shape [batch size, k]. The final
dimension contains the top `k` predicted class indices. [D1,... DN] must
match `labels`. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> k
						</dt>
						<dd>Integer, k for @k metric. Only used for the default op name. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> class_id
						</dt>
						<dd>Integer class ID for which we want binary metrics. This should be
in range [0, num_classes), where num_classes is the last dimension of
`predictions`. If class_id is outside this range, the method returns NAN. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> weights
						</dt>
						<dd>`Tensor` whose rank is either 0, or n-1, where n is the rank of
`labels`. If the latter, it must be broadcastable to `labels` (i.e., all
dimensions must be either `1`, or the same as the corresponding `labels`
dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that values should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that updates should
be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> name
						</dt>
						<dd>Name of new update operation, and namespace for other dependent ops. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall_at_top_k" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>recall_at_top_k</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions_idx, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> k, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> class_id, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> name)
		</h4>
		<div class="content">Computes recall@k of top-k predictions with respect to sparse labels. <p></p> Differs from `recall_at_k` in that predictions must be in the form of top `k`
class indices, whereas `recall_at_k` expects logits. Refer to `recall_at_k`
for more details. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> labels
						</dt>
						<dd>`int64` `Tensor` or `SparseTensor` with shape
[D1,... DN, num_labels] or [D1,... DN], where the latter implies
num_labels=1. N >= 1 and num_labels is the number of target classes for
the associated prediction. Commonly, N=1 and `labels` has shape
[batch_size, num_labels]. [D1,... DN] must match `predictions`. Values
should be in range [0, num_classes), where num_classes is the last
dimension of `predictions`. Values outside this range always count
towards `false_negative_at_<k>`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions_idx
						</dt>
						<dd>Integer `Tensor` with shape [D1,... DN, k] where N >= 1.
Commonly, N=1 and predictions has shape [batch size, k]. The final
dimension contains the top `k` predicted class indices. [D1,... DN] must
match `labels`. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> k
						</dt>
						<dd>Integer, k for @k metric. Only used for the default op name. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> class_id
						</dt>
						<dd>Integer class ID for which we want binary metrics. This should be
in range [0, num_classes), where num_classes is the last dimension of
`predictions`. If class_id is outside this range, the method returns NAN. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> weights
						</dt>
						<dd>`Tensor` whose rank is either 0, or n-1, where n is the rank of
`labels`. If the latter, it must be broadcastable to `labels` (i.e., all
dimensions must be either `1`, or the same as the corresponding `labels`
dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that values should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that updates should
be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> name
						</dt>
						<dd>Name of new update operation, and namespace for other dependent ops. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall_at_top_k" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>recall_at_top_k</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions_idx, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> k, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> class_id, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes recall@k of top-k predictions with respect to sparse labels. <p></p> Differs from `recall_at_k` in that predictions must be in the form of top `k`
class indices, whereas `recall_at_k` expects logits. Refer to `recall_at_k`
for more details. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> labels
						</dt>
						<dd>`int64` `Tensor` or `SparseTensor` with shape
[D1,... DN, num_labels] or [D1,... DN], where the latter implies
num_labels=1. N >= 1 and num_labels is the number of target classes for
the associated prediction. Commonly, N=1 and `labels` has shape
[batch_size, num_labels]. [D1,... DN] must match `predictions`. Values
should be in range [0, num_classes), where num_classes is the last
dimension of `predictions`. Values outside this range always count
towards `false_negative_at_<k>`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions_idx
						</dt>
						<dd>Integer `Tensor` with shape [D1,... DN, k] where N >= 1.
Commonly, N=1 and predictions has shape [batch size, k]. The final
dimension contains the top `k` predicted class indices. [D1,... DN] must
match `labels`. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> k
						</dt>
						<dd>Integer, k for @k metric. Only used for the default op name. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> class_id
						</dt>
						<dd>Integer class ID for which we want binary metrics. This should be
in range [0, num_classes), where num_classes is the last dimension of
`predictions`. If class_id is outside this range, the method returns NAN. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> weights
						</dt>
						<dd>`Tensor` whose rank is either 0, or n-1, where n is the rank of
`labels`. If the latter, it must be broadcastable to `labels` (i.e., all
dimensions must be either `1`, or the same as the corresponding `labels`
dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that values should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that updates should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>Name of new update operation, and namespace for other dependent ops. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall_at_top_k" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>recall_at_top_k</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions_idx, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> k, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> class_id, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> name)
		</h4>
		<div class="content">Computes recall@k of top-k predictions with respect to sparse labels. <p></p> Differs from `recall_at_k` in that predictions must be in the form of top `k`
class indices, whereas `recall_at_k` expects logits. Refer to `recall_at_k`
for more details. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> labels
						</dt>
						<dd>`int64` `Tensor` or `SparseTensor` with shape
[D1,... DN, num_labels] or [D1,... DN], where the latter implies
num_labels=1. N >= 1 and num_labels is the number of target classes for
the associated prediction. Commonly, N=1 and `labels` has shape
[batch_size, num_labels]. [D1,... DN] must match `predictions`. Values
should be in range [0, num_classes), where num_classes is the last
dimension of `predictions`. Values outside this range always count
towards `false_negative_at_<k>`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions_idx
						</dt>
						<dd>Integer `Tensor` with shape [D1,... DN, k] where N >= 1.
Commonly, N=1 and predictions has shape [batch size, k]. The final
dimension contains the top `k` predicted class indices. [D1,... DN] must
match `labels`. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> k
						</dt>
						<dd>Integer, k for @k metric. Only used for the default op name. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> class_id
						</dt>
						<dd>Integer class ID for which we want binary metrics. This should be
in range [0, num_classes), where num_classes is the last dimension of
`predictions`. If class_id is outside this range, the method returns NAN. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>`Tensor` whose rank is either 0, or n-1, where n is the rank of
`labels`. If the latter, it must be broadcastable to `labels` (i.e., all
dimensions must be either `1`, or the same as the corresponding `labels`
dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that values should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that updates should
be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> name
						</dt>
						<dd>Name of new update operation, and namespace for other dependent ops. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall_at_top_k" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>recall_at_top_k</strong>(<span title="System.object">object</span> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions_idx, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> k, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> class_id, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes recall@k of top-k predictions with respect to sparse labels. <p></p> Differs from `recall_at_k` in that predictions must be in the form of top `k`
class indices, whereas `recall_at_k` expects logits. Refer to `recall_at_k`
for more details. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>`int64` `Tensor` or `SparseTensor` with shape
[D1,... DN, num_labels] or [D1,... DN], where the latter implies
num_labels=1. N >= 1 and num_labels is the number of target classes for
the associated prediction. Commonly, N=1 and `labels` has shape
[batch_size, num_labels]. [D1,... DN] must match `predictions`. Values
should be in range [0, num_classes), where num_classes is the last
dimension of `predictions`. Values outside this range always count
towards `false_negative_at_<k>`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions_idx
						</dt>
						<dd>Integer `Tensor` with shape [D1,... DN, k] where N >= 1.
Commonly, N=1 and predictions has shape [batch size, k]. The final
dimension contains the top `k` predicted class indices. [D1,... DN] must
match `labels`. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> k
						</dt>
						<dd>Integer, k for @k metric. Only used for the default op name. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> class_id
						</dt>
						<dd>Integer class ID for which we want binary metrics. This should be
in range [0, num_classes), where num_classes is the last dimension of
`predictions`. If class_id is outside this range, the method returns NAN. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>`Tensor` whose rank is either 0, or n-1, where n is the rank of
`labels`. If the latter, it must be broadcastable to `labels` (i.e., all
dimensions must be either `1`, or the same as the corresponding `labels`
dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that values should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that updates should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>Name of new update operation, and namespace for other dependent ops. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall_at_top_k" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>recall_at_top_k</strong>(<span title="System.object">object</span> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions_idx, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> k, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> class_id, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes recall@k of top-k predictions with respect to sparse labels. <p></p> Differs from `recall_at_k` in that predictions must be in the form of top `k`
class indices, whereas `recall_at_k` expects logits. Refer to `recall_at_k`
for more details. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>`int64` `Tensor` or `SparseTensor` with shape
[D1,... DN, num_labels] or [D1,... DN], where the latter implies
num_labels=1. N >= 1 and num_labels is the number of target classes for
the associated prediction. Commonly, N=1 and `labels` has shape
[batch_size, num_labels]. [D1,... DN] must match `predictions`. Values
should be in range [0, num_classes), where num_classes is the last
dimension of `predictions`. Values outside this range always count
towards `false_negative_at_<k>`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions_idx
						</dt>
						<dd>Integer `Tensor` with shape [D1,... DN, k] where N >= 1.
Commonly, N=1 and predictions has shape [batch size, k]. The final
dimension contains the top `k` predicted class indices. [D1,... DN] must
match `labels`. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> k
						</dt>
						<dd>Integer, k for @k metric. Only used for the default op name. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> class_id
						</dt>
						<dd>Integer class ID for which we want binary metrics. This should be
in range [0, num_classes), where num_classes is the last dimension of
`predictions`. If class_id is outside this range, the method returns NAN. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> weights
						</dt>
						<dd>`Tensor` whose rank is either 0, or n-1, where n is the rank of
`labels`. If the latter, it must be broadcastable to `labels` (i.e., all
dimensions must be either `1`, or the same as the corresponding `labels`
dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that values should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that updates should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>Name of new update operation, and namespace for other dependent ops. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall_at_top_k" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>recall_at_top_k</strong>(<span title="System.object">object</span> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions_idx, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> k, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> class_id, <span title="System.ValueTuple<double>">ValueTuple&lt;double&gt;</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> name)
		</h4>
		<div class="content">Computes recall@k of top-k predictions with respect to sparse labels. <p></p> Differs from `recall_at_k` in that predictions must be in the form of top `k`
class indices, whereas `recall_at_k` expects logits. Refer to `recall_at_k`
for more details. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>`int64` `Tensor` or `SparseTensor` with shape
[D1,... DN, num_labels] or [D1,... DN], where the latter implies
num_labels=1. N >= 1 and num_labels is the number of target classes for
the associated prediction. Commonly, N=1 and `labels` has shape
[batch_size, num_labels]. [D1,... DN] must match `predictions`. Values
should be in range [0, num_classes), where num_classes is the last
dimension of `predictions`. Values outside this range always count
towards `false_negative_at_<k>`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions_idx
						</dt>
						<dd>Integer `Tensor` with shape [D1,... DN, k] where N >= 1.
Commonly, N=1 and predictions has shape [batch size, k]. The final
dimension contains the top `k` predicted class indices. [D1,... DN] must
match `labels`. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> k
						</dt>
						<dd>Integer, k for @k metric. Only used for the default op name. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> class_id
						</dt>
						<dd>Integer class ID for which we want binary metrics. This should be
in range [0, num_classes), where num_classes is the last dimension of
`predictions`. If class_id is outside this range, the method returns NAN. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<double>">ValueTuple&lt;double&gt;</span></code> weights
						</dt>
						<dd>`Tensor` whose rank is either 0, or n-1, where n is the rank of
`labels`. If the latter, it must be broadcastable to `labels` (i.e., all
dimensions must be either `1`, or the same as the corresponding `labels`
dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that values should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that updates should
be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> name
						</dt>
						<dd>Name of new update operation, and namespace for other dependent ops. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall_at_top_k" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>recall_at_top_k</strong>(<span title="System.object">object</span> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions_idx, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> k, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> class_id, <span title="System.ValueTuple<double>">ValueTuple&lt;double&gt;</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes recall@k of top-k predictions with respect to sparse labels. <p></p> Differs from `recall_at_k` in that predictions must be in the form of top `k`
class indices, whereas `recall_at_k` expects logits. Refer to `recall_at_k`
for more details. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>`int64` `Tensor` or `SparseTensor` with shape
[D1,... DN, num_labels] or [D1,... DN], where the latter implies
num_labels=1. N >= 1 and num_labels is the number of target classes for
the associated prediction. Commonly, N=1 and `labels` has shape
[batch_size, num_labels]. [D1,... DN] must match `predictions`. Values
should be in range [0, num_classes), where num_classes is the last
dimension of `predictions`. Values outside this range always count
towards `false_negative_at_<k>`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions_idx
						</dt>
						<dd>Integer `Tensor` with shape [D1,... DN, k] where N >= 1.
Commonly, N=1 and predictions has shape [batch size, k]. The final
dimension contains the top `k` predicted class indices. [D1,... DN] must
match `labels`. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> k
						</dt>
						<dd>Integer, k for @k metric. Only used for the default op name. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> class_id
						</dt>
						<dd>Integer class ID for which we want binary metrics. This should be
in range [0, num_classes), where num_classes is the last dimension of
`predictions`. If class_id is outside this range, the method returns NAN. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<double>">ValueTuple&lt;double&gt;</span></code> weights
						</dt>
						<dd>`Tensor` whose rank is either 0, or n-1, where n is the rank of
`labels`. If the latter, it must be broadcastable to `labels` (i.e., all
dimensions must be either `1`, or the same as the corresponding `labels`
dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that values should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that updates should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>Name of new update operation, and namespace for other dependent ops. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall_at_top_k" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>recall_at_top_k</strong>(<span title="System.object">object</span> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions_idx, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> k, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> class_id, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> name)
		</h4>
		<div class="content">Computes recall@k of top-k predictions with respect to sparse labels. <p></p> Differs from `recall_at_k` in that predictions must be in the form of top `k`
class indices, whereas `recall_at_k` expects logits. Refer to `recall_at_k`
for more details. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>`int64` `Tensor` or `SparseTensor` with shape
[D1,... DN, num_labels] or [D1,... DN], where the latter implies
num_labels=1. N >= 1 and num_labels is the number of target classes for
the associated prediction. Commonly, N=1 and `labels` has shape
[batch_size, num_labels]. [D1,... DN] must match `predictions`. Values
should be in range [0, num_classes), where num_classes is the last
dimension of `predictions`. Values outside this range always count
towards `false_negative_at_<k>`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions_idx
						</dt>
						<dd>Integer `Tensor` with shape [D1,... DN, k] where N >= 1.
Commonly, N=1 and predictions has shape [batch size, k]. The final
dimension contains the top `k` predicted class indices. [D1,... DN] must
match `labels`. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> k
						</dt>
						<dd>Integer, k for @k metric. Only used for the default op name. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> class_id
						</dt>
						<dd>Integer class ID for which we want binary metrics. This should be
in range [0, num_classes), where num_classes is the last dimension of
`predictions`. If class_id is outside this range, the method returns NAN. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>`Tensor` whose rank is either 0, or n-1, where n is the rank of
`labels`. If the latter, it must be broadcastable to `labels` (i.e., all
dimensions must be either `1`, or the same as the corresponding `labels`
dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that values should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that updates should
be added to. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> name
						</dt>
						<dd>Name of new update operation, and namespace for other dependent ops. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall_at_top_k" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>recall_at_top_k</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions_idx, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> k, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> class_id, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes recall@k of top-k predictions with respect to sparse labels. <p></p> Differs from `recall_at_k` in that predictions must be in the form of top `k`
class indices, whereas `recall_at_k` expects logits. Refer to `recall_at_k`
for more details. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> labels
						</dt>
						<dd>`int64` `Tensor` or `SparseTensor` with shape
[D1,... DN, num_labels] or [D1,... DN], where the latter implies
num_labels=1. N >= 1 and num_labels is the number of target classes for
the associated prediction. Commonly, N=1 and `labels` has shape
[batch_size, num_labels]. [D1,... DN] must match `predictions`. Values
should be in range [0, num_classes), where num_classes is the last
dimension of `predictions`. Values outside this range always count
towards `false_negative_at_<k>`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions_idx
						</dt>
						<dd>Integer `Tensor` with shape [D1,... DN, k] where N >= 1.
Commonly, N=1 and predictions has shape [batch size, k]. The final
dimension contains the top `k` predicted class indices. [D1,... DN] must
match `labels`. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> k
						</dt>
						<dd>Integer, k for @k metric. Only used for the default op name. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> class_id
						</dt>
						<dd>Integer class ID for which we want binary metrics. This should be
in range [0, num_classes), where num_classes is the last dimension of
`predictions`. If class_id is outside this range, the method returns NAN. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>`Tensor` whose rank is either 0, or n-1, where n is the rank of
`labels`. If the latter, it must be broadcastable to `labels` (i.e., all
dimensions must be either `1`, or the same as the corresponding `labels`
dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that values should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that updates should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>Name of new update operation, and namespace for other dependent ops. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall_at_top_k_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>recall_at_top_k_dyn</strong>(<span title="System.object">object</span> labels, <span title="System.object">object</span> predictions_idx, <span title="System.object">object</span> k, <span title="System.object">object</span> class_id, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Computes recall@k of top-k predictions with respect to sparse labels. <p></p> Differs from `recall_at_k` in that predictions must be in the form of top `k`
class indices, whereas `recall_at_k` expects logits. Refer to `recall_at_k`
for more details. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>`int64` `Tensor` or `SparseTensor` with shape
[D1,... DN, num_labels] or [D1,... DN], where the latter implies
num_labels=1. N >= 1 and num_labels is the number of target classes for
the associated prediction. Commonly, N=1 and `labels` has shape
[batch_size, num_labels]. [D1,... DN] must match `predictions`. Values
should be in range [0, num_classes), where num_classes is the last
dimension of `predictions`. Values outside this range always count
towards `false_negative_at_<k>`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions_idx
						</dt>
						<dd>Integer `Tensor` with shape [D1,... DN, k] where N >= 1.
Commonly, N=1 and predictions has shape [batch size, k]. The final
dimension contains the top `k` predicted class indices. [D1,... DN] must
match `labels`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> k
						</dt>
						<dd>Integer, k for @k metric. Only used for the default op name. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> class_id
						</dt>
						<dd>Integer class ID for which we want binary metrics. This should be
in range [0, num_classes), where num_classes is the last dimension of
`predictions`. If class_id is outside this range, the method returns NAN. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>`Tensor` whose rank is either 0, or n-1, where n is the rank of
`labels`. If the latter, it must be broadcastable to `labels` (i.e., all
dimensions must be either `1`, or the same as the corresponding `labels`
dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that values should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that updates should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>Name of new update operation, and namespace for other dependent ops. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="recall_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>recall_dyn</strong>(<span title="System.object">object</span> labels, <span title="System.object">object</span> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Computes the recall of the predictions with respect to the labels. <p></p> The `recall` function creates two local variables, `true_positives`
and `false_negatives`, that are used to compute the recall. This value is
ultimately returned as `recall`, an idempotent operation that simply divides
`true_positives` by the sum of `true_positives` and `false_negatives`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` that updates these variables and returns the `recall`. `update_op`
weights each prediction by the corresponding value in `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `recall` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="root_mean_squared_error" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>root_mean_squared_error</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the root mean squared error between the labels and predictions. <p></p> The `root_mean_squared_error` function creates two local variables,
`total` and `count` that are used to compute the root mean squared error.
This average is weighted by `weights`, and it is ultimately returned as
`root_mean_squared_error`: an idempotent operation that takes the square root
of the division of `total` by `count`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`root_mean_squared_error`. Internally, a `squared_error` operation computes
the element-wise square of the difference between `predictions` and `labels`.
Then `update_op` increments `total` with the reduced sum of the product of
`weights` and `squared_error`, and it increments `count` with the reduced sum
of `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>A `Tensor` of the same shape as `predictions`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A `Tensor` of arbitrary shape. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that
`root_mean_squared_error` should be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="root_mean_squared_error_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>root_mean_squared_error_dyn</strong>(<span title="System.object">object</span> labels, <span title="System.object">object</span> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Computes the root mean squared error between the labels and predictions. <p></p> The `root_mean_squared_error` function creates two local variables,
`total` and `count` that are used to compute the root mean squared error.
This average is weighted by `weights`, and it is ultimately returned as
`root_mean_squared_error`: an idempotent operation that takes the square root
of the division of `total` by `count`. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`root_mean_squared_error`. Internally, a `squared_error` operation computes
the element-wise square of the difference between `predictions` and `labels`.
Then `update_op` increments `total` with the reduced sum of the product of
`weights` and `squared_error`, and it increments `count` with the reduced sum
of `weights`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>A `Tensor` of the same shape as `predictions`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>A `Tensor` of arbitrary shape. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that
`root_mean_squared_error` should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="sensitivity_at_specificity" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>sensitivity_at_specificity</strong>(<a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.double">double</span> specificity, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.int">int</span> num_thresholds, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the specificity at a given sensitivity. <p></p> The `sensitivity_at_specificity` function creates four local
variables, `true_positives`, `true_negatives`, `false_positives` and
`false_negatives` that are used to compute the sensitivity at the given
specificity value. The threshold for the given specificity value is computed
and used to evaluate the corresponding sensitivity. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`sensitivity`. `update_op` increments the `true_positives`, `true_negatives`,
`false_positives` and `false_negatives` counts with the weight of each case
found in the `predictions` and `labels`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. <p></p> For additional information about specificity and sensitivity, see the
following: https://en.wikipedia.org/wiki/Sensitivity_and_specificity 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> specificity
						</dt>
						<dd>A scalar value in range `[0, 1]`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_thresholds
						</dt>
						<dd>The number of thresholds to use for matching the given
specificity. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `sensitivity`
should be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="sensitivity_at_specificity" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>sensitivity_at_specificity</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.double">double</span> specificity, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.int">int</span> num_thresholds, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the specificity at a given sensitivity. <p></p> The `sensitivity_at_specificity` function creates four local
variables, `true_positives`, `true_negatives`, `false_positives` and
`false_negatives` that are used to compute the sensitivity at the given
specificity value. The threshold for the given specificity value is computed
and used to evaluate the corresponding sensitivity. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`sensitivity`. `update_op` increments the `true_positives`, `true_negatives`,
`false_positives` and `false_negatives` counts with the weight of each case
found in the `predictions` and `labels`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. <p></p> For additional information about specificity and sensitivity, see the
following: https://en.wikipedia.org/wiki/Sensitivity_and_specificity 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> specificity
						</dt>
						<dd>A scalar value in range `[0, 1]`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_thresholds
						</dt>
						<dd>The number of thresholds to use for matching the given
specificity. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `sensitivity`
should be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="sensitivity_at_specificity" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>sensitivity_at_specificity</strong>(<span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.double">double</span> specificity, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.int">int</span> num_thresholds, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the specificity at a given sensitivity. <p></p> The `sensitivity_at_specificity` function creates four local
variables, `true_positives`, `true_negatives`, `false_positives` and
`false_negatives` that are used to compute the sensitivity at the given
specificity value. The threshold for the given specificity value is computed
and used to evaluate the corresponding sensitivity. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`sensitivity`. `update_op` increments the `true_positives`, `true_negatives`,
`false_positives` and `false_negatives` counts with the weight of each case
found in the `predictions` and `labels`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. <p></p> For additional information about specificity and sensitivity, see the
following: https://en.wikipedia.org/wiki/Sensitivity_and_specificity 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> specificity
						</dt>
						<dd>A scalar value in range `[0, 1]`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_thresholds
						</dt>
						<dd>The number of thresholds to use for matching the given
specificity. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `sensitivity`
should be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="sensitivity_at_specificity" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>sensitivity_at_specificity</strong>(<span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.double">double</span> specificity, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.int">int</span> num_thresholds, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the specificity at a given sensitivity. <p></p> The `sensitivity_at_specificity` function creates four local
variables, `true_positives`, `true_negatives`, `false_positives` and
`false_negatives` that are used to compute the sensitivity at the given
specificity value. The threshold for the given specificity value is computed
and used to evaluate the corresponding sensitivity. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`sensitivity`. `update_op` increments the `true_positives`, `true_negatives`,
`false_positives` and `false_negatives` counts with the weight of each case
found in the `predictions` and `labels`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. <p></p> For additional information about specificity and sensitivity, see the
following: https://en.wikipedia.org/wiki/Sensitivity_and_specificity 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> specificity
						</dt>
						<dd>A scalar value in range `[0, 1]`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_thresholds
						</dt>
						<dd>The number of thresholds to use for matching the given
specificity. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `sensitivity`
should be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="sensitivity_at_specificity_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>sensitivity_at_specificity_dyn</strong>(<span title="System.object">object</span> labels, <span title="System.object">object</span> predictions, <span title="System.object">object</span> specificity, <span title="System.object">object</span> weights, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> num_thresholds, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Computes the specificity at a given sensitivity. <p></p> The `sensitivity_at_specificity` function creates four local
variables, `true_positives`, `true_negatives`, `false_positives` and
`false_negatives` that are used to compute the sensitivity at the given
specificity value. The threshold for the given specificity value is computed
and used to evaluate the corresponding sensitivity. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`sensitivity`. `update_op` increments the `true_positives`, `true_negatives`,
`false_positives` and `false_negatives` counts with the weight of each case
found in the `predictions` and `labels`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. <p></p> For additional information about specificity and sensitivity, see the
following: https://en.wikipedia.org/wiki/Sensitivity_and_specificity 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> specificity
						</dt>
						<dd>A scalar value in range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> num_thresholds
						</dt>
						<dd>The number of thresholds to use for matching the given
specificity. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `sensitivity`
should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="sparse_average_precision_at_k" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>sparse_average_precision_at_k</strong>(<span title="System.object">object</span> labels, <span title="System.object">object</span> predictions, <span title="System.object">object</span> k, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Renamed to `average_precision_at_k`, please use that method instead. (deprecated) <p></p> Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Use average_precision_at_k instead 




		</div>
	</div>
	<div id="sparse_average_precision_at_k_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>sparse_average_precision_at_k_dyn</strong>(<span title="System.object">object</span> labels, <span title="System.object">object</span> predictions, <span title="System.object">object</span> k, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Renamed to `average_precision_at_k`, please use that method instead. (deprecated) <p></p> Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Use average_precision_at_k instead 




		</div>
	</div>
	<div id="sparse_precision_at_k" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>sparse_precision_at_k</strong>(<span title="System.object">object</span> labels, <span title="System.object">object</span> predictions, <span title="System.object">object</span> k, <span title="System.object">object</span> class_id, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Renamed to `precision_at_k`, please use that method instead. (deprecated) <p></p> Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Use precision_at_k instead 




		</div>
	</div>
	<div id="sparse_precision_at_k_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>sparse_precision_at_k_dyn</strong>(<span title="System.object">object</span> labels, <span title="System.object">object</span> predictions, <span title="System.object">object</span> k, <span title="System.object">object</span> class_id, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Renamed to `precision_at_k`, please use that method instead. (deprecated) <p></p> Warning: THIS FUNCTION IS DEPRECATED. It will be removed in a future version.
Instructions for updating:
Use precision_at_k instead 




		</div>
	</div>
	<div id="specificity_at_sensitivity" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>specificity_at_sensitivity</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.double">double</span> sensitivity, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.int">int</span> num_thresholds, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the specificity at a given sensitivity. <p></p> The `specificity_at_sensitivity` function creates four local
variables, `true_positives`, `true_negatives`, `false_positives` and
`false_negatives` that are used to compute the specificity at the given
sensitivity value. The threshold for the given sensitivity value is computed
and used to evaluate the corresponding specificity. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`specificity`. `update_op` increments the `true_positives`, `true_negatives`,
`false_positives` and `false_negatives` counts with the weight of each case
found in the `predictions` and `labels`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. <p></p> For additional information about specificity and sensitivity, see the
following: https://en.wikipedia.org/wiki/Sensitivity_and_specificity 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> sensitivity
						</dt>
						<dd>A scalar value in range `[0, 1]`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_thresholds
						</dt>
						<dd>The number of thresholds to use for matching the given
sensitivity. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `specificity`
should be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="specificity_at_sensitivity" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>specificity_at_sensitivity</strong>(<a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.double">double</span> sensitivity, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.int">int</span> num_thresholds, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the specificity at a given sensitivity. <p></p> The `specificity_at_sensitivity` function creates four local
variables, `true_positives`, `true_negatives`, `false_positives` and
`false_negatives` that are used to compute the specificity at the given
sensitivity value. The threshold for the given sensitivity value is computed
and used to evaluate the corresponding specificity. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`specificity`. `update_op` increments the `true_positives`, `true_negatives`,
`false_positives` and `false_negatives` counts with the weight of each case
found in the `predictions` and `labels`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. <p></p> For additional information about specificity and sensitivity, see the
following: https://en.wikipedia.org/wiki/Sensitivity_and_specificity 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> sensitivity
						</dt>
						<dd>A scalar value in range `[0, 1]`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_thresholds
						</dt>
						<dd>The number of thresholds to use for matching the given
sensitivity. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `specificity`
should be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="specificity_at_sensitivity" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>specificity_at_sensitivity</strong>(<span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.double">double</span> sensitivity, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.int">int</span> num_thresholds, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the specificity at a given sensitivity. <p></p> The `specificity_at_sensitivity` function creates four local
variables, `true_positives`, `true_negatives`, `false_positives` and
`false_negatives` that are used to compute the specificity at the given
sensitivity value. The threshold for the given sensitivity value is computed
and used to evaluate the corresponding specificity. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`specificity`. `update_op` increments the `true_positives`, `true_negatives`,
`false_positives` and `false_negatives` counts with the weight of each case
found in the `predictions` and `labels`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. <p></p> For additional information about specificity and sensitivity, see the
following: https://en.wikipedia.org/wiki/Sensitivity_and_specificity 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> sensitivity
						</dt>
						<dd>A scalar value in range `[0, 1]`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_thresholds
						</dt>
						<dd>The number of thresholds to use for matching the given
sensitivity. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `specificity`
should be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="specificity_at_sensitivity" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>specificity_at_sensitivity</strong>(<span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.double">double</span> sensitivity, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> weights, <span title="System.int">int</span> num_thresholds, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> metrics_collections, <span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the specificity at a given sensitivity. <p></p> The `specificity_at_sensitivity` function creates four local
variables, `true_positives`, `true_negatives`, `false_positives` and
`false_negatives` that are used to compute the specificity at the given
sensitivity value. The threshold for the given sensitivity value is computed
and used to evaluate the corresponding specificity. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`specificity`. `update_op` increments the `true_positives`, `true_negatives`,
`false_positives` and `false_negatives` counts with the weight of each case
found in the `predictions` and `labels`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. <p></p> For additional information about specificity and sensitivity, see the
following: https://en.wikipedia.org/wiki/Sensitivity_and_specificity 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> sensitivity
						</dt>
						<dd>A scalar value in range `[0, 1]`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_thresholds
						</dt>
						<dd>The number of thresholds to use for matching the given
sensitivity. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `specificity`
should be added to. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="specificity_at_sensitivity_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>specificity_at_sensitivity_dyn</strong>(<span title="System.object">object</span> labels, <span title="System.object">object</span> predictions, <span title="System.object">object</span> sensitivity, <span title="System.object">object</span> weights, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> num_thresholds, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Computes the specificity at a given sensitivity. <p></p> The `specificity_at_sensitivity` function creates four local
variables, `true_positives`, `true_negatives`, `false_positives` and
`false_negatives` that are used to compute the specificity at the given
sensitivity value. The threshold for the given sensitivity value is computed
and used to evaluate the corresponding specificity. <p></p> For estimation of the metric over a stream of data, the function creates an
`update_op` operation that updates these variables and returns the
`specificity`. `update_op` increments the `true_positives`, `true_negatives`,
`false_positives` and `false_negatives` counts with the weight of each case
found in the `predictions` and `labels`. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. <p></p> For additional information about specificity and sensitivity, see the
following: https://en.wikipedia.org/wiki/Sensitivity_and_specificity 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> sensitivity
						</dt>
						<dd>A scalar value in range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> num_thresholds
						</dt>
						<dd>The number of thresholds to use for matching the given
sensitivity. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `specificity`
should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="true_negatives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>true_negatives</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <a href="../numpy/ndarray.htm">ndarray</a> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Sum the weights of true_negatives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="true_negatives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>true_negatives</strong>(<span title="System.double">double</span> labels, <span title="System.double">double</span> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Sum the weights of true_negatives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.double">double</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="true_negatives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>true_negatives</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Sum the weights of true_negatives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="true_negatives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>true_negatives</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Sum the weights of true_negatives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="true_negatives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>true_negatives</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Sum the weights of true_negatives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="true_negatives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>true_negatives</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <span title="System.double">double</span> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Sum the weights of true_negatives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="true_negatives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>true_negatives</strong>(<a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Sum the weights of true_negatives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="true_negatives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>true_negatives</strong>(<a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> labels, <a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Sum the weights of true_negatives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="true_negatives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>true_negatives</strong>(<a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> labels, <a href="../numpy/ndarray.htm">ndarray</a> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Sum the weights of true_negatives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="true_negatives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>true_negatives</strong>(<a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> labels, <span title="System.double">double</span> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Sum the weights of true_negatives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="true_negatives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>true_negatives</strong>(<span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Sum the weights of true_negatives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="true_negatives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>true_negatives</strong>(<span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> labels, <a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Sum the weights of true_negatives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="true_negatives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>true_negatives</strong>(<span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> labels, <span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Sum the weights of true_negatives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="true_negatives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>true_negatives</strong>(<span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> labels, <a href="../numpy/ndarray.htm">ndarray</a> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Sum the weights of true_negatives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="true_negatives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>true_negatives</strong>(<span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> labels, <span title="System.double">double</span> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Sum the weights of true_negatives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="true_negatives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>true_negatives</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Sum the weights of true_negatives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="true_negatives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>true_negatives</strong>(<a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> labels, <span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Sum the weights of true_negatives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="true_negatives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>true_negatives</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> labels, <span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Sum the weights of true_negatives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="true_negatives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>true_negatives</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> labels, <a href="../numpy/ndarray.htm">ndarray</a> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Sum the weights of true_negatives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="true_negatives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>true_negatives</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> labels, <a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Sum the weights of true_negatives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="true_negatives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>true_negatives</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> labels, <span title="System.double">double</span> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Sum the weights of true_negatives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="true_negatives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>true_negatives</strong>(<span title="System.double">double</span> labels, <a href="../numpy/ndarray.htm">ndarray</a> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Sum the weights of true_negatives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.double">double</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="true_negatives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>true_negatives</strong>(<a href="../numpy/ndarray.htm">ndarray</a> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Sum the weights of true_negatives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="true_negatives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>true_negatives</strong>(<a href="../numpy/ndarray.htm">ndarray</a> labels, <a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Sum the weights of true_negatives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="true_negatives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>true_negatives</strong>(<a href="../numpy/ndarray.htm">ndarray</a> labels, <span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Sum the weights of true_negatives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="true_negatives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>true_negatives</strong>(<span title="System.double">double</span> labels, <span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Sum the weights of true_negatives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.double">double</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="true_negatives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>true_negatives</strong>(<a href="../numpy/ndarray.htm">ndarray</a> labels, <a href="../numpy/ndarray.htm">ndarray</a> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Sum the weights of true_negatives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="true_negatives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>true_negatives</strong>(<a href="../numpy/ndarray.htm">ndarray</a> labels, <span title="System.double">double</span> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Sum the weights of true_negatives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="true_negatives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>true_negatives</strong>(<span title="System.double">double</span> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Sum the weights of true_negatives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.double">double</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="true_negatives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>true_negatives</strong>(<span title="System.double">double</span> labels, <a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Sum the weights of true_negatives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.double">double</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="true_negatives_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>true_negatives_at_thresholds</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span> thresholds, <span title="System.Nullable<ValueTuple<object>>">Nullable&lt;ValueTuple&lt;object&gt;&gt;</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes true negatives at provided threshold values. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>A `Tensor` whose shape matches `predictions`. Will be cast to
`bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.Nullable<ValueTuple<object>>">Nullable&lt;ValueTuple&lt;object&gt;&gt;</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `true_negatives`
should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="true_negatives_at_thresholds_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>true_negatives_at_thresholds_dyn</strong>(<span title="System.object">object</span> labels, <span title="System.object">object</span> predictions, <span title="System.object">object</span> thresholds, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Computes true negatives at provided threshold values. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>A `Tensor` whose shape matches `predictions`. Will be cast to
`bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `true_negatives`
should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="true_negatives_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>true_negatives_dyn</strong>(<span title="System.object">object</span> labels, <span title="System.object">object</span> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Sum the weights of true_negatives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="true_positives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>true_positives</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> labels, <span title="System.object">object</span> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Sum the weights of true_positives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="true_positives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>true_positives</strong>(<span title="System.object">object</span> labels, <span title="System.object">object</span> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Sum the weights of true_positives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="true_positives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>true_positives</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Sum the weights of true_positives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="true_positives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>true_positives</strong>(<a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> labels, <span title="System.object">object</span> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Sum the weights of true_positives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="true_positives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>true_positives</strong>(<a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> labels, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Sum the weights of true_positives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="true_positives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>true_positives</strong>(<span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> labels, <span title="System.object">object</span> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Sum the weights of true_positives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="true_positives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>true_positives</strong>(<span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span> labels, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Sum the weights of true_positives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<PythonClassContainer, PythonClassContainer>">ValueTuple&lt;PythonClassContainer, PythonClassContainer&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="true_positives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>true_positives</strong>(<span title="System.object">object</span> labels, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Sum the weights of true_positives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="true_positives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>true_positives</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> labels, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Sum the weights of true_positives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="true_positives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>true_positives</strong>(<a href="../numpy/ndarray.htm">ndarray</a> labels, <span title="System.object">object</span> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Sum the weights of true_positives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="true_positives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>true_positives</strong>(<a href="../numpy/ndarray.htm">ndarray</a> labels, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Sum the weights of true_positives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="true_positives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>true_positives</strong>(<span title="System.double">double</span> labels, <span title="System.object">object</span> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Sum the weights of true_positives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.double">double</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="true_positives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>true_positives</strong>(<span title="System.double">double</span> labels, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Sum the weights of true_positives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.double">double</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="true_positives" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>true_positives</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <span title="System.object">object</span> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Sum the weights of true_positives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="true_positives_at_thresholds" class="method">
		<h4>
			<span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span> <strong>true_positives_at_thresholds</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> labels, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> predictions, <span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span> thresholds, <span title="System.Nullable<double>">Nullable&lt;double&gt;</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes true positives at provided threshold values. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> labels
						</dt>
						<dd>A `Tensor` whose shape matches `predictions`. Will be cast to
`bool`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<double>">IEnumerable&lt;double&gt;</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.Nullable<double>">Nullable&lt;double&gt;</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `true_positives`
should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, Tensor>">ValueTuple&lt;object, Tensor&gt;</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="true_positives_at_thresholds_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>true_positives_at_thresholds_dyn</strong>(<span title="System.object">object</span> labels, <span title="System.object">object</span> predictions, <span title="System.object">object</span> thresholds, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Computes true positives at provided threshold values. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>A `Tensor` whose shape matches `predictions`. Will be cast to
`bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>A floating point `Tensor` of arbitrary shape and whose values
are in the range `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> thresholds
						</dt>
						<dd>A python list or tuple of float thresholds in `[0, 1]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that `true_positives`
should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that `update_op` should
be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="true_positives_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>true_positives_dyn</strong>(<span title="System.object">object</span> labels, <span title="System.object">object</span> predictions, <span title="System.object">object</span> weights, <span title="System.object">object</span> metrics_collections, <span title="System.object">object</span> updates_collections, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Sum the weights of true_positives. <p></p> If `weights` is `None`, weights default to 1. Use weights of 0 to mask values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> labels
						</dt>
						<dd>The ground truth values, a `Tensor` whose dimensions must match
`predictions`. Will be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> predictions
						</dt>
						<dd>The predicted values, a `Tensor` of arbitrary dimensions. Will
be cast to `bool`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> weights
						</dt>
						<dd>Optional `Tensor` whose rank is either 0, or the same rank as
`labels`, and must be broadcastable to `labels` (i.e., all dimensions must
be either `1`, or the same as the corresponding `labels` dimension). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> metrics_collections
						</dt>
						<dd>An optional list of collections that the metric
value variable should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> updates_collections
						</dt>
						<dd>An optional list of collections that the metric update
ops should be added to. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>An optional variable_scope name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd><p></p> 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	
	<h3 class="section">Public properties</h3>

	<div id="accuracy_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>accuracy_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="auc_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>auc_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="average_precision_at_k_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>average_precision_at_k_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="false_negatives_at_thresholds_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>false_negatives_at_thresholds_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="false_negatives_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>false_negatives_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="false_positives_at_thresholds_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>false_positives_at_thresholds_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="false_positives_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>false_positives_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="mean_absolute_error_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>mean_absolute_error_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="mean_cosine_distance_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>mean_cosine_distance_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="mean_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>mean_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="mean_iou_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>mean_iou_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="mean_per_class_accuracy_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>mean_per_class_accuracy_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="mean_relative_error_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>mean_relative_error_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="mean_squared_error_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>mean_squared_error_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="mean_tensor_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>mean_tensor_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="percentage_below_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>percentage_below_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="precision_at_k_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>precision_at_k_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="precision_at_thresholds_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>precision_at_thresholds_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="precision_at_top_k_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>precision_at_top_k_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="precision_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>precision_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="recall_at_k_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>recall_at_k_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="recall_at_thresholds_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>recall_at_thresholds_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="recall_at_top_k_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>recall_at_top_k_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="recall_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>recall_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="root_mean_squared_error_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>root_mean_squared_error_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="sensitivity_at_specificity_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>sensitivity_at_specificity_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="sparse_average_precision_at_k_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>sparse_average_precision_at_k_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="sparse_precision_at_k_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>sparse_precision_at_k_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="specificity_at_sensitivity_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>specificity_at_sensitivity_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="true_negatives_at_thresholds_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>true_negatives_at_thresholds_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="true_negatives_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>true_negatives_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="true_positives_at_thresholds_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>true_positives_at_thresholds_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="true_positives_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>true_positives_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	</section>
	</article><footer>
	<span id="version">Built from v1.15.0.0 of LostTech.TensorFlow</span>
	<span id="docu-link">
		Generated by <a href="http://docu.jagregory.com">docu</a>
	</span>
</footer>
  </body>
</html>