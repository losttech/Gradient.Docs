<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
	<!--[if lt IE 9]>
	<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
    <title>tf.signal - LostTech.TensorFlow Documentation</title>
    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"/>
    <link type="text/css" rel="stylesheet" href="../main.css"/>
    <script type="text/javascript" src="../js/jquery-1.3.2.min.js"></script>
    <script type="text/javascript" src="../js/jquery.scrollTo-min.js"></script>
    <script type="text/javascript" src="../js/navigation.js"></script>
    <script type="text/javascript" src="../js/example.js"></script>
  </head>
  <body>
  	<header><h1>LostTech.TensorFlow : API Documentation</h1>
	</header>

    <nav id="namespaces">
      <iframe src="../namespaces.htm"></iframe>
    </nav><nav id="types">
  <h2 class="fixed">Types in tensorflow</h2>
	<div class="scroll">
		<ul>
				<li>
            <a href="../tensorflow/AggregationMethod.htm">AggregationMethod</a>
        </li>
				<li>
            <a href="../tensorflow/ConditionalAccumulator.htm">ConditionalAccumulator</a>
        </li>
				<li>
            <a href="../tensorflow/ConditionalAccumulatorBase.htm">ConditionalAccumulatorBase</a>
        </li>
				<li>
            <a href="../tensorflow/constant_initializer.htm">constant_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/CriticalSection.htm">CriticalSection</a>
        </li>
				<li>
            <a href="../tensorflow/DeviceSpec.htm">DeviceSpec</a>
        </li>
				<li>
            <a href="../tensorflow/Dimension.htm">Dimension</a>
        </li>
				<li>
            <a href="../tensorflow/DType.htm">DType</a>
        </li>
				<li>
            <a href="../tensorflow/FIFOQueue.htm">FIFOQueue</a>
        </li>
				<li>
            <a href="../tensorflow/FixedLenFeature.htm">FixedLenFeature</a>
        </li>
				<li>
            <a href="../tensorflow/FixedLengthRecordReader.htm">FixedLengthRecordReader</a>
        </li>
				<li>
            <a href="../tensorflow/FixedLenSequenceFeature.htm">FixedLenSequenceFeature</a>
        </li>
				<li>
            <a href="../tensorflow/glorot_normal_initializer.htm">glorot_normal_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/glorot_uniform_initializer.htm">glorot_uniform_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/GradientTape.htm">GradientTape</a>
        </li>
				<li>
            <a href="../tensorflow/Graph.htm">Graph</a>
        </li>
				<li>
            <a href="../tensorflow/Graph._ControlDependenciesController.htm">Graph._ControlDependenciesController</a>
        </li>
				<li>
            <a href="../tensorflow/Graph.I_ControlDependenciesController.htm">Graph.I_ControlDependenciesController</a>
        </li>
				<li>
            <a href="../tensorflow/GraphKeys.htm">GraphKeys</a>
        </li>
				<li>
            <a href="../tensorflow/HeadingAxes.htm">HeadingAxes</a>
        </li>
				<li>
            <a href="../tensorflow/IAggregationMethod.htm">IAggregationMethod</a>
        </li>
				<li>
            <a href="../tensorflow/IConditionalAccumulator.htm">IConditionalAccumulator</a>
        </li>
				<li>
            <a href="../tensorflow/IConditionalAccumulatorBase.htm">IConditionalAccumulatorBase</a>
        </li>
				<li>
            <a href="../tensorflow/Iconstant_initializer.htm">Iconstant_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/ICriticalSection.htm">ICriticalSection</a>
        </li>
				<li>
            <a href="../tensorflow/IdentityReader.htm">IdentityReader</a>
        </li>
				<li>
            <a href="../tensorflow/IDeviceSpec.htm">IDeviceSpec</a>
        </li>
				<li>
            <a href="../tensorflow/IDimension.htm">IDimension</a>
        </li>
				<li>
            <a href="../tensorflow/IDType.htm">IDType</a>
        </li>
				<li>
            <a href="../tensorflow/IFIFOQueue.htm">IFIFOQueue</a>
        </li>
				<li>
            <a href="../tensorflow/IFixedLenFeature.htm">IFixedLenFeature</a>
        </li>
				<li>
            <a href="../tensorflow/IFixedLengthRecordReader.htm">IFixedLengthRecordReader</a>
        </li>
				<li>
            <a href="../tensorflow/IFixedLenSequenceFeature.htm">IFixedLenSequenceFeature</a>
        </li>
				<li>
            <a href="../tensorflow/Iglorot_normal_initializer.htm">Iglorot_normal_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/Iglorot_uniform_initializer.htm">Iglorot_uniform_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/IGradientTape.htm">IGradientTape</a>
        </li>
				<li>
            <a href="../tensorflow/IGraph.htm">IGraph</a>
        </li>
				<li>
            <a href="../tensorflow/IGraphKeys.htm">IGraphKeys</a>
        </li>
				<li>
            <a href="../tensorflow/IIdentityReader.htm">IIdentityReader</a>
        </li>
				<li>
            <a href="../tensorflow/IIndexedSlices.htm">IIndexedSlices</a>
        </li>
				<li>
            <a href="../tensorflow/IIndexedSlicesSpec.htm">IIndexedSlicesSpec</a>
        </li>
				<li>
            <a href="../tensorflow/IInteractiveSession.htm">IInteractiveSession</a>
        </li>
				<li>
            <a href="../tensorflow/ILazyLoader.htm">ILazyLoader</a>
        </li>
				<li>
            <a href="../tensorflow/ILMDBReader.htm">ILMDBReader</a>
        </li>
				<li>
            <a href="../tensorflow/IModule.htm">IModule</a>
        </li>
				<li>
            <a href="../tensorflow/Iname_scope.htm">Iname_scope</a>
        </li>
				<li>
            <a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a>
        </li>
				<li>
            <a href="../tensorflow/IndexedSlicesSpec.htm">IndexedSlicesSpec</a>
        </li>
				<li>
            <a href="../tensorflow/InteractiveSession.htm">InteractiveSession</a>
        </li>
				<li>
            <a href="../tensorflow/Iones_initializer.htm">Iones_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/IOperation.htm">IOperation</a>
        </li>
				<li>
            <a href="../tensorflow/IOpError.htm">IOpError</a>
        </li>
				<li>
            <a href="../tensorflow/IOptionalSpec.htm">IOptionalSpec</a>
        </li>
				<li>
            <a href="../tensorflow/Iorthogonal_initializer.htm">Iorthogonal_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/IPaddingFIFOQueue.htm">IPaddingFIFOQueue</a>
        </li>
				<li>
            <a href="../tensorflow/IPriorityQueue.htm">IPriorityQueue</a>
        </li>
				<li>
            <a href="../tensorflow/IQueueBase.htm">IQueueBase</a>
        </li>
				<li>
            <a href="../tensorflow/IRaggedTensor.htm">IRaggedTensor</a>
        </li>
				<li>
            <a href="../tensorflow/IRaggedTensorSpec.htm">IRaggedTensorSpec</a>
        </li>
				<li>
            <a href="../tensorflow/Irandom_normal_initializer.htm">Irandom_normal_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/Irandom_uniform_initializer.htm">Irandom_uniform_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/IRandomShuffleQueue.htm">IRandomShuffleQueue</a>
        </li>
				<li>
            <a href="../tensorflow/IReaderBase.htm">IReaderBase</a>
        </li>
				<li>
            <a href="../tensorflow/IRegisterGradient.htm">IRegisterGradient</a>
        </li>
				<li>
            <a href="../tensorflow/ISession.htm">ISession</a>
        </li>
				<li>
            <a href="../tensorflow/ISparseConditionalAccumulator.htm">ISparseConditionalAccumulator</a>
        </li>
				<li>
            <a href="../tensorflow/ISparseFeature.htm">ISparseFeature</a>
        </li>
				<li>
            <a href="../tensorflow/ISparseTensor.htm">ISparseTensor</a>
        </li>
				<li>
            <a href="../tensorflow/ISparseTensorSpec.htm">ISparseTensorSpec</a>
        </li>
				<li>
            <a href="../tensorflow/ISparseTensorValue.htm">ISparseTensorValue</a>
        </li>
				<li>
            <a href="../tensorflow/ITensor.htm">ITensor</a>
        </li>
				<li>
            <a href="../tensorflow/ITensorArray.htm">ITensorArray</a>
        </li>
				<li>
            <a href="../tensorflow/ITensorArraySpec.htm">ITensorArraySpec</a>
        </li>
				<li>
            <a href="../tensorflow/ITensorShape.htm">ITensorShape</a>
        </li>
				<li>
            <a href="../tensorflow/ITensorSpec.htm">ITensorSpec</a>
        </li>
				<li>
            <a href="../tensorflow/ITextLineReader.htm">ITextLineReader</a>
        </li>
				<li>
            <a href="../tensorflow/ITFRecordReader.htm">ITFRecordReader</a>
        </li>
				<li>
            <a href="../tensorflow/Itruncated_normal_initializer.htm">Itruncated_normal_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/ITypeSpec.htm">ITypeSpec</a>
        </li>
				<li>
            <a href="../tensorflow/IUnconnectedGradients.htm">IUnconnectedGradients</a>
        </li>
				<li>
            <a href="../tensorflow/Iuniform_unit_scaling_initializer.htm">Iuniform_unit_scaling_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/IVariable.htm">IVariable</a>
        </li>
				<li>
            <a href="../tensorflow/Ivariable_scope.htm">Ivariable_scope</a>
        </li>
				<li>
            <a href="../tensorflow/IVariableScope.htm">IVariableScope</a>
        </li>
				<li>
            <a href="../tensorflow/Ivariance_scaling_initializer.htm">Ivariance_scaling_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/IVarLenFeature.htm">IVarLenFeature</a>
        </li>
				<li>
            <a href="../tensorflow/IWholeFileReader.htm">IWholeFileReader</a>
        </li>
				<li>
            <a href="../tensorflow/Izeros_initializer.htm">Izeros_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/LazyLoader.htm">LazyLoader</a>
        </li>
				<li>
            <a href="../tensorflow/LMDBReader.htm">LMDBReader</a>
        </li>
				<li>
            <a href="../tensorflow/Module.htm">Module</a>
        </li>
				<li>
            <a href="../tensorflow/name_scope.htm">name_scope</a>
        </li>
				<li>
            <a href="../tensorflow/ones_initializer.htm">ones_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/Operation.htm">Operation</a>
        </li>
				<li>
            <a href="../tensorflow/Operation._InputList.htm">Operation._InputList</a>
        </li>
				<li>
            <a href="../tensorflow/Operation.I_InputList.htm">Operation.I_InputList</a>
        </li>
				<li>
            <a href="../tensorflow/OpError.htm">OpError</a>
        </li>
				<li>
            <a href="../tensorflow/OptionalSpec.htm">OptionalSpec</a>
        </li>
				<li>
            <a href="../tensorflow/orthogonal_initializer.htm">orthogonal_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/PaddingFIFOQueue.htm">PaddingFIFOQueue</a>
        </li>
				<li>
            <a href="../tensorflow/PriorityQueue.htm">PriorityQueue</a>
        </li>
				<li>
            <a href="../tensorflow/QueueBase.htm">QueueBase</a>
        </li>
				<li>
            <a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a>
        </li>
				<li>
            <a href="../tensorflow/RaggedTensorSpec.htm">RaggedTensorSpec</a>
        </li>
				<li>
            <a href="../tensorflow/random_normal_initializer.htm">random_normal_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/random_uniform_initializer.htm">random_uniform_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/RandomShuffleQueue.htm">RandomShuffleQueue</a>
        </li>
				<li>
            <a href="../tensorflow/ReaderBase.htm">ReaderBase</a>
        </li>
				<li>
            <a href="../tensorflow/RegisterGradient.htm">RegisterGradient</a>
        </li>
				<li>
            <a href="../tensorflow/Session.htm">Session</a>
        </li>
				<li>
            <a href="../tensorflow/SparseConditionalAccumulator.htm">SparseConditionalAccumulator</a>
        </li>
				<li>
            <a href="../tensorflow/SparseFeature.htm">SparseFeature</a>
        </li>
				<li>
            <a href="../tensorflow/SparseTensor.htm">SparseTensor</a>
        </li>
				<li>
            <a href="../tensorflow/SparseTensorSpec.htm">SparseTensorSpec</a>
        </li>
				<li>
            <a href="../tensorflow/SparseTensorValue.htm">SparseTensorValue</a>
        </li>
				<li>
            <a href="../tensorflow/Tensor.htm">Tensor</a>
        </li>
				<li>
            <a href="../tensorflow/Tensor`1.htm">Tensor&lt;T&gt;</a>
        </li>
				<li>
            <a href="../tensorflow/TensorArray.htm">TensorArray</a>
        </li>
				<li>
            <a href="../tensorflow/TensorArraySpec.htm">TensorArraySpec</a>
        </li>
				<li>
            <a href="../tensorflow/TensorDimension.htm">TensorDimension</a>
        </li>
				<li>
            <a href="../tensorflow/TensorDimensionSlice.htm">TensorDimensionSlice</a>
        </li>
				<li>
            <a href="../tensorflow/TensorShape.htm">TensorShape</a>
        </li>
				<li>
            <a href="../tensorflow/TensorSpec.htm">TensorSpec</a>
        </li>
				<li>
            <a href="../tensorflow/TextLineReader.htm">TextLineReader</a>
        </li>
				<li>
            <a href="../tensorflow/tf.htm">tf</a>
        </li>
				<li>
            <a href="../tensorflow/tf.audio.htm">tf.audio</a>
        </li>
				<li>
            <a href="../tensorflow/tf.autograph.htm">tf.autograph</a>
        </li>
				<li>
            <a href="../tensorflow/tf.autograph.experimental.htm">tf.autograph.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.bitwise.htm">tf.bitwise</a>
        </li>
				<li>
            <a href="../tensorflow/tf.compat.htm">tf.compat</a>
        </li>
				<li>
            <a href="../tensorflow/tf.config.htm">tf.config</a>
        </li>
				<li>
            <a href="../tensorflow/tf.config.experimental.htm">tf.config.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.config.optimizer.htm">tf.config.optimizer</a>
        </li>
				<li>
            <a href="../tensorflow/tf.config.threading.htm">tf.config.threading</a>
        </li>
				<li>
            <a href="../tensorflow/tf.data.htm">tf.data</a>
        </li>
				<li>
            <a href="../tensorflow/tf.data.experimental.htm">tf.data.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.debugging.htm">tf.debugging</a>
        </li>
				<li>
            <a href="../tensorflow/tf.distribute.htm">tf.distribute</a>
        </li>
				<li>
            <a href="../tensorflow/tf.distributions.htm">tf.distributions</a>
        </li>
				<li>
            <a href="../tensorflow/tf.errors.htm">tf.errors</a>
        </li>
				<li>
            <a href="../tensorflow/tf.estimator.htm">tf.estimator</a>
        </li>
				<li>
            <a href="../tensorflow/tf.estimator.experimental.htm">tf.estimator.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.estimator.export.htm">tf.estimator.export</a>
        </li>
				<li>
            <a href="../tensorflow/tf.estimator.inputs.htm">tf.estimator.inputs</a>
        </li>
				<li>
            <a href="../tensorflow/tf.experimental.htm">tf.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.feature_column.htm">tf.feature_column</a>
        </li>
				<li>
            <a href="../tensorflow/tf.gfile.htm">tf.gfile</a>
        </li>
				<li>
            <a href="../tensorflow/tf.graph_util.htm">tf.graph_util</a>
        </li>
				<li>
            <a href="../tensorflow/tf.image.htm">tf.image</a>
        </li>
				<li>
            <a href="../tensorflow/tf.initializers.htm">tf.initializers</a>
        </li>
				<li>
            <a href="../tensorflow/tf.io.htm">tf.io</a>
        </li>
				<li>
            <a href="../tensorflow/tf.io.gfile.htm">tf.io.gfile</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.htm">tf.keras</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.activations.htm">tf.keras.activations</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.htm">tf.keras.applications</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.densenet.htm">tf.keras.applications.densenet</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.imagenet_utils.htm">tf.keras.applications.imagenet_utils</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.inception_resnet_v2.htm">tf.keras.applications.inception_resnet_v2</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.inception_v3.htm">tf.keras.applications.inception_v3</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.mobilenet.htm">tf.keras.applications.mobilenet</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.mobilenet_v2.htm">tf.keras.applications.mobilenet_v2</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.nasnet.htm">tf.keras.applications.nasnet</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.resnet.htm">tf.keras.applications.resnet</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.resnet_v2.htm">tf.keras.applications.resnet_v2</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.vgg16.htm">tf.keras.applications.vgg16</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.vgg19.htm">tf.keras.applications.vgg19</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.xception.htm">tf.keras.applications.xception</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.backend.htm">tf.keras.backend</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.constraints.htm">tf.keras.constraints</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.datasets.htm">tf.keras.datasets</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.datasets.boston_housing.htm">tf.keras.datasets.boston_housing</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.datasets.cifar10.htm">tf.keras.datasets.cifar10</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.datasets.cifar100.htm">tf.keras.datasets.cifar100</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.datasets.fashion_mnist.htm">tf.keras.datasets.fashion_mnist</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.datasets.imdb.htm">tf.keras.datasets.imdb</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.datasets.mnist.htm">tf.keras.datasets.mnist</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.datasets.reuters.htm">tf.keras.datasets.reuters</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.estimator.htm">tf.keras.estimator</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.experimental.htm">tf.keras.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.initializers.htm">tf.keras.initializers</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.layers.htm">tf.keras.layers</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.losses.htm">tf.keras.losses</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.metrics.htm">tf.keras.metrics</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.mixed_precision.htm">tf.keras.mixed_precision</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.mixed_precision.experimental.htm">tf.keras.mixed_precision.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.models.htm">tf.keras.models</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.optimizers.htm">tf.keras.optimizers</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.optimizers.schedules.htm">tf.keras.optimizers.schedules</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.preprocessing.htm">tf.keras.preprocessing</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.preprocessing.image.htm">tf.keras.preprocessing.image</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.regularizers.htm">tf.keras.regularizers</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.utils.htm">tf.keras.utils</a>
        </li>
				<li>
            <a href="../tensorflow/tf.layers.htm">tf.layers</a>
        </li>
				<li>
            <a href="../tensorflow/tf.layers.experimental.htm">tf.layers.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.linalg.htm">tf.linalg</a>
        </li>
				<li>
            <a href="../tensorflow/tf.lite.htm">tf.lite</a>
        </li>
				<li>
            <a href="../tensorflow/tf.lite.experimental.htm">tf.lite.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.lite.experimental.microfrontend.htm">tf.lite.experimental.microfrontend</a>
        </li>
				<li>
            <a href="../tensorflow/tf.lite.experimental.microfrontend.python.htm">tf.lite.experimental.microfrontend.python</a>
        </li>
				<li>
            <a href="../tensorflow/tf.lite.experimental.microfrontend.python.ops.htm">tf.lite.experimental.microfrontend.python.ops</a>
        </li>
				<li>
            <a href="../tensorflow/tf.lite.experimental.nn.htm">tf.lite.experimental.nn</a>
        </li>
				<li>
            <a href="../tensorflow/tf.logging.htm">tf.logging</a>
        </li>
				<li>
            <a href="../tensorflow/tf.losses.htm">tf.losses</a>
        </li>
				<li>
            <a href="../tensorflow/tf.math.htm">tf.math</a>
        </li>
				<li>
            <a href="../tensorflow/tf.metrics.htm">tf.metrics</a>
        </li>
				<li>
            <a href="../tensorflow/tf.nest.htm">tf.nest</a>
        </li>
				<li>
            <a href="../tensorflow/tf.nn.htm">tf.nn</a>
        </li>
				<li>
            <a href="../tensorflow/tf.profiler.htm">tf.profiler</a>
        </li>
				<li>
            <a href="../tensorflow/tf.quantization.htm">tf.quantization</a>
        </li>
				<li>
            <a href="../tensorflow/tf.ragged.htm">tf.ragged</a>
        </li>
				<li>
            <a href="../tensorflow/tf.random.htm">tf.random</a>
        </li>
				<li>
            <a href="../tensorflow/tf.random.experimental.htm">tf.random.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.resource_loader.htm">tf.resource_loader</a>
        </li>
				<li>
            <a href="../tensorflow/tf.saved_model.htm">tf.saved_model</a>
        </li>
				<li>
            <a href="../tensorflow/tf.saved_model.main_op.htm">tf.saved_model.main_op</a>
        </li>
				<li>
            <a href="../tensorflow/tf.sets.htm">tf.sets</a>
        </li>
				<li>
            <a href="../tensorflow/tf.signal.htm" class="current">tf.signal</a>
        </li>
				<li>
            <a href="../tensorflow/tf.sparse.htm">tf.sparse</a>
        </li>
				<li>
            <a href="../tensorflow/tf.strings.htm">tf.strings</a>
        </li>
				<li>
            <a href="../tensorflow/tf.summary.htm">tf.summary</a>
        </li>
				<li>
            <a href="../tensorflow/tf.summary.experimental.htm">tf.summary.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.sysconfig.htm">tf.sysconfig</a>
        </li>
				<li>
            <a href="../tensorflow/tf.test.htm">tf.test</a>
        </li>
				<li>
            <a href="../tensorflow/tf.tpu.htm">tf.tpu</a>
        </li>
				<li>
            <a href="../tensorflow/tf.tpu.experimental.htm">tf.tpu.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.train.htm">tf.train</a>
        </li>
				<li>
            <a href="../tensorflow/tf.train.experimental.htm">tf.train.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.user_ops.htm">tf.user_ops</a>
        </li>
				<li>
            <a href="../tensorflow/tf.xla.htm">tf.xla</a>
        </li>
				<li>
            <a href="../tensorflow/tf.xla.experimental.htm">tf.xla.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/TFRecordReader.htm">TFRecordReader</a>
        </li>
				<li>
            <a href="../tensorflow/truncated_normal_initializer.htm">truncated_normal_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/TypeSpec.htm">TypeSpec</a>
        </li>
				<li>
            <a href="../tensorflow/UnconnectedGradients.htm">UnconnectedGradients</a>
        </li>
				<li>
            <a href="../tensorflow/uniform_unit_scaling_initializer.htm">uniform_unit_scaling_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/Variable.htm">Variable</a>
        </li>
				<li>
            <a href="../tensorflow/variable_scope.htm">variable_scope</a>
        </li>
				<li>
            <a href="../tensorflow/VariableAggregation.htm">VariableAggregation</a>
        </li>
				<li>
            <a href="../tensorflow/VariableScope.htm">VariableScope</a>
        </li>
				<li>
            <a href="../tensorflow/VariableSynchronization.htm">VariableSynchronization</a>
        </li>
				<li>
            <a href="../tensorflow/variance_scaling_initializer.htm">variance_scaling_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/VarLenFeature.htm">VarLenFeature</a>
        </li>
				<li>
            <a href="../tensorflow/WholeFileReader.htm">WholeFileReader</a>
        </li>
				<li>
            <a href="../tensorflow/zeros_initializer.htm">zeros_initializer</a>
        </li>
		</ul>
	</div>
</nav>
	<article>
    <header>
		<p class="class"><strong>Type</strong> tf.signal</p>
	</header>
	<section>
		<header>
		<p><strong>Namespace</strong> tensorflow</p>
		</header>
    <div class="sub-header">
		
		
			<h3 class="section">Methods</h3>
			<ul>
				<li><a href="../tensorflow/tf.signal.htm#dct">dct</a></li>
				<li><a href="../tensorflow/tf.signal.htm#dct">dct</a></li>
				<li><a href="../tensorflow/tf.signal.htm#dct">dct</a></li>
				<li><a href="../tensorflow/tf.signal.htm#dct_dyn">dct_dyn</a></li>
				<li><a href="../tensorflow/tf.signal.htm#fftshift">fftshift</a></li>
				<li><a href="../tensorflow/tf.signal.htm#fftshift">fftshift</a></li>
				<li><a href="../tensorflow/tf.signal.htm#fftshift_dyn">fftshift_dyn</a></li>
				<li><a href="../tensorflow/tf.signal.htm#frame">frame</a></li>
				<li><a href="../tensorflow/tf.signal.htm#frame">frame</a></li>
				<li><a href="../tensorflow/tf.signal.htm#frame">frame</a></li>
				<li><a href="../tensorflow/tf.signal.htm#frame">frame</a></li>
				<li><a href="../tensorflow/tf.signal.htm#frame">frame</a></li>
				<li><a href="../tensorflow/tf.signal.htm#frame">frame</a></li>
				<li><a href="../tensorflow/tf.signal.htm#frame">frame</a></li>
				<li><a href="../tensorflow/tf.signal.htm#frame">frame</a></li>
				<li><a href="../tensorflow/tf.signal.htm#frame">frame</a></li>
				<li><a href="../tensorflow/tf.signal.htm#frame">frame</a></li>
				<li><a href="../tensorflow/tf.signal.htm#frame">frame</a></li>
				<li><a href="../tensorflow/tf.signal.htm#frame">frame</a></li>
				<li><a href="../tensorflow/tf.signal.htm#frame">frame</a></li>
				<li><a href="../tensorflow/tf.signal.htm#frame">frame</a></li>
				<li><a href="../tensorflow/tf.signal.htm#frame">frame</a></li>
				<li><a href="../tensorflow/tf.signal.htm#frame">frame</a></li>
				<li><a href="../tensorflow/tf.signal.htm#frame">frame</a></li>
				<li><a href="../tensorflow/tf.signal.htm#frame">frame</a></li>
				<li><a href="../tensorflow/tf.signal.htm#frame">frame</a></li>
				<li><a href="../tensorflow/tf.signal.htm#frame">frame</a></li>
				<li><a href="../tensorflow/tf.signal.htm#frame">frame</a></li>
				<li><a href="../tensorflow/tf.signal.htm#frame">frame</a></li>
				<li><a href="../tensorflow/tf.signal.htm#frame">frame</a></li>
				<li><a href="../tensorflow/tf.signal.htm#frame">frame</a></li>
				<li><a href="../tensorflow/tf.signal.htm#frame">frame</a></li>
				<li><a href="../tensorflow/tf.signal.htm#frame">frame</a></li>
				<li><a href="../tensorflow/tf.signal.htm#frame">frame</a></li>
				<li><a href="../tensorflow/tf.signal.htm#frame_dyn">frame_dyn</a></li>
				<li><a href="../tensorflow/tf.signal.htm#hamming_window">hamming_window</a></li>
				<li><a href="../tensorflow/tf.signal.htm#hamming_window_dyn">hamming_window_dyn</a></li>
				<li><a href="../tensorflow/tf.signal.htm#hann_window">hann_window</a></li>
				<li><a href="../tensorflow/tf.signal.htm#hann_window">hann_window</a></li>
				<li><a href="../tensorflow/tf.signal.htm#hann_window_dyn">hann_window_dyn</a></li>
				<li><a href="../tensorflow/tf.signal.htm#idct">idct</a></li>
				<li><a href="../tensorflow/tf.signal.htm#idct">idct</a></li>
				<li><a href="../tensorflow/tf.signal.htm#idct_dyn">idct_dyn</a></li>
				<li><a href="../tensorflow/tf.signal.htm#ifftshift">ifftshift</a></li>
				<li><a href="../tensorflow/tf.signal.htm#ifftshift">ifftshift</a></li>
				<li><a href="../tensorflow/tf.signal.htm#ifftshift_dyn">ifftshift_dyn</a></li>
				<li><a href="../tensorflow/tf.signal.htm#inverse_stft">inverse_stft</a></li>
				<li><a href="../tensorflow/tf.signal.htm#inverse_stft_dyn">inverse_stft_dyn</a></li>
				<li><a href="../tensorflow/tf.signal.htm#inverse_stft_window_fn">inverse_stft_window_fn</a></li>
				<li><a href="../tensorflow/tf.signal.htm#inverse_stft_window_fn">inverse_stft_window_fn</a></li>
				<li><a href="../tensorflow/tf.signal.htm#inverse_stft_window_fn_dyn">inverse_stft_window_fn_dyn</a></li>
				<li><a href="../tensorflow/tf.signal.htm#linear_to_mel_weight_matrix">linear_to_mel_weight_matrix</a></li>
				<li><a href="../tensorflow/tf.signal.htm#linear_to_mel_weight_matrix">linear_to_mel_weight_matrix</a></li>
				<li><a href="../tensorflow/tf.signal.htm#linear_to_mel_weight_matrix">linear_to_mel_weight_matrix</a></li>
				<li><a href="../tensorflow/tf.signal.htm#linear_to_mel_weight_matrix">linear_to_mel_weight_matrix</a></li>
				<li><a href="../tensorflow/tf.signal.htm#linear_to_mel_weight_matrix">linear_to_mel_weight_matrix</a></li>
				<li><a href="../tensorflow/tf.signal.htm#linear_to_mel_weight_matrix">linear_to_mel_weight_matrix</a></li>
				<li><a href="../tensorflow/tf.signal.htm#linear_to_mel_weight_matrix">linear_to_mel_weight_matrix</a></li>
				<li><a href="../tensorflow/tf.signal.htm#linear_to_mel_weight_matrix">linear_to_mel_weight_matrix</a></li>
				<li><a href="../tensorflow/tf.signal.htm#linear_to_mel_weight_matrix">linear_to_mel_weight_matrix</a></li>
				<li><a href="../tensorflow/tf.signal.htm#linear_to_mel_weight_matrix">linear_to_mel_weight_matrix</a></li>
				<li><a href="../tensorflow/tf.signal.htm#linear_to_mel_weight_matrix">linear_to_mel_weight_matrix</a></li>
				<li><a href="../tensorflow/tf.signal.htm#linear_to_mel_weight_matrix">linear_to_mel_weight_matrix</a></li>
				<li><a href="../tensorflow/tf.signal.htm#linear_to_mel_weight_matrix">linear_to_mel_weight_matrix</a></li>
				<li><a href="../tensorflow/tf.signal.htm#linear_to_mel_weight_matrix">linear_to_mel_weight_matrix</a></li>
				<li><a href="../tensorflow/tf.signal.htm#linear_to_mel_weight_matrix">linear_to_mel_weight_matrix</a></li>
				<li><a href="../tensorflow/tf.signal.htm#linear_to_mel_weight_matrix">linear_to_mel_weight_matrix</a></li>
				<li><a href="../tensorflow/tf.signal.htm#linear_to_mel_weight_matrix">linear_to_mel_weight_matrix</a></li>
				<li><a href="../tensorflow/tf.signal.htm#linear_to_mel_weight_matrix">linear_to_mel_weight_matrix</a></li>
				<li><a href="../tensorflow/tf.signal.htm#linear_to_mel_weight_matrix">linear_to_mel_weight_matrix</a></li>
				<li><a href="../tensorflow/tf.signal.htm#linear_to_mel_weight_matrix">linear_to_mel_weight_matrix</a></li>
				<li><a href="../tensorflow/tf.signal.htm#linear_to_mel_weight_matrix">linear_to_mel_weight_matrix</a></li>
				<li><a href="../tensorflow/tf.signal.htm#linear_to_mel_weight_matrix">linear_to_mel_weight_matrix</a></li>
				<li><a href="../tensorflow/tf.signal.htm#linear_to_mel_weight_matrix">linear_to_mel_weight_matrix</a></li>
				<li><a href="../tensorflow/tf.signal.htm#linear_to_mel_weight_matrix">linear_to_mel_weight_matrix</a></li>
				<li><a href="../tensorflow/tf.signal.htm#linear_to_mel_weight_matrix_dyn">linear_to_mel_weight_matrix_dyn</a></li>
				<li><a href="../tensorflow/tf.signal.htm#mfccs_from_log_mel_spectrograms">mfccs_from_log_mel_spectrograms</a></li>
				<li><a href="../tensorflow/tf.signal.htm#mfccs_from_log_mel_spectrograms_dyn">mfccs_from_log_mel_spectrograms_dyn</a></li>
				<li><a href="../tensorflow/tf.signal.htm#overlap_and_add">overlap_and_add</a></li>
				<li><a href="../tensorflow/tf.signal.htm#overlap_and_add">overlap_and_add</a></li>
				<li><a href="../tensorflow/tf.signal.htm#overlap_and_add">overlap_and_add</a></li>
				<li><a href="../tensorflow/tf.signal.htm#overlap_and_add">overlap_and_add</a></li>
				<li><a href="../tensorflow/tf.signal.htm#overlap_and_add_dyn">overlap_and_add_dyn</a></li>
				<li><a href="../tensorflow/tf.signal.htm#stft">stft</a></li>
				<li><a href="../tensorflow/tf.signal.htm#stft_dyn">stft_dyn</a></li>
			</ul>
		
			<h3 class="section">Properties</h3>
			<ul>
				<li><a href="../tensorflow/tf.signal.htm#dct_fn">dct_fn</a></li>
				<li><a href="../tensorflow/tf.signal.htm#fftshift_fn">fftshift_fn</a></li>
				<li><a href="../tensorflow/tf.signal.htm#frame_fn">frame_fn</a></li>
				<li><a href="../tensorflow/tf.signal.htm#hamming_window_fn">hamming_window_fn</a></li>
				<li><a href="../tensorflow/tf.signal.htm#hann_window_fn">hann_window_fn</a></li>
				<li><a href="../tensorflow/tf.signal.htm#idct_fn">idct_fn</a></li>
				<li><a href="../tensorflow/tf.signal.htm#ifftshift_fn">ifftshift_fn</a></li>
				<li><a href="../tensorflow/tf.signal.htm#inverse_stft_fn">inverse_stft_fn</a></li>
				<li><a href="../tensorflow/tf.signal.htm#inverse_stft_window_fn_fn">inverse_stft_window_fn_fn</a></li>
				<li><a href="../tensorflow/tf.signal.htm#linear_to_mel_weight_matrix_fn">linear_to_mel_weight_matrix_fn</a></li>
				<li><a href="../tensorflow/tf.signal.htm#mfccs_from_log_mel_spectrograms_fn">mfccs_from_log_mel_spectrograms_fn</a></li>
				<li><a href="../tensorflow/tf.signal.htm#overlap_and_add_fn">overlap_and_add_fn</a></li>
				<li><a href="../tensorflow/tf.signal.htm#stft_fn">stft_fn</a></li>
			</ul>
		
	</div>
	
	
	<h3 class="section">Public static methods</h3>

	<div id="dct" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>dct</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> input, <span title="System.int">int</span> type, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> n, <span title="System.int">int</span> axis, <span title="System.string">string</span> norm, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the 1D [Discrete Cosine Transform (DCT)][dct] of `input`. <p></p> Currently only Types I, II and III are supported.
Type I is implemented using a length `2N` padded <a href="..\..\tf\signal\rfft.md"><code>tf.signal.rfft</code></a>.
Type II is implemented using a length `2N` padded <a href="..\..\tf\signal\rfft.md"><code>tf.signal.rfft</code></a>, as
described here: [Type 2 DCT using 2N FFT padded (Makhoul)](https://dsp.stackexchange.com/a/10606).
Type III is a fairly straightforward inverse of Type II
(i.e. using a length `2N` padded <a href="..\..\tf\signal\irfft.md"><code>tf.signal.irfft</code></a>). 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> input
						</dt>
						<dd>A `[..., samples]` `float32` `Tensor` containing the signals to
take the DCT of. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> type
						</dt>
						<dd>The DCT type to perform. Must be 1, 2 or 3. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> n
						</dt>
						<dd>The length of the transform. If length is less than sequence length,
only the first n elements of the sequence are considered for the DCT.
If n is greater than the sequence length, zeros are padded and then
the DCT is computed as usual. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> axis
						</dt>
						<dd>For future expansion. The axis to compute the DCT along. Must be `-1`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> norm
						</dt>
						<dd>The normalization to apply. `None` for no normalization or `'ortho'`
for orthonormal normalization. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `[..., samples]` `float32` `Tensor` containing the DCT of `input`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="dct" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>dct</strong>(<span title="System.object">object</span> input, <span title="System.int">int</span> type, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> n, <span title="System.int">int</span> axis, <span title="System.string">string</span> norm, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the 1D [Discrete Cosine Transform (DCT)][dct] of `input`. <p></p> Currently only Types I, II and III are supported.
Type I is implemented using a length `2N` padded <a href="..\..\tf\signal\rfft.md"><code>tf.signal.rfft</code></a>.
Type II is implemented using a length `2N` padded <a href="..\..\tf\signal\rfft.md"><code>tf.signal.rfft</code></a>, as
described here: [Type 2 DCT using 2N FFT padded (Makhoul)](https://dsp.stackexchange.com/a/10606).
Type III is a fairly straightforward inverse of Type II
(i.e. using a length `2N` padded <a href="..\..\tf\signal\irfft.md"><code>tf.signal.irfft</code></a>). 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> input
						</dt>
						<dd>A `[..., samples]` `float32` `Tensor` containing the signals to
take the DCT of. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> type
						</dt>
						<dd>The DCT type to perform. Must be 1, 2 or 3. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> n
						</dt>
						<dd>The length of the transform. If length is less than sequence length,
only the first n elements of the sequence are considered for the DCT.
If n is greater than the sequence length, zeros are padded and then
the DCT is computed as usual. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> axis
						</dt>
						<dd>For future expansion. The axis to compute the DCT along. Must be `-1`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> norm
						</dt>
						<dd>The normalization to apply. `None` for no normalization or `'ortho'`
for orthonormal normalization. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `[..., samples]` `float32` `Tensor` containing the DCT of `input`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="dct" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>dct</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> input, <span title="System.int">int</span> type, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> n, <span title="System.int">int</span> axis, <span title="System.string">string</span> norm, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the 1D [Discrete Cosine Transform (DCT)][dct] of `input`. <p></p> Currently only Types I, II and III are supported.
Type I is implemented using a length `2N` padded <a href="..\..\tf\signal\rfft.md"><code>tf.signal.rfft</code></a>.
Type II is implemented using a length `2N` padded <a href="..\..\tf\signal\rfft.md"><code>tf.signal.rfft</code></a>, as
described here: [Type 2 DCT using 2N FFT padded (Makhoul)](https://dsp.stackexchange.com/a/10606).
Type III is a fairly straightforward inverse of Type II
(i.e. using a length `2N` padded <a href="..\..\tf\signal\irfft.md"><code>tf.signal.irfft</code></a>). 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> input
						</dt>
						<dd>A `[..., samples]` `float32` `Tensor` containing the signals to
take the DCT of. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> type
						</dt>
						<dd>The DCT type to perform. Must be 1, 2 or 3. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> n
						</dt>
						<dd>The length of the transform. If length is less than sequence length,
only the first n elements of the sequence are considered for the DCT.
If n is greater than the sequence length, zeros are padded and then
the DCT is computed as usual. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> axis
						</dt>
						<dd>For future expansion. The axis to compute the DCT along. Must be `-1`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> norm
						</dt>
						<dd>The normalization to apply. `None` for no normalization or `'ortho'`
for orthonormal normalization. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `[..., samples]` `float32` `Tensor` containing the DCT of `input`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="dct_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>dct_dyn</strong>(<span title="System.object">object</span> input, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> type, <span title="System.object">object</span> n, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> axis, <span title="System.object">object</span> norm, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Computes the 1D [Discrete Cosine Transform (DCT)][dct] of `input`. <p></p> Currently only Types I, II and III are supported.
Type I is implemented using a length `2N` padded <a href="..\..\tf\signal\rfft.md"><code>tf.signal.rfft</code></a>.
Type II is implemented using a length `2N` padded <a href="..\..\tf\signal\rfft.md"><code>tf.signal.rfft</code></a>, as
described here: [Type 2 DCT using 2N FFT padded (Makhoul)](https://dsp.stackexchange.com/a/10606).
Type III is a fairly straightforward inverse of Type II
(i.e. using a length `2N` padded <a href="..\..\tf\signal\irfft.md"><code>tf.signal.irfft</code></a>). 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> input
						</dt>
						<dd>A `[..., samples]` `float32` `Tensor` containing the signals to
take the DCT of. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> type
						</dt>
						<dd>The DCT type to perform. Must be 1, 2 or 3. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> n
						</dt>
						<dd>The length of the transform. If length is less than sequence length,
only the first n elements of the sequence are considered for the DCT.
If n is greater than the sequence length, zeros are padded and then
the DCT is computed as usual. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> axis
						</dt>
						<dd>For future expansion. The axis to compute the DCT along. Must be `-1`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> norm
						</dt>
						<dd>The normalization to apply. `None` for no normalization or `'ortho'`
for orthonormal normalization. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `[..., samples]` `float32` `Tensor` containing the DCT of `input`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="fftshift" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>fftshift</strong>(<span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> x, <span title="System.Nullable<ValueTuple<int, int>>">Nullable&lt;ValueTuple&lt;int, int&gt;&gt;</span> axes, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Shift the zero-frequency component to the center of the spectrum. <p></p> This function swaps half-spaces for all axes listed (defaults to all).
Note that ``y[0]`` is the Nyquist component only if ``len(x)`` is even. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> x
						</dt>
						<dd>`Tensor`, input tensor. 
						</dd>
						<dt>
							<code><span title="System.Nullable<ValueTuple<int, int>>">Nullable&lt;ValueTuple&lt;int, int&gt;&gt;</span></code> axes
						</dt>
						<dd>`int` or shape `tuple`, optional Axes over which to shift.  Default is
None, which shifts all axes. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor`, The shifted tensor. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>x = tf.signal.fftshift([ 0.,  1.,  2.,  3.,  4., -5., -4., -3., -2., -1.])
            x.numpy() # array([-5., -4., -3., -2., -1.,  0.,  1.,  2.,  3.,  4.]) </pre>
</div>
		</div>
	</div>
	<div id="fftshift" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>fftshift</strong>(<span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> x, <span title="System.int">int</span> axes, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Shift the zero-frequency component to the center of the spectrum. <p></p> This function swaps half-spaces for all axes listed (defaults to all).
Note that ``y[0]`` is the Nyquist component only if ``len(x)`` is even. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> x
						</dt>
						<dd>`Tensor`, input tensor. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> axes
						</dt>
						<dd>`int` or shape `tuple`, optional Axes over which to shift.  Default is
None, which shifts all axes. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor`, The shifted tensor. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>x = tf.signal.fftshift([ 0.,  1.,  2.,  3.,  4., -5., -4., -3., -2., -1.])
            x.numpy() # array([-5., -4., -3., -2., -1.,  0.,  1.,  2.,  3.,  4.]) </pre>
</div>
		</div>
	</div>
	<div id="fftshift_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>fftshift_dyn</strong>(<span title="System.object">object</span> x, <span title="System.object">object</span> axes, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Shift the zero-frequency component to the center of the spectrum. <p></p> This function swaps half-spaces for all axes listed (defaults to all).
Note that ``y[0]`` is the Nyquist component only if ``len(x)`` is even. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> x
						</dt>
						<dd>`Tensor`, input tensor. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> axes
						</dt>
						<dd>`int` or shape `tuple`, optional Axes over which to shift.  Default is
None, which shifts all axes. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `Tensor`, The shifted tensor. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>x = tf.signal.fftshift([ 0.,  1.,  2.,  3.,  4., -5., -4., -3., -2., -1.])
            x.numpy() # array([-5., -4., -3., -2., -1.,  0.,  1.,  2.,  3.,  4.]) </pre>
</div>
		</div>
	</div>
	<div id="frame" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>frame</strong>(<span title="System.int">int</span> signal, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> frame_length, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> frame_step, <span title="System.bool">bool</span> pad_end, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> pad_value, <span title="System.int">int</span> axis, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Expands `signal`'s `axis` dimension into frames of `frame_length`. <p></p> Slides a window of size `frame_length` over `signal`'s `axis` dimension
with a stride of `frame_step`, replacing the `axis` dimension with
`[frames, frame_length]` frames. <p></p> If `pad_end` is True, window positions that are past the end of the `axis`
dimension are padded with `pad_value` until the window moves fully past the
end of the dimension. Otherwise, only window positions that fully overlap the
`axis` dimension are produced. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> signal
						</dt>
						<dd>A `[..., samples,...]` `Tensor`. The rank and dimensions
may be unknown. Rank must be at least 1. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> frame_length
						</dt>
						<dd>The frame length in samples. An integer or scalar `Tensor`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> frame_step
						</dt>
						<dd>The frame hop size in samples. An integer or scalar `Tensor`. 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> pad_end
						</dt>
						<dd>Whether to pad the end of `signal` with `pad_value`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> pad_value
						</dt>
						<dd>An optional scalar `Tensor` to use where the input signal
does not exist when `pad_end` is True. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> axis
						</dt>
						<dd>A scalar integer `Tensor` indicating the axis to frame. Defaults to
the last axis. Supports negative values for indexing from the end. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of frames with shape `[..., frames, frame_length,...]`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>pcm = tf.compat.v1.placeholder(tf.float32, [None, 9152])
            frames = tf.signal.frame(pcm, 512, 180)
            magspec = tf.abs(tf.signal.rfft(frames, [512]))
            image = tf.expand_dims(magspec, 3) </pre>
</div>
		</div>
	</div>
	<div id="frame" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>frame</strong>(<span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> signal, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> frame_length, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> frame_step, <span title="System.bool">bool</span> pad_end, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> pad_value, <span title="System.int">int</span> axis, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Expands `signal`'s `axis` dimension into frames of `frame_length`. <p></p> Slides a window of size `frame_length` over `signal`'s `axis` dimension
with a stride of `frame_step`, replacing the `axis` dimension with
`[frames, frame_length]` frames. <p></p> If `pad_end` is True, window positions that are past the end of the `axis`
dimension are padded with `pad_value` until the window moves fully past the
end of the dimension. Otherwise, only window positions that fully overlap the
`axis` dimension are produced. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> signal
						</dt>
						<dd>A `[..., samples,...]` `Tensor`. The rank and dimensions
may be unknown. Rank must be at least 1. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> frame_length
						</dt>
						<dd>The frame length in samples. An integer or scalar `Tensor`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> frame_step
						</dt>
						<dd>The frame hop size in samples. An integer or scalar `Tensor`. 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> pad_end
						</dt>
						<dd>Whether to pad the end of `signal` with `pad_value`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> pad_value
						</dt>
						<dd>An optional scalar `Tensor` to use where the input signal
does not exist when `pad_end` is True. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> axis
						</dt>
						<dd>A scalar integer `Tensor` indicating the axis to frame. Defaults to
the last axis. Supports negative values for indexing from the end. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of frames with shape `[..., frames, frame_length,...]`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>pcm = tf.compat.v1.placeholder(tf.float32, [None, 9152])
            frames = tf.signal.frame(pcm, 512, 180)
            magspec = tf.abs(tf.signal.rfft(frames, [512]))
            image = tf.expand_dims(magspec, 3) </pre>
</div>
		</div>
	</div>
	<div id="frame" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>frame</strong>(<span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> signal, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> frame_length, <span title="System.int">int</span> frame_step, <span title="System.bool">bool</span> pad_end, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> pad_value, <span title="System.int">int</span> axis, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Expands `signal`'s `axis` dimension into frames of `frame_length`. <p></p> Slides a window of size `frame_length` over `signal`'s `axis` dimension
with a stride of `frame_step`, replacing the `axis` dimension with
`[frames, frame_length]` frames. <p></p> If `pad_end` is True, window positions that are past the end of the `axis`
dimension are padded with `pad_value` until the window moves fully past the
end of the dimension. Otherwise, only window positions that fully overlap the
`axis` dimension are produced. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> signal
						</dt>
						<dd>A `[..., samples,...]` `Tensor`. The rank and dimensions
may be unknown. Rank must be at least 1. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> frame_length
						</dt>
						<dd>The frame length in samples. An integer or scalar `Tensor`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> frame_step
						</dt>
						<dd>The frame hop size in samples. An integer or scalar `Tensor`. 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> pad_end
						</dt>
						<dd>Whether to pad the end of `signal` with `pad_value`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> pad_value
						</dt>
						<dd>An optional scalar `Tensor` to use where the input signal
does not exist when `pad_end` is True. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> axis
						</dt>
						<dd>A scalar integer `Tensor` indicating the axis to frame. Defaults to
the last axis. Supports negative values for indexing from the end. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of frames with shape `[..., frames, frame_length,...]`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>pcm = tf.compat.v1.placeholder(tf.float32, [None, 9152])
            frames = tf.signal.frame(pcm, 512, 180)
            magspec = tf.abs(tf.signal.rfft(frames, [512]))
            image = tf.expand_dims(magspec, 3) </pre>
</div>
		</div>
	</div>
	<div id="frame" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>frame</strong>(<span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> signal, <span title="System.int">int</span> frame_length, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> frame_step, <span title="System.bool">bool</span> pad_end, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> pad_value, <span title="System.int">int</span> axis, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Expands `signal`'s `axis` dimension into frames of `frame_length`. <p></p> Slides a window of size `frame_length` over `signal`'s `axis` dimension
with a stride of `frame_step`, replacing the `axis` dimension with
`[frames, frame_length]` frames. <p></p> If `pad_end` is True, window positions that are past the end of the `axis`
dimension are padded with `pad_value` until the window moves fully past the
end of the dimension. Otherwise, only window positions that fully overlap the
`axis` dimension are produced. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> signal
						</dt>
						<dd>A `[..., samples,...]` `Tensor`. The rank and dimensions
may be unknown. Rank must be at least 1. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> frame_length
						</dt>
						<dd>The frame length in samples. An integer or scalar `Tensor`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> frame_step
						</dt>
						<dd>The frame hop size in samples. An integer or scalar `Tensor`. 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> pad_end
						</dt>
						<dd>Whether to pad the end of `signal` with `pad_value`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> pad_value
						</dt>
						<dd>An optional scalar `Tensor` to use where the input signal
does not exist when `pad_end` is True. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> axis
						</dt>
						<dd>A scalar integer `Tensor` indicating the axis to frame. Defaults to
the last axis. Supports negative values for indexing from the end. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of frames with shape `[..., frames, frame_length,...]`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>pcm = tf.compat.v1.placeholder(tf.float32, [None, 9152])
            frames = tf.signal.frame(pcm, 512, 180)
            magspec = tf.abs(tf.signal.rfft(frames, [512]))
            image = tf.expand_dims(magspec, 3) </pre>
</div>
		</div>
	</div>
	<div id="frame" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>frame</strong>(<span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> signal, <span title="System.int">int</span> frame_length, <span title="System.int">int</span> frame_step, <span title="System.bool">bool</span> pad_end, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> pad_value, <span title="System.int">int</span> axis, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Expands `signal`'s `axis` dimension into frames of `frame_length`. <p></p> Slides a window of size `frame_length` over `signal`'s `axis` dimension
with a stride of `frame_step`, replacing the `axis` dimension with
`[frames, frame_length]` frames. <p></p> If `pad_end` is True, window positions that are past the end of the `axis`
dimension are padded with `pad_value` until the window moves fully past the
end of the dimension. Otherwise, only window positions that fully overlap the
`axis` dimension are produced. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> signal
						</dt>
						<dd>A `[..., samples,...]` `Tensor`. The rank and dimensions
may be unknown. Rank must be at least 1. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> frame_length
						</dt>
						<dd>The frame length in samples. An integer or scalar `Tensor`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> frame_step
						</dt>
						<dd>The frame hop size in samples. An integer or scalar `Tensor`. 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> pad_end
						</dt>
						<dd>Whether to pad the end of `signal` with `pad_value`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> pad_value
						</dt>
						<dd>An optional scalar `Tensor` to use where the input signal
does not exist when `pad_end` is True. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> axis
						</dt>
						<dd>A scalar integer `Tensor` indicating the axis to frame. Defaults to
the last axis. Supports negative values for indexing from the end. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of frames with shape `[..., frames, frame_length,...]`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>pcm = tf.compat.v1.placeholder(tf.float32, [None, 9152])
            frames = tf.signal.frame(pcm, 512, 180)
            magspec = tf.abs(tf.signal.rfft(frames, [512]))
            image = tf.expand_dims(magspec, 3) </pre>
</div>
		</div>
	</div>
	<div id="frame" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>frame</strong>(<span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> signal, <span title="System.int">int</span> frame_length, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> frame_step, <span title="System.bool">bool</span> pad_end, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> pad_value, <span title="System.int">int</span> axis, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Expands `signal`'s `axis` dimension into frames of `frame_length`. <p></p> Slides a window of size `frame_length` over `signal`'s `axis` dimension
with a stride of `frame_step`, replacing the `axis` dimension with
`[frames, frame_length]` frames. <p></p> If `pad_end` is True, window positions that are past the end of the `axis`
dimension are padded with `pad_value` until the window moves fully past the
end of the dimension. Otherwise, only window positions that fully overlap the
`axis` dimension are produced. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> signal
						</dt>
						<dd>A `[..., samples,...]` `Tensor`. The rank and dimensions
may be unknown. Rank must be at least 1. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> frame_length
						</dt>
						<dd>The frame length in samples. An integer or scalar `Tensor`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> frame_step
						</dt>
						<dd>The frame hop size in samples. An integer or scalar `Tensor`. 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> pad_end
						</dt>
						<dd>Whether to pad the end of `signal` with `pad_value`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> pad_value
						</dt>
						<dd>An optional scalar `Tensor` to use where the input signal
does not exist when `pad_end` is True. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> axis
						</dt>
						<dd>A scalar integer `Tensor` indicating the axis to frame. Defaults to
the last axis. Supports negative values for indexing from the end. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of frames with shape `[..., frames, frame_length,...]`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>pcm = tf.compat.v1.placeholder(tf.float32, [None, 9152])
            frames = tf.signal.frame(pcm, 512, 180)
            magspec = tf.abs(tf.signal.rfft(frames, [512]))
            image = tf.expand_dims(magspec, 3) </pre>
</div>
		</div>
	</div>
	<div id="frame" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>frame</strong>(<span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> signal, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> frame_length, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> frame_step, <span title="System.bool">bool</span> pad_end, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> pad_value, <span title="System.int">int</span> axis, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Expands `signal`'s `axis` dimension into frames of `frame_length`. <p></p> Slides a window of size `frame_length` over `signal`'s `axis` dimension
with a stride of `frame_step`, replacing the `axis` dimension with
`[frames, frame_length]` frames. <p></p> If `pad_end` is True, window positions that are past the end of the `axis`
dimension are padded with `pad_value` until the window moves fully past the
end of the dimension. Otherwise, only window positions that fully overlap the
`axis` dimension are produced. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> signal
						</dt>
						<dd>A `[..., samples,...]` `Tensor`. The rank and dimensions
may be unknown. Rank must be at least 1. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> frame_length
						</dt>
						<dd>The frame length in samples. An integer or scalar `Tensor`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> frame_step
						</dt>
						<dd>The frame hop size in samples. An integer or scalar `Tensor`. 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> pad_end
						</dt>
						<dd>Whether to pad the end of `signal` with `pad_value`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> pad_value
						</dt>
						<dd>An optional scalar `Tensor` to use where the input signal
does not exist when `pad_end` is True. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> axis
						</dt>
						<dd>A scalar integer `Tensor` indicating the axis to frame. Defaults to
the last axis. Supports negative values for indexing from the end. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of frames with shape `[..., frames, frame_length,...]`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>pcm = tf.compat.v1.placeholder(tf.float32, [None, 9152])
            frames = tf.signal.frame(pcm, 512, 180)
            magspec = tf.abs(tf.signal.rfft(frames, [512]))
            image = tf.expand_dims(magspec, 3) </pre>
</div>
		</div>
	</div>
	<div id="frame" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>frame</strong>(<span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> signal, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> frame_length, <span title="System.int">int</span> frame_step, <span title="System.bool">bool</span> pad_end, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> pad_value, <span title="System.int">int</span> axis, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Expands `signal`'s `axis` dimension into frames of `frame_length`. <p></p> Slides a window of size `frame_length` over `signal`'s `axis` dimension
with a stride of `frame_step`, replacing the `axis` dimension with
`[frames, frame_length]` frames. <p></p> If `pad_end` is True, window positions that are past the end of the `axis`
dimension are padded with `pad_value` until the window moves fully past the
end of the dimension. Otherwise, only window positions that fully overlap the
`axis` dimension are produced. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> signal
						</dt>
						<dd>A `[..., samples,...]` `Tensor`. The rank and dimensions
may be unknown. Rank must be at least 1. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> frame_length
						</dt>
						<dd>The frame length in samples. An integer or scalar `Tensor`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> frame_step
						</dt>
						<dd>The frame hop size in samples. An integer or scalar `Tensor`. 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> pad_end
						</dt>
						<dd>Whether to pad the end of `signal` with `pad_value`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> pad_value
						</dt>
						<dd>An optional scalar `Tensor` to use where the input signal
does not exist when `pad_end` is True. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> axis
						</dt>
						<dd>A scalar integer `Tensor` indicating the axis to frame. Defaults to
the last axis. Supports negative values for indexing from the end. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of frames with shape `[..., frames, frame_length,...]`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>pcm = tf.compat.v1.placeholder(tf.float32, [None, 9152])
            frames = tf.signal.frame(pcm, 512, 180)
            magspec = tf.abs(tf.signal.rfft(frames, [512]))
            image = tf.expand_dims(magspec, 3) </pre>
</div>
		</div>
	</div>
	<div id="frame" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>frame</strong>(<span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> signal, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> frame_length, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> frame_step, <span title="System.bool">bool</span> pad_end, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> pad_value, <span title="System.int">int</span> axis, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Expands `signal`'s `axis` dimension into frames of `frame_length`. <p></p> Slides a window of size `frame_length` over `signal`'s `axis` dimension
with a stride of `frame_step`, replacing the `axis` dimension with
`[frames, frame_length]` frames. <p></p> If `pad_end` is True, window positions that are past the end of the `axis`
dimension are padded with `pad_value` until the window moves fully past the
end of the dimension. Otherwise, only window positions that fully overlap the
`axis` dimension are produced. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> signal
						</dt>
						<dd>A `[..., samples,...]` `Tensor`. The rank and dimensions
may be unknown. Rank must be at least 1. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> frame_length
						</dt>
						<dd>The frame length in samples. An integer or scalar `Tensor`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> frame_step
						</dt>
						<dd>The frame hop size in samples. An integer or scalar `Tensor`. 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> pad_end
						</dt>
						<dd>Whether to pad the end of `signal` with `pad_value`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> pad_value
						</dt>
						<dd>An optional scalar `Tensor` to use where the input signal
does not exist when `pad_end` is True. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> axis
						</dt>
						<dd>A scalar integer `Tensor` indicating the axis to frame. Defaults to
the last axis. Supports negative values for indexing from the end. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of frames with shape `[..., frames, frame_length,...]`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>pcm = tf.compat.v1.placeholder(tf.float32, [None, 9152])
            frames = tf.signal.frame(pcm, 512, 180)
            magspec = tf.abs(tf.signal.rfft(frames, [512]))
            image = tf.expand_dims(magspec, 3) </pre>
</div>
		</div>
	</div>
	<div id="frame" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>frame</strong>(<span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> signal, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> frame_length, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> frame_step, <span title="System.bool">bool</span> pad_end, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> pad_value, <span title="System.int">int</span> axis, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Expands `signal`'s `axis` dimension into frames of `frame_length`. <p></p> Slides a window of size `frame_length` over `signal`'s `axis` dimension
with a stride of `frame_step`, replacing the `axis` dimension with
`[frames, frame_length]` frames. <p></p> If `pad_end` is True, window positions that are past the end of the `axis`
dimension are padded with `pad_value` until the window moves fully past the
end of the dimension. Otherwise, only window positions that fully overlap the
`axis` dimension are produced. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> signal
						</dt>
						<dd>A `[..., samples,...]` `Tensor`. The rank and dimensions
may be unknown. Rank must be at least 1. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> frame_length
						</dt>
						<dd>The frame length in samples. An integer or scalar `Tensor`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> frame_step
						</dt>
						<dd>The frame hop size in samples. An integer or scalar `Tensor`. 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> pad_end
						</dt>
						<dd>Whether to pad the end of `signal` with `pad_value`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> pad_value
						</dt>
						<dd>An optional scalar `Tensor` to use where the input signal
does not exist when `pad_end` is True. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> axis
						</dt>
						<dd>A scalar integer `Tensor` indicating the axis to frame. Defaults to
the last axis. Supports negative values for indexing from the end. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of frames with shape `[..., frames, frame_length,...]`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>pcm = tf.compat.v1.placeholder(tf.float32, [None, 9152])
            frames = tf.signal.frame(pcm, 512, 180)
            magspec = tf.abs(tf.signal.rfft(frames, [512]))
            image = tf.expand_dims(magspec, 3) </pre>
</div>
		</div>
	</div>
	<div id="frame" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>frame</strong>(<span title="System.int">int</span> signal, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> frame_length, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> frame_step, <span title="System.bool">bool</span> pad_end, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> pad_value, <span title="System.int">int</span> axis, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Expands `signal`'s `axis` dimension into frames of `frame_length`. <p></p> Slides a window of size `frame_length` over `signal`'s `axis` dimension
with a stride of `frame_step`, replacing the `axis` dimension with
`[frames, frame_length]` frames. <p></p> If `pad_end` is True, window positions that are past the end of the `axis`
dimension are padded with `pad_value` until the window moves fully past the
end of the dimension. Otherwise, only window positions that fully overlap the
`axis` dimension are produced. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> signal
						</dt>
						<dd>A `[..., samples,...]` `Tensor`. The rank and dimensions
may be unknown. Rank must be at least 1. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> frame_length
						</dt>
						<dd>The frame length in samples. An integer or scalar `Tensor`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> frame_step
						</dt>
						<dd>The frame hop size in samples. An integer or scalar `Tensor`. 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> pad_end
						</dt>
						<dd>Whether to pad the end of `signal` with `pad_value`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> pad_value
						</dt>
						<dd>An optional scalar `Tensor` to use where the input signal
does not exist when `pad_end` is True. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> axis
						</dt>
						<dd>A scalar integer `Tensor` indicating the axis to frame. Defaults to
the last axis. Supports negative values for indexing from the end. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of frames with shape `[..., frames, frame_length,...]`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>pcm = tf.compat.v1.placeholder(tf.float32, [None, 9152])
            frames = tf.signal.frame(pcm, 512, 180)
            magspec = tf.abs(tf.signal.rfft(frames, [512]))
            image = tf.expand_dims(magspec, 3) </pre>
</div>
		</div>
	</div>
	<div id="frame" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>frame</strong>(<span title="System.int">int</span> signal, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> frame_length, <span title="System.int">int</span> frame_step, <span title="System.bool">bool</span> pad_end, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> pad_value, <span title="System.int">int</span> axis, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Expands `signal`'s `axis` dimension into frames of `frame_length`. <p></p> Slides a window of size `frame_length` over `signal`'s `axis` dimension
with a stride of `frame_step`, replacing the `axis` dimension with
`[frames, frame_length]` frames. <p></p> If `pad_end` is True, window positions that are past the end of the `axis`
dimension are padded with `pad_value` until the window moves fully past the
end of the dimension. Otherwise, only window positions that fully overlap the
`axis` dimension are produced. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> signal
						</dt>
						<dd>A `[..., samples,...]` `Tensor`. The rank and dimensions
may be unknown. Rank must be at least 1. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> frame_length
						</dt>
						<dd>The frame length in samples. An integer or scalar `Tensor`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> frame_step
						</dt>
						<dd>The frame hop size in samples. An integer or scalar `Tensor`. 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> pad_end
						</dt>
						<dd>Whether to pad the end of `signal` with `pad_value`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> pad_value
						</dt>
						<dd>An optional scalar `Tensor` to use where the input signal
does not exist when `pad_end` is True. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> axis
						</dt>
						<dd>A scalar integer `Tensor` indicating the axis to frame. Defaults to
the last axis. Supports negative values for indexing from the end. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of frames with shape `[..., frames, frame_length,...]`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>pcm = tf.compat.v1.placeholder(tf.float32, [None, 9152])
            frames = tf.signal.frame(pcm, 512, 180)
            magspec = tf.abs(tf.signal.rfft(frames, [512]))
            image = tf.expand_dims(magspec, 3) </pre>
</div>
		</div>
	</div>
	<div id="frame" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>frame</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> signal, <span title="System.int">int</span> frame_length, <span title="System.int">int</span> frame_step, <span title="System.bool">bool</span> pad_end, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> pad_value, <span title="System.int">int</span> axis, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Expands `signal`'s `axis` dimension into frames of `frame_length`. <p></p> Slides a window of size `frame_length` over `signal`'s `axis` dimension
with a stride of `frame_step`, replacing the `axis` dimension with
`[frames, frame_length]` frames. <p></p> If `pad_end` is True, window positions that are past the end of the `axis`
dimension are padded with `pad_value` until the window moves fully past the
end of the dimension. Otherwise, only window positions that fully overlap the
`axis` dimension are produced. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> signal
						</dt>
						<dd>A `[..., samples,...]` `Tensor`. The rank and dimensions
may be unknown. Rank must be at least 1. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> frame_length
						</dt>
						<dd>The frame length in samples. An integer or scalar `Tensor`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> frame_step
						</dt>
						<dd>The frame hop size in samples. An integer or scalar `Tensor`. 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> pad_end
						</dt>
						<dd>Whether to pad the end of `signal` with `pad_value`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> pad_value
						</dt>
						<dd>An optional scalar `Tensor` to use where the input signal
does not exist when `pad_end` is True. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> axis
						</dt>
						<dd>A scalar integer `Tensor` indicating the axis to frame. Defaults to
the last axis. Supports negative values for indexing from the end. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of frames with shape `[..., frames, frame_length,...]`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>pcm = tf.compat.v1.placeholder(tf.float32, [None, 9152])
            frames = tf.signal.frame(pcm, 512, 180)
            magspec = tf.abs(tf.signal.rfft(frames, [512]))
            image = tf.expand_dims(magspec, 3) </pre>
</div>
		</div>
	</div>
	<div id="frame" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>frame</strong>(<span title="System.int">int</span> signal, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> frame_length, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> frame_step, <span title="System.bool">bool</span> pad_end, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> pad_value, <span title="System.int">int</span> axis, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Expands `signal`'s `axis` dimension into frames of `frame_length`. <p></p> Slides a window of size `frame_length` over `signal`'s `axis` dimension
with a stride of `frame_step`, replacing the `axis` dimension with
`[frames, frame_length]` frames. <p></p> If `pad_end` is True, window positions that are past the end of the `axis`
dimension are padded with `pad_value` until the window moves fully past the
end of the dimension. Otherwise, only window positions that fully overlap the
`axis` dimension are produced. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> signal
						</dt>
						<dd>A `[..., samples,...]` `Tensor`. The rank and dimensions
may be unknown. Rank must be at least 1. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> frame_length
						</dt>
						<dd>The frame length in samples. An integer or scalar `Tensor`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> frame_step
						</dt>
						<dd>The frame hop size in samples. An integer or scalar `Tensor`. 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> pad_end
						</dt>
						<dd>Whether to pad the end of `signal` with `pad_value`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> pad_value
						</dt>
						<dd>An optional scalar `Tensor` to use where the input signal
does not exist when `pad_end` is True. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> axis
						</dt>
						<dd>A scalar integer `Tensor` indicating the axis to frame. Defaults to
the last axis. Supports negative values for indexing from the end. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of frames with shape `[..., frames, frame_length,...]`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>pcm = tf.compat.v1.placeholder(tf.float32, [None, 9152])
            frames = tf.signal.frame(pcm, 512, 180)
            magspec = tf.abs(tf.signal.rfft(frames, [512]))
            image = tf.expand_dims(magspec, 3) </pre>
</div>
		</div>
	</div>
	<div id="frame" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>frame</strong>(<span title="System.int">int</span> signal, <span title="System.int">int</span> frame_length, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> frame_step, <span title="System.bool">bool</span> pad_end, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> pad_value, <span title="System.int">int</span> axis, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Expands `signal`'s `axis` dimension into frames of `frame_length`. <p></p> Slides a window of size `frame_length` over `signal`'s `axis` dimension
with a stride of `frame_step`, replacing the `axis` dimension with
`[frames, frame_length]` frames. <p></p> If `pad_end` is True, window positions that are past the end of the `axis`
dimension are padded with `pad_value` until the window moves fully past the
end of the dimension. Otherwise, only window positions that fully overlap the
`axis` dimension are produced. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> signal
						</dt>
						<dd>A `[..., samples,...]` `Tensor`. The rank and dimensions
may be unknown. Rank must be at least 1. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> frame_length
						</dt>
						<dd>The frame length in samples. An integer or scalar `Tensor`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> frame_step
						</dt>
						<dd>The frame hop size in samples. An integer or scalar `Tensor`. 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> pad_end
						</dt>
						<dd>Whether to pad the end of `signal` with `pad_value`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> pad_value
						</dt>
						<dd>An optional scalar `Tensor` to use where the input signal
does not exist when `pad_end` is True. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> axis
						</dt>
						<dd>A scalar integer `Tensor` indicating the axis to frame. Defaults to
the last axis. Supports negative values for indexing from the end. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of frames with shape `[..., frames, frame_length,...]`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>pcm = tf.compat.v1.placeholder(tf.float32, [None, 9152])
            frames = tf.signal.frame(pcm, 512, 180)
            magspec = tf.abs(tf.signal.rfft(frames, [512]))
            image = tf.expand_dims(magspec, 3) </pre>
</div>
		</div>
	</div>
	<div id="frame" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>frame</strong>(<span title="System.int">int</span> signal, <span title="System.int">int</span> frame_length, <span title="System.int">int</span> frame_step, <span title="System.bool">bool</span> pad_end, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> pad_value, <span title="System.int">int</span> axis, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Expands `signal`'s `axis` dimension into frames of `frame_length`. <p></p> Slides a window of size `frame_length` over `signal`'s `axis` dimension
with a stride of `frame_step`, replacing the `axis` dimension with
`[frames, frame_length]` frames. <p></p> If `pad_end` is True, window positions that are past the end of the `axis`
dimension are padded with `pad_value` until the window moves fully past the
end of the dimension. Otherwise, only window positions that fully overlap the
`axis` dimension are produced. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> signal
						</dt>
						<dd>A `[..., samples,...]` `Tensor`. The rank and dimensions
may be unknown. Rank must be at least 1. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> frame_length
						</dt>
						<dd>The frame length in samples. An integer or scalar `Tensor`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> frame_step
						</dt>
						<dd>The frame hop size in samples. An integer or scalar `Tensor`. 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> pad_end
						</dt>
						<dd>Whether to pad the end of `signal` with `pad_value`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> pad_value
						</dt>
						<dd>An optional scalar `Tensor` to use where the input signal
does not exist when `pad_end` is True. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> axis
						</dt>
						<dd>A scalar integer `Tensor` indicating the axis to frame. Defaults to
the last axis. Supports negative values for indexing from the end. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of frames with shape `[..., frames, frame_length,...]`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>pcm = tf.compat.v1.placeholder(tf.float32, [None, 9152])
            frames = tf.signal.frame(pcm, 512, 180)
            magspec = tf.abs(tf.signal.rfft(frames, [512]))
            image = tf.expand_dims(magspec, 3) </pre>
</div>
		</div>
	</div>
	<div id="frame" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>frame</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> signal, <span title="System.int">int</span> frame_length, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> frame_step, <span title="System.bool">bool</span> pad_end, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> pad_value, <span title="System.int">int</span> axis, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Expands `signal`'s `axis` dimension into frames of `frame_length`. <p></p> Slides a window of size `frame_length` over `signal`'s `axis` dimension
with a stride of `frame_step`, replacing the `axis` dimension with
`[frames, frame_length]` frames. <p></p> If `pad_end` is True, window positions that are past the end of the `axis`
dimension are padded with `pad_value` until the window moves fully past the
end of the dimension. Otherwise, only window positions that fully overlap the
`axis` dimension are produced. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> signal
						</dt>
						<dd>A `[..., samples,...]` `Tensor`. The rank and dimensions
may be unknown. Rank must be at least 1. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> frame_length
						</dt>
						<dd>The frame length in samples. An integer or scalar `Tensor`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> frame_step
						</dt>
						<dd>The frame hop size in samples. An integer or scalar `Tensor`. 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> pad_end
						</dt>
						<dd>Whether to pad the end of `signal` with `pad_value`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> pad_value
						</dt>
						<dd>An optional scalar `Tensor` to use where the input signal
does not exist when `pad_end` is True. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> axis
						</dt>
						<dd>A scalar integer `Tensor` indicating the axis to frame. Defaults to
the last axis. Supports negative values for indexing from the end. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of frames with shape `[..., frames, frame_length,...]`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>pcm = tf.compat.v1.placeholder(tf.float32, [None, 9152])
            frames = tf.signal.frame(pcm, 512, 180)
            magspec = tf.abs(tf.signal.rfft(frames, [512]))
            image = tf.expand_dims(magspec, 3) </pre>
</div>
		</div>
	</div>
	<div id="frame" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>frame</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> signal, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> frame_length, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> frame_step, <span title="System.bool">bool</span> pad_end, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> pad_value, <span title="System.int">int</span> axis, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Expands `signal`'s `axis` dimension into frames of `frame_length`. <p></p> Slides a window of size `frame_length` over `signal`'s `axis` dimension
with a stride of `frame_step`, replacing the `axis` dimension with
`[frames, frame_length]` frames. <p></p> If `pad_end` is True, window positions that are past the end of the `axis`
dimension are padded with `pad_value` until the window moves fully past the
end of the dimension. Otherwise, only window positions that fully overlap the
`axis` dimension are produced. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> signal
						</dt>
						<dd>A `[..., samples,...]` `Tensor`. The rank and dimensions
may be unknown. Rank must be at least 1. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> frame_length
						</dt>
						<dd>The frame length in samples. An integer or scalar `Tensor`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> frame_step
						</dt>
						<dd>The frame hop size in samples. An integer or scalar `Tensor`. 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> pad_end
						</dt>
						<dd>Whether to pad the end of `signal` with `pad_value`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> pad_value
						</dt>
						<dd>An optional scalar `Tensor` to use where the input signal
does not exist when `pad_end` is True. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> axis
						</dt>
						<dd>A scalar integer `Tensor` indicating the axis to frame. Defaults to
the last axis. Supports negative values for indexing from the end. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of frames with shape `[..., frames, frame_length,...]`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>pcm = tf.compat.v1.placeholder(tf.float32, [None, 9152])
            frames = tf.signal.frame(pcm, 512, 180)
            magspec = tf.abs(tf.signal.rfft(frames, [512]))
            image = tf.expand_dims(magspec, 3) </pre>
</div>
		</div>
	</div>
	<div id="frame" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>frame</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> signal, <span title="System.int">int</span> frame_length, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> frame_step, <span title="System.bool">bool</span> pad_end, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> pad_value, <span title="System.int">int</span> axis, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Expands `signal`'s `axis` dimension into frames of `frame_length`. <p></p> Slides a window of size `frame_length` over `signal`'s `axis` dimension
with a stride of `frame_step`, replacing the `axis` dimension with
`[frames, frame_length]` frames. <p></p> If `pad_end` is True, window positions that are past the end of the `axis`
dimension are padded with `pad_value` until the window moves fully past the
end of the dimension. Otherwise, only window positions that fully overlap the
`axis` dimension are produced. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> signal
						</dt>
						<dd>A `[..., samples,...]` `Tensor`. The rank and dimensions
may be unknown. Rank must be at least 1. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> frame_length
						</dt>
						<dd>The frame length in samples. An integer or scalar `Tensor`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> frame_step
						</dt>
						<dd>The frame hop size in samples. An integer or scalar `Tensor`. 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> pad_end
						</dt>
						<dd>Whether to pad the end of `signal` with `pad_value`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> pad_value
						</dt>
						<dd>An optional scalar `Tensor` to use where the input signal
does not exist when `pad_end` is True. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> axis
						</dt>
						<dd>A scalar integer `Tensor` indicating the axis to frame. Defaults to
the last axis. Supports negative values for indexing from the end. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of frames with shape `[..., frames, frame_length,...]`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>pcm = tf.compat.v1.placeholder(tf.float32, [None, 9152])
            frames = tf.signal.frame(pcm, 512, 180)
            magspec = tf.abs(tf.signal.rfft(frames, [512]))
            image = tf.expand_dims(magspec, 3) </pre>
</div>
		</div>
	</div>
	<div id="frame" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>frame</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> signal, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> frame_length, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> frame_step, <span title="System.bool">bool</span> pad_end, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> pad_value, <span title="System.int">int</span> axis, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Expands `signal`'s `axis` dimension into frames of `frame_length`. <p></p> Slides a window of size `frame_length` over `signal`'s `axis` dimension
with a stride of `frame_step`, replacing the `axis` dimension with
`[frames, frame_length]` frames. <p></p> If `pad_end` is True, window positions that are past the end of the `axis`
dimension are padded with `pad_value` until the window moves fully past the
end of the dimension. Otherwise, only window positions that fully overlap the
`axis` dimension are produced. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> signal
						</dt>
						<dd>A `[..., samples,...]` `Tensor`. The rank and dimensions
may be unknown. Rank must be at least 1. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> frame_length
						</dt>
						<dd>The frame length in samples. An integer or scalar `Tensor`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> frame_step
						</dt>
						<dd>The frame hop size in samples. An integer or scalar `Tensor`. 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> pad_end
						</dt>
						<dd>Whether to pad the end of `signal` with `pad_value`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> pad_value
						</dt>
						<dd>An optional scalar `Tensor` to use where the input signal
does not exist when `pad_end` is True. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> axis
						</dt>
						<dd>A scalar integer `Tensor` indicating the axis to frame. Defaults to
the last axis. Supports negative values for indexing from the end. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of frames with shape `[..., frames, frame_length,...]`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>pcm = tf.compat.v1.placeholder(tf.float32, [None, 9152])
            frames = tf.signal.frame(pcm, 512, 180)
            magspec = tf.abs(tf.signal.rfft(frames, [512]))
            image = tf.expand_dims(magspec, 3) </pre>
</div>
		</div>
	</div>
	<div id="frame" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>frame</strong>(<span title="System.int">int</span> signal, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> frame_length, <span title="System.int">int</span> frame_step, <span title="System.bool">bool</span> pad_end, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> pad_value, <span title="System.int">int</span> axis, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Expands `signal`'s `axis` dimension into frames of `frame_length`. <p></p> Slides a window of size `frame_length` over `signal`'s `axis` dimension
with a stride of `frame_step`, replacing the `axis` dimension with
`[frames, frame_length]` frames. <p></p> If `pad_end` is True, window positions that are past the end of the `axis`
dimension are padded with `pad_value` until the window moves fully past the
end of the dimension. Otherwise, only window positions that fully overlap the
`axis` dimension are produced. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> signal
						</dt>
						<dd>A `[..., samples,...]` `Tensor`. The rank and dimensions
may be unknown. Rank must be at least 1. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> frame_length
						</dt>
						<dd>The frame length in samples. An integer or scalar `Tensor`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> frame_step
						</dt>
						<dd>The frame hop size in samples. An integer or scalar `Tensor`. 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> pad_end
						</dt>
						<dd>Whether to pad the end of `signal` with `pad_value`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> pad_value
						</dt>
						<dd>An optional scalar `Tensor` to use where the input signal
does not exist when `pad_end` is True. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> axis
						</dt>
						<dd>A scalar integer `Tensor` indicating the axis to frame. Defaults to
the last axis. Supports negative values for indexing from the end. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of frames with shape `[..., frames, frame_length,...]`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>pcm = tf.compat.v1.placeholder(tf.float32, [None, 9152])
            frames = tf.signal.frame(pcm, 512, 180)
            magspec = tf.abs(tf.signal.rfft(frames, [512]))
            image = tf.expand_dims(magspec, 3) </pre>
</div>
		</div>
	</div>
	<div id="frame" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>frame</strong>(<span title="System.int">int</span> signal, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> frame_length, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> frame_step, <span title="System.bool">bool</span> pad_end, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> pad_value, <span title="System.int">int</span> axis, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Expands `signal`'s `axis` dimension into frames of `frame_length`. <p></p> Slides a window of size `frame_length` over `signal`'s `axis` dimension
with a stride of `frame_step`, replacing the `axis` dimension with
`[frames, frame_length]` frames. <p></p> If `pad_end` is True, window positions that are past the end of the `axis`
dimension are padded with `pad_value` until the window moves fully past the
end of the dimension. Otherwise, only window positions that fully overlap the
`axis` dimension are produced. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> signal
						</dt>
						<dd>A `[..., samples,...]` `Tensor`. The rank and dimensions
may be unknown. Rank must be at least 1. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> frame_length
						</dt>
						<dd>The frame length in samples. An integer or scalar `Tensor`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> frame_step
						</dt>
						<dd>The frame hop size in samples. An integer or scalar `Tensor`. 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> pad_end
						</dt>
						<dd>Whether to pad the end of `signal` with `pad_value`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> pad_value
						</dt>
						<dd>An optional scalar `Tensor` to use where the input signal
does not exist when `pad_end` is True. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> axis
						</dt>
						<dd>A scalar integer `Tensor` indicating the axis to frame. Defaults to
the last axis. Supports negative values for indexing from the end. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of frames with shape `[..., frames, frame_length,...]`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>pcm = tf.compat.v1.placeholder(tf.float32, [None, 9152])
            frames = tf.signal.frame(pcm, 512, 180)
            magspec = tf.abs(tf.signal.rfft(frames, [512]))
            image = tf.expand_dims(magspec, 3) </pre>
</div>
		</div>
	</div>
	<div id="frame" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>frame</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> signal, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> frame_length, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> frame_step, <span title="System.bool">bool</span> pad_end, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> pad_value, <span title="System.int">int</span> axis, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Expands `signal`'s `axis` dimension into frames of `frame_length`. <p></p> Slides a window of size `frame_length` over `signal`'s `axis` dimension
with a stride of `frame_step`, replacing the `axis` dimension with
`[frames, frame_length]` frames. <p></p> If `pad_end` is True, window positions that are past the end of the `axis`
dimension are padded with `pad_value` until the window moves fully past the
end of the dimension. Otherwise, only window positions that fully overlap the
`axis` dimension are produced. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> signal
						</dt>
						<dd>A `[..., samples,...]` `Tensor`. The rank and dimensions
may be unknown. Rank must be at least 1. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> frame_length
						</dt>
						<dd>The frame length in samples. An integer or scalar `Tensor`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> frame_step
						</dt>
						<dd>The frame hop size in samples. An integer or scalar `Tensor`. 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> pad_end
						</dt>
						<dd>Whether to pad the end of `signal` with `pad_value`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> pad_value
						</dt>
						<dd>An optional scalar `Tensor` to use where the input signal
does not exist when `pad_end` is True. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> axis
						</dt>
						<dd>A scalar integer `Tensor` indicating the axis to frame. Defaults to
the last axis. Supports negative values for indexing from the end. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of frames with shape `[..., frames, frame_length,...]`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>pcm = tf.compat.v1.placeholder(tf.float32, [None, 9152])
            frames = tf.signal.frame(pcm, 512, 180)
            magspec = tf.abs(tf.signal.rfft(frames, [512]))
            image = tf.expand_dims(magspec, 3) </pre>
</div>
		</div>
	</div>
	<div id="frame" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>frame</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> signal, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> frame_length, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> frame_step, <span title="System.bool">bool</span> pad_end, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> pad_value, <span title="System.int">int</span> axis, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Expands `signal`'s `axis` dimension into frames of `frame_length`. <p></p> Slides a window of size `frame_length` over `signal`'s `axis` dimension
with a stride of `frame_step`, replacing the `axis` dimension with
`[frames, frame_length]` frames. <p></p> If `pad_end` is True, window positions that are past the end of the `axis`
dimension are padded with `pad_value` until the window moves fully past the
end of the dimension. Otherwise, only window positions that fully overlap the
`axis` dimension are produced. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> signal
						</dt>
						<dd>A `[..., samples,...]` `Tensor`. The rank and dimensions
may be unknown. Rank must be at least 1. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> frame_length
						</dt>
						<dd>The frame length in samples. An integer or scalar `Tensor`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> frame_step
						</dt>
						<dd>The frame hop size in samples. An integer or scalar `Tensor`. 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> pad_end
						</dt>
						<dd>Whether to pad the end of `signal` with `pad_value`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> pad_value
						</dt>
						<dd>An optional scalar `Tensor` to use where the input signal
does not exist when `pad_end` is True. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> axis
						</dt>
						<dd>A scalar integer `Tensor` indicating the axis to frame. Defaults to
the last axis. Supports negative values for indexing from the end. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of frames with shape `[..., frames, frame_length,...]`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>pcm = tf.compat.v1.placeholder(tf.float32, [None, 9152])
            frames = tf.signal.frame(pcm, 512, 180)
            magspec = tf.abs(tf.signal.rfft(frames, [512]))
            image = tf.expand_dims(magspec, 3) </pre>
</div>
		</div>
	</div>
	<div id="frame" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>frame</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> signal, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> frame_length, <span title="System.int">int</span> frame_step, <span title="System.bool">bool</span> pad_end, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> pad_value, <span title="System.int">int</span> axis, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Expands `signal`'s `axis` dimension into frames of `frame_length`. <p></p> Slides a window of size `frame_length` over `signal`'s `axis` dimension
with a stride of `frame_step`, replacing the `axis` dimension with
`[frames, frame_length]` frames. <p></p> If `pad_end` is True, window positions that are past the end of the `axis`
dimension are padded with `pad_value` until the window moves fully past the
end of the dimension. Otherwise, only window positions that fully overlap the
`axis` dimension are produced. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> signal
						</dt>
						<dd>A `[..., samples,...]` `Tensor`. The rank and dimensions
may be unknown. Rank must be at least 1. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> frame_length
						</dt>
						<dd>The frame length in samples. An integer or scalar `Tensor`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> frame_step
						</dt>
						<dd>The frame hop size in samples. An integer or scalar `Tensor`. 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> pad_end
						</dt>
						<dd>Whether to pad the end of `signal` with `pad_value`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> pad_value
						</dt>
						<dd>An optional scalar `Tensor` to use where the input signal
does not exist when `pad_end` is True. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> axis
						</dt>
						<dd>A scalar integer `Tensor` indicating the axis to frame. Defaults to
the last axis. Supports negative values for indexing from the end. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of frames with shape `[..., frames, frame_length,...]`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>pcm = tf.compat.v1.placeholder(tf.float32, [None, 9152])
            frames = tf.signal.frame(pcm, 512, 180)
            magspec = tf.abs(tf.signal.rfft(frames, [512]))
            image = tf.expand_dims(magspec, 3) </pre>
</div>
		</div>
	</div>
	<div id="frame" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>frame</strong>(<span title="System.int">int</span> signal, <span title="System.int">int</span> frame_length, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> frame_step, <span title="System.bool">bool</span> pad_end, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> pad_value, <span title="System.int">int</span> axis, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Expands `signal`'s `axis` dimension into frames of `frame_length`. <p></p> Slides a window of size `frame_length` over `signal`'s `axis` dimension
with a stride of `frame_step`, replacing the `axis` dimension with
`[frames, frame_length]` frames. <p></p> If `pad_end` is True, window positions that are past the end of the `axis`
dimension are padded with `pad_value` until the window moves fully past the
end of the dimension. Otherwise, only window positions that fully overlap the
`axis` dimension are produced. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> signal
						</dt>
						<dd>A `[..., samples,...]` `Tensor`. The rank and dimensions
may be unknown. Rank must be at least 1. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> frame_length
						</dt>
						<dd>The frame length in samples. An integer or scalar `Tensor`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> frame_step
						</dt>
						<dd>The frame hop size in samples. An integer or scalar `Tensor`. 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> pad_end
						</dt>
						<dd>Whether to pad the end of `signal` with `pad_value`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> pad_value
						</dt>
						<dd>An optional scalar `Tensor` to use where the input signal
does not exist when `pad_end` is True. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> axis
						</dt>
						<dd>A scalar integer `Tensor` indicating the axis to frame. Defaults to
the last axis. Supports negative values for indexing from the end. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of frames with shape `[..., frames, frame_length,...]`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>pcm = tf.compat.v1.placeholder(tf.float32, [None, 9152])
            frames = tf.signal.frame(pcm, 512, 180)
            magspec = tf.abs(tf.signal.rfft(frames, [512]))
            image = tf.expand_dims(magspec, 3) </pre>
</div>
		</div>
	</div>
	<div id="frame" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>frame</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> signal, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> frame_length, <span title="System.int">int</span> frame_step, <span title="System.bool">bool</span> pad_end, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> pad_value, <span title="System.int">int</span> axis, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Expands `signal`'s `axis` dimension into frames of `frame_length`. <p></p> Slides a window of size `frame_length` over `signal`'s `axis` dimension
with a stride of `frame_step`, replacing the `axis` dimension with
`[frames, frame_length]` frames. <p></p> If `pad_end` is True, window positions that are past the end of the `axis`
dimension are padded with `pad_value` until the window moves fully past the
end of the dimension. Otherwise, only window positions that fully overlap the
`axis` dimension are produced. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> signal
						</dt>
						<dd>A `[..., samples,...]` `Tensor`. The rank and dimensions
may be unknown. Rank must be at least 1. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> frame_length
						</dt>
						<dd>The frame length in samples. An integer or scalar `Tensor`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> frame_step
						</dt>
						<dd>The frame hop size in samples. An integer or scalar `Tensor`. 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> pad_end
						</dt>
						<dd>Whether to pad the end of `signal` with `pad_value`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> pad_value
						</dt>
						<dd>An optional scalar `Tensor` to use where the input signal
does not exist when `pad_end` is True. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> axis
						</dt>
						<dd>A scalar integer `Tensor` indicating the axis to frame. Defaults to
the last axis. Supports negative values for indexing from the end. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of frames with shape `[..., frames, frame_length,...]`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>pcm = tf.compat.v1.placeholder(tf.float32, [None, 9152])
            frames = tf.signal.frame(pcm, 512, 180)
            magspec = tf.abs(tf.signal.rfft(frames, [512]))
            image = tf.expand_dims(magspec, 3) </pre>
</div>
		</div>
	</div>
	<div id="frame_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>frame_dyn</strong>(<span title="System.object">object</span> signal, <span title="System.object">object</span> frame_length, <span title="System.object">object</span> frame_step, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> pad_end, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> pad_value, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> axis, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Expands `signal`'s `axis` dimension into frames of `frame_length`. <p></p> Slides a window of size `frame_length` over `signal`'s `axis` dimension
with a stride of `frame_step`, replacing the `axis` dimension with
`[frames, frame_length]` frames. <p></p> If `pad_end` is True, window positions that are past the end of the `axis`
dimension are padded with `pad_value` until the window moves fully past the
end of the dimension. Otherwise, only window positions that fully overlap the
`axis` dimension are produced. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> signal
						</dt>
						<dd>A `[..., samples,...]` `Tensor`. The rank and dimensions
may be unknown. Rank must be at least 1. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> frame_length
						</dt>
						<dd>The frame length in samples. An integer or scalar `Tensor`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> frame_step
						</dt>
						<dd>The frame hop size in samples. An integer or scalar `Tensor`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> pad_end
						</dt>
						<dd>Whether to pad the end of `signal` with `pad_value`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> pad_value
						</dt>
						<dd>An optional scalar `Tensor` to use where the input signal
does not exist when `pad_end` is True. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> axis
						</dt>
						<dd>A scalar integer `Tensor` indicating the axis to frame. Defaults to
the last axis. Supports negative values for indexing from the end. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `Tensor` of frames with shape `[..., frames, frame_length,...]`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>pcm = tf.compat.v1.placeholder(tf.float32, [None, 9152])
            frames = tf.signal.frame(pcm, 512, 180)
            magspec = tf.abs(tf.signal.rfft(frames, [512]))
            image = tf.expand_dims(magspec, 3) </pre>
</div>
		</div>
	</div>
	<div id="hamming_window" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>hamming_window</strong>(<span title="System.int">int</span> window_length, <span title="System.bool">bool</span> periodic, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> dtype, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Generate a [Hamming][hamming] window. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> window_length
						</dt>
						<dd>A scalar `Tensor` indicating the window length to generate. 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> periodic
						</dt>
						<dd>A bool `Tensor` indicating whether to generate a periodic or
symmetric window. Periodic windows are typically used for spectral
analysis while symmetric windows are typically used for digital
filter design. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> dtype
						</dt>
						<dd>The data type to produce. Must be a floating point type. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of shape `[window_length]` of type `dtype`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="hamming_window_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>hamming_window_dyn</strong>(<span title="System.object">object</span> window_length, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> periodic, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> dtype, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Generate a [Hamming][hamming] window. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> window_length
						</dt>
						<dd>A scalar `Tensor` indicating the window length to generate. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> periodic
						</dt>
						<dd>A bool `Tensor` indicating whether to generate a periodic or
symmetric window. Periodic windows are typically used for spectral
analysis while symmetric windows are typically used for digital
filter design. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> dtype
						</dt>
						<dd>The data type to produce. Must be a floating point type. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `Tensor` of shape `[window_length]` of type `dtype`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="hann_window" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>hann_window</strong>(<span title="System.int">int</span> window_length, <span title="System.bool">bool</span> periodic, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> dtype, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Generate a [Hann window][hann]. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> window_length
						</dt>
						<dd>A scalar `Tensor` indicating the window length to generate. 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> periodic
						</dt>
						<dd>A bool `Tensor` indicating whether to generate a periodic or
symmetric window. Periodic windows are typically used for spectral
analysis while symmetric windows are typically used for digital
filter design. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> dtype
						</dt>
						<dd>The data type to produce. Must be a floating point type. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of shape `[window_length]` of type `dtype`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="hann_window" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>hann_window</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> window_length, <span title="System.bool">bool</span> periodic, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> dtype, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Generate a [Hann window][hann]. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> window_length
						</dt>
						<dd>A scalar `Tensor` indicating the window length to generate. 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> periodic
						</dt>
						<dd>A bool `Tensor` indicating whether to generate a periodic or
symmetric window. Periodic windows are typically used for spectral
analysis while symmetric windows are typically used for digital
filter design. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> dtype
						</dt>
						<dd>The data type to produce. Must be a floating point type. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of shape `[window_length]` of type `dtype`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="hann_window_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>hann_window_dyn</strong>(<span title="System.object">object</span> window_length, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> periodic, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> dtype, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Generate a [Hann window][hann]. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> window_length
						</dt>
						<dd>A scalar `Tensor` indicating the window length to generate. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> periodic
						</dt>
						<dd>A bool `Tensor` indicating whether to generate a periodic or
symmetric window. Periodic windows are typically used for spectral
analysis while symmetric windows are typically used for digital
filter design. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> dtype
						</dt>
						<dd>The data type to produce. Must be a floating point type. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `Tensor` of shape `[window_length]` of type `dtype`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="idct" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>idct</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> input, <span title="System.int">int</span> type, <span title="System.object">object</span> n, <span title="System.int">int</span> axis, <span title="System.string">string</span> norm, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the 1D [Inverse Discrete Cosine Transform (DCT)][idct] of `input`. <p></p> Currently only Types I, II and III are supported. Type III is the inverse of
Type II, and vice versa. <p></p> Note that you must re-normalize by 1/(2n) to obtain an inverse if `norm` is
not `'ortho'`. That is:
`signal == idct(dct(signal)) * 0.5 / signal.shape[-1]`.
When `norm='ortho'`, we have:
`signal == idct(dct(signal, norm='ortho'), norm='ortho')`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> input
						</dt>
						<dd>A `[..., samples]` `float32` `Tensor` containing the signals to take
the DCT of. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> type
						</dt>
						<dd>The IDCT type to perform. Must be 1, 2 or 3. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> n
						</dt>
						<dd>For future expansion. The length of the transform. Must be `None`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> axis
						</dt>
						<dd>For future expansion. The axis to compute the DCT along. Must be `-1`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> norm
						</dt>
						<dd>The normalization to apply. `None` for no normalization or `'ortho'`
for orthonormal normalization. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `[..., samples]` `float32` `Tensor` containing the IDCT of `input`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="idct" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>idct</strong>(<span title="System.object">object</span> input, <span title="System.int">int</span> type, <span title="System.object">object</span> n, <span title="System.int">int</span> axis, <span title="System.string">string</span> norm, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the 1D [Inverse Discrete Cosine Transform (DCT)][idct] of `input`. <p></p> Currently only Types I, II and III are supported. Type III is the inverse of
Type II, and vice versa. <p></p> Note that you must re-normalize by 1/(2n) to obtain an inverse if `norm` is
not `'ortho'`. That is:
`signal == idct(dct(signal)) * 0.5 / signal.shape[-1]`.
When `norm='ortho'`, we have:
`signal == idct(dct(signal, norm='ortho'), norm='ortho')`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> input
						</dt>
						<dd>A `[..., samples]` `float32` `Tensor` containing the signals to take
the DCT of. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> type
						</dt>
						<dd>The IDCT type to perform. Must be 1, 2 or 3. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> n
						</dt>
						<dd>For future expansion. The length of the transform. Must be `None`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> axis
						</dt>
						<dd>For future expansion. The axis to compute the DCT along. Must be `-1`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> norm
						</dt>
						<dd>The normalization to apply. `None` for no normalization or `'ortho'`
for orthonormal normalization. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `[..., samples]` `float32` `Tensor` containing the IDCT of `input`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="idct_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>idct_dyn</strong>(<span title="System.object">object</span> input, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> type, <span title="System.object">object</span> n, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> axis, <span title="System.object">object</span> norm, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Computes the 1D [Inverse Discrete Cosine Transform (DCT)][idct] of `input`. <p></p> Currently only Types I, II and III are supported. Type III is the inverse of
Type II, and vice versa. <p></p> Note that you must re-normalize by 1/(2n) to obtain an inverse if `norm` is
not `'ortho'`. That is:
`signal == idct(dct(signal)) * 0.5 / signal.shape[-1]`.
When `norm='ortho'`, we have:
`signal == idct(dct(signal, norm='ortho'), norm='ortho')`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> input
						</dt>
						<dd>A `[..., samples]` `float32` `Tensor` containing the signals to take
the DCT of. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> type
						</dt>
						<dd>The IDCT type to perform. Must be 1, 2 or 3. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> n
						</dt>
						<dd>For future expansion. The length of the transform. Must be `None`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> axis
						</dt>
						<dd>For future expansion. The axis to compute the DCT along. Must be `-1`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> norm
						</dt>
						<dd>The normalization to apply. `None` for no normalization or `'ortho'`
for orthonormal normalization. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `[..., samples]` `float32` `Tensor` containing the IDCT of `input`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="ifftshift" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>ifftshift</strong>(<span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> x, <span title="System.int">int</span> axes, <span title="System.string">string</span> name)
		</h4>
		<div class="content">The inverse of fftshift. <p></p> Although identical for even-length x,
the functions differ by one sample for odd-length x. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> x
						</dt>
						<dd>`Tensor`, input tensor. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> axes
						</dt>
						<dd>`int` or shape `tuple` Axes over which to calculate. Defaults to None,
which shifts all axes. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor`, The shifted tensor. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>x = tf.signal.ifftshift([[ 0.,  1.,  2.],[ 3.,  4., -4.],[-3., -2., -1.]])
            x.numpy() # array([[ 4., -4.,  3.],[-2., -1., -3.],[ 1.,  2.,  0.]]) </pre>
</div>
		</div>
	</div>
	<div id="ifftshift" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>ifftshift</strong>(<span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> x, <span title="System.Nullable<ValueTuple<int, int>>">Nullable&lt;ValueTuple&lt;int, int&gt;&gt;</span> axes, <span title="System.string">string</span> name)
		</h4>
		<div class="content">The inverse of fftshift. <p></p> Although identical for even-length x,
the functions differ by one sample for odd-length x. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> x
						</dt>
						<dd>`Tensor`, input tensor. 
						</dd>
						<dt>
							<code><span title="System.Nullable<ValueTuple<int, int>>">Nullable&lt;ValueTuple&lt;int, int&gt;&gt;</span></code> axes
						</dt>
						<dd>`int` or shape `tuple` Axes over which to calculate. Defaults to None,
which shifts all axes. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor`, The shifted tensor. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>x = tf.signal.ifftshift([[ 0.,  1.,  2.],[ 3.,  4., -4.],[-3., -2., -1.]])
            x.numpy() # array([[ 4., -4.,  3.],[-2., -1., -3.],[ 1.,  2.,  0.]]) </pre>
</div>
		</div>
	</div>
	<div id="ifftshift_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>ifftshift_dyn</strong>(<span title="System.object">object</span> x, <span title="System.object">object</span> axes, <span title="System.object">object</span> name)
		</h4>
		<div class="content">The inverse of fftshift. <p></p> Although identical for even-length x,
the functions differ by one sample for odd-length x. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> x
						</dt>
						<dd>`Tensor`, input tensor. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> axes
						</dt>
						<dd>`int` or shape `tuple` Axes over which to calculate. Defaults to None,
which shifts all axes. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `Tensor`, The shifted tensor. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>x = tf.signal.ifftshift([[ 0.,  1.,  2.],[ 3.,  4., -4.],[-3., -2., -1.]])
            x.numpy() # array([[ 4., -4.,  3.],[-2., -1., -3.],[ 1.,  2.,  0.]]) </pre>
</div>
		</div>
	</div>
	<div id="inverse_stft" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>inverse_stft</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> stfts, <span title="System.int">int</span> frame_length, <span title="System.int">int</span> frame_step, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> fft_length, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> window_fn, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the inverse [Short-time Fourier Transform][stft] of `stfts`. <p></p> To reconstruct an original waveform, a complimentary window function should
be used in inverse_stft. Such a window function can be constructed with
tf.signal.inverse_stft_window_fn. <p></p> Example:
if a custom window_fn is used in stft, it must be passed to
inverse_stft_window_fn:
Implemented with GPU-compatible ops and supports gradients. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> stfts
						</dt>
						<dd>A `complex64` `[..., frames, fft_unique_bins]` `Tensor` of STFT bins
representing a batch of `fft_length`-point STFTs where `fft_unique_bins`
is `fft_length // 2 + 1` 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> frame_length
						</dt>
						<dd>An integer scalar `Tensor`. The window length in samples. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> frame_step
						</dt>
						<dd>An integer scalar `Tensor`. The number of samples to step. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> fft_length
						</dt>
						<dd>An integer scalar `Tensor`. The size of the FFT that produced
`stfts`. If not provided, uses the smallest power of 2 enclosing
`frame_length`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> window_fn
						</dt>
						<dd>A callable that takes a window length and a `dtype` keyword
argument and returns a `[window_length]` `Tensor` of samples in the
provided datatype. If set to `None`, no windowing is used. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `[..., samples]` `Tensor` of `float32` signals representing the inverse
STFT for each input STFT in `stfts`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>frame_length = 400
            frame_step = 160
            waveform = tf.compat.v1.placeholder(dtype=tf.float32, shape=[1000])
            stft = tf.signal.stft(waveform, frame_length, frame_step)
            inverse_stft = tf.signal.inverse_stft(
                stft, frame_length, frame_step,
                window_fn=tf.signal.inverse_stft_window_fn(frame_step)) </pre>
</div>
		</div>
	</div>
	<div id="inverse_stft_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>inverse_stft_dyn</strong>(<span title="System.object">object</span> stfts, <span title="System.object">object</span> frame_length, <span title="System.object">object</span> frame_step, <span title="System.object">object</span> fft_length, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> window_fn, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Computes the inverse [Short-time Fourier Transform][stft] of `stfts`. <p></p> To reconstruct an original waveform, a complimentary window function should
be used in inverse_stft. Such a window function can be constructed with
tf.signal.inverse_stft_window_fn. <p></p> Example:
if a custom window_fn is used in stft, it must be passed to
inverse_stft_window_fn:
Implemented with GPU-compatible ops and supports gradients. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> stfts
						</dt>
						<dd>A `complex64` `[..., frames, fft_unique_bins]` `Tensor` of STFT bins
representing a batch of `fft_length`-point STFTs where `fft_unique_bins`
is `fft_length // 2 + 1` 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> frame_length
						</dt>
						<dd>An integer scalar `Tensor`. The window length in samples. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> frame_step
						</dt>
						<dd>An integer scalar `Tensor`. The number of samples to step. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> fft_length
						</dt>
						<dd>An integer scalar `Tensor`. The size of the FFT that produced
`stfts`. If not provided, uses the smallest power of 2 enclosing
`frame_length`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> window_fn
						</dt>
						<dd>A callable that takes a window length and a `dtype` keyword
argument and returns a `[window_length]` `Tensor` of samples in the
provided datatype. If set to `None`, no windowing is used. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `[..., samples]` `Tensor` of `float32` signals representing the inverse
STFT for each input STFT in `stfts`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>frame_length = 400
            frame_step = 160
            waveform = tf.compat.v1.placeholder(dtype=tf.float32, shape=[1000])
            stft = tf.signal.stft(waveform, frame_length, frame_step)
            inverse_stft = tf.signal.inverse_stft(
                stft, frame_length, frame_step,
                window_fn=tf.signal.inverse_stft_window_fn(frame_step)) </pre>
</div>
		</div>
	</div>
	<div id="inverse_stft_window_fn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>inverse_stft_window_fn</strong>(<span title="System.int">int</span> frame_step, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> forward_window_fn, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Generates a window function that can be used in `inverse_stft`. <p></p> Constructs a window that is equal to the forward window with a further
pointwise amplitude correction.  `inverse_stft_window_fn` is equivalent to
`forward_window_fn` in the case where it would produce an exact inverse. <p></p> See examples in `inverse_stft` documentation for usage. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> frame_step
						</dt>
						<dd>An integer scalar `Tensor`. The number of samples to step. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> forward_window_fn
						</dt>
						<dd>window_fn used in the forward transform, `stft`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A callable that takes a window length and a `dtype` keyword argument and
returns a `[window_length]` `Tensor` of samples in the provided datatype.
The returned window is suitable for reconstructing original waveform in
inverse_stft. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="inverse_stft_window_fn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>inverse_stft_window_fn</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> frame_step, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> forward_window_fn, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Generates a window function that can be used in `inverse_stft`. <p></p> Constructs a window that is equal to the forward window with a further
pointwise amplitude correction.  `inverse_stft_window_fn` is equivalent to
`forward_window_fn` in the case where it would produce an exact inverse. <p></p> See examples in `inverse_stft` documentation for usage. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> frame_step
						</dt>
						<dd>An integer scalar `Tensor`. The number of samples to step. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> forward_window_fn
						</dt>
						<dd>window_fn used in the forward transform, `stft`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A callable that takes a window length and a `dtype` keyword argument and
returns a `[window_length]` `Tensor` of samples in the provided datatype.
The returned window is suitable for reconstructing original waveform in
inverse_stft. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="inverse_stft_window_fn_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>inverse_stft_window_fn_dyn</strong>(<span title="System.object">object</span> frame_step, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> forward_window_fn, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Generates a window function that can be used in `inverse_stft`. <p></p> Constructs a window that is equal to the forward window with a further
pointwise amplitude correction.  `inverse_stft_window_fn` is equivalent to
`forward_window_fn` in the case where it would produce an exact inverse. <p></p> See examples in `inverse_stft` documentation for usage. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> frame_step
						</dt>
						<dd>An integer scalar `Tensor`. The number of samples to step. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> forward_window_fn
						</dt>
						<dd>window_fn used in the forward transform, `stft`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A callable that takes a window length and a `dtype` keyword argument and
returns a `[window_length]` `Tensor` of samples in the provided datatype.
The returned window is suitable for reconstructing original waveform in
inverse_stft. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="linear_to_mel_weight_matrix" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>linear_to_mel_weight_matrix</strong>(<span title="System.int">int</span> num_mel_bins, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> num_spectrogram_bins, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> sample_rate, <span title="System.int">int</span> lower_edge_hertz, <span title="System.int">int</span> upper_edge_hertz, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> dtype, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Returns a matrix to warp linear scale spectrograms to the [mel scale][mel]. <p></p> Returns a weight matrix that can be used to re-weight a `Tensor` containing
`num_spectrogram_bins` linearly sampled frequency information from
`[0, sample_rate / 2]` into `num_mel_bins` frequency information from
`[lower_edge_hertz, upper_edge_hertz]` on the [mel scale][mel]. <p></p> For example, the returned matrix `A` can be used to right-multiply a
spectrogram `S` of shape `[frames, num_spectrogram_bins]` of linear
scale spectrum values (e.g. STFT magnitudes) to generate a "mel spectrogram"
`M` of shape `[frames, num_mel_bins]`. <p></p> # `S` has shape [frames, num_spectrogram_bins]
# `M` has shape [frames, num_mel_bins]
M = tf.matmul(S, A) <p></p> The matrix can be used with <a href="..\..\tf\tensordot.md"><code>tf.tensordot</code></a> to convert an arbitrary rank
`Tensor` of linear-scale spectral bins into the mel scale. <p></p> # S has shape [..., num_spectrogram_bins].
# M has shape [..., num_mel_bins].
M = tf.tensordot(S, A, 1)
# tf.tensordot does not support shape inference for this case yet.
M.set_shape(S.shape[:-1].concatenate(A.shape[-1:])) 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> num_mel_bins
						</dt>
						<dd>Python int. How many bands in the resulting mel spectrum. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> num_spectrogram_bins
						</dt>
						<dd>An integer `Tensor`. How many bins there are in the
source spectrogram data, which is understood to be `fft_size // 2 + 1`,
i.e. the spectrogram only contains the nonredundant FFT bins. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> sample_rate
						</dt>
						<dd>Python float. Samples per second of the input signal used to
create the spectrogram. We need this to figure out the actual frequencies
for each spectrogram bin, which dictates how they are mapped into the mel
scale. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> lower_edge_hertz
						</dt>
						<dd>Python float. Lower bound on the frequencies to be
included in the mel spectrum. This corresponds to the lower edge of the
lowest triangular band. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> upper_edge_hertz
						</dt>
						<dd>Python float. The desired top edge of the highest
frequency band. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> dtype
						</dt>
						<dd>The `DType` of the result matrix. Must be a floating point type. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of shape `[num_spectrogram_bins, num_mel_bins]`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="linear_to_mel_weight_matrix" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>linear_to_mel_weight_matrix</strong>(<span title="System.int">int</span> num_mel_bins, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> num_spectrogram_bins, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> sample_rate, <span title="System.int">int</span> lower_edge_hertz, <span title="System.double">double</span> upper_edge_hertz, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> dtype, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Returns a matrix to warp linear scale spectrograms to the [mel scale][mel]. <p></p> Returns a weight matrix that can be used to re-weight a `Tensor` containing
`num_spectrogram_bins` linearly sampled frequency information from
`[0, sample_rate / 2]` into `num_mel_bins` frequency information from
`[lower_edge_hertz, upper_edge_hertz]` on the [mel scale][mel]. <p></p> For example, the returned matrix `A` can be used to right-multiply a
spectrogram `S` of shape `[frames, num_spectrogram_bins]` of linear
scale spectrum values (e.g. STFT magnitudes) to generate a "mel spectrogram"
`M` of shape `[frames, num_mel_bins]`. <p></p> # `S` has shape [frames, num_spectrogram_bins]
# `M` has shape [frames, num_mel_bins]
M = tf.matmul(S, A) <p></p> The matrix can be used with <a href="..\..\tf\tensordot.md"><code>tf.tensordot</code></a> to convert an arbitrary rank
`Tensor` of linear-scale spectral bins into the mel scale. <p></p> # S has shape [..., num_spectrogram_bins].
# M has shape [..., num_mel_bins].
M = tf.tensordot(S, A, 1)
# tf.tensordot does not support shape inference for this case yet.
M.set_shape(S.shape[:-1].concatenate(A.shape[-1:])) 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> num_mel_bins
						</dt>
						<dd>Python int. How many bands in the resulting mel spectrum. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> num_spectrogram_bins
						</dt>
						<dd>An integer `Tensor`. How many bins there are in the
source spectrogram data, which is understood to be `fft_size // 2 + 1`,
i.e. the spectrogram only contains the nonredundant FFT bins. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> sample_rate
						</dt>
						<dd>Python float. Samples per second of the input signal used to
create the spectrogram. We need this to figure out the actual frequencies
for each spectrogram bin, which dictates how they are mapped into the mel
scale. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> lower_edge_hertz
						</dt>
						<dd>Python float. Lower bound on the frequencies to be
included in the mel spectrum. This corresponds to the lower edge of the
lowest triangular band. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> upper_edge_hertz
						</dt>
						<dd>Python float. The desired top edge of the highest
frequency band. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> dtype
						</dt>
						<dd>The `DType` of the result matrix. Must be a floating point type. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of shape `[num_spectrogram_bins, num_mel_bins]`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="linear_to_mel_weight_matrix" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>linear_to_mel_weight_matrix</strong>(<span title="System.int">int</span> num_mel_bins, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> num_spectrogram_bins, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> sample_rate, <span title="System.double">double</span> lower_edge_hertz, <span title="System.int">int</span> upper_edge_hertz, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> dtype, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Returns a matrix to warp linear scale spectrograms to the [mel scale][mel]. <p></p> Returns a weight matrix that can be used to re-weight a `Tensor` containing
`num_spectrogram_bins` linearly sampled frequency information from
`[0, sample_rate / 2]` into `num_mel_bins` frequency information from
`[lower_edge_hertz, upper_edge_hertz]` on the [mel scale][mel]. <p></p> For example, the returned matrix `A` can be used to right-multiply a
spectrogram `S` of shape `[frames, num_spectrogram_bins]` of linear
scale spectrum values (e.g. STFT magnitudes) to generate a "mel spectrogram"
`M` of shape `[frames, num_mel_bins]`. <p></p> # `S` has shape [frames, num_spectrogram_bins]
# `M` has shape [frames, num_mel_bins]
M = tf.matmul(S, A) <p></p> The matrix can be used with <a href="..\..\tf\tensordot.md"><code>tf.tensordot</code></a> to convert an arbitrary rank
`Tensor` of linear-scale spectral bins into the mel scale. <p></p> # S has shape [..., num_spectrogram_bins].
# M has shape [..., num_mel_bins].
M = tf.tensordot(S, A, 1)
# tf.tensordot does not support shape inference for this case yet.
M.set_shape(S.shape[:-1].concatenate(A.shape[-1:])) 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> num_mel_bins
						</dt>
						<dd>Python int. How many bands in the resulting mel spectrum. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> num_spectrogram_bins
						</dt>
						<dd>An integer `Tensor`. How many bins there are in the
source spectrogram data, which is understood to be `fft_size // 2 + 1`,
i.e. the spectrogram only contains the nonredundant FFT bins. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> sample_rate
						</dt>
						<dd>Python float. Samples per second of the input signal used to
create the spectrogram. We need this to figure out the actual frequencies
for each spectrogram bin, which dictates how they are mapped into the mel
scale. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> lower_edge_hertz
						</dt>
						<dd>Python float. Lower bound on the frequencies to be
included in the mel spectrum. This corresponds to the lower edge of the
lowest triangular band. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> upper_edge_hertz
						</dt>
						<dd>Python float. The desired top edge of the highest
frequency band. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> dtype
						</dt>
						<dd>The `DType` of the result matrix. Must be a floating point type. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of shape `[num_spectrogram_bins, num_mel_bins]`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="linear_to_mel_weight_matrix" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>linear_to_mel_weight_matrix</strong>(<span title="System.int">int</span> num_mel_bins, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> num_spectrogram_bins, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> sample_rate, <span title="System.double">double</span> lower_edge_hertz, <span title="System.double">double</span> upper_edge_hertz, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> dtype, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Returns a matrix to warp linear scale spectrograms to the [mel scale][mel]. <p></p> Returns a weight matrix that can be used to re-weight a `Tensor` containing
`num_spectrogram_bins` linearly sampled frequency information from
`[0, sample_rate / 2]` into `num_mel_bins` frequency information from
`[lower_edge_hertz, upper_edge_hertz]` on the [mel scale][mel]. <p></p> For example, the returned matrix `A` can be used to right-multiply a
spectrogram `S` of shape `[frames, num_spectrogram_bins]` of linear
scale spectrum values (e.g. STFT magnitudes) to generate a "mel spectrogram"
`M` of shape `[frames, num_mel_bins]`. <p></p> # `S` has shape [frames, num_spectrogram_bins]
# `M` has shape [frames, num_mel_bins]
M = tf.matmul(S, A) <p></p> The matrix can be used with <a href="..\..\tf\tensordot.md"><code>tf.tensordot</code></a> to convert an arbitrary rank
`Tensor` of linear-scale spectral bins into the mel scale. <p></p> # S has shape [..., num_spectrogram_bins].
# M has shape [..., num_mel_bins].
M = tf.tensordot(S, A, 1)
# tf.tensordot does not support shape inference for this case yet.
M.set_shape(S.shape[:-1].concatenate(A.shape[-1:])) 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> num_mel_bins
						</dt>
						<dd>Python int. How many bands in the resulting mel spectrum. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> num_spectrogram_bins
						</dt>
						<dd>An integer `Tensor`. How many bins there are in the
source spectrogram data, which is understood to be `fft_size // 2 + 1`,
i.e. the spectrogram only contains the nonredundant FFT bins. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> sample_rate
						</dt>
						<dd>Python float. Samples per second of the input signal used to
create the spectrogram. We need this to figure out the actual frequencies
for each spectrogram bin, which dictates how they are mapped into the mel
scale. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> lower_edge_hertz
						</dt>
						<dd>Python float. Lower bound on the frequencies to be
included in the mel spectrum. This corresponds to the lower edge of the
lowest triangular band. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> upper_edge_hertz
						</dt>
						<dd>Python float. The desired top edge of the highest
frequency band. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> dtype
						</dt>
						<dd>The `DType` of the result matrix. Must be a floating point type. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of shape `[num_spectrogram_bins, num_mel_bins]`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="linear_to_mel_weight_matrix" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>linear_to_mel_weight_matrix</strong>(<span title="System.int">int</span> num_mel_bins, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> num_spectrogram_bins, <span title="System.int">int</span> sample_rate, <span title="System.int">int</span> lower_edge_hertz, <span title="System.int">int</span> upper_edge_hertz, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> dtype, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Returns a matrix to warp linear scale spectrograms to the [mel scale][mel]. <p></p> Returns a weight matrix that can be used to re-weight a `Tensor` containing
`num_spectrogram_bins` linearly sampled frequency information from
`[0, sample_rate / 2]` into `num_mel_bins` frequency information from
`[lower_edge_hertz, upper_edge_hertz]` on the [mel scale][mel]. <p></p> For example, the returned matrix `A` can be used to right-multiply a
spectrogram `S` of shape `[frames, num_spectrogram_bins]` of linear
scale spectrum values (e.g. STFT magnitudes) to generate a "mel spectrogram"
`M` of shape `[frames, num_mel_bins]`. <p></p> # `S` has shape [frames, num_spectrogram_bins]
# `M` has shape [frames, num_mel_bins]
M = tf.matmul(S, A) <p></p> The matrix can be used with <a href="..\..\tf\tensordot.md"><code>tf.tensordot</code></a> to convert an arbitrary rank
`Tensor` of linear-scale spectral bins into the mel scale. <p></p> # S has shape [..., num_spectrogram_bins].
# M has shape [..., num_mel_bins].
M = tf.tensordot(S, A, 1)
# tf.tensordot does not support shape inference for this case yet.
M.set_shape(S.shape[:-1].concatenate(A.shape[-1:])) 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> num_mel_bins
						</dt>
						<dd>Python int. How many bands in the resulting mel spectrum. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> num_spectrogram_bins
						</dt>
						<dd>An integer `Tensor`. How many bins there are in the
source spectrogram data, which is understood to be `fft_size // 2 + 1`,
i.e. the spectrogram only contains the nonredundant FFT bins. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> sample_rate
						</dt>
						<dd>Python float. Samples per second of the input signal used to
create the spectrogram. We need this to figure out the actual frequencies
for each spectrogram bin, which dictates how they are mapped into the mel
scale. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> lower_edge_hertz
						</dt>
						<dd>Python float. Lower bound on the frequencies to be
included in the mel spectrum. This corresponds to the lower edge of the
lowest triangular band. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> upper_edge_hertz
						</dt>
						<dd>Python float. The desired top edge of the highest
frequency band. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> dtype
						</dt>
						<dd>The `DType` of the result matrix. Must be a floating point type. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of shape `[num_spectrogram_bins, num_mel_bins]`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="linear_to_mel_weight_matrix" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>linear_to_mel_weight_matrix</strong>(<span title="System.int">int</span> num_mel_bins, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> num_spectrogram_bins, <span title="System.int">int</span> sample_rate, <span title="System.int">int</span> lower_edge_hertz, <span title="System.double">double</span> upper_edge_hertz, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> dtype, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Returns a matrix to warp linear scale spectrograms to the [mel scale][mel]. <p></p> Returns a weight matrix that can be used to re-weight a `Tensor` containing
`num_spectrogram_bins` linearly sampled frequency information from
`[0, sample_rate / 2]` into `num_mel_bins` frequency information from
`[lower_edge_hertz, upper_edge_hertz]` on the [mel scale][mel]. <p></p> For example, the returned matrix `A` can be used to right-multiply a
spectrogram `S` of shape `[frames, num_spectrogram_bins]` of linear
scale spectrum values (e.g. STFT magnitudes) to generate a "mel spectrogram"
`M` of shape `[frames, num_mel_bins]`. <p></p> # `S` has shape [frames, num_spectrogram_bins]
# `M` has shape [frames, num_mel_bins]
M = tf.matmul(S, A) <p></p> The matrix can be used with <a href="..\..\tf\tensordot.md"><code>tf.tensordot</code></a> to convert an arbitrary rank
`Tensor` of linear-scale spectral bins into the mel scale. <p></p> # S has shape [..., num_spectrogram_bins].
# M has shape [..., num_mel_bins].
M = tf.tensordot(S, A, 1)
# tf.tensordot does not support shape inference for this case yet.
M.set_shape(S.shape[:-1].concatenate(A.shape[-1:])) 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> num_mel_bins
						</dt>
						<dd>Python int. How many bands in the resulting mel spectrum. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> num_spectrogram_bins
						</dt>
						<dd>An integer `Tensor`. How many bins there are in the
source spectrogram data, which is understood to be `fft_size // 2 + 1`,
i.e. the spectrogram only contains the nonredundant FFT bins. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> sample_rate
						</dt>
						<dd>Python float. Samples per second of the input signal used to
create the spectrogram. We need this to figure out the actual frequencies
for each spectrogram bin, which dictates how they are mapped into the mel
scale. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> lower_edge_hertz
						</dt>
						<dd>Python float. Lower bound on the frequencies to be
included in the mel spectrum. This corresponds to the lower edge of the
lowest triangular band. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> upper_edge_hertz
						</dt>
						<dd>Python float. The desired top edge of the highest
frequency band. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> dtype
						</dt>
						<dd>The `DType` of the result matrix. Must be a floating point type. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of shape `[num_spectrogram_bins, num_mel_bins]`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="linear_to_mel_weight_matrix" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>linear_to_mel_weight_matrix</strong>(<span title="System.int">int</span> num_mel_bins, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> num_spectrogram_bins, <span title="System.int">int</span> sample_rate, <span title="System.double">double</span> lower_edge_hertz, <span title="System.int">int</span> upper_edge_hertz, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> dtype, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Returns a matrix to warp linear scale spectrograms to the [mel scale][mel]. <p></p> Returns a weight matrix that can be used to re-weight a `Tensor` containing
`num_spectrogram_bins` linearly sampled frequency information from
`[0, sample_rate / 2]` into `num_mel_bins` frequency information from
`[lower_edge_hertz, upper_edge_hertz]` on the [mel scale][mel]. <p></p> For example, the returned matrix `A` can be used to right-multiply a
spectrogram `S` of shape `[frames, num_spectrogram_bins]` of linear
scale spectrum values (e.g. STFT magnitudes) to generate a "mel spectrogram"
`M` of shape `[frames, num_mel_bins]`. <p></p> # `S` has shape [frames, num_spectrogram_bins]
# `M` has shape [frames, num_mel_bins]
M = tf.matmul(S, A) <p></p> The matrix can be used with <a href="..\..\tf\tensordot.md"><code>tf.tensordot</code></a> to convert an arbitrary rank
`Tensor` of linear-scale spectral bins into the mel scale. <p></p> # S has shape [..., num_spectrogram_bins].
# M has shape [..., num_mel_bins].
M = tf.tensordot(S, A, 1)
# tf.tensordot does not support shape inference for this case yet.
M.set_shape(S.shape[:-1].concatenate(A.shape[-1:])) 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> num_mel_bins
						</dt>
						<dd>Python int. How many bands in the resulting mel spectrum. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> num_spectrogram_bins
						</dt>
						<dd>An integer `Tensor`. How many bins there are in the
source spectrogram data, which is understood to be `fft_size // 2 + 1`,
i.e. the spectrogram only contains the nonredundant FFT bins. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> sample_rate
						</dt>
						<dd>Python float. Samples per second of the input signal used to
create the spectrogram. We need this to figure out the actual frequencies
for each spectrogram bin, which dictates how they are mapped into the mel
scale. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> lower_edge_hertz
						</dt>
						<dd>Python float. Lower bound on the frequencies to be
included in the mel spectrum. This corresponds to the lower edge of the
lowest triangular band. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> upper_edge_hertz
						</dt>
						<dd>Python float. The desired top edge of the highest
frequency band. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> dtype
						</dt>
						<dd>The `DType` of the result matrix. Must be a floating point type. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of shape `[num_spectrogram_bins, num_mel_bins]`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="linear_to_mel_weight_matrix" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>linear_to_mel_weight_matrix</strong>(<span title="System.int">int</span> num_mel_bins, <span title="System.int">int</span> num_spectrogram_bins, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> sample_rate, <span title="System.double">double</span> lower_edge_hertz, <span title="System.int">int</span> upper_edge_hertz, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> dtype, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Returns a matrix to warp linear scale spectrograms to the [mel scale][mel]. <p></p> Returns a weight matrix that can be used to re-weight a `Tensor` containing
`num_spectrogram_bins` linearly sampled frequency information from
`[0, sample_rate / 2]` into `num_mel_bins` frequency information from
`[lower_edge_hertz, upper_edge_hertz]` on the [mel scale][mel]. <p></p> For example, the returned matrix `A` can be used to right-multiply a
spectrogram `S` of shape `[frames, num_spectrogram_bins]` of linear
scale spectrum values (e.g. STFT magnitudes) to generate a "mel spectrogram"
`M` of shape `[frames, num_mel_bins]`. <p></p> # `S` has shape [frames, num_spectrogram_bins]
# `M` has shape [frames, num_mel_bins]
M = tf.matmul(S, A) <p></p> The matrix can be used with <a href="..\..\tf\tensordot.md"><code>tf.tensordot</code></a> to convert an arbitrary rank
`Tensor` of linear-scale spectral bins into the mel scale. <p></p> # S has shape [..., num_spectrogram_bins].
# M has shape [..., num_mel_bins].
M = tf.tensordot(S, A, 1)
# tf.tensordot does not support shape inference for this case yet.
M.set_shape(S.shape[:-1].concatenate(A.shape[-1:])) 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> num_mel_bins
						</dt>
						<dd>Python int. How many bands in the resulting mel spectrum. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_spectrogram_bins
						</dt>
						<dd>An integer `Tensor`. How many bins there are in the
source spectrogram data, which is understood to be `fft_size // 2 + 1`,
i.e. the spectrogram only contains the nonredundant FFT bins. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> sample_rate
						</dt>
						<dd>Python float. Samples per second of the input signal used to
create the spectrogram. We need this to figure out the actual frequencies
for each spectrogram bin, which dictates how they are mapped into the mel
scale. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> lower_edge_hertz
						</dt>
						<dd>Python float. Lower bound on the frequencies to be
included in the mel spectrum. This corresponds to the lower edge of the
lowest triangular band. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> upper_edge_hertz
						</dt>
						<dd>Python float. The desired top edge of the highest
frequency band. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> dtype
						</dt>
						<dd>The `DType` of the result matrix. Must be a floating point type. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of shape `[num_spectrogram_bins, num_mel_bins]`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="linear_to_mel_weight_matrix" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>linear_to_mel_weight_matrix</strong>(<span title="System.int">int</span> num_mel_bins, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> num_spectrogram_bins, <span title="System.double">double</span> sample_rate, <span title="System.int">int</span> lower_edge_hertz, <span title="System.int">int</span> upper_edge_hertz, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> dtype, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Returns a matrix to warp linear scale spectrograms to the [mel scale][mel]. <p></p> Returns a weight matrix that can be used to re-weight a `Tensor` containing
`num_spectrogram_bins` linearly sampled frequency information from
`[0, sample_rate / 2]` into `num_mel_bins` frequency information from
`[lower_edge_hertz, upper_edge_hertz]` on the [mel scale][mel]. <p></p> For example, the returned matrix `A` can be used to right-multiply a
spectrogram `S` of shape `[frames, num_spectrogram_bins]` of linear
scale spectrum values (e.g. STFT magnitudes) to generate a "mel spectrogram"
`M` of shape `[frames, num_mel_bins]`. <p></p> # `S` has shape [frames, num_spectrogram_bins]
# `M` has shape [frames, num_mel_bins]
M = tf.matmul(S, A) <p></p> The matrix can be used with <a href="..\..\tf\tensordot.md"><code>tf.tensordot</code></a> to convert an arbitrary rank
`Tensor` of linear-scale spectral bins into the mel scale. <p></p> # S has shape [..., num_spectrogram_bins].
# M has shape [..., num_mel_bins].
M = tf.tensordot(S, A, 1)
# tf.tensordot does not support shape inference for this case yet.
M.set_shape(S.shape[:-1].concatenate(A.shape[-1:])) 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> num_mel_bins
						</dt>
						<dd>Python int. How many bands in the resulting mel spectrum. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> num_spectrogram_bins
						</dt>
						<dd>An integer `Tensor`. How many bins there are in the
source spectrogram data, which is understood to be `fft_size // 2 + 1`,
i.e. the spectrogram only contains the nonredundant FFT bins. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> sample_rate
						</dt>
						<dd>Python float. Samples per second of the input signal used to
create the spectrogram. We need this to figure out the actual frequencies
for each spectrogram bin, which dictates how they are mapped into the mel
scale. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> lower_edge_hertz
						</dt>
						<dd>Python float. Lower bound on the frequencies to be
included in the mel spectrum. This corresponds to the lower edge of the
lowest triangular band. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> upper_edge_hertz
						</dt>
						<dd>Python float. The desired top edge of the highest
frequency band. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> dtype
						</dt>
						<dd>The `DType` of the result matrix. Must be a floating point type. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of shape `[num_spectrogram_bins, num_mel_bins]`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="linear_to_mel_weight_matrix" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>linear_to_mel_weight_matrix</strong>(<span title="System.int">int</span> num_mel_bins, <span title="System.int">int</span> num_spectrogram_bins, <span title="System.double">double</span> sample_rate, <span title="System.double">double</span> lower_edge_hertz, <span title="System.int">int</span> upper_edge_hertz, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> dtype, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Returns a matrix to warp linear scale spectrograms to the [mel scale][mel]. <p></p> Returns a weight matrix that can be used to re-weight a `Tensor` containing
`num_spectrogram_bins` linearly sampled frequency information from
`[0, sample_rate / 2]` into `num_mel_bins` frequency information from
`[lower_edge_hertz, upper_edge_hertz]` on the [mel scale][mel]. <p></p> For example, the returned matrix `A` can be used to right-multiply a
spectrogram `S` of shape `[frames, num_spectrogram_bins]` of linear
scale spectrum values (e.g. STFT magnitudes) to generate a "mel spectrogram"
`M` of shape `[frames, num_mel_bins]`. <p></p> # `S` has shape [frames, num_spectrogram_bins]
# `M` has shape [frames, num_mel_bins]
M = tf.matmul(S, A) <p></p> The matrix can be used with <a href="..\..\tf\tensordot.md"><code>tf.tensordot</code></a> to convert an arbitrary rank
`Tensor` of linear-scale spectral bins into the mel scale. <p></p> # S has shape [..., num_spectrogram_bins].
# M has shape [..., num_mel_bins].
M = tf.tensordot(S, A, 1)
# tf.tensordot does not support shape inference for this case yet.
M.set_shape(S.shape[:-1].concatenate(A.shape[-1:])) 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> num_mel_bins
						</dt>
						<dd>Python int. How many bands in the resulting mel spectrum. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_spectrogram_bins
						</dt>
						<dd>An integer `Tensor`. How many bins there are in the
source spectrogram data, which is understood to be `fft_size // 2 + 1`,
i.e. the spectrogram only contains the nonredundant FFT bins. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> sample_rate
						</dt>
						<dd>Python float. Samples per second of the input signal used to
create the spectrogram. We need this to figure out the actual frequencies
for each spectrogram bin, which dictates how they are mapped into the mel
scale. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> lower_edge_hertz
						</dt>
						<dd>Python float. Lower bound on the frequencies to be
included in the mel spectrum. This corresponds to the lower edge of the
lowest triangular band. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> upper_edge_hertz
						</dt>
						<dd>Python float. The desired top edge of the highest
frequency band. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> dtype
						</dt>
						<dd>The `DType` of the result matrix. Must be a floating point type. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of shape `[num_spectrogram_bins, num_mel_bins]`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="linear_to_mel_weight_matrix" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>linear_to_mel_weight_matrix</strong>(<span title="System.int">int</span> num_mel_bins, <span title="System.int">int</span> num_spectrogram_bins, <span title="System.double">double</span> sample_rate, <span title="System.int">int</span> lower_edge_hertz, <span title="System.double">double</span> upper_edge_hertz, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> dtype, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Returns a matrix to warp linear scale spectrograms to the [mel scale][mel]. <p></p> Returns a weight matrix that can be used to re-weight a `Tensor` containing
`num_spectrogram_bins` linearly sampled frequency information from
`[0, sample_rate / 2]` into `num_mel_bins` frequency information from
`[lower_edge_hertz, upper_edge_hertz]` on the [mel scale][mel]. <p></p> For example, the returned matrix `A` can be used to right-multiply a
spectrogram `S` of shape `[frames, num_spectrogram_bins]` of linear
scale spectrum values (e.g. STFT magnitudes) to generate a "mel spectrogram"
`M` of shape `[frames, num_mel_bins]`. <p></p> # `S` has shape [frames, num_spectrogram_bins]
# `M` has shape [frames, num_mel_bins]
M = tf.matmul(S, A) <p></p> The matrix can be used with <a href="..\..\tf\tensordot.md"><code>tf.tensordot</code></a> to convert an arbitrary rank
`Tensor` of linear-scale spectral bins into the mel scale. <p></p> # S has shape [..., num_spectrogram_bins].
# M has shape [..., num_mel_bins].
M = tf.tensordot(S, A, 1)
# tf.tensordot does not support shape inference for this case yet.
M.set_shape(S.shape[:-1].concatenate(A.shape[-1:])) 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> num_mel_bins
						</dt>
						<dd>Python int. How many bands in the resulting mel spectrum. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_spectrogram_bins
						</dt>
						<dd>An integer `Tensor`. How many bins there are in the
source spectrogram data, which is understood to be `fft_size // 2 + 1`,
i.e. the spectrogram only contains the nonredundant FFT bins. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> sample_rate
						</dt>
						<dd>Python float. Samples per second of the input signal used to
create the spectrogram. We need this to figure out the actual frequencies
for each spectrogram bin, which dictates how they are mapped into the mel
scale. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> lower_edge_hertz
						</dt>
						<dd>Python float. Lower bound on the frequencies to be
included in the mel spectrum. This corresponds to the lower edge of the
lowest triangular band. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> upper_edge_hertz
						</dt>
						<dd>Python float. The desired top edge of the highest
frequency band. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> dtype
						</dt>
						<dd>The `DType` of the result matrix. Must be a floating point type. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of shape `[num_spectrogram_bins, num_mel_bins]`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="linear_to_mel_weight_matrix" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>linear_to_mel_weight_matrix</strong>(<span title="System.int">int</span> num_mel_bins, <span title="System.int">int</span> num_spectrogram_bins, <span title="System.double">double</span> sample_rate, <span title="System.int">int</span> lower_edge_hertz, <span title="System.int">int</span> upper_edge_hertz, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> dtype, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Returns a matrix to warp linear scale spectrograms to the [mel scale][mel]. <p></p> Returns a weight matrix that can be used to re-weight a `Tensor` containing
`num_spectrogram_bins` linearly sampled frequency information from
`[0, sample_rate / 2]` into `num_mel_bins` frequency information from
`[lower_edge_hertz, upper_edge_hertz]` on the [mel scale][mel]. <p></p> For example, the returned matrix `A` can be used to right-multiply a
spectrogram `S` of shape `[frames, num_spectrogram_bins]` of linear
scale spectrum values (e.g. STFT magnitudes) to generate a "mel spectrogram"
`M` of shape `[frames, num_mel_bins]`. <p></p> # `S` has shape [frames, num_spectrogram_bins]
# `M` has shape [frames, num_mel_bins]
M = tf.matmul(S, A) <p></p> The matrix can be used with <a href="..\..\tf\tensordot.md"><code>tf.tensordot</code></a> to convert an arbitrary rank
`Tensor` of linear-scale spectral bins into the mel scale. <p></p> # S has shape [..., num_spectrogram_bins].
# M has shape [..., num_mel_bins].
M = tf.tensordot(S, A, 1)
# tf.tensordot does not support shape inference for this case yet.
M.set_shape(S.shape[:-1].concatenate(A.shape[-1:])) 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> num_mel_bins
						</dt>
						<dd>Python int. How many bands in the resulting mel spectrum. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_spectrogram_bins
						</dt>
						<dd>An integer `Tensor`. How many bins there are in the
source spectrogram data, which is understood to be `fft_size // 2 + 1`,
i.e. the spectrogram only contains the nonredundant FFT bins. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> sample_rate
						</dt>
						<dd>Python float. Samples per second of the input signal used to
create the spectrogram. We need this to figure out the actual frequencies
for each spectrogram bin, which dictates how they are mapped into the mel
scale. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> lower_edge_hertz
						</dt>
						<dd>Python float. Lower bound on the frequencies to be
included in the mel spectrum. This corresponds to the lower edge of the
lowest triangular band. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> upper_edge_hertz
						</dt>
						<dd>Python float. The desired top edge of the highest
frequency band. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> dtype
						</dt>
						<dd>The `DType` of the result matrix. Must be a floating point type. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of shape `[num_spectrogram_bins, num_mel_bins]`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="linear_to_mel_weight_matrix" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>linear_to_mel_weight_matrix</strong>(<span title="System.int">int</span> num_mel_bins, <span title="System.int">int</span> num_spectrogram_bins, <span title="System.int">int</span> sample_rate, <span title="System.double">double</span> lower_edge_hertz, <span title="System.double">double</span> upper_edge_hertz, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> dtype, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Returns a matrix to warp linear scale spectrograms to the [mel scale][mel]. <p></p> Returns a weight matrix that can be used to re-weight a `Tensor` containing
`num_spectrogram_bins` linearly sampled frequency information from
`[0, sample_rate / 2]` into `num_mel_bins` frequency information from
`[lower_edge_hertz, upper_edge_hertz]` on the [mel scale][mel]. <p></p> For example, the returned matrix `A` can be used to right-multiply a
spectrogram `S` of shape `[frames, num_spectrogram_bins]` of linear
scale spectrum values (e.g. STFT magnitudes) to generate a "mel spectrogram"
`M` of shape `[frames, num_mel_bins]`. <p></p> # `S` has shape [frames, num_spectrogram_bins]
# `M` has shape [frames, num_mel_bins]
M = tf.matmul(S, A) <p></p> The matrix can be used with <a href="..\..\tf\tensordot.md"><code>tf.tensordot</code></a> to convert an arbitrary rank
`Tensor` of linear-scale spectral bins into the mel scale. <p></p> # S has shape [..., num_spectrogram_bins].
# M has shape [..., num_mel_bins].
M = tf.tensordot(S, A, 1)
# tf.tensordot does not support shape inference for this case yet.
M.set_shape(S.shape[:-1].concatenate(A.shape[-1:])) 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> num_mel_bins
						</dt>
						<dd>Python int. How many bands in the resulting mel spectrum. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_spectrogram_bins
						</dt>
						<dd>An integer `Tensor`. How many bins there are in the
source spectrogram data, which is understood to be `fft_size // 2 + 1`,
i.e. the spectrogram only contains the nonredundant FFT bins. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> sample_rate
						</dt>
						<dd>Python float. Samples per second of the input signal used to
create the spectrogram. We need this to figure out the actual frequencies
for each spectrogram bin, which dictates how they are mapped into the mel
scale. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> lower_edge_hertz
						</dt>
						<dd>Python float. Lower bound on the frequencies to be
included in the mel spectrum. This corresponds to the lower edge of the
lowest triangular band. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> upper_edge_hertz
						</dt>
						<dd>Python float. The desired top edge of the highest
frequency band. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> dtype
						</dt>
						<dd>The `DType` of the result matrix. Must be a floating point type. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of shape `[num_spectrogram_bins, num_mel_bins]`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="linear_to_mel_weight_matrix" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>linear_to_mel_weight_matrix</strong>(<span title="System.int">int</span> num_mel_bins, <span title="System.int">int</span> num_spectrogram_bins, <span title="System.int">int</span> sample_rate, <span title="System.double">double</span> lower_edge_hertz, <span title="System.int">int</span> upper_edge_hertz, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> dtype, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Returns a matrix to warp linear scale spectrograms to the [mel scale][mel]. <p></p> Returns a weight matrix that can be used to re-weight a `Tensor` containing
`num_spectrogram_bins` linearly sampled frequency information from
`[0, sample_rate / 2]` into `num_mel_bins` frequency information from
`[lower_edge_hertz, upper_edge_hertz]` on the [mel scale][mel]. <p></p> For example, the returned matrix `A` can be used to right-multiply a
spectrogram `S` of shape `[frames, num_spectrogram_bins]` of linear
scale spectrum values (e.g. STFT magnitudes) to generate a "mel spectrogram"
`M` of shape `[frames, num_mel_bins]`. <p></p> # `S` has shape [frames, num_spectrogram_bins]
# `M` has shape [frames, num_mel_bins]
M = tf.matmul(S, A) <p></p> The matrix can be used with <a href="..\..\tf\tensordot.md"><code>tf.tensordot</code></a> to convert an arbitrary rank
`Tensor` of linear-scale spectral bins into the mel scale. <p></p> # S has shape [..., num_spectrogram_bins].
# M has shape [..., num_mel_bins].
M = tf.tensordot(S, A, 1)
# tf.tensordot does not support shape inference for this case yet.
M.set_shape(S.shape[:-1].concatenate(A.shape[-1:])) 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> num_mel_bins
						</dt>
						<dd>Python int. How many bands in the resulting mel spectrum. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_spectrogram_bins
						</dt>
						<dd>An integer `Tensor`. How many bins there are in the
source spectrogram data, which is understood to be `fft_size // 2 + 1`,
i.e. the spectrogram only contains the nonredundant FFT bins. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> sample_rate
						</dt>
						<dd>Python float. Samples per second of the input signal used to
create the spectrogram. We need this to figure out the actual frequencies
for each spectrogram bin, which dictates how they are mapped into the mel
scale. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> lower_edge_hertz
						</dt>
						<dd>Python float. Lower bound on the frequencies to be
included in the mel spectrum. This corresponds to the lower edge of the
lowest triangular band. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> upper_edge_hertz
						</dt>
						<dd>Python float. The desired top edge of the highest
frequency band. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> dtype
						</dt>
						<dd>The `DType` of the result matrix. Must be a floating point type. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of shape `[num_spectrogram_bins, num_mel_bins]`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="linear_to_mel_weight_matrix" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>linear_to_mel_weight_matrix</strong>(<span title="System.int">int</span> num_mel_bins, <span title="System.int">int</span> num_spectrogram_bins, <span title="System.int">int</span> sample_rate, <span title="System.int">int</span> lower_edge_hertz, <span title="System.double">double</span> upper_edge_hertz, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> dtype, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Returns a matrix to warp linear scale spectrograms to the [mel scale][mel]. <p></p> Returns a weight matrix that can be used to re-weight a `Tensor` containing
`num_spectrogram_bins` linearly sampled frequency information from
`[0, sample_rate / 2]` into `num_mel_bins` frequency information from
`[lower_edge_hertz, upper_edge_hertz]` on the [mel scale][mel]. <p></p> For example, the returned matrix `A` can be used to right-multiply a
spectrogram `S` of shape `[frames, num_spectrogram_bins]` of linear
scale spectrum values (e.g. STFT magnitudes) to generate a "mel spectrogram"
`M` of shape `[frames, num_mel_bins]`. <p></p> # `S` has shape [frames, num_spectrogram_bins]
# `M` has shape [frames, num_mel_bins]
M = tf.matmul(S, A) <p></p> The matrix can be used with <a href="..\..\tf\tensordot.md"><code>tf.tensordot</code></a> to convert an arbitrary rank
`Tensor` of linear-scale spectral bins into the mel scale. <p></p> # S has shape [..., num_spectrogram_bins].
# M has shape [..., num_mel_bins].
M = tf.tensordot(S, A, 1)
# tf.tensordot does not support shape inference for this case yet.
M.set_shape(S.shape[:-1].concatenate(A.shape[-1:])) 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> num_mel_bins
						</dt>
						<dd>Python int. How many bands in the resulting mel spectrum. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_spectrogram_bins
						</dt>
						<dd>An integer `Tensor`. How many bins there are in the
source spectrogram data, which is understood to be `fft_size // 2 + 1`,
i.e. the spectrogram only contains the nonredundant FFT bins. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> sample_rate
						</dt>
						<dd>Python float. Samples per second of the input signal used to
create the spectrogram. We need this to figure out the actual frequencies
for each spectrogram bin, which dictates how they are mapped into the mel
scale. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> lower_edge_hertz
						</dt>
						<dd>Python float. Lower bound on the frequencies to be
included in the mel spectrum. This corresponds to the lower edge of the
lowest triangular band. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> upper_edge_hertz
						</dt>
						<dd>Python float. The desired top edge of the highest
frequency band. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> dtype
						</dt>
						<dd>The `DType` of the result matrix. Must be a floating point type. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of shape `[num_spectrogram_bins, num_mel_bins]`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="linear_to_mel_weight_matrix" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>linear_to_mel_weight_matrix</strong>(<span title="System.int">int</span> num_mel_bins, <span title="System.int">int</span> num_spectrogram_bins, <span title="System.int">int</span> sample_rate, <span title="System.int">int</span> lower_edge_hertz, <span title="System.int">int</span> upper_edge_hertz, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> dtype, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Returns a matrix to warp linear scale spectrograms to the [mel scale][mel]. <p></p> Returns a weight matrix that can be used to re-weight a `Tensor` containing
`num_spectrogram_bins` linearly sampled frequency information from
`[0, sample_rate / 2]` into `num_mel_bins` frequency information from
`[lower_edge_hertz, upper_edge_hertz]` on the [mel scale][mel]. <p></p> For example, the returned matrix `A` can be used to right-multiply a
spectrogram `S` of shape `[frames, num_spectrogram_bins]` of linear
scale spectrum values (e.g. STFT magnitudes) to generate a "mel spectrogram"
`M` of shape `[frames, num_mel_bins]`. <p></p> # `S` has shape [frames, num_spectrogram_bins]
# `M` has shape [frames, num_mel_bins]
M = tf.matmul(S, A) <p></p> The matrix can be used with <a href="..\..\tf\tensordot.md"><code>tf.tensordot</code></a> to convert an arbitrary rank
`Tensor` of linear-scale spectral bins into the mel scale. <p></p> # S has shape [..., num_spectrogram_bins].
# M has shape [..., num_mel_bins].
M = tf.tensordot(S, A, 1)
# tf.tensordot does not support shape inference for this case yet.
M.set_shape(S.shape[:-1].concatenate(A.shape[-1:])) 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> num_mel_bins
						</dt>
						<dd>Python int. How many bands in the resulting mel spectrum. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_spectrogram_bins
						</dt>
						<dd>An integer `Tensor`. How many bins there are in the
source spectrogram data, which is understood to be `fft_size // 2 + 1`,
i.e. the spectrogram only contains the nonredundant FFT bins. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> sample_rate
						</dt>
						<dd>Python float. Samples per second of the input signal used to
create the spectrogram. We need this to figure out the actual frequencies
for each spectrogram bin, which dictates how they are mapped into the mel
scale. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> lower_edge_hertz
						</dt>
						<dd>Python float. Lower bound on the frequencies to be
included in the mel spectrum. This corresponds to the lower edge of the
lowest triangular band. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> upper_edge_hertz
						</dt>
						<dd>Python float. The desired top edge of the highest
frequency band. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> dtype
						</dt>
						<dd>The `DType` of the result matrix. Must be a floating point type. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of shape `[num_spectrogram_bins, num_mel_bins]`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="linear_to_mel_weight_matrix" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>linear_to_mel_weight_matrix</strong>(<span title="System.int">int</span> num_mel_bins, <span title="System.int">int</span> num_spectrogram_bins, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> sample_rate, <span title="System.double">double</span> lower_edge_hertz, <span title="System.double">double</span> upper_edge_hertz, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> dtype, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Returns a matrix to warp linear scale spectrograms to the [mel scale][mel]. <p></p> Returns a weight matrix that can be used to re-weight a `Tensor` containing
`num_spectrogram_bins` linearly sampled frequency information from
`[0, sample_rate / 2]` into `num_mel_bins` frequency information from
`[lower_edge_hertz, upper_edge_hertz]` on the [mel scale][mel]. <p></p> For example, the returned matrix `A` can be used to right-multiply a
spectrogram `S` of shape `[frames, num_spectrogram_bins]` of linear
scale spectrum values (e.g. STFT magnitudes) to generate a "mel spectrogram"
`M` of shape `[frames, num_mel_bins]`. <p></p> # `S` has shape [frames, num_spectrogram_bins]
# `M` has shape [frames, num_mel_bins]
M = tf.matmul(S, A) <p></p> The matrix can be used with <a href="..\..\tf\tensordot.md"><code>tf.tensordot</code></a> to convert an arbitrary rank
`Tensor` of linear-scale spectral bins into the mel scale. <p></p> # S has shape [..., num_spectrogram_bins].
# M has shape [..., num_mel_bins].
M = tf.tensordot(S, A, 1)
# tf.tensordot does not support shape inference for this case yet.
M.set_shape(S.shape[:-1].concatenate(A.shape[-1:])) 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> num_mel_bins
						</dt>
						<dd>Python int. How many bands in the resulting mel spectrum. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_spectrogram_bins
						</dt>
						<dd>An integer `Tensor`. How many bins there are in the
source spectrogram data, which is understood to be `fft_size // 2 + 1`,
i.e. the spectrogram only contains the nonredundant FFT bins. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> sample_rate
						</dt>
						<dd>Python float. Samples per second of the input signal used to
create the spectrogram. We need this to figure out the actual frequencies
for each spectrogram bin, which dictates how they are mapped into the mel
scale. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> lower_edge_hertz
						</dt>
						<dd>Python float. Lower bound on the frequencies to be
included in the mel spectrum. This corresponds to the lower edge of the
lowest triangular band. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> upper_edge_hertz
						</dt>
						<dd>Python float. The desired top edge of the highest
frequency band. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> dtype
						</dt>
						<dd>The `DType` of the result matrix. Must be a floating point type. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of shape `[num_spectrogram_bins, num_mel_bins]`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="linear_to_mel_weight_matrix" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>linear_to_mel_weight_matrix</strong>(<span title="System.int">int</span> num_mel_bins, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> num_spectrogram_bins, <span title="System.int">int</span> sample_rate, <span title="System.double">double</span> lower_edge_hertz, <span title="System.double">double</span> upper_edge_hertz, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> dtype, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Returns a matrix to warp linear scale spectrograms to the [mel scale][mel]. <p></p> Returns a weight matrix that can be used to re-weight a `Tensor` containing
`num_spectrogram_bins` linearly sampled frequency information from
`[0, sample_rate / 2]` into `num_mel_bins` frequency information from
`[lower_edge_hertz, upper_edge_hertz]` on the [mel scale][mel]. <p></p> For example, the returned matrix `A` can be used to right-multiply a
spectrogram `S` of shape `[frames, num_spectrogram_bins]` of linear
scale spectrum values (e.g. STFT magnitudes) to generate a "mel spectrogram"
`M` of shape `[frames, num_mel_bins]`. <p></p> # `S` has shape [frames, num_spectrogram_bins]
# `M` has shape [frames, num_mel_bins]
M = tf.matmul(S, A) <p></p> The matrix can be used with <a href="..\..\tf\tensordot.md"><code>tf.tensordot</code></a> to convert an arbitrary rank
`Tensor` of linear-scale spectral bins into the mel scale. <p></p> # S has shape [..., num_spectrogram_bins].
# M has shape [..., num_mel_bins].
M = tf.tensordot(S, A, 1)
# tf.tensordot does not support shape inference for this case yet.
M.set_shape(S.shape[:-1].concatenate(A.shape[-1:])) 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> num_mel_bins
						</dt>
						<dd>Python int. How many bands in the resulting mel spectrum. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> num_spectrogram_bins
						</dt>
						<dd>An integer `Tensor`. How many bins there are in the
source spectrogram data, which is understood to be `fft_size // 2 + 1`,
i.e. the spectrogram only contains the nonredundant FFT bins. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> sample_rate
						</dt>
						<dd>Python float. Samples per second of the input signal used to
create the spectrogram. We need this to figure out the actual frequencies
for each spectrogram bin, which dictates how they are mapped into the mel
scale. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> lower_edge_hertz
						</dt>
						<dd>Python float. Lower bound on the frequencies to be
included in the mel spectrum. This corresponds to the lower edge of the
lowest triangular band. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> upper_edge_hertz
						</dt>
						<dd>Python float. The desired top edge of the highest
frequency band. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> dtype
						</dt>
						<dd>The `DType` of the result matrix. Must be a floating point type. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of shape `[num_spectrogram_bins, num_mel_bins]`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="linear_to_mel_weight_matrix" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>linear_to_mel_weight_matrix</strong>(<span title="System.int">int</span> num_mel_bins, <span title="System.int">int</span> num_spectrogram_bins, <span title="System.double">double</span> sample_rate, <span title="System.double">double</span> lower_edge_hertz, <span title="System.double">double</span> upper_edge_hertz, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> dtype, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Returns a matrix to warp linear scale spectrograms to the [mel scale][mel]. <p></p> Returns a weight matrix that can be used to re-weight a `Tensor` containing
`num_spectrogram_bins` linearly sampled frequency information from
`[0, sample_rate / 2]` into `num_mel_bins` frequency information from
`[lower_edge_hertz, upper_edge_hertz]` on the [mel scale][mel]. <p></p> For example, the returned matrix `A` can be used to right-multiply a
spectrogram `S` of shape `[frames, num_spectrogram_bins]` of linear
scale spectrum values (e.g. STFT magnitudes) to generate a "mel spectrogram"
`M` of shape `[frames, num_mel_bins]`. <p></p> # `S` has shape [frames, num_spectrogram_bins]
# `M` has shape [frames, num_mel_bins]
M = tf.matmul(S, A) <p></p> The matrix can be used with <a href="..\..\tf\tensordot.md"><code>tf.tensordot</code></a> to convert an arbitrary rank
`Tensor` of linear-scale spectral bins into the mel scale. <p></p> # S has shape [..., num_spectrogram_bins].
# M has shape [..., num_mel_bins].
M = tf.tensordot(S, A, 1)
# tf.tensordot does not support shape inference for this case yet.
M.set_shape(S.shape[:-1].concatenate(A.shape[-1:])) 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> num_mel_bins
						</dt>
						<dd>Python int. How many bands in the resulting mel spectrum. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_spectrogram_bins
						</dt>
						<dd>An integer `Tensor`. How many bins there are in the
source spectrogram data, which is understood to be `fft_size // 2 + 1`,
i.e. the spectrogram only contains the nonredundant FFT bins. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> sample_rate
						</dt>
						<dd>Python float. Samples per second of the input signal used to
create the spectrogram. We need this to figure out the actual frequencies
for each spectrogram bin, which dictates how they are mapped into the mel
scale. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> lower_edge_hertz
						</dt>
						<dd>Python float. Lower bound on the frequencies to be
included in the mel spectrum. This corresponds to the lower edge of the
lowest triangular band. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> upper_edge_hertz
						</dt>
						<dd>Python float. The desired top edge of the highest
frequency band. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> dtype
						</dt>
						<dd>The `DType` of the result matrix. Must be a floating point type. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of shape `[num_spectrogram_bins, num_mel_bins]`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="linear_to_mel_weight_matrix" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>linear_to_mel_weight_matrix</strong>(<span title="System.int">int</span> num_mel_bins, <span title="System.int">int</span> num_spectrogram_bins, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> sample_rate, <span title="System.int">int</span> lower_edge_hertz, <span title="System.double">double</span> upper_edge_hertz, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> dtype, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Returns a matrix to warp linear scale spectrograms to the [mel scale][mel]. <p></p> Returns a weight matrix that can be used to re-weight a `Tensor` containing
`num_spectrogram_bins` linearly sampled frequency information from
`[0, sample_rate / 2]` into `num_mel_bins` frequency information from
`[lower_edge_hertz, upper_edge_hertz]` on the [mel scale][mel]. <p></p> For example, the returned matrix `A` can be used to right-multiply a
spectrogram `S` of shape `[frames, num_spectrogram_bins]` of linear
scale spectrum values (e.g. STFT magnitudes) to generate a "mel spectrogram"
`M` of shape `[frames, num_mel_bins]`. <p></p> # `S` has shape [frames, num_spectrogram_bins]
# `M` has shape [frames, num_mel_bins]
M = tf.matmul(S, A) <p></p> The matrix can be used with <a href="..\..\tf\tensordot.md"><code>tf.tensordot</code></a> to convert an arbitrary rank
`Tensor` of linear-scale spectral bins into the mel scale. <p></p> # S has shape [..., num_spectrogram_bins].
# M has shape [..., num_mel_bins].
M = tf.tensordot(S, A, 1)
# tf.tensordot does not support shape inference for this case yet.
M.set_shape(S.shape[:-1].concatenate(A.shape[-1:])) 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> num_mel_bins
						</dt>
						<dd>Python int. How many bands in the resulting mel spectrum. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_spectrogram_bins
						</dt>
						<dd>An integer `Tensor`. How many bins there are in the
source spectrogram data, which is understood to be `fft_size // 2 + 1`,
i.e. the spectrogram only contains the nonredundant FFT bins. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> sample_rate
						</dt>
						<dd>Python float. Samples per second of the input signal used to
create the spectrogram. We need this to figure out the actual frequencies
for each spectrogram bin, which dictates how they are mapped into the mel
scale. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> lower_edge_hertz
						</dt>
						<dd>Python float. Lower bound on the frequencies to be
included in the mel spectrum. This corresponds to the lower edge of the
lowest triangular band. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> upper_edge_hertz
						</dt>
						<dd>Python float. The desired top edge of the highest
frequency band. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> dtype
						</dt>
						<dd>The `DType` of the result matrix. Must be a floating point type. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of shape `[num_spectrogram_bins, num_mel_bins]`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="linear_to_mel_weight_matrix" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>linear_to_mel_weight_matrix</strong>(<span title="System.int">int</span> num_mel_bins, <span title="System.int">int</span> num_spectrogram_bins, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> sample_rate, <span title="System.int">int</span> lower_edge_hertz, <span title="System.int">int</span> upper_edge_hertz, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> dtype, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Returns a matrix to warp linear scale spectrograms to the [mel scale][mel]. <p></p> Returns a weight matrix that can be used to re-weight a `Tensor` containing
`num_spectrogram_bins` linearly sampled frequency information from
`[0, sample_rate / 2]` into `num_mel_bins` frequency information from
`[lower_edge_hertz, upper_edge_hertz]` on the [mel scale][mel]. <p></p> For example, the returned matrix `A` can be used to right-multiply a
spectrogram `S` of shape `[frames, num_spectrogram_bins]` of linear
scale spectrum values (e.g. STFT magnitudes) to generate a "mel spectrogram"
`M` of shape `[frames, num_mel_bins]`. <p></p> # `S` has shape [frames, num_spectrogram_bins]
# `M` has shape [frames, num_mel_bins]
M = tf.matmul(S, A) <p></p> The matrix can be used with <a href="..\..\tf\tensordot.md"><code>tf.tensordot</code></a> to convert an arbitrary rank
`Tensor` of linear-scale spectral bins into the mel scale. <p></p> # S has shape [..., num_spectrogram_bins].
# M has shape [..., num_mel_bins].
M = tf.tensordot(S, A, 1)
# tf.tensordot does not support shape inference for this case yet.
M.set_shape(S.shape[:-1].concatenate(A.shape[-1:])) 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> num_mel_bins
						</dt>
						<dd>Python int. How many bands in the resulting mel spectrum. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_spectrogram_bins
						</dt>
						<dd>An integer `Tensor`. How many bins there are in the
source spectrogram data, which is understood to be `fft_size // 2 + 1`,
i.e. the spectrogram only contains the nonredundant FFT bins. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> sample_rate
						</dt>
						<dd>Python float. Samples per second of the input signal used to
create the spectrogram. We need this to figure out the actual frequencies
for each spectrogram bin, which dictates how they are mapped into the mel
scale. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> lower_edge_hertz
						</dt>
						<dd>Python float. Lower bound on the frequencies to be
included in the mel spectrum. This corresponds to the lower edge of the
lowest triangular band. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> upper_edge_hertz
						</dt>
						<dd>Python float. The desired top edge of the highest
frequency band. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> dtype
						</dt>
						<dd>The `DType` of the result matrix. Must be a floating point type. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of shape `[num_spectrogram_bins, num_mel_bins]`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="linear_to_mel_weight_matrix" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>linear_to_mel_weight_matrix</strong>(<span title="System.int">int</span> num_mel_bins, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> num_spectrogram_bins, <span title="System.double">double</span> sample_rate, <span title="System.double">double</span> lower_edge_hertz, <span title="System.double">double</span> upper_edge_hertz, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> dtype, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Returns a matrix to warp linear scale spectrograms to the [mel scale][mel]. <p></p> Returns a weight matrix that can be used to re-weight a `Tensor` containing
`num_spectrogram_bins` linearly sampled frequency information from
`[0, sample_rate / 2]` into `num_mel_bins` frequency information from
`[lower_edge_hertz, upper_edge_hertz]` on the [mel scale][mel]. <p></p> For example, the returned matrix `A` can be used to right-multiply a
spectrogram `S` of shape `[frames, num_spectrogram_bins]` of linear
scale spectrum values (e.g. STFT magnitudes) to generate a "mel spectrogram"
`M` of shape `[frames, num_mel_bins]`. <p></p> # `S` has shape [frames, num_spectrogram_bins]
# `M` has shape [frames, num_mel_bins]
M = tf.matmul(S, A) <p></p> The matrix can be used with <a href="..\..\tf\tensordot.md"><code>tf.tensordot</code></a> to convert an arbitrary rank
`Tensor` of linear-scale spectral bins into the mel scale. <p></p> # S has shape [..., num_spectrogram_bins].
# M has shape [..., num_mel_bins].
M = tf.tensordot(S, A, 1)
# tf.tensordot does not support shape inference for this case yet.
M.set_shape(S.shape[:-1].concatenate(A.shape[-1:])) 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> num_mel_bins
						</dt>
						<dd>Python int. How many bands in the resulting mel spectrum. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> num_spectrogram_bins
						</dt>
						<dd>An integer `Tensor`. How many bins there are in the
source spectrogram data, which is understood to be `fft_size // 2 + 1`,
i.e. the spectrogram only contains the nonredundant FFT bins. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> sample_rate
						</dt>
						<dd>Python float. Samples per second of the input signal used to
create the spectrogram. We need this to figure out the actual frequencies
for each spectrogram bin, which dictates how they are mapped into the mel
scale. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> lower_edge_hertz
						</dt>
						<dd>Python float. Lower bound on the frequencies to be
included in the mel spectrum. This corresponds to the lower edge of the
lowest triangular band. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> upper_edge_hertz
						</dt>
						<dd>Python float. The desired top edge of the highest
frequency band. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> dtype
						</dt>
						<dd>The `DType` of the result matrix. Must be a floating point type. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of shape `[num_spectrogram_bins, num_mel_bins]`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="linear_to_mel_weight_matrix" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>linear_to_mel_weight_matrix</strong>(<span title="System.int">int</span> num_mel_bins, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> num_spectrogram_bins, <span title="System.double">double</span> sample_rate, <span title="System.double">double</span> lower_edge_hertz, <span title="System.int">int</span> upper_edge_hertz, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> dtype, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Returns a matrix to warp linear scale spectrograms to the [mel scale][mel]. <p></p> Returns a weight matrix that can be used to re-weight a `Tensor` containing
`num_spectrogram_bins` linearly sampled frequency information from
`[0, sample_rate / 2]` into `num_mel_bins` frequency information from
`[lower_edge_hertz, upper_edge_hertz]` on the [mel scale][mel]. <p></p> For example, the returned matrix `A` can be used to right-multiply a
spectrogram `S` of shape `[frames, num_spectrogram_bins]` of linear
scale spectrum values (e.g. STFT magnitudes) to generate a "mel spectrogram"
`M` of shape `[frames, num_mel_bins]`. <p></p> # `S` has shape [frames, num_spectrogram_bins]
# `M` has shape [frames, num_mel_bins]
M = tf.matmul(S, A) <p></p> The matrix can be used with <a href="..\..\tf\tensordot.md"><code>tf.tensordot</code></a> to convert an arbitrary rank
`Tensor` of linear-scale spectral bins into the mel scale. <p></p> # S has shape [..., num_spectrogram_bins].
# M has shape [..., num_mel_bins].
M = tf.tensordot(S, A, 1)
# tf.tensordot does not support shape inference for this case yet.
M.set_shape(S.shape[:-1].concatenate(A.shape[-1:])) 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> num_mel_bins
						</dt>
						<dd>Python int. How many bands in the resulting mel spectrum. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> num_spectrogram_bins
						</dt>
						<dd>An integer `Tensor`. How many bins there are in the
source spectrogram data, which is understood to be `fft_size // 2 + 1`,
i.e. the spectrogram only contains the nonredundant FFT bins. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> sample_rate
						</dt>
						<dd>Python float. Samples per second of the input signal used to
create the spectrogram. We need this to figure out the actual frequencies
for each spectrogram bin, which dictates how they are mapped into the mel
scale. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> lower_edge_hertz
						</dt>
						<dd>Python float. Lower bound on the frequencies to be
included in the mel spectrum. This corresponds to the lower edge of the
lowest triangular band. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> upper_edge_hertz
						</dt>
						<dd>Python float. The desired top edge of the highest
frequency band. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> dtype
						</dt>
						<dd>The `DType` of the result matrix. Must be a floating point type. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of shape `[num_spectrogram_bins, num_mel_bins]`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="linear_to_mel_weight_matrix" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>linear_to_mel_weight_matrix</strong>(<span title="System.int">int</span> num_mel_bins, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> num_spectrogram_bins, <span title="System.double">double</span> sample_rate, <span title="System.int">int</span> lower_edge_hertz, <span title="System.double">double</span> upper_edge_hertz, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> dtype, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Returns a matrix to warp linear scale spectrograms to the [mel scale][mel]. <p></p> Returns a weight matrix that can be used to re-weight a `Tensor` containing
`num_spectrogram_bins` linearly sampled frequency information from
`[0, sample_rate / 2]` into `num_mel_bins` frequency information from
`[lower_edge_hertz, upper_edge_hertz]` on the [mel scale][mel]. <p></p> For example, the returned matrix `A` can be used to right-multiply a
spectrogram `S` of shape `[frames, num_spectrogram_bins]` of linear
scale spectrum values (e.g. STFT magnitudes) to generate a "mel spectrogram"
`M` of shape `[frames, num_mel_bins]`. <p></p> # `S` has shape [frames, num_spectrogram_bins]
# `M` has shape [frames, num_mel_bins]
M = tf.matmul(S, A) <p></p> The matrix can be used with <a href="..\..\tf\tensordot.md"><code>tf.tensordot</code></a> to convert an arbitrary rank
`Tensor` of linear-scale spectral bins into the mel scale. <p></p> # S has shape [..., num_spectrogram_bins].
# M has shape [..., num_mel_bins].
M = tf.tensordot(S, A, 1)
# tf.tensordot does not support shape inference for this case yet.
M.set_shape(S.shape[:-1].concatenate(A.shape[-1:])) 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> num_mel_bins
						</dt>
						<dd>Python int. How many bands in the resulting mel spectrum. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> num_spectrogram_bins
						</dt>
						<dd>An integer `Tensor`. How many bins there are in the
source spectrogram data, which is understood to be `fft_size // 2 + 1`,
i.e. the spectrogram only contains the nonredundant FFT bins. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> sample_rate
						</dt>
						<dd>Python float. Samples per second of the input signal used to
create the spectrogram. We need this to figure out the actual frequencies
for each spectrogram bin, which dictates how they are mapped into the mel
scale. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> lower_edge_hertz
						</dt>
						<dd>Python float. Lower bound on the frequencies to be
included in the mel spectrum. This corresponds to the lower edge of the
lowest triangular band. 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> upper_edge_hertz
						</dt>
						<dd>Python float. The desired top edge of the highest
frequency band. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> dtype
						</dt>
						<dd>The `DType` of the result matrix. Must be a floating point type. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of shape `[num_spectrogram_bins, num_mel_bins]`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="linear_to_mel_weight_matrix_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>linear_to_mel_weight_matrix_dyn</strong>(<a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> num_mel_bins, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> num_spectrogram_bins, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> sample_rate, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> lower_edge_hertz, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> upper_edge_hertz, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> dtype, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Returns a matrix to warp linear scale spectrograms to the [mel scale][mel]. <p></p> Returns a weight matrix that can be used to re-weight a `Tensor` containing
`num_spectrogram_bins` linearly sampled frequency information from
`[0, sample_rate / 2]` into `num_mel_bins` frequency information from
`[lower_edge_hertz, upper_edge_hertz]` on the [mel scale][mel]. <p></p> For example, the returned matrix `A` can be used to right-multiply a
spectrogram `S` of shape `[frames, num_spectrogram_bins]` of linear
scale spectrum values (e.g. STFT magnitudes) to generate a "mel spectrogram"
`M` of shape `[frames, num_mel_bins]`. <p></p> # `S` has shape [frames, num_spectrogram_bins]
# `M` has shape [frames, num_mel_bins]
M = tf.matmul(S, A) <p></p> The matrix can be used with <a href="..\..\tf\tensordot.md"><code>tf.tensordot</code></a> to convert an arbitrary rank
`Tensor` of linear-scale spectral bins into the mel scale. <p></p> # S has shape [..., num_spectrogram_bins].
# M has shape [..., num_mel_bins].
M = tf.tensordot(S, A, 1)
# tf.tensordot does not support shape inference for this case yet.
M.set_shape(S.shape[:-1].concatenate(A.shape[-1:])) 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> num_mel_bins
						</dt>
						<dd>Python int. How many bands in the resulting mel spectrum. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> num_spectrogram_bins
						</dt>
						<dd>An integer `Tensor`. How many bins there are in the
source spectrogram data, which is understood to be `fft_size // 2 + 1`,
i.e. the spectrogram only contains the nonredundant FFT bins. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> sample_rate
						</dt>
						<dd>Python float. Samples per second of the input signal used to
create the spectrogram. We need this to figure out the actual frequencies
for each spectrogram bin, which dictates how they are mapped into the mel
scale. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> lower_edge_hertz
						</dt>
						<dd>Python float. Lower bound on the frequencies to be
included in the mel spectrum. This corresponds to the lower edge of the
lowest triangular band. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> upper_edge_hertz
						</dt>
						<dd>Python float. The desired top edge of the highest
frequency band. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> dtype
						</dt>
						<dd>The `DType` of the result matrix. Must be a floating point type. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `Tensor` of shape `[num_spectrogram_bins, num_mel_bins]`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="mfccs_from_log_mel_spectrograms" class="method">
		<h4>
			<span title="System.object">object</span> <strong>mfccs_from_log_mel_spectrograms</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> log_mel_spectrograms, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes [MFCCs][mfcc] of `log_mel_spectrograms`. <p></p> Implemented with GPU-compatible ops and supports gradients. <p></p> [Mel-Frequency Cepstral Coefficient (MFCC)][mfcc] calculation consists of
taking the DCT-II of a log-magnitude mel-scale spectrogram. [HTK][htk]'s MFCCs
use a particular scaling of the DCT-II which is almost orthogonal
normalization. We follow this convention. <p></p> All `num_mel_bins` MFCCs are returned and it is up to the caller to select
a subset of the MFCCs based on their application. For example, it is typical
to only use the first few for speech recognition, as this results in
an approximately pitch-invariant representation of the signal. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> log_mel_spectrograms
						</dt>
						<dd>A `[..., num_mel_bins]` `float32` `Tensor` of
log-magnitude mel-scale spectrograms. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `[..., num_mel_bins]` `float32` `Tensor` of the MFCCs of
`log_mel_spectrograms`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>sample_rate = 16000.0
            # A Tensor of [batch_size, num_samples] mono PCM samples in the range [-1, 1].
            pcm = tf.compat.v1.placeholder(tf.float32, [None, None]) <p></p> # A 1024-point STFT with frames of 64 ms and 75% overlap.
stfts = tf.signal.stft(pcm, frame_length=1024, frame_step=256,
                       fft_length=1024)
spectrograms = tf.abs(stfts) <p></p> # Warp the linear scale spectrograms into the mel-scale.
num_spectrogram_bins = stfts.shape[-1].value
lower_edge_hertz, upper_edge_hertz, num_mel_bins = 80.0, 7600.0, 80
linear_to_mel_weight_matrix = tf.signal.linear_to_mel_weight_matrix(
  num_mel_bins, num_spectrogram_bins, sample_rate, lower_edge_hertz,
  upper_edge_hertz)
mel_spectrograms = tf.tensordot(
  spectrograms, linear_to_mel_weight_matrix, 1)
mel_spectrograms.set_shape(spectrograms.shape[:-1].concatenate(
  linear_to_mel_weight_matrix.shape[-1:])) <p></p> # Compute a stabilized log to get log-magnitude mel-scale spectrograms.
log_mel_spectrograms = tf.math.log(mel_spectrograms + 1e-6) <p></p> # Compute MFCCs from log_mel_spectrograms and take the first 13.
mfccs = tf.signal.mfccs_from_log_mel_spectrograms(
  log_mel_spectrograms)[..., :13] </pre>
</div>
		</div>
	</div>
	<div id="mfccs_from_log_mel_spectrograms_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>mfccs_from_log_mel_spectrograms_dyn</strong>(<span title="System.object">object</span> log_mel_spectrograms, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Computes [MFCCs][mfcc] of `log_mel_spectrograms`. <p></p> Implemented with GPU-compatible ops and supports gradients. <p></p> [Mel-Frequency Cepstral Coefficient (MFCC)][mfcc] calculation consists of
taking the DCT-II of a log-magnitude mel-scale spectrogram. [HTK][htk]'s MFCCs
use a particular scaling of the DCT-II which is almost orthogonal
normalization. We follow this convention. <p></p> All `num_mel_bins` MFCCs are returned and it is up to the caller to select
a subset of the MFCCs based on their application. For example, it is typical
to only use the first few for speech recognition, as this results in
an approximately pitch-invariant representation of the signal. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> log_mel_spectrograms
						</dt>
						<dd>A `[..., num_mel_bins]` `float32` `Tensor` of
log-magnitude mel-scale spectrograms. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `[..., num_mel_bins]` `float32` `Tensor` of the MFCCs of
`log_mel_spectrograms`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>sample_rate = 16000.0
            # A Tensor of [batch_size, num_samples] mono PCM samples in the range [-1, 1].
            pcm = tf.compat.v1.placeholder(tf.float32, [None, None]) <p></p> # A 1024-point STFT with frames of 64 ms and 75% overlap.
stfts = tf.signal.stft(pcm, frame_length=1024, frame_step=256,
                       fft_length=1024)
spectrograms = tf.abs(stfts) <p></p> # Warp the linear scale spectrograms into the mel-scale.
num_spectrogram_bins = stfts.shape[-1].value
lower_edge_hertz, upper_edge_hertz, num_mel_bins = 80.0, 7600.0, 80
linear_to_mel_weight_matrix = tf.signal.linear_to_mel_weight_matrix(
  num_mel_bins, num_spectrogram_bins, sample_rate, lower_edge_hertz,
  upper_edge_hertz)
mel_spectrograms = tf.tensordot(
  spectrograms, linear_to_mel_weight_matrix, 1)
mel_spectrograms.set_shape(spectrograms.shape[:-1].concatenate(
  linear_to_mel_weight_matrix.shape[-1:])) <p></p> # Compute a stabilized log to get log-magnitude mel-scale spectrograms.
log_mel_spectrograms = tf.math.log(mel_spectrograms + 1e-6) <p></p> # Compute MFCCs from log_mel_spectrograms and take the first 13.
mfccs = tf.signal.mfccs_from_log_mel_spectrograms(
  log_mel_spectrograms)[..., :13] </pre>
</div>
		</div>
	</div>
	<div id="overlap_and_add" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>overlap_and_add</strong>(<a href="../numpy/ndarray.htm">ndarray</a> signal, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> frame_step, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Reconstructs a signal from a framed representation. <p></p> Adds potentially overlapping frames of a signal with shape
`[..., frames, frame_length]`, offsetting subsequent frames by `frame_step`.
The resulting tensor has shape `[..., output_size]` where <p></p> output_size = (frames - 1) * frame_step + frame_length 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> signal
						</dt>
						<dd>A [..., frames, frame_length] `Tensor`. All dimensions may be
unknown, and rank must be at least 2. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> frame_step
						</dt>
						<dd>An integer or scalar `Tensor` denoting overlap offsets. Must be
less than or equal to `frame_length`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` with shape `[..., output_size]` containing the overlap-added
frames of `signal`'s inner-most two dimensions. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="overlap_and_add" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>overlap_and_add</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> signal, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> frame_step, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Reconstructs a signal from a framed representation. <p></p> Adds potentially overlapping frames of a signal with shape
`[..., frames, frame_length]`, offsetting subsequent frames by `frame_step`.
The resulting tensor has shape `[..., output_size]` where <p></p> output_size = (frames - 1) * frame_step + frame_length 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> signal
						</dt>
						<dd>A [..., frames, frame_length] `Tensor`. All dimensions may be
unknown, and rank must be at least 2. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> frame_step
						</dt>
						<dd>An integer or scalar `Tensor` denoting overlap offsets. Must be
less than or equal to `frame_length`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` with shape `[..., output_size]` containing the overlap-added
frames of `signal`'s inner-most two dimensions. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="overlap_and_add" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>overlap_and_add</strong>(<a href="../numpy/ndarray.htm">ndarray</a> signal, <span title="System.int">int</span> frame_step, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Reconstructs a signal from a framed representation. <p></p> Adds potentially overlapping frames of a signal with shape
`[..., frames, frame_length]`, offsetting subsequent frames by `frame_step`.
The resulting tensor has shape `[..., output_size]` where <p></p> output_size = (frames - 1) * frame_step + frame_length 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> signal
						</dt>
						<dd>A [..., frames, frame_length] `Tensor`. All dimensions may be
unknown, and rank must be at least 2. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> frame_step
						</dt>
						<dd>An integer or scalar `Tensor` denoting overlap offsets. Must be
less than or equal to `frame_length`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` with shape `[..., output_size]` containing the overlap-added
frames of `signal`'s inner-most two dimensions. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="overlap_and_add" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>overlap_and_add</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> signal, <span title="System.int">int</span> frame_step, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Reconstructs a signal from a framed representation. <p></p> Adds potentially overlapping frames of a signal with shape
`[..., frames, frame_length]`, offsetting subsequent frames by `frame_step`.
The resulting tensor has shape `[..., output_size]` where <p></p> output_size = (frames - 1) * frame_step + frame_length 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> signal
						</dt>
						<dd>A [..., frames, frame_length] `Tensor`. All dimensions may be
unknown, and rank must be at least 2. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> frame_step
						</dt>
						<dd>An integer or scalar `Tensor` denoting overlap offsets. Must be
less than or equal to `frame_length`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` with shape `[..., output_size]` containing the overlap-added
frames of `signal`'s inner-most two dimensions. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="overlap_and_add_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>overlap_and_add_dyn</strong>(<span title="System.object">object</span> signal, <span title="System.object">object</span> frame_step, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Reconstructs a signal from a framed representation. <p></p> Adds potentially overlapping frames of a signal with shape
`[..., frames, frame_length]`, offsetting subsequent frames by `frame_step`.
The resulting tensor has shape `[..., output_size]` where <p></p> output_size = (frames - 1) * frame_step + frame_length 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> signal
						</dt>
						<dd>A [..., frames, frame_length] `Tensor`. All dimensions may be
unknown, and rank must be at least 2. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> frame_step
						</dt>
						<dd>An integer or scalar `Tensor` denoting overlap offsets. Must be
less than or equal to `frame_length`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `Tensor` with shape `[..., output_size]` containing the overlap-added
frames of `signal`'s inner-most two dimensions. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="stft" class="method">
		<h4>
			<span title="System.object">object</span> <strong>stft</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> signals, <span title="System.int">int</span> frame_length, <span title="System.int">int</span> frame_step, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> fft_length, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> window_fn, <span title="System.bool">bool</span> pad_end, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Computes the [Short-time Fourier Transform][stft] of `signals`. <p></p> Implemented with GPU-compatible ops and supports gradients. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> signals
						</dt>
						<dd>A `[..., samples]` `float32` `Tensor` of real-valued signals. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> frame_length
						</dt>
						<dd>An integer scalar `Tensor`. The window length in samples. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> frame_step
						</dt>
						<dd>An integer scalar `Tensor`. The number of samples to step. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> fft_length
						</dt>
						<dd>An integer scalar `Tensor`. The size of the FFT to apply.
If not provided, uses the smallest power of 2 enclosing `frame_length`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> window_fn
						</dt>
						<dd>A callable that takes a window length and a `dtype` keyword
argument and returns a `[window_length]` `Tensor` of samples in the
provided datatype. If set to `None`, no windowing is used. 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> pad_end
						</dt>
						<dd>Whether to pad the end of `signals` with zeros when the provided
frame length and step produces a frame that lies partially past its end. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `[..., frames, fft_unique_bins]` `Tensor` of `complex64` STFT values where
`fft_unique_bins` is `fft_length // 2 + 1` (the unique components of the
FFT). 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="stft_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>stft_dyn</strong>(<span title="System.object">object</span> signals, <span title="System.object">object</span> frame_length, <span title="System.object">object</span> frame_step, <span title="System.object">object</span> fft_length, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> window_fn, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> pad_end, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Computes the [Short-time Fourier Transform][stft] of `signals`. <p></p> Implemented with GPU-compatible ops and supports gradients. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> signals
						</dt>
						<dd>A `[..., samples]` `float32` `Tensor` of real-valued signals. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> frame_length
						</dt>
						<dd>An integer scalar `Tensor`. The window length in samples. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> frame_step
						</dt>
						<dd>An integer scalar `Tensor`. The number of samples to step. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> fft_length
						</dt>
						<dd>An integer scalar `Tensor`. The size of the FFT to apply.
If not provided, uses the smallest power of 2 enclosing `frame_length`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> window_fn
						</dt>
						<dd>A callable that takes a window length and a `dtype` keyword
argument and returns a `[window_length]` `Tensor` of samples in the
provided datatype. If set to `None`, no windowing is used. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> pad_end
						</dt>
						<dd>Whether to pad the end of `signals` with zeros when the provided
frame length and step produces a frame that lies partially past its end. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>An optional name for the operation. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `[..., frames, fft_unique_bins]` `Tensor` of `complex64` STFT values where
`fft_unique_bins` is `fft_length // 2 + 1` (the unique components of the
FFT). 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	
	<h3 class="section">Public properties</h3>

	<div id="dct_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>dct_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="fftshift_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>fftshift_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="frame_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>frame_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="hamming_window_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>hamming_window_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="hann_window_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>hann_window_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="idct_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>idct_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="ifftshift_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>ifftshift_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="inverse_stft_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>inverse_stft_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="inverse_stft_window_fn_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>inverse_stft_window_fn_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="linear_to_mel_weight_matrix_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>linear_to_mel_weight_matrix_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="mfccs_from_log_mel_spectrograms_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>mfccs_from_log_mel_spectrograms_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="overlap_and_add_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>overlap_and_add_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="stft_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>stft_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	</section>
	</article><footer>
	<span id="version">Built from v1.15.0.0 of LostTech.TensorFlow</span>
	<span id="docu-link">
		Generated by <a href="http://docu.jagregory.com">docu</a>
	</span>
</footer>
  </body>
</html>