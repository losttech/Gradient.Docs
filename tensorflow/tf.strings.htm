<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
	<!--[if lt IE 9]>
	<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
    <title>tf.strings - LostTech.TensorFlow Documentation</title>
    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"/>
    <link type="text/css" rel="stylesheet" href="../main.css"/>
    <script type="text/javascript" src="../js/jquery-1.3.2.min.js"></script>
    <script type="text/javascript" src="../js/jquery.scrollTo-min.js"></script>
    <script type="text/javascript" src="../js/navigation.js"></script>
    <script type="text/javascript" src="../js/example.js"></script>
  </head>
  <body>
  	<header><h1>LostTech.TensorFlow : API Documentation</h1>
	</header>

    <nav id="namespaces">
      <iframe src="../namespaces.htm"></iframe>
    </nav><nav id="types">
  <h2 class="fixed">Types in tensorflow</h2>
	<div class="scroll">
		<ul>
				<li>
            <a href="../tensorflow/AggregationMethod.htm">AggregationMethod</a>
        </li>
				<li>
            <a href="../tensorflow/ConditionalAccumulator.htm">ConditionalAccumulator</a>
        </li>
				<li>
            <a href="../tensorflow/ConditionalAccumulatorBase.htm">ConditionalAccumulatorBase</a>
        </li>
				<li>
            <a href="../tensorflow/constant_initializer.htm">constant_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/CriticalSection.htm">CriticalSection</a>
        </li>
				<li>
            <a href="../tensorflow/DeviceSpec.htm">DeviceSpec</a>
        </li>
				<li>
            <a href="../tensorflow/Dimension.htm">Dimension</a>
        </li>
				<li>
            <a href="../tensorflow/DType.htm">DType</a>
        </li>
				<li>
            <a href="../tensorflow/FIFOQueue.htm">FIFOQueue</a>
        </li>
				<li>
            <a href="../tensorflow/FixedLenFeature.htm">FixedLenFeature</a>
        </li>
				<li>
            <a href="../tensorflow/FixedLengthRecordReader.htm">FixedLengthRecordReader</a>
        </li>
				<li>
            <a href="../tensorflow/FixedLenSequenceFeature.htm">FixedLenSequenceFeature</a>
        </li>
				<li>
            <a href="../tensorflow/glorot_normal_initializer.htm">glorot_normal_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/glorot_uniform_initializer.htm">glorot_uniform_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/GradientTape.htm">GradientTape</a>
        </li>
				<li>
            <a href="../tensorflow/Graph.htm">Graph</a>
        </li>
				<li>
            <a href="../tensorflow/Graph._ControlDependenciesController.htm">Graph._ControlDependenciesController</a>
        </li>
				<li>
            <a href="../tensorflow/Graph.I_ControlDependenciesController.htm">Graph.I_ControlDependenciesController</a>
        </li>
				<li>
            <a href="../tensorflow/GraphKeys.htm">GraphKeys</a>
        </li>
				<li>
            <a href="../tensorflow/HeadingAxes.htm">HeadingAxes</a>
        </li>
				<li>
            <a href="../tensorflow/IAggregationMethod.htm">IAggregationMethod</a>
        </li>
				<li>
            <a href="../tensorflow/IConditionalAccumulator.htm">IConditionalAccumulator</a>
        </li>
				<li>
            <a href="../tensorflow/IConditionalAccumulatorBase.htm">IConditionalAccumulatorBase</a>
        </li>
				<li>
            <a href="../tensorflow/Iconstant_initializer.htm">Iconstant_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/ICriticalSection.htm">ICriticalSection</a>
        </li>
				<li>
            <a href="../tensorflow/IdentityReader.htm">IdentityReader</a>
        </li>
				<li>
            <a href="../tensorflow/IDeviceSpec.htm">IDeviceSpec</a>
        </li>
				<li>
            <a href="../tensorflow/IDimension.htm">IDimension</a>
        </li>
				<li>
            <a href="../tensorflow/IDType.htm">IDType</a>
        </li>
				<li>
            <a href="../tensorflow/IFIFOQueue.htm">IFIFOQueue</a>
        </li>
				<li>
            <a href="../tensorflow/IFixedLenFeature.htm">IFixedLenFeature</a>
        </li>
				<li>
            <a href="../tensorflow/IFixedLengthRecordReader.htm">IFixedLengthRecordReader</a>
        </li>
				<li>
            <a href="../tensorflow/IFixedLenSequenceFeature.htm">IFixedLenSequenceFeature</a>
        </li>
				<li>
            <a href="../tensorflow/Iglorot_normal_initializer.htm">Iglorot_normal_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/Iglorot_uniform_initializer.htm">Iglorot_uniform_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/IGradientTape.htm">IGradientTape</a>
        </li>
				<li>
            <a href="../tensorflow/IGraph.htm">IGraph</a>
        </li>
				<li>
            <a href="../tensorflow/IGraphKeys.htm">IGraphKeys</a>
        </li>
				<li>
            <a href="../tensorflow/IIdentityReader.htm">IIdentityReader</a>
        </li>
				<li>
            <a href="../tensorflow/IIndexedSlices.htm">IIndexedSlices</a>
        </li>
				<li>
            <a href="../tensorflow/IIndexedSlicesSpec.htm">IIndexedSlicesSpec</a>
        </li>
				<li>
            <a href="../tensorflow/IInteractiveSession.htm">IInteractiveSession</a>
        </li>
				<li>
            <a href="../tensorflow/ILazyLoader.htm">ILazyLoader</a>
        </li>
				<li>
            <a href="../tensorflow/ILMDBReader.htm">ILMDBReader</a>
        </li>
				<li>
            <a href="../tensorflow/IModule.htm">IModule</a>
        </li>
				<li>
            <a href="../tensorflow/Iname_scope.htm">Iname_scope</a>
        </li>
				<li>
            <a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a>
        </li>
				<li>
            <a href="../tensorflow/IndexedSlicesSpec.htm">IndexedSlicesSpec</a>
        </li>
				<li>
            <a href="../tensorflow/InteractiveSession.htm">InteractiveSession</a>
        </li>
				<li>
            <a href="../tensorflow/Iones_initializer.htm">Iones_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/IOperation.htm">IOperation</a>
        </li>
				<li>
            <a href="../tensorflow/IOpError.htm">IOpError</a>
        </li>
				<li>
            <a href="../tensorflow/IOptionalSpec.htm">IOptionalSpec</a>
        </li>
				<li>
            <a href="../tensorflow/Iorthogonal_initializer.htm">Iorthogonal_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/IPaddingFIFOQueue.htm">IPaddingFIFOQueue</a>
        </li>
				<li>
            <a href="../tensorflow/IPriorityQueue.htm">IPriorityQueue</a>
        </li>
				<li>
            <a href="../tensorflow/IQueueBase.htm">IQueueBase</a>
        </li>
				<li>
            <a href="../tensorflow/IRaggedTensor.htm">IRaggedTensor</a>
        </li>
				<li>
            <a href="../tensorflow/IRaggedTensorSpec.htm">IRaggedTensorSpec</a>
        </li>
				<li>
            <a href="../tensorflow/Irandom_normal_initializer.htm">Irandom_normal_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/Irandom_uniform_initializer.htm">Irandom_uniform_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/IRandomShuffleQueue.htm">IRandomShuffleQueue</a>
        </li>
				<li>
            <a href="../tensorflow/IReaderBase.htm">IReaderBase</a>
        </li>
				<li>
            <a href="../tensorflow/IRegisterGradient.htm">IRegisterGradient</a>
        </li>
				<li>
            <a href="../tensorflow/ISession.htm">ISession</a>
        </li>
				<li>
            <a href="../tensorflow/ISparseConditionalAccumulator.htm">ISparseConditionalAccumulator</a>
        </li>
				<li>
            <a href="../tensorflow/ISparseFeature.htm">ISparseFeature</a>
        </li>
				<li>
            <a href="../tensorflow/ISparseTensor.htm">ISparseTensor</a>
        </li>
				<li>
            <a href="../tensorflow/ISparseTensorSpec.htm">ISparseTensorSpec</a>
        </li>
				<li>
            <a href="../tensorflow/ISparseTensorValue.htm">ISparseTensorValue</a>
        </li>
				<li>
            <a href="../tensorflow/ITensor.htm">ITensor</a>
        </li>
				<li>
            <a href="../tensorflow/ITensorArray.htm">ITensorArray</a>
        </li>
				<li>
            <a href="../tensorflow/ITensorArraySpec.htm">ITensorArraySpec</a>
        </li>
				<li>
            <a href="../tensorflow/ITensorShape.htm">ITensorShape</a>
        </li>
				<li>
            <a href="../tensorflow/ITensorSpec.htm">ITensorSpec</a>
        </li>
				<li>
            <a href="../tensorflow/ITextLineReader.htm">ITextLineReader</a>
        </li>
				<li>
            <a href="../tensorflow/ITFRecordReader.htm">ITFRecordReader</a>
        </li>
				<li>
            <a href="../tensorflow/Itruncated_normal_initializer.htm">Itruncated_normal_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/ITypeSpec.htm">ITypeSpec</a>
        </li>
				<li>
            <a href="../tensorflow/IUnconnectedGradients.htm">IUnconnectedGradients</a>
        </li>
				<li>
            <a href="../tensorflow/Iuniform_unit_scaling_initializer.htm">Iuniform_unit_scaling_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/IVariable.htm">IVariable</a>
        </li>
				<li>
            <a href="../tensorflow/Ivariable_scope.htm">Ivariable_scope</a>
        </li>
				<li>
            <a href="../tensorflow/IVariableScope.htm">IVariableScope</a>
        </li>
				<li>
            <a href="../tensorflow/Ivariance_scaling_initializer.htm">Ivariance_scaling_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/IVarLenFeature.htm">IVarLenFeature</a>
        </li>
				<li>
            <a href="../tensorflow/IWholeFileReader.htm">IWholeFileReader</a>
        </li>
				<li>
            <a href="../tensorflow/Izeros_initializer.htm">Izeros_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/LazyLoader.htm">LazyLoader</a>
        </li>
				<li>
            <a href="../tensorflow/LMDBReader.htm">LMDBReader</a>
        </li>
				<li>
            <a href="../tensorflow/Module.htm">Module</a>
        </li>
				<li>
            <a href="../tensorflow/name_scope.htm">name_scope</a>
        </li>
				<li>
            <a href="../tensorflow/ones_initializer.htm">ones_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/Operation.htm">Operation</a>
        </li>
				<li>
            <a href="../tensorflow/Operation._InputList.htm">Operation._InputList</a>
        </li>
				<li>
            <a href="../tensorflow/Operation.I_InputList.htm">Operation.I_InputList</a>
        </li>
				<li>
            <a href="../tensorflow/OpError.htm">OpError</a>
        </li>
				<li>
            <a href="../tensorflow/OptionalSpec.htm">OptionalSpec</a>
        </li>
				<li>
            <a href="../tensorflow/orthogonal_initializer.htm">orthogonal_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/PaddingFIFOQueue.htm">PaddingFIFOQueue</a>
        </li>
				<li>
            <a href="../tensorflow/PriorityQueue.htm">PriorityQueue</a>
        </li>
				<li>
            <a href="../tensorflow/QueueBase.htm">QueueBase</a>
        </li>
				<li>
            <a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a>
        </li>
				<li>
            <a href="../tensorflow/RaggedTensorSpec.htm">RaggedTensorSpec</a>
        </li>
				<li>
            <a href="../tensorflow/random_normal_initializer.htm">random_normal_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/random_uniform_initializer.htm">random_uniform_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/RandomShuffleQueue.htm">RandomShuffleQueue</a>
        </li>
				<li>
            <a href="../tensorflow/ReaderBase.htm">ReaderBase</a>
        </li>
				<li>
            <a href="../tensorflow/RegisterGradient.htm">RegisterGradient</a>
        </li>
				<li>
            <a href="../tensorflow/Session.htm">Session</a>
        </li>
				<li>
            <a href="../tensorflow/SparseConditionalAccumulator.htm">SparseConditionalAccumulator</a>
        </li>
				<li>
            <a href="../tensorflow/SparseFeature.htm">SparseFeature</a>
        </li>
				<li>
            <a href="../tensorflow/SparseTensor.htm">SparseTensor</a>
        </li>
				<li>
            <a href="../tensorflow/SparseTensorSpec.htm">SparseTensorSpec</a>
        </li>
				<li>
            <a href="../tensorflow/SparseTensorValue.htm">SparseTensorValue</a>
        </li>
				<li>
            <a href="../tensorflow/Tensor.htm">Tensor</a>
        </li>
				<li>
            <a href="../tensorflow/Tensor`1.htm">Tensor&lt;T&gt;</a>
        </li>
				<li>
            <a href="../tensorflow/TensorArray.htm">TensorArray</a>
        </li>
				<li>
            <a href="../tensorflow/TensorArraySpec.htm">TensorArraySpec</a>
        </li>
				<li>
            <a href="../tensorflow/TensorDimension.htm">TensorDimension</a>
        </li>
				<li>
            <a href="../tensorflow/TensorDimensionSlice.htm">TensorDimensionSlice</a>
        </li>
				<li>
            <a href="../tensorflow/TensorShape.htm">TensorShape</a>
        </li>
				<li>
            <a href="../tensorflow/TensorSpec.htm">TensorSpec</a>
        </li>
				<li>
            <a href="../tensorflow/TextLineReader.htm">TextLineReader</a>
        </li>
				<li>
            <a href="../tensorflow/tf.htm">tf</a>
        </li>
				<li>
            <a href="../tensorflow/tf.audio.htm">tf.audio</a>
        </li>
				<li>
            <a href="../tensorflow/tf.autograph.htm">tf.autograph</a>
        </li>
				<li>
            <a href="../tensorflow/tf.autograph.experimental.htm">tf.autograph.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.bitwise.htm">tf.bitwise</a>
        </li>
				<li>
            <a href="../tensorflow/tf.compat.htm">tf.compat</a>
        </li>
				<li>
            <a href="../tensorflow/tf.config.htm">tf.config</a>
        </li>
				<li>
            <a href="../tensorflow/tf.config.experimental.htm">tf.config.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.config.optimizer.htm">tf.config.optimizer</a>
        </li>
				<li>
            <a href="../tensorflow/tf.config.threading.htm">tf.config.threading</a>
        </li>
				<li>
            <a href="../tensorflow/tf.data.htm">tf.data</a>
        </li>
				<li>
            <a href="../tensorflow/tf.data.experimental.htm">tf.data.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.debugging.htm">tf.debugging</a>
        </li>
				<li>
            <a href="../tensorflow/tf.distribute.htm">tf.distribute</a>
        </li>
				<li>
            <a href="../tensorflow/tf.distributions.htm">tf.distributions</a>
        </li>
				<li>
            <a href="../tensorflow/tf.errors.htm">tf.errors</a>
        </li>
				<li>
            <a href="../tensorflow/tf.estimator.htm">tf.estimator</a>
        </li>
				<li>
            <a href="../tensorflow/tf.estimator.experimental.htm">tf.estimator.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.estimator.export.htm">tf.estimator.export</a>
        </li>
				<li>
            <a href="../tensorflow/tf.estimator.inputs.htm">tf.estimator.inputs</a>
        </li>
				<li>
            <a href="../tensorflow/tf.experimental.htm">tf.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.feature_column.htm">tf.feature_column</a>
        </li>
				<li>
            <a href="../tensorflow/tf.gfile.htm">tf.gfile</a>
        </li>
				<li>
            <a href="../tensorflow/tf.graph_util.htm">tf.graph_util</a>
        </li>
				<li>
            <a href="../tensorflow/tf.image.htm">tf.image</a>
        </li>
				<li>
            <a href="../tensorflow/tf.initializers.htm">tf.initializers</a>
        </li>
				<li>
            <a href="../tensorflow/tf.io.htm">tf.io</a>
        </li>
				<li>
            <a href="../tensorflow/tf.io.gfile.htm">tf.io.gfile</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.htm">tf.keras</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.activations.htm">tf.keras.activations</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.htm">tf.keras.applications</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.densenet.htm">tf.keras.applications.densenet</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.imagenet_utils.htm">tf.keras.applications.imagenet_utils</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.inception_resnet_v2.htm">tf.keras.applications.inception_resnet_v2</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.inception_v3.htm">tf.keras.applications.inception_v3</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.mobilenet.htm">tf.keras.applications.mobilenet</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.mobilenet_v2.htm">tf.keras.applications.mobilenet_v2</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.nasnet.htm">tf.keras.applications.nasnet</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.resnet.htm">tf.keras.applications.resnet</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.resnet_v2.htm">tf.keras.applications.resnet_v2</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.vgg16.htm">tf.keras.applications.vgg16</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.vgg19.htm">tf.keras.applications.vgg19</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.xception.htm">tf.keras.applications.xception</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.backend.htm">tf.keras.backend</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.constraints.htm">tf.keras.constraints</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.datasets.htm">tf.keras.datasets</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.datasets.boston_housing.htm">tf.keras.datasets.boston_housing</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.datasets.cifar10.htm">tf.keras.datasets.cifar10</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.datasets.cifar100.htm">tf.keras.datasets.cifar100</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.datasets.fashion_mnist.htm">tf.keras.datasets.fashion_mnist</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.datasets.imdb.htm">tf.keras.datasets.imdb</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.datasets.mnist.htm">tf.keras.datasets.mnist</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.datasets.reuters.htm">tf.keras.datasets.reuters</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.estimator.htm">tf.keras.estimator</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.experimental.htm">tf.keras.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.initializers.htm">tf.keras.initializers</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.layers.htm">tf.keras.layers</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.losses.htm">tf.keras.losses</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.metrics.htm">tf.keras.metrics</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.mixed_precision.htm">tf.keras.mixed_precision</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.mixed_precision.experimental.htm">tf.keras.mixed_precision.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.models.htm">tf.keras.models</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.optimizers.htm">tf.keras.optimizers</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.optimizers.schedules.htm">tf.keras.optimizers.schedules</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.preprocessing.htm">tf.keras.preprocessing</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.preprocessing.image.htm">tf.keras.preprocessing.image</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.regularizers.htm">tf.keras.regularizers</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.utils.htm">tf.keras.utils</a>
        </li>
				<li>
            <a href="../tensorflow/tf.layers.htm">tf.layers</a>
        </li>
				<li>
            <a href="../tensorflow/tf.layers.experimental.htm">tf.layers.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.linalg.htm">tf.linalg</a>
        </li>
				<li>
            <a href="../tensorflow/tf.lite.htm">tf.lite</a>
        </li>
				<li>
            <a href="../tensorflow/tf.lite.experimental.htm">tf.lite.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.lite.experimental.microfrontend.htm">tf.lite.experimental.microfrontend</a>
        </li>
				<li>
            <a href="../tensorflow/tf.lite.experimental.microfrontend.python.htm">tf.lite.experimental.microfrontend.python</a>
        </li>
				<li>
            <a href="../tensorflow/tf.lite.experimental.microfrontend.python.ops.htm">tf.lite.experimental.microfrontend.python.ops</a>
        </li>
				<li>
            <a href="../tensorflow/tf.lite.experimental.nn.htm">tf.lite.experimental.nn</a>
        </li>
				<li>
            <a href="../tensorflow/tf.logging.htm">tf.logging</a>
        </li>
				<li>
            <a href="../tensorflow/tf.losses.htm">tf.losses</a>
        </li>
				<li>
            <a href="../tensorflow/tf.math.htm">tf.math</a>
        </li>
				<li>
            <a href="../tensorflow/tf.metrics.htm">tf.metrics</a>
        </li>
				<li>
            <a href="../tensorflow/tf.nest.htm">tf.nest</a>
        </li>
				<li>
            <a href="../tensorflow/tf.nn.htm">tf.nn</a>
        </li>
				<li>
            <a href="../tensorflow/tf.profiler.htm">tf.profiler</a>
        </li>
				<li>
            <a href="../tensorflow/tf.quantization.htm">tf.quantization</a>
        </li>
				<li>
            <a href="../tensorflow/tf.ragged.htm">tf.ragged</a>
        </li>
				<li>
            <a href="../tensorflow/tf.random.htm">tf.random</a>
        </li>
				<li>
            <a href="../tensorflow/tf.random.experimental.htm">tf.random.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.resource_loader.htm">tf.resource_loader</a>
        </li>
				<li>
            <a href="../tensorflow/tf.saved_model.htm">tf.saved_model</a>
        </li>
				<li>
            <a href="../tensorflow/tf.saved_model.main_op.htm">tf.saved_model.main_op</a>
        </li>
				<li>
            <a href="../tensorflow/tf.sets.htm">tf.sets</a>
        </li>
				<li>
            <a href="../tensorflow/tf.signal.htm">tf.signal</a>
        </li>
				<li>
            <a href="../tensorflow/tf.sparse.htm">tf.sparse</a>
        </li>
				<li>
            <a href="../tensorflow/tf.strings.htm" class="current">tf.strings</a>
        </li>
				<li>
            <a href="../tensorflow/tf.summary.htm">tf.summary</a>
        </li>
				<li>
            <a href="../tensorflow/tf.summary.experimental.htm">tf.summary.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.sysconfig.htm">tf.sysconfig</a>
        </li>
				<li>
            <a href="../tensorflow/tf.test.htm">tf.test</a>
        </li>
				<li>
            <a href="../tensorflow/tf.tpu.htm">tf.tpu</a>
        </li>
				<li>
            <a href="../tensorflow/tf.tpu.experimental.htm">tf.tpu.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.train.htm">tf.train</a>
        </li>
				<li>
            <a href="../tensorflow/tf.train.experimental.htm">tf.train.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.user_ops.htm">tf.user_ops</a>
        </li>
				<li>
            <a href="../tensorflow/tf.xla.htm">tf.xla</a>
        </li>
				<li>
            <a href="../tensorflow/tf.xla.experimental.htm">tf.xla.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/TFRecordReader.htm">TFRecordReader</a>
        </li>
				<li>
            <a href="../tensorflow/truncated_normal_initializer.htm">truncated_normal_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/TypeSpec.htm">TypeSpec</a>
        </li>
				<li>
            <a href="../tensorflow/UnconnectedGradients.htm">UnconnectedGradients</a>
        </li>
				<li>
            <a href="../tensorflow/uniform_unit_scaling_initializer.htm">uniform_unit_scaling_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/Variable.htm">Variable</a>
        </li>
				<li>
            <a href="../tensorflow/variable_scope.htm">variable_scope</a>
        </li>
				<li>
            <a href="../tensorflow/VariableAggregation.htm">VariableAggregation</a>
        </li>
				<li>
            <a href="../tensorflow/VariableScope.htm">VariableScope</a>
        </li>
				<li>
            <a href="../tensorflow/VariableSynchronization.htm">VariableSynchronization</a>
        </li>
				<li>
            <a href="../tensorflow/variance_scaling_initializer.htm">variance_scaling_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/VarLenFeature.htm">VarLenFeature</a>
        </li>
				<li>
            <a href="../tensorflow/WholeFileReader.htm">WholeFileReader</a>
        </li>
				<li>
            <a href="../tensorflow/zeros_initializer.htm">zeros_initializer</a>
        </li>
		</ul>
	</div>
</nav>
	<article>
    <header>
		<p class="class"><strong>Type</strong> tf.strings</p>
	</header>
	<section>
		<header>
		<p><strong>Namespace</strong> tensorflow</p>
		</header>
    <div class="sub-header">
		
		
			<h3 class="section">Methods</h3>
			<ul>
				<li><a href="../tensorflow/tf.strings.htm#bytes_split">bytes_split</a></li>
				<li><a href="../tensorflow/tf.strings.htm#bytes_split">bytes_split</a></li>
				<li><a href="../tensorflow/tf.strings.htm#bytes_split_dyn">bytes_split_dyn</a></li>
				<li><a href="../tensorflow/tf.strings.htm#format">format</a></li>
				<li><a href="../tensorflow/tf.strings.htm#format">format</a></li>
				<li><a href="../tensorflow/tf.strings.htm#format">format</a></li>
				<li><a href="../tensorflow/tf.strings.htm#format">format</a></li>
				<li><a href="../tensorflow/tf.strings.htm#format">format</a></li>
				<li><a href="../tensorflow/tf.strings.htm#format">format</a></li>
				<li><a href="../tensorflow/tf.strings.htm#format">format</a></li>
				<li><a href="../tensorflow/tf.strings.htm#format">format</a></li>
				<li><a href="../tensorflow/tf.strings.htm#format">format</a></li>
				<li><a href="../tensorflow/tf.strings.htm#format">format</a></li>
				<li><a href="../tensorflow/tf.strings.htm#format">format</a></li>
				<li><a href="../tensorflow/tf.strings.htm#format">format</a></li>
				<li><a href="../tensorflow/tf.strings.htm#format_dyn">format_dyn</a></li>
				<li><a href="../tensorflow/tf.strings.htm#length">length</a></li>
				<li><a href="../tensorflow/tf.strings.htm#length_dyn">length_dyn</a></li>
				<li><a href="../tensorflow/tf.strings.htm#lower">lower</a></li>
				<li><a href="../tensorflow/tf.strings.htm#lower_dyn">lower_dyn</a></li>
				<li><a href="../tensorflow/tf.strings.htm#ngrams">ngrams</a></li>
				<li><a href="../tensorflow/tf.strings.htm#ngrams">ngrams</a></li>
				<li><a href="../tensorflow/tf.strings.htm#ngrams">ngrams</a></li>
				<li><a href="../tensorflow/tf.strings.htm#ngrams">ngrams</a></li>
				<li><a href="../tensorflow/tf.strings.htm#ngrams">ngrams</a></li>
				<li><a href="../tensorflow/tf.strings.htm#ngrams">ngrams</a></li>
				<li><a href="../tensorflow/tf.strings.htm#ngrams">ngrams</a></li>
				<li><a href="../tensorflow/tf.strings.htm#ngrams">ngrams</a></li>
				<li><a href="../tensorflow/tf.strings.htm#ngrams">ngrams</a></li>
				<li><a href="../tensorflow/tf.strings.htm#ngrams">ngrams</a></li>
				<li><a href="../tensorflow/tf.strings.htm#ngrams">ngrams</a></li>
				<li><a href="../tensorflow/tf.strings.htm#ngrams">ngrams</a></li>
				<li><a href="../tensorflow/tf.strings.htm#ngrams">ngrams</a></li>
				<li><a href="../tensorflow/tf.strings.htm#ngrams">ngrams</a></li>
				<li><a href="../tensorflow/tf.strings.htm#ngrams">ngrams</a></li>
				<li><a href="../tensorflow/tf.strings.htm#ngrams">ngrams</a></li>
				<li><a href="../tensorflow/tf.strings.htm#ngrams">ngrams</a></li>
				<li><a href="../tensorflow/tf.strings.htm#ngrams">ngrams</a></li>
				<li><a href="../tensorflow/tf.strings.htm#ngrams">ngrams</a></li>
				<li><a href="../tensorflow/tf.strings.htm#ngrams">ngrams</a></li>
				<li><a href="../tensorflow/tf.strings.htm#ngrams_dyn">ngrams_dyn</a></li>
				<li><a href="../tensorflow/tf.strings.htm#regex_full_match">regex_full_match</a></li>
				<li><a href="../tensorflow/tf.strings.htm#regex_full_match">regex_full_match</a></li>
				<li><a href="../tensorflow/tf.strings.htm#split">split</a></li>
				<li><a href="../tensorflow/tf.strings.htm#split">split</a></li>
				<li><a href="../tensorflow/tf.strings.htm#split">split</a></li>
				<li><a href="../tensorflow/tf.strings.htm#split">split</a></li>
				<li><a href="../tensorflow/tf.strings.htm#split">split</a></li>
				<li><a href="../tensorflow/tf.strings.htm#split">split</a></li>
				<li><a href="../tensorflow/tf.strings.htm#split">split</a></li>
				<li><a href="../tensorflow/tf.strings.htm#split">split</a></li>
				<li><a href="../tensorflow/tf.strings.htm#split">split</a></li>
				<li><a href="../tensorflow/tf.strings.htm#split_dyn">split_dyn</a></li>
				<li><a href="../tensorflow/tf.strings.htm#substr">substr</a></li>
				<li><a href="../tensorflow/tf.strings.htm#substr">substr</a></li>
				<li><a href="../tensorflow/tf.strings.htm#substr">substr</a></li>
				<li><a href="../tensorflow/tf.strings.htm#substr">substr</a></li>
				<li><a href="../tensorflow/tf.strings.htm#substr">substr</a></li>
				<li><a href="../tensorflow/tf.strings.htm#substr">substr</a></li>
				<li><a href="../tensorflow/tf.strings.htm#substr">substr</a></li>
				<li><a href="../tensorflow/tf.strings.htm#substr">substr</a></li>
				<li><a href="../tensorflow/tf.strings.htm#substr">substr</a></li>
				<li><a href="../tensorflow/tf.strings.htm#substr">substr</a></li>
				<li><a href="../tensorflow/tf.strings.htm#substr">substr</a></li>
				<li><a href="../tensorflow/tf.strings.htm#substr">substr</a></li>
				<li><a href="../tensorflow/tf.strings.htm#substr">substr</a></li>
				<li><a href="../tensorflow/tf.strings.htm#substr">substr</a></li>
				<li><a href="../tensorflow/tf.strings.htm#substr">substr</a></li>
				<li><a href="../tensorflow/tf.strings.htm#substr">substr</a></li>
				<li><a href="../tensorflow/tf.strings.htm#substr">substr</a></li>
				<li><a href="../tensorflow/tf.strings.htm#substr">substr</a></li>
				<li><a href="../tensorflow/tf.strings.htm#substr">substr</a></li>
				<li><a href="../tensorflow/tf.strings.htm#substr">substr</a></li>
				<li><a href="../tensorflow/tf.strings.htm#substr">substr</a></li>
				<li><a href="../tensorflow/tf.strings.htm#substr">substr</a></li>
				<li><a href="../tensorflow/tf.strings.htm#substr">substr</a></li>
				<li><a href="../tensorflow/tf.strings.htm#substr">substr</a></li>
				<li><a href="../tensorflow/tf.strings.htm#substr">substr</a></li>
				<li><a href="../tensorflow/tf.strings.htm#substr">substr</a></li>
				<li><a href="../tensorflow/tf.strings.htm#substr">substr</a></li>
				<li><a href="../tensorflow/tf.strings.htm#substr">substr</a></li>
				<li><a href="../tensorflow/tf.strings.htm#substr">substr</a></li>
				<li><a href="../tensorflow/tf.strings.htm#substr">substr</a></li>
				<li><a href="../tensorflow/tf.strings.htm#substr">substr</a></li>
				<li><a href="../tensorflow/tf.strings.htm#substr">substr</a></li>
				<li><a href="../tensorflow/tf.strings.htm#substr">substr</a></li>
				<li><a href="../tensorflow/tf.strings.htm#substr">substr</a></li>
				<li><a href="../tensorflow/tf.strings.htm#substr">substr</a></li>
				<li><a href="../tensorflow/tf.strings.htm#substr">substr</a></li>
				<li><a href="../tensorflow/tf.strings.htm#unicode_decode">unicode_decode</a></li>
				<li><a href="../tensorflow/tf.strings.htm#unicode_decode">unicode_decode</a></li>
				<li><a href="../tensorflow/tf.strings.htm#unicode_decode">unicode_decode</a></li>
				<li><a href="../tensorflow/tf.strings.htm#unicode_decode_dyn">unicode_decode_dyn</a></li>
				<li><a href="../tensorflow/tf.strings.htm#unicode_decode_with_offsets">unicode_decode_with_offsets</a></li>
				<li><a href="../tensorflow/tf.strings.htm#unicode_decode_with_offsets">unicode_decode_with_offsets</a></li>
				<li><a href="../tensorflow/tf.strings.htm#unicode_decode_with_offsets_dyn">unicode_decode_with_offsets_dyn</a></li>
				<li><a href="../tensorflow/tf.strings.htm#unicode_encode">unicode_encode</a></li>
				<li><a href="../tensorflow/tf.strings.htm#unicode_encode">unicode_encode</a></li>
				<li><a href="../tensorflow/tf.strings.htm#unicode_encode">unicode_encode</a></li>
				<li><a href="../tensorflow/tf.strings.htm#unicode_encode">unicode_encode</a></li>
				<li><a href="../tensorflow/tf.strings.htm#unicode_encode">unicode_encode</a></li>
				<li><a href="../tensorflow/tf.strings.htm#unicode_encode">unicode_encode</a></li>
				<li><a href="../tensorflow/tf.strings.htm#unicode_encode_dyn">unicode_encode_dyn</a></li>
				<li><a href="../tensorflow/tf.strings.htm#unicode_script">unicode_script</a></li>
				<li><a href="../tensorflow/tf.strings.htm#unicode_script_dyn">unicode_script_dyn</a></li>
				<li><a href="../tensorflow/tf.strings.htm#unicode_split">unicode_split</a></li>
				<li><a href="../tensorflow/tf.strings.htm#unicode_split">unicode_split</a></li>
				<li><a href="../tensorflow/tf.strings.htm#unicode_split">unicode_split</a></li>
				<li><a href="../tensorflow/tf.strings.htm#unicode_split_dyn">unicode_split_dyn</a></li>
				<li><a href="../tensorflow/tf.strings.htm#unicode_split_with_offsets">unicode_split_with_offsets</a></li>
				<li><a href="../tensorflow/tf.strings.htm#unicode_split_with_offsets">unicode_split_with_offsets</a></li>
				<li><a href="../tensorflow/tf.strings.htm#unicode_split_with_offsets_dyn">unicode_split_with_offsets_dyn</a></li>
				<li><a href="../tensorflow/tf.strings.htm#unicode_transcode">unicode_transcode</a></li>
				<li><a href="../tensorflow/tf.strings.htm#unicode_transcode_dyn">unicode_transcode_dyn</a></li>
				<li><a href="../tensorflow/tf.strings.htm#unsorted_segment_join">unsorted_segment_join</a></li>
				<li><a href="../tensorflow/tf.strings.htm#unsorted_segment_join_dyn">unsorted_segment_join_dyn</a></li>
				<li><a href="../tensorflow/tf.strings.htm#upper">upper</a></li>
				<li><a href="../tensorflow/tf.strings.htm#upper_dyn">upper_dyn</a></li>
			</ul>
		
			<h3 class="section">Properties</h3>
			<ul>
				<li><a href="../tensorflow/tf.strings.htm#bytes_split_fn">bytes_split_fn</a></li>
				<li><a href="../tensorflow/tf.strings.htm#format_fn">format_fn</a></li>
				<li><a href="../tensorflow/tf.strings.htm#length_fn">length_fn</a></li>
				<li><a href="../tensorflow/tf.strings.htm#lower_fn">lower_fn</a></li>
				<li><a href="../tensorflow/tf.strings.htm#ngrams_fn">ngrams_fn</a></li>
				<li><a href="../tensorflow/tf.strings.htm#regex_full_match_fn">regex_full_match_fn</a></li>
				<li><a href="../tensorflow/tf.strings.htm#split_fn_">split_fn_</a></li>
				<li><a href="../tensorflow/tf.strings.htm#substr_fn">substr_fn</a></li>
				<li><a href="../tensorflow/tf.strings.htm#unicode_decode_fn">unicode_decode_fn</a></li>
				<li><a href="../tensorflow/tf.strings.htm#unicode_decode_with_offsets_fn">unicode_decode_with_offsets_fn</a></li>
				<li><a href="../tensorflow/tf.strings.htm#unicode_encode_fn">unicode_encode_fn</a></li>
				<li><a href="../tensorflow/tf.strings.htm#unicode_script_fn">unicode_script_fn</a></li>
				<li><a href="../tensorflow/tf.strings.htm#unicode_split_fn">unicode_split_fn</a></li>
				<li><a href="../tensorflow/tf.strings.htm#unicode_split_with_offsets_fn">unicode_split_with_offsets_fn</a></li>
				<li><a href="../tensorflow/tf.strings.htm#unicode_transcode_fn">unicode_transcode_fn</a></li>
				<li><a href="../tensorflow/tf.strings.htm#unsorted_segment_join_fn">unsorted_segment_join_fn</a></li>
				<li><a href="../tensorflow/tf.strings.htm#upper_fn">upper_fn</a></li>
			</ul>
		
	</div>
	
	
	<h3 class="section">Public static methods</h3>

	<div id="bytes_split" class="method">
		<h4>
			<span title="System.object">object</span> <strong>bytes_split</strong>(<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> input, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Split string elements of `input` into bytes. <p></p> Examples:
Note that this op splits strings into bytes, not unicode characters.  To
split strings into unicode characters, use <a href="..\..\tf\strings\unicode_split.md"><code>tf.strings.unicode_split</code></a>. <p></p> See also: <a href="..\..\tf\decode_raw.md"><code>tf.io.decode_raw</code></a>, <a href="..\..\tf\strings\split.md"><code>tf.strings.split</code></a>, <a href="..\..\tf\strings\unicode_split.md"><code>tf.strings.unicode_split</code></a>. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code> input
						</dt>
						<dd>A string `Tensor` or `RaggedTensor`: the strings to split.  Must
have a statically known rank (`N`). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `RaggedTensor` of rank `N+1`: the bytes that make up the source strings. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> tf.strings.bytes_split('hello')
            ['h', 'e', 'l', 'l', 'o']
            >>> tf.strings.bytes_split(['hello', '123'])
            <RaggedTensor [['h', 'e', 'l', 'l', 'o'], ['1', '2', '3']]> </pre>
</div>
		</div>
	</div>
	<div id="bytes_split" class="method">
		<h4>
			<span title="System.object">object</span> <strong>bytes_split</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> input, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Split string elements of `input` into bytes. <p></p> Examples:
Note that this op splits strings into bytes, not unicode characters.  To
split strings into unicode characters, use <a href="..\..\tf\strings\unicode_split.md"><code>tf.strings.unicode_split</code></a>. <p></p> See also: <a href="..\..\tf\decode_raw.md"><code>tf.io.decode_raw</code></a>, <a href="..\..\tf\strings\split.md"><code>tf.strings.split</code></a>, <a href="..\..\tf\strings\unicode_split.md"><code>tf.strings.unicode_split</code></a>. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> input
						</dt>
						<dd>A string `Tensor` or `RaggedTensor`: the strings to split.  Must
have a statically known rank (`N`). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `RaggedTensor` of rank `N+1`: the bytes that make up the source strings. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> tf.strings.bytes_split('hello')
            ['h', 'e', 'l', 'l', 'o']
            >>> tf.strings.bytes_split(['hello', '123'])
            <RaggedTensor [['h', 'e', 'l', 'l', 'o'], ['1', '2', '3']]> </pre>
</div>
		</div>
	</div>
	<div id="bytes_split_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>bytes_split_dyn</strong>(<span title="System.object">object</span> input, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Split string elements of `input` into bytes. <p></p> Examples:
Note that this op splits strings into bytes, not unicode characters.  To
split strings into unicode characters, use <a href="..\..\tf\strings\unicode_split.md"><code>tf.strings.unicode_split</code></a>. <p></p> See also: <a href="..\..\tf\decode_raw.md"><code>tf.io.decode_raw</code></a>, <a href="..\..\tf\strings\split.md"><code>tf.strings.split</code></a>, <a href="..\..\tf\strings\unicode_split.md"><code>tf.strings.unicode_split</code></a>. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> input
						</dt>
						<dd>A string `Tensor` or `RaggedTensor`: the strings to split.  Must
have a statically known rank (`N`). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `RaggedTensor` of rank `N+1`: the bytes that make up the source strings. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> tf.strings.bytes_split('hello')
            ['h', 'e', 'l', 'l', 'o']
            >>> tf.strings.bytes_split(['hello', '123'])
            <RaggedTensor [['h', 'e', 'l', 'l', 'o'], ['1', '2', '3']]> </pre>
</div>
		</div>
	</div>
	<div id="format" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>format</strong>(<span title="System.string">string</span> template, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> inputs, <span title="System.string">string</span> placeholder, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> summarize, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Formats a string template using a list of tensors. <p></p> Formats a string template using a list of tensors, abbreviating tensors by
only printing the first and last `summarize` elements of each dimension
(recursively). If formatting only one tensor into a template, the tensor does
not have to be wrapped in a list. <p></p> Example:
Formatting a single-tensor template:
Formatting a multi-tensor template: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.string">string</span></code> template
						</dt>
						<dd>A string template to format tensor values into. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> inputs
						</dt>
						<dd>A list of `Tensor` objects, or a single Tensor.
The list of tensors to format into the template string. If a solitary
tensor is passed in, the input tensor will automatically be wrapped as a
list. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> placeholder
						</dt>
						<dd>An optional `string`. Defaults to `{}`.
At each placeholder occurring in the template, a subsequent tensor
will be inserted. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> summarize
						</dt>
						<dd>An optional `int`. Defaults to `3`.
When formatting the tensors, show the first and last `summarize`
entries of each tensor dimension (recursively). If set to -1, all
elements of the tensor will be shown. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A scalar `Tensor` of type `string`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>sess = tf.compat.v1.Session()
            with sess.as_default():
                tensor = tf.range(10)
                formatted = tf.strings.format("tensor: {}, suffix", tensor)
                out = sess.run(formatted)
                expected = "tensor: [0 1 2... 7 8 9], suffix" <p></p> assert(out.decode() == expected) <p></p> </pre>
</div>
		</div>
	</div>
	<div id="format" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>format</strong>(<span title="System.string">string</span> template, <span title="System.ValueTuple">ValueTuple</span> inputs, <span title="System.string">string</span> placeholder, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> summarize, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Formats a string template using a list of tensors. <p></p> Formats a string template using a list of tensors, abbreviating tensors by
only printing the first and last `summarize` elements of each dimension
(recursively). If formatting only one tensor into a template, the tensor does
not have to be wrapped in a list. <p></p> Example:
Formatting a single-tensor template:
Formatting a multi-tensor template: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.string">string</span></code> template
						</dt>
						<dd>A string template to format tensor values into. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple">ValueTuple</span></code> inputs
						</dt>
						<dd>A list of `Tensor` objects, or a single Tensor.
The list of tensors to format into the template string. If a solitary
tensor is passed in, the input tensor will automatically be wrapped as a
list. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> placeholder
						</dt>
						<dd>An optional `string`. Defaults to `{}`.
At each placeholder occurring in the template, a subsequent tensor
will be inserted. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> summarize
						</dt>
						<dd>An optional `int`. Defaults to `3`.
When formatting the tensors, show the first and last `summarize`
entries of each tensor dimension (recursively). If set to -1, all
elements of the tensor will be shown. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A scalar `Tensor` of type `string`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>sess = tf.compat.v1.Session()
            with sess.as_default():
                tensor = tf.range(10)
                formatted = tf.strings.format("tensor: {}, suffix", tensor)
                out = sess.run(formatted)
                expected = "tensor: [0 1 2... 7 8 9], suffix" <p></p> assert(out.decode() == expected) <p></p> </pre>
</div>
		</div>
	</div>
	<div id="format" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>format</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> template, <span title="System.ValueTuple">ValueTuple</span> inputs, <span title="System.string">string</span> placeholder, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> summarize, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Formats a string template using a list of tensors. <p></p> Formats a string template using a list of tensors, abbreviating tensors by
only printing the first and last `summarize` elements of each dimension
(recursively). If formatting only one tensor into a template, the tensor does
not have to be wrapped in a list. <p></p> Example:
Formatting a single-tensor template:
Formatting a multi-tensor template: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> template
						</dt>
						<dd>A string template to format tensor values into. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple">ValueTuple</span></code> inputs
						</dt>
						<dd>A list of `Tensor` objects, or a single Tensor.
The list of tensors to format into the template string. If a solitary
tensor is passed in, the input tensor will automatically be wrapped as a
list. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> placeholder
						</dt>
						<dd>An optional `string`. Defaults to `{}`.
At each placeholder occurring in the template, a subsequent tensor
will be inserted. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> summarize
						</dt>
						<dd>An optional `int`. Defaults to `3`.
When formatting the tensors, show the first and last `summarize`
entries of each tensor dimension (recursively). If set to -1, all
elements of the tensor will be shown. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A scalar `Tensor` of type `string`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>sess = tf.compat.v1.Session()
            with sess.as_default():
                tensor = tf.range(10)
                formatted = tf.strings.format("tensor: {}, suffix", tensor)
                out = sess.run(formatted)
                expected = "tensor: [0 1 2... 7 8 9], suffix" <p></p> assert(out.decode() == expected) <p></p> </pre>
</div>
		</div>
	</div>
	<div id="format" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>format</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> template, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> inputs, <span title="System.string">string</span> placeholder, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> summarize, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Formats a string template using a list of tensors. <p></p> Formats a string template using a list of tensors, abbreviating tensors by
only printing the first and last `summarize` elements of each dimension
(recursively). If formatting only one tensor into a template, the tensor does
not have to be wrapped in a list. <p></p> Example:
Formatting a single-tensor template:
Formatting a multi-tensor template: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> template
						</dt>
						<dd>A string template to format tensor values into. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> inputs
						</dt>
						<dd>A list of `Tensor` objects, or a single Tensor.
The list of tensors to format into the template string. If a solitary
tensor is passed in, the input tensor will automatically be wrapped as a
list. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> placeholder
						</dt>
						<dd>An optional `string`. Defaults to `{}`.
At each placeholder occurring in the template, a subsequent tensor
will be inserted. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> summarize
						</dt>
						<dd>An optional `int`. Defaults to `3`.
When formatting the tensors, show the first and last `summarize`
entries of each tensor dimension (recursively). If set to -1, all
elements of the tensor will be shown. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A scalar `Tensor` of type `string`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>sess = tf.compat.v1.Session()
            with sess.as_default():
                tensor = tf.range(10)
                formatted = tf.strings.format("tensor: {}, suffix", tensor)
                out = sess.run(formatted)
                expected = "tensor: [0 1 2... 7 8 9], suffix" <p></p> assert(out.decode() == expected) <p></p> </pre>
</div>
		</div>
	</div>
	<div id="format" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>format</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> template, <span title="System.ValueTuple">ValueTuple</span> inputs, <span title="System.string">string</span> placeholder, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> summarize, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Formats a string template using a list of tensors. <p></p> Formats a string template using a list of tensors, abbreviating tensors by
only printing the first and last `summarize` elements of each dimension
(recursively). If formatting only one tensor into a template, the tensor does
not have to be wrapped in a list. <p></p> Example:
Formatting a single-tensor template:
Formatting a multi-tensor template: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> template
						</dt>
						<dd>A string template to format tensor values into. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple">ValueTuple</span></code> inputs
						</dt>
						<dd>A list of `Tensor` objects, or a single Tensor.
The list of tensors to format into the template string. If a solitary
tensor is passed in, the input tensor will automatically be wrapped as a
list. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> placeholder
						</dt>
						<dd>An optional `string`. Defaults to `{}`.
At each placeholder occurring in the template, a subsequent tensor
will be inserted. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> summarize
						</dt>
						<dd>An optional `int`. Defaults to `3`.
When formatting the tensors, show the first and last `summarize`
entries of each tensor dimension (recursively). If set to -1, all
elements of the tensor will be shown. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A scalar `Tensor` of type `string`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>sess = tf.compat.v1.Session()
            with sess.as_default():
                tensor = tf.range(10)
                formatted = tf.strings.format("tensor: {}, suffix", tensor)
                out = sess.run(formatted)
                expected = "tensor: [0 1 2... 7 8 9], suffix" <p></p> assert(out.decode() == expected) <p></p> </pre>
</div>
		</div>
	</div>
	<div id="format" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>format</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> template, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> inputs, <span title="System.string">string</span> placeholder, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> summarize, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Formats a string template using a list of tensors. <p></p> Formats a string template using a list of tensors, abbreviating tensors by
only printing the first and last `summarize` elements of each dimension
(recursively). If formatting only one tensor into a template, the tensor does
not have to be wrapped in a list. <p></p> Example:
Formatting a single-tensor template:
Formatting a multi-tensor template: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> template
						</dt>
						<dd>A string template to format tensor values into. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> inputs
						</dt>
						<dd>A list of `Tensor` objects, or a single Tensor.
The list of tensors to format into the template string. If a solitary
tensor is passed in, the input tensor will automatically be wrapped as a
list. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> placeholder
						</dt>
						<dd>An optional `string`. Defaults to `{}`.
At each placeholder occurring in the template, a subsequent tensor
will be inserted. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> summarize
						</dt>
						<dd>An optional `int`. Defaults to `3`.
When formatting the tensors, show the first and last `summarize`
entries of each tensor dimension (recursively). If set to -1, all
elements of the tensor will be shown. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A scalar `Tensor` of type `string`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>sess = tf.compat.v1.Session()
            with sess.as_default():
                tensor = tf.range(10)
                formatted = tf.strings.format("tensor: {}, suffix", tensor)
                out = sess.run(formatted)
                expected = "tensor: [0 1 2... 7 8 9], suffix" <p></p> assert(out.decode() == expected) <p></p> </pre>
</div>
		</div>
	</div>
	<div id="format" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>format</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> template, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> inputs, <span title="System.string">string</span> placeholder, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> summarize, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Formats a string template using a list of tensors. <p></p> Formats a string template using a list of tensors, abbreviating tensors by
only printing the first and last `summarize` elements of each dimension
(recursively). If formatting only one tensor into a template, the tensor does
not have to be wrapped in a list. <p></p> Example:
Formatting a single-tensor template:
Formatting a multi-tensor template: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> template
						</dt>
						<dd>A string template to format tensor values into. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> inputs
						</dt>
						<dd>A list of `Tensor` objects, or a single Tensor.
The list of tensors to format into the template string. If a solitary
tensor is passed in, the input tensor will automatically be wrapped as a
list. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> placeholder
						</dt>
						<dd>An optional `string`. Defaults to `{}`.
At each placeholder occurring in the template, a subsequent tensor
will be inserted. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> summarize
						</dt>
						<dd>An optional `int`. Defaults to `3`.
When formatting the tensors, show the first and last `summarize`
entries of each tensor dimension (recursively). If set to -1, all
elements of the tensor will be shown. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A scalar `Tensor` of type `string`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>sess = tf.compat.v1.Session()
            with sess.as_default():
                tensor = tf.range(10)
                formatted = tf.strings.format("tensor: {}, suffix", tensor)
                out = sess.run(formatted)
                expected = "tensor: [0 1 2... 7 8 9], suffix" <p></p> assert(out.decode() == expected) <p></p> </pre>
</div>
		</div>
	</div>
	<div id="format" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>format</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> template, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> inputs, <span title="System.string">string</span> placeholder, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> summarize, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Formats a string template using a list of tensors. <p></p> Formats a string template using a list of tensors, abbreviating tensors by
only printing the first and last `summarize` elements of each dimension
(recursively). If formatting only one tensor into a template, the tensor does
not have to be wrapped in a list. <p></p> Example:
Formatting a single-tensor template:
Formatting a multi-tensor template: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> template
						</dt>
						<dd>A string template to format tensor values into. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> inputs
						</dt>
						<dd>A list of `Tensor` objects, or a single Tensor.
The list of tensors to format into the template string. If a solitary
tensor is passed in, the input tensor will automatically be wrapped as a
list. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> placeholder
						</dt>
						<dd>An optional `string`. Defaults to `{}`.
At each placeholder occurring in the template, a subsequent tensor
will be inserted. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> summarize
						</dt>
						<dd>An optional `int`. Defaults to `3`.
When formatting the tensors, show the first and last `summarize`
entries of each tensor dimension (recursively). If set to -1, all
elements of the tensor will be shown. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A scalar `Tensor` of type `string`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>sess = tf.compat.v1.Session()
            with sess.as_default():
                tensor = tf.range(10)
                formatted = tf.strings.format("tensor: {}, suffix", tensor)
                out = sess.run(formatted)
                expected = "tensor: [0 1 2... 7 8 9], suffix" <p></p> assert(out.decode() == expected) <p></p> </pre>
</div>
		</div>
	</div>
	<div id="format" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>format</strong>(<span title="System.string">string</span> template, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> inputs, <span title="System.string">string</span> placeholder, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> summarize, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Formats a string template using a list of tensors. <p></p> Formats a string template using a list of tensors, abbreviating tensors by
only printing the first and last `summarize` elements of each dimension
(recursively). If formatting only one tensor into a template, the tensor does
not have to be wrapped in a list. <p></p> Example:
Formatting a single-tensor template:
Formatting a multi-tensor template: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.string">string</span></code> template
						</dt>
						<dd>A string template to format tensor values into. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> inputs
						</dt>
						<dd>A list of `Tensor` objects, or a single Tensor.
The list of tensors to format into the template string. If a solitary
tensor is passed in, the input tensor will automatically be wrapped as a
list. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> placeholder
						</dt>
						<dd>An optional `string`. Defaults to `{}`.
At each placeholder occurring in the template, a subsequent tensor
will be inserted. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> summarize
						</dt>
						<dd>An optional `int`. Defaults to `3`.
When formatting the tensors, show the first and last `summarize`
entries of each tensor dimension (recursively). If set to -1, all
elements of the tensor will be shown. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A scalar `Tensor` of type `string`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>sess = tf.compat.v1.Session()
            with sess.as_default():
                tensor = tf.range(10)
                formatted = tf.strings.format("tensor: {}, suffix", tensor)
                out = sess.run(formatted)
                expected = "tensor: [0 1 2... 7 8 9], suffix" <p></p> assert(out.decode() == expected) <p></p> </pre>
</div>
		</div>
	</div>
	<div id="format" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>format</strong>(<span title="System.string">string</span> template, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> inputs, <span title="System.string">string</span> placeholder, <a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> summarize, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Formats a string template using a list of tensors. <p></p> Formats a string template using a list of tensors, abbreviating tensors by
only printing the first and last `summarize` elements of each dimension
(recursively). If formatting only one tensor into a template, the tensor does
not have to be wrapped in a list. <p></p> Example:
Formatting a single-tensor template:
Formatting a multi-tensor template: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.string">string</span></code> template
						</dt>
						<dd>A string template to format tensor values into. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> inputs
						</dt>
						<dd>A list of `Tensor` objects, or a single Tensor.
The list of tensors to format into the template string. If a solitary
tensor is passed in, the input tensor will automatically be wrapped as a
list. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> placeholder
						</dt>
						<dd>An optional `string`. Defaults to `{}`.
At each placeholder occurring in the template, a subsequent tensor
will be inserted. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> summarize
						</dt>
						<dd>An optional `int`. Defaults to `3`.
When formatting the tensors, show the first and last `summarize`
entries of each tensor dimension (recursively). If set to -1, all
elements of the tensor will be shown. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A scalar `Tensor` of type `string`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>sess = tf.compat.v1.Session()
            with sess.as_default():
                tensor = tf.range(10)
                formatted = tf.strings.format("tensor: {}, suffix", tensor)
                out = sess.run(formatted)
                expected = "tensor: [0 1 2... 7 8 9], suffix" <p></p> assert(out.decode() == expected) <p></p> </pre>
</div>
		</div>
	</div>
	<div id="format" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>format</strong>(<span title="System.string">string</span> template, <span title="System.ValueTuple">ValueTuple</span> inputs, <span title="System.string">string</span> placeholder, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> summarize, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Formats a string template using a list of tensors. <p></p> Formats a string template using a list of tensors, abbreviating tensors by
only printing the first and last `summarize` elements of each dimension
(recursively). If formatting only one tensor into a template, the tensor does
not have to be wrapped in a list. <p></p> Example:
Formatting a single-tensor template:
Formatting a multi-tensor template: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.string">string</span></code> template
						</dt>
						<dd>A string template to format tensor values into. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple">ValueTuple</span></code> inputs
						</dt>
						<dd>A list of `Tensor` objects, or a single Tensor.
The list of tensors to format into the template string. If a solitary
tensor is passed in, the input tensor will automatically be wrapped as a
list. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> placeholder
						</dt>
						<dd>An optional `string`. Defaults to `{}`.
At each placeholder occurring in the template, a subsequent tensor
will be inserted. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> summarize
						</dt>
						<dd>An optional `int`. Defaults to `3`.
When formatting the tensors, show the first and last `summarize`
entries of each tensor dimension (recursively). If set to -1, all
elements of the tensor will be shown. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A scalar `Tensor` of type `string`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>sess = tf.compat.v1.Session()
            with sess.as_default():
                tensor = tf.range(10)
                formatted = tf.strings.format("tensor: {}, suffix", tensor)
                out = sess.run(formatted)
                expected = "tensor: [0 1 2... 7 8 9], suffix" <p></p> assert(out.decode() == expected) <p></p> </pre>
</div>
		</div>
	</div>
	<div id="format" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>format</strong>(<span title="System.string">string</span> template, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> inputs, <span title="System.string">string</span> placeholder, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> summarize, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Formats a string template using a list of tensors. <p></p> Formats a string template using a list of tensors, abbreviating tensors by
only printing the first and last `summarize` elements of each dimension
(recursively). If formatting only one tensor into a template, the tensor does
not have to be wrapped in a list. <p></p> Example:
Formatting a single-tensor template:
Formatting a multi-tensor template: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.string">string</span></code> template
						</dt>
						<dd>A string template to format tensor values into. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> inputs
						</dt>
						<dd>A list of `Tensor` objects, or a single Tensor.
The list of tensors to format into the template string. If a solitary
tensor is passed in, the input tensor will automatically be wrapped as a
list. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> placeholder
						</dt>
						<dd>An optional `string`. Defaults to `{}`.
At each placeholder occurring in the template, a subsequent tensor
will be inserted. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> summarize
						</dt>
						<dd>An optional `int`. Defaults to `3`.
When formatting the tensors, show the first and last `summarize`
entries of each tensor dimension (recursively). If set to -1, all
elements of the tensor will be shown. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A scalar `Tensor` of type `string`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>sess = tf.compat.v1.Session()
            with sess.as_default():
                tensor = tf.range(10)
                formatted = tf.strings.format("tensor: {}, suffix", tensor)
                out = sess.run(formatted)
                expected = "tensor: [0 1 2... 7 8 9], suffix" <p></p> assert(out.decode() == expected) <p></p> </pre>
</div>
		</div>
	</div>
	<div id="format_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>format_dyn</strong>(<span title="System.object">object</span> template, <span title="System.object">object</span> inputs, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> placeholder, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> summarize, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Formats a string template using a list of tensors. <p></p> Formats a string template using a list of tensors, abbreviating tensors by
only printing the first and last `summarize` elements of each dimension
(recursively). If formatting only one tensor into a template, the tensor does
not have to be wrapped in a list. <p></p> Example:
Formatting a single-tensor template:
Formatting a multi-tensor template: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> template
						</dt>
						<dd>A string template to format tensor values into. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> inputs
						</dt>
						<dd>A list of `Tensor` objects, or a single Tensor.
The list of tensors to format into the template string. If a solitary
tensor is passed in, the input tensor will automatically be wrapped as a
list. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> placeholder
						</dt>
						<dd>An optional `string`. Defaults to `{}`.
At each placeholder occurring in the template, a subsequent tensor
will be inserted. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> summarize
						</dt>
						<dd>An optional `int`. Defaults to `3`.
When formatting the tensors, show the first and last `summarize`
entries of each tensor dimension (recursively). If set to -1, all
elements of the tensor will be shown. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A scalar `Tensor` of type `string`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>sess = tf.compat.v1.Session()
            with sess.as_default():
                tensor = tf.range(10)
                formatted = tf.strings.format("tensor: {}, suffix", tensor)
                out = sess.run(formatted)
                expected = "tensor: [0 1 2... 7 8 9], suffix" <p></p> assert(out.decode() == expected) <p></p> </pre>
</div>
		</div>
	</div>
	<div id="length" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>length</strong>(<span title="System.Collections.Generic.IEnumerable<Byte[]>">IEnumerable&lt;Byte[]&gt;</span> input, <span title="System.string">string</span> name, <span title="System.string">string</span> unit)
		</h4>
		<div class="content">String lengths of `input`. <p></p> Computes the length of each string given in the input tensor. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<Byte[]>">IEnumerable&lt;Byte[]&gt;</span></code> input
						</dt>
						<dd>A `Tensor` of type `string`.
The string for which to compute the length. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> unit
						</dt>
						<dd>An optional `string` from: `"BYTE", "UTF8_CHAR"`. Defaults to `"BYTE"`.
The unit that is counted to compute string length.  One of: `"BYTE"` (for
the number of bytes in each string) or `"UTF8_CHAR"` (for the number of UTF-8
encoded Unicode code points in each string).  Results are undefined
if `unit=UTF8_CHAR` and the `input` strings do not contain structurally
valid UTF-8. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of type `int32`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="length_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>length_dyn</strong>(<span title="System.object">object</span> input, <span title="System.object">object</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> unit)
		</h4>
		<div class="content">String lengths of `input`. <p></p> Computes the length of each string given in the input tensor. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> input
						</dt>
						<dd>A `Tensor` of type `string`.
The string for which to compute the length. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> unit
						</dt>
						<dd>An optional `string` from: `"BYTE", "UTF8_CHAR"`. Defaults to `"BYTE"`.
The unit that is counted to compute string length.  One of: `"BYTE"` (for
the number of bytes in each string) or `"UTF8_CHAR"` (for the number of UTF-8
encoded Unicode code points in each string).  Results are undefined
if `unit=UTF8_CHAR` and the `input` strings do not contain structurally
valid UTF-8. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `Tensor` of type `int32`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="lower" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>lower</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> input, <span title="System.string">string</span> encoding, <span title="System.string">string</span> name)
		</h4>
		<div class="content">TODO: add doc. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> input
						</dt>
						<dd>A `Tensor` of type `string`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> encoding
						</dt>
						<dd>An optional `string`. Defaults to `""`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of type `string`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="lower_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>lower_dyn</strong>(<span title="System.object">object</span> input, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> encoding, <span title="System.object">object</span> name)
		</h4>
		<div class="content">TODO: add doc. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> input
						</dt>
						<dd>A `Tensor` of type `string`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> encoding
						</dt>
						<dd>An optional `string`. Defaults to `""`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `Tensor` of type `string`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="ngrams" class="method">
		<h4>
			<span title="System.object">object</span> <strong>ngrams</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> data, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> ngram_width, <span title="System.string">string</span> separator, <span title="System.object">object</span> pad_values, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> padding_width, <span title="System.bool">bool</span> preserve_short_sequences, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Create a tensor of n-grams based on `data`. <p></p> Creates a tensor of n-grams based on `data`. The n-grams are created by
joining windows of `width` adjacent strings from the inner axis of `data`
using `separator`. <p></p> The input data can be padded on both the start and end of the sequence, if
desired, using the `pad_values` argument. If set, `pad_values` should contain
either a tuple of strings or a single string; the 0th element of the tuple
will be used to pad the left side of the sequence and the 1st element of the
tuple will be used to pad the right side of the sequence. The `padding_width`
arg controls how many padding values are added to each side; it defaults to
`ngram_width-1`. <p></p> If this op is configured to not have padding, or if it is configured to add
padding with `padding_width` set to less than ngram_width-1, it is possible
that a sequence, or a sequence plus padding, is smaller than the ngram
width. In that case, no ngrams will be generated for that sequence. This can
be prevented by setting `preserve_short_sequences`, which will cause the op
to always generate at least one ngram per non-empty sequence. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> data
						</dt>
						<dd>A Tensor or RaggedTensor containing the source data for the ngrams. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> ngram_width
						</dt>
						<dd>The width(s) of the ngrams to create. If this is a list or
tuple, the op will return ngrams of all specified arities in list order.
Values must be non-Tensor integers greater than 0. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> separator
						</dt>
						<dd>The separator string used between ngram elements. Must be a
string constant, not a Tensor. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> pad_values
						</dt>
						<dd>A tuple of (left_pad_value, right_pad_value), a single string,
or None. If None, no padding will be added; if a single string, then that
string will be used for both left and right padding. Values must be Python
strings. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> padding_width
						</dt>
						<dd>If set, `padding_width` pad values will be added to both
sides of each sequence. Defaults to `ngram_width`-1. Must be greater than
0. (Note that 1-grams are never padded, regardless of this value.) 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> preserve_short_sequences
						</dt>
						<dd>If true, then ensure that at least one ngram is
generated for each input sequence.  In particular, if an input sequence is
shorter than `min(ngram_width) + 2*pad_width`, then generate a single
ngram containing the entire sequence.  If false, then no ngrams are
generated for these short input sequences. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>The op name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A RaggedTensor of ngrams. If `data.shape=[D1...DN, S]`, then
`output.shape=[D1...DN, NUM_NGRAMS]`, where
`NUM_NGRAMS=S-ngram_width+1+2*padding_width`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="ngrams" class="method">
		<h4>
			<span title="System.object">object</span> <strong>ngrams</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> data, <span title="System.int">int</span> ngram_width, <span title="System.Byte[]">Byte[]</span> separator, <span title="System.object">object</span> pad_values, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> padding_width, <span title="System.bool">bool</span> preserve_short_sequences, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Create a tensor of n-grams based on `data`. <p></p> Creates a tensor of n-grams based on `data`. The n-grams are created by
joining windows of `width` adjacent strings from the inner axis of `data`
using `separator`. <p></p> The input data can be padded on both the start and end of the sequence, if
desired, using the `pad_values` argument. If set, `pad_values` should contain
either a tuple of strings or a single string; the 0th element of the tuple
will be used to pad the left side of the sequence and the 1st element of the
tuple will be used to pad the right side of the sequence. The `padding_width`
arg controls how many padding values are added to each side; it defaults to
`ngram_width-1`. <p></p> If this op is configured to not have padding, or if it is configured to add
padding with `padding_width` set to less than ngram_width-1, it is possible
that a sequence, or a sequence plus padding, is smaller than the ngram
width. In that case, no ngrams will be generated for that sequence. This can
be prevented by setting `preserve_short_sequences`, which will cause the op
to always generate at least one ngram per non-empty sequence. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> data
						</dt>
						<dd>A Tensor or RaggedTensor containing the source data for the ngrams. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> ngram_width
						</dt>
						<dd>The width(s) of the ngrams to create. If this is a list or
tuple, the op will return ngrams of all specified arities in list order.
Values must be non-Tensor integers greater than 0. 
						</dd>
						<dt>
							<code><span title="System.Byte[]">Byte[]</span></code> separator
						</dt>
						<dd>The separator string used between ngram elements. Must be a
string constant, not a Tensor. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> pad_values
						</dt>
						<dd>A tuple of (left_pad_value, right_pad_value), a single string,
or None. If None, no padding will be added; if a single string, then that
string will be used for both left and right padding. Values must be Python
strings. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> padding_width
						</dt>
						<dd>If set, `padding_width` pad values will be added to both
sides of each sequence. Defaults to `ngram_width`-1. Must be greater than
0. (Note that 1-grams are never padded, regardless of this value.) 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> preserve_short_sequences
						</dt>
						<dd>If true, then ensure that at least one ngram is
generated for each input sequence.  In particular, if an input sequence is
shorter than `min(ngram_width) + 2*pad_width`, then generate a single
ngram containing the entire sequence.  If false, then no ngrams are
generated for these short input sequences. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>The op name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A RaggedTensor of ngrams. If `data.shape=[D1...DN, S]`, then
`output.shape=[D1...DN, NUM_NGRAMS]`, where
`NUM_NGRAMS=S-ngram_width+1+2*padding_width`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="ngrams" class="method">
		<h4>
			<span title="System.object">object</span> <strong>ngrams</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> data, <span title="System.int">int</span> ngram_width, <span title="System.string">string</span> separator, <span title="System.object">object</span> pad_values, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> padding_width, <span title="System.bool">bool</span> preserve_short_sequences, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Create a tensor of n-grams based on `data`. <p></p> Creates a tensor of n-grams based on `data`. The n-grams are created by
joining windows of `width` adjacent strings from the inner axis of `data`
using `separator`. <p></p> The input data can be padded on both the start and end of the sequence, if
desired, using the `pad_values` argument. If set, `pad_values` should contain
either a tuple of strings or a single string; the 0th element of the tuple
will be used to pad the left side of the sequence and the 1st element of the
tuple will be used to pad the right side of the sequence. The `padding_width`
arg controls how many padding values are added to each side; it defaults to
`ngram_width-1`. <p></p> If this op is configured to not have padding, or if it is configured to add
padding with `padding_width` set to less than ngram_width-1, it is possible
that a sequence, or a sequence plus padding, is smaller than the ngram
width. In that case, no ngrams will be generated for that sequence. This can
be prevented by setting `preserve_short_sequences`, which will cause the op
to always generate at least one ngram per non-empty sequence. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> data
						</dt>
						<dd>A Tensor or RaggedTensor containing the source data for the ngrams. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> ngram_width
						</dt>
						<dd>The width(s) of the ngrams to create. If this is a list or
tuple, the op will return ngrams of all specified arities in list order.
Values must be non-Tensor integers greater than 0. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> separator
						</dt>
						<dd>The separator string used between ngram elements. Must be a
string constant, not a Tensor. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> pad_values
						</dt>
						<dd>A tuple of (left_pad_value, right_pad_value), a single string,
or None. If None, no padding will be added; if a single string, then that
string will be used for both left and right padding. Values must be Python
strings. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> padding_width
						</dt>
						<dd>If set, `padding_width` pad values will be added to both
sides of each sequence. Defaults to `ngram_width`-1. Must be greater than
0. (Note that 1-grams are never padded, regardless of this value.) 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> preserve_short_sequences
						</dt>
						<dd>If true, then ensure that at least one ngram is
generated for each input sequence.  In particular, if an input sequence is
shorter than `min(ngram_width) + 2*pad_width`, then generate a single
ngram containing the entire sequence.  If false, then no ngrams are
generated for these short input sequences. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>The op name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A RaggedTensor of ngrams. If `data.shape=[D1...DN, S]`, then
`output.shape=[D1...DN, NUM_NGRAMS]`, where
`NUM_NGRAMS=S-ngram_width+1+2*padding_width`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="ngrams" class="method">
		<h4>
			<span title="System.object">object</span> <strong>ngrams</strong>(<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> data, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> ngram_width, <span title="System.Byte[]">Byte[]</span> separator, <span title="System.object">object</span> pad_values, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> padding_width, <span title="System.bool">bool</span> preserve_short_sequences, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Create a tensor of n-grams based on `data`. <p></p> Creates a tensor of n-grams based on `data`. The n-grams are created by
joining windows of `width` adjacent strings from the inner axis of `data`
using `separator`. <p></p> The input data can be padded on both the start and end of the sequence, if
desired, using the `pad_values` argument. If set, `pad_values` should contain
either a tuple of strings or a single string; the 0th element of the tuple
will be used to pad the left side of the sequence and the 1st element of the
tuple will be used to pad the right side of the sequence. The `padding_width`
arg controls how many padding values are added to each side; it defaults to
`ngram_width-1`. <p></p> If this op is configured to not have padding, or if it is configured to add
padding with `padding_width` set to less than ngram_width-1, it is possible
that a sequence, or a sequence plus padding, is smaller than the ngram
width. In that case, no ngrams will be generated for that sequence. This can
be prevented by setting `preserve_short_sequences`, which will cause the op
to always generate at least one ngram per non-empty sequence. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code> data
						</dt>
						<dd>A Tensor or RaggedTensor containing the source data for the ngrams. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> ngram_width
						</dt>
						<dd>The width(s) of the ngrams to create. If this is a list or
tuple, the op will return ngrams of all specified arities in list order.
Values must be non-Tensor integers greater than 0. 
						</dd>
						<dt>
							<code><span title="System.Byte[]">Byte[]</span></code> separator
						</dt>
						<dd>The separator string used between ngram elements. Must be a
string constant, not a Tensor. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> pad_values
						</dt>
						<dd>A tuple of (left_pad_value, right_pad_value), a single string,
or None. If None, no padding will be added; if a single string, then that
string will be used for both left and right padding. Values must be Python
strings. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> padding_width
						</dt>
						<dd>If set, `padding_width` pad values will be added to both
sides of each sequence. Defaults to `ngram_width`-1. Must be greater than
0. (Note that 1-grams are never padded, regardless of this value.) 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> preserve_short_sequences
						</dt>
						<dd>If true, then ensure that at least one ngram is
generated for each input sequence.  In particular, if an input sequence is
shorter than `min(ngram_width) + 2*pad_width`, then generate a single
ngram containing the entire sequence.  If false, then no ngrams are
generated for these short input sequences. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>The op name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A RaggedTensor of ngrams. If `data.shape=[D1...DN, S]`, then
`output.shape=[D1...DN, NUM_NGRAMS]`, where
`NUM_NGRAMS=S-ngram_width+1+2*padding_width`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="ngrams" class="method">
		<h4>
			<span title="System.object">object</span> <strong>ngrams</strong>(<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> data, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> ngram_width, <span title="System.string">string</span> separator, <span title="System.object">object</span> pad_values, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> padding_width, <span title="System.bool">bool</span> preserve_short_sequences, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Create a tensor of n-grams based on `data`. <p></p> Creates a tensor of n-grams based on `data`. The n-grams are created by
joining windows of `width` adjacent strings from the inner axis of `data`
using `separator`. <p></p> The input data can be padded on both the start and end of the sequence, if
desired, using the `pad_values` argument. If set, `pad_values` should contain
either a tuple of strings or a single string; the 0th element of the tuple
will be used to pad the left side of the sequence and the 1st element of the
tuple will be used to pad the right side of the sequence. The `padding_width`
arg controls how many padding values are added to each side; it defaults to
`ngram_width-1`. <p></p> If this op is configured to not have padding, or if it is configured to add
padding with `padding_width` set to less than ngram_width-1, it is possible
that a sequence, or a sequence plus padding, is smaller than the ngram
width. In that case, no ngrams will be generated for that sequence. This can
be prevented by setting `preserve_short_sequences`, which will cause the op
to always generate at least one ngram per non-empty sequence. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code> data
						</dt>
						<dd>A Tensor or RaggedTensor containing the source data for the ngrams. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> ngram_width
						</dt>
						<dd>The width(s) of the ngrams to create. If this is a list or
tuple, the op will return ngrams of all specified arities in list order.
Values must be non-Tensor integers greater than 0. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> separator
						</dt>
						<dd>The separator string used between ngram elements. Must be a
string constant, not a Tensor. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> pad_values
						</dt>
						<dd>A tuple of (left_pad_value, right_pad_value), a single string,
or None. If None, no padding will be added; if a single string, then that
string will be used for both left and right padding. Values must be Python
strings. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> padding_width
						</dt>
						<dd>If set, `padding_width` pad values will be added to both
sides of each sequence. Defaults to `ngram_width`-1. Must be greater than
0. (Note that 1-grams are never padded, regardless of this value.) 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> preserve_short_sequences
						</dt>
						<dd>If true, then ensure that at least one ngram is
generated for each input sequence.  In particular, if an input sequence is
shorter than `min(ngram_width) + 2*pad_width`, then generate a single
ngram containing the entire sequence.  If false, then no ngrams are
generated for these short input sequences. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>The op name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A RaggedTensor of ngrams. If `data.shape=[D1...DN, S]`, then
`output.shape=[D1...DN, NUM_NGRAMS]`, where
`NUM_NGRAMS=S-ngram_width+1+2*padding_width`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="ngrams" class="method">
		<h4>
			<span title="System.object">object</span> <strong>ngrams</strong>(<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> data, <span title="System.int">int</span> ngram_width, <span title="System.Byte[]">Byte[]</span> separator, <span title="System.object">object</span> pad_values, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> padding_width, <span title="System.bool">bool</span> preserve_short_sequences, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Create a tensor of n-grams based on `data`. <p></p> Creates a tensor of n-grams based on `data`. The n-grams are created by
joining windows of `width` adjacent strings from the inner axis of `data`
using `separator`. <p></p> The input data can be padded on both the start and end of the sequence, if
desired, using the `pad_values` argument. If set, `pad_values` should contain
either a tuple of strings or a single string; the 0th element of the tuple
will be used to pad the left side of the sequence and the 1st element of the
tuple will be used to pad the right side of the sequence. The `padding_width`
arg controls how many padding values are added to each side; it defaults to
`ngram_width-1`. <p></p> If this op is configured to not have padding, or if it is configured to add
padding with `padding_width` set to less than ngram_width-1, it is possible
that a sequence, or a sequence plus padding, is smaller than the ngram
width. In that case, no ngrams will be generated for that sequence. This can
be prevented by setting `preserve_short_sequences`, which will cause the op
to always generate at least one ngram per non-empty sequence. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code> data
						</dt>
						<dd>A Tensor or RaggedTensor containing the source data for the ngrams. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> ngram_width
						</dt>
						<dd>The width(s) of the ngrams to create. If this is a list or
tuple, the op will return ngrams of all specified arities in list order.
Values must be non-Tensor integers greater than 0. 
						</dd>
						<dt>
							<code><span title="System.Byte[]">Byte[]</span></code> separator
						</dt>
						<dd>The separator string used between ngram elements. Must be a
string constant, not a Tensor. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> pad_values
						</dt>
						<dd>A tuple of (left_pad_value, right_pad_value), a single string,
or None. If None, no padding will be added; if a single string, then that
string will be used for both left and right padding. Values must be Python
strings. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> padding_width
						</dt>
						<dd>If set, `padding_width` pad values will be added to both
sides of each sequence. Defaults to `ngram_width`-1. Must be greater than
0. (Note that 1-grams are never padded, regardless of this value.) 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> preserve_short_sequences
						</dt>
						<dd>If true, then ensure that at least one ngram is
generated for each input sequence.  In particular, if an input sequence is
shorter than `min(ngram_width) + 2*pad_width`, then generate a single
ngram containing the entire sequence.  If false, then no ngrams are
generated for these short input sequences. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>The op name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A RaggedTensor of ngrams. If `data.shape=[D1...DN, S]`, then
`output.shape=[D1...DN, NUM_NGRAMS]`, where
`NUM_NGRAMS=S-ngram_width+1+2*padding_width`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="ngrams" class="method">
		<h4>
			<span title="System.object">object</span> <strong>ngrams</strong>(<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> data, <span title="System.int">int</span> ngram_width, <span title="System.string">string</span> separator, <span title="System.object">object</span> pad_values, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> padding_width, <span title="System.bool">bool</span> preserve_short_sequences, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Create a tensor of n-grams based on `data`. <p></p> Creates a tensor of n-grams based on `data`. The n-grams are created by
joining windows of `width` adjacent strings from the inner axis of `data`
using `separator`. <p></p> The input data can be padded on both the start and end of the sequence, if
desired, using the `pad_values` argument. If set, `pad_values` should contain
either a tuple of strings or a single string; the 0th element of the tuple
will be used to pad the left side of the sequence and the 1st element of the
tuple will be used to pad the right side of the sequence. The `padding_width`
arg controls how many padding values are added to each side; it defaults to
`ngram_width-1`. <p></p> If this op is configured to not have padding, or if it is configured to add
padding with `padding_width` set to less than ngram_width-1, it is possible
that a sequence, or a sequence plus padding, is smaller than the ngram
width. In that case, no ngrams will be generated for that sequence. This can
be prevented by setting `preserve_short_sequences`, which will cause the op
to always generate at least one ngram per non-empty sequence. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code> data
						</dt>
						<dd>A Tensor or RaggedTensor containing the source data for the ngrams. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> ngram_width
						</dt>
						<dd>The width(s) of the ngrams to create. If this is a list or
tuple, the op will return ngrams of all specified arities in list order.
Values must be non-Tensor integers greater than 0. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> separator
						</dt>
						<dd>The separator string used between ngram elements. Must be a
string constant, not a Tensor. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> pad_values
						</dt>
						<dd>A tuple of (left_pad_value, right_pad_value), a single string,
or None. If None, no padding will be added; if a single string, then that
string will be used for both left and right padding. Values must be Python
strings. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> padding_width
						</dt>
						<dd>If set, `padding_width` pad values will be added to both
sides of each sequence. Defaults to `ngram_width`-1. Must be greater than
0. (Note that 1-grams are never padded, regardless of this value.) 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> preserve_short_sequences
						</dt>
						<dd>If true, then ensure that at least one ngram is
generated for each input sequence.  In particular, if an input sequence is
shorter than `min(ngram_width) + 2*pad_width`, then generate a single
ngram containing the entire sequence.  If false, then no ngrams are
generated for these short input sequences. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>The op name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A RaggedTensor of ngrams. If `data.shape=[D1...DN, S]`, then
`output.shape=[D1...DN, NUM_NGRAMS]`, where
`NUM_NGRAMS=S-ngram_width+1+2*padding_width`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="ngrams" class="method">
		<h4>
			<span title="System.object">object</span> <strong>ngrams</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> data, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> ngram_width, <span title="System.Byte[]">Byte[]</span> separator, <span title="System.object">object</span> pad_values, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> padding_width, <span title="System.bool">bool</span> preserve_short_sequences, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Create a tensor of n-grams based on `data`. <p></p> Creates a tensor of n-grams based on `data`. The n-grams are created by
joining windows of `width` adjacent strings from the inner axis of `data`
using `separator`. <p></p> The input data can be padded on both the start and end of the sequence, if
desired, using the `pad_values` argument. If set, `pad_values` should contain
either a tuple of strings or a single string; the 0th element of the tuple
will be used to pad the left side of the sequence and the 1st element of the
tuple will be used to pad the right side of the sequence. The `padding_width`
arg controls how many padding values are added to each side; it defaults to
`ngram_width-1`. <p></p> If this op is configured to not have padding, or if it is configured to add
padding with `padding_width` set to less than ngram_width-1, it is possible
that a sequence, or a sequence plus padding, is smaller than the ngram
width. In that case, no ngrams will be generated for that sequence. This can
be prevented by setting `preserve_short_sequences`, which will cause the op
to always generate at least one ngram per non-empty sequence. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> data
						</dt>
						<dd>A Tensor or RaggedTensor containing the source data for the ngrams. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> ngram_width
						</dt>
						<dd>The width(s) of the ngrams to create. If this is a list or
tuple, the op will return ngrams of all specified arities in list order.
Values must be non-Tensor integers greater than 0. 
						</dd>
						<dt>
							<code><span title="System.Byte[]">Byte[]</span></code> separator
						</dt>
						<dd>The separator string used between ngram elements. Must be a
string constant, not a Tensor. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> pad_values
						</dt>
						<dd>A tuple of (left_pad_value, right_pad_value), a single string,
or None. If None, no padding will be added; if a single string, then that
string will be used for both left and right padding. Values must be Python
strings. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> padding_width
						</dt>
						<dd>If set, `padding_width` pad values will be added to both
sides of each sequence. Defaults to `ngram_width`-1. Must be greater than
0. (Note that 1-grams are never padded, regardless of this value.) 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> preserve_short_sequences
						</dt>
						<dd>If true, then ensure that at least one ngram is
generated for each input sequence.  In particular, if an input sequence is
shorter than `min(ngram_width) + 2*pad_width`, then generate a single
ngram containing the entire sequence.  If false, then no ngrams are
generated for these short input sequences. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>The op name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A RaggedTensor of ngrams. If `data.shape=[D1...DN, S]`, then
`output.shape=[D1...DN, NUM_NGRAMS]`, where
`NUM_NGRAMS=S-ngram_width+1+2*padding_width`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="ngrams" class="method">
		<h4>
			<span title="System.object">object</span> <strong>ngrams</strong>(<span title="System.int">int</span> data, <span title="System.int">int</span> ngram_width, <span title="System.Byte[]">Byte[]</span> separator, <span title="System.object">object</span> pad_values, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> padding_width, <span title="System.bool">bool</span> preserve_short_sequences, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Create a tensor of n-grams based on `data`. <p></p> Creates a tensor of n-grams based on `data`. The n-grams are created by
joining windows of `width` adjacent strings from the inner axis of `data`
using `separator`. <p></p> The input data can be padded on both the start and end of the sequence, if
desired, using the `pad_values` argument. If set, `pad_values` should contain
either a tuple of strings or a single string; the 0th element of the tuple
will be used to pad the left side of the sequence and the 1st element of the
tuple will be used to pad the right side of the sequence. The `padding_width`
arg controls how many padding values are added to each side; it defaults to
`ngram_width-1`. <p></p> If this op is configured to not have padding, or if it is configured to add
padding with `padding_width` set to less than ngram_width-1, it is possible
that a sequence, or a sequence plus padding, is smaller than the ngram
width. In that case, no ngrams will be generated for that sequence. This can
be prevented by setting `preserve_short_sequences`, which will cause the op
to always generate at least one ngram per non-empty sequence. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> data
						</dt>
						<dd>A Tensor or RaggedTensor containing the source data for the ngrams. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> ngram_width
						</dt>
						<dd>The width(s) of the ngrams to create. If this is a list or
tuple, the op will return ngrams of all specified arities in list order.
Values must be non-Tensor integers greater than 0. 
						</dd>
						<dt>
							<code><span title="System.Byte[]">Byte[]</span></code> separator
						</dt>
						<dd>The separator string used between ngram elements. Must be a
string constant, not a Tensor. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> pad_values
						</dt>
						<dd>A tuple of (left_pad_value, right_pad_value), a single string,
or None. If None, no padding will be added; if a single string, then that
string will be used for both left and right padding. Values must be Python
strings. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> padding_width
						</dt>
						<dd>If set, `padding_width` pad values will be added to both
sides of each sequence. Defaults to `ngram_width`-1. Must be greater than
0. (Note that 1-grams are never padded, regardless of this value.) 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> preserve_short_sequences
						</dt>
						<dd>If true, then ensure that at least one ngram is
generated for each input sequence.  In particular, if an input sequence is
shorter than `min(ngram_width) + 2*pad_width`, then generate a single
ngram containing the entire sequence.  If false, then no ngrams are
generated for these short input sequences. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>The op name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A RaggedTensor of ngrams. If `data.shape=[D1...DN, S]`, then
`output.shape=[D1...DN, NUM_NGRAMS]`, where
`NUM_NGRAMS=S-ngram_width+1+2*padding_width`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="ngrams" class="method">
		<h4>
			<span title="System.object">object</span> <strong>ngrams</strong>(<span title="System.int">int</span> data, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> ngram_width, <span title="System.Byte[]">Byte[]</span> separator, <span title="System.object">object</span> pad_values, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> padding_width, <span title="System.bool">bool</span> preserve_short_sequences, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Create a tensor of n-grams based on `data`. <p></p> Creates a tensor of n-grams based on `data`. The n-grams are created by
joining windows of `width` adjacent strings from the inner axis of `data`
using `separator`. <p></p> The input data can be padded on both the start and end of the sequence, if
desired, using the `pad_values` argument. If set, `pad_values` should contain
either a tuple of strings or a single string; the 0th element of the tuple
will be used to pad the left side of the sequence and the 1st element of the
tuple will be used to pad the right side of the sequence. The `padding_width`
arg controls how many padding values are added to each side; it defaults to
`ngram_width-1`. <p></p> If this op is configured to not have padding, or if it is configured to add
padding with `padding_width` set to less than ngram_width-1, it is possible
that a sequence, or a sequence plus padding, is smaller than the ngram
width. In that case, no ngrams will be generated for that sequence. This can
be prevented by setting `preserve_short_sequences`, which will cause the op
to always generate at least one ngram per non-empty sequence. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> data
						</dt>
						<dd>A Tensor or RaggedTensor containing the source data for the ngrams. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> ngram_width
						</dt>
						<dd>The width(s) of the ngrams to create. If this is a list or
tuple, the op will return ngrams of all specified arities in list order.
Values must be non-Tensor integers greater than 0. 
						</dd>
						<dt>
							<code><span title="System.Byte[]">Byte[]</span></code> separator
						</dt>
						<dd>The separator string used between ngram elements. Must be a
string constant, not a Tensor. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> pad_values
						</dt>
						<dd>A tuple of (left_pad_value, right_pad_value), a single string,
or None. If None, no padding will be added; if a single string, then that
string will be used for both left and right padding. Values must be Python
strings. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> padding_width
						</dt>
						<dd>If set, `padding_width` pad values will be added to both
sides of each sequence. Defaults to `ngram_width`-1. Must be greater than
0. (Note that 1-grams are never padded, regardless of this value.) 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> preserve_short_sequences
						</dt>
						<dd>If true, then ensure that at least one ngram is
generated for each input sequence.  In particular, if an input sequence is
shorter than `min(ngram_width) + 2*pad_width`, then generate a single
ngram containing the entire sequence.  If false, then no ngrams are
generated for these short input sequences. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>The op name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A RaggedTensor of ngrams. If `data.shape=[D1...DN, S]`, then
`output.shape=[D1...DN, NUM_NGRAMS]`, where
`NUM_NGRAMS=S-ngram_width+1+2*padding_width`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="ngrams" class="method">
		<h4>
			<span title="System.object">object</span> <strong>ngrams</strong>(<span title="System.int">int</span> data, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> ngram_width, <span title="System.string">string</span> separator, <span title="System.object">object</span> pad_values, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> padding_width, <span title="System.bool">bool</span> preserve_short_sequences, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Create a tensor of n-grams based on `data`. <p></p> Creates a tensor of n-grams based on `data`. The n-grams are created by
joining windows of `width` adjacent strings from the inner axis of `data`
using `separator`. <p></p> The input data can be padded on both the start and end of the sequence, if
desired, using the `pad_values` argument. If set, `pad_values` should contain
either a tuple of strings or a single string; the 0th element of the tuple
will be used to pad the left side of the sequence and the 1st element of the
tuple will be used to pad the right side of the sequence. The `padding_width`
arg controls how many padding values are added to each side; it defaults to
`ngram_width-1`. <p></p> If this op is configured to not have padding, or if it is configured to add
padding with `padding_width` set to less than ngram_width-1, it is possible
that a sequence, or a sequence plus padding, is smaller than the ngram
width. In that case, no ngrams will be generated for that sequence. This can
be prevented by setting `preserve_short_sequences`, which will cause the op
to always generate at least one ngram per non-empty sequence. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> data
						</dt>
						<dd>A Tensor or RaggedTensor containing the source data for the ngrams. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> ngram_width
						</dt>
						<dd>The width(s) of the ngrams to create. If this is a list or
tuple, the op will return ngrams of all specified arities in list order.
Values must be non-Tensor integers greater than 0. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> separator
						</dt>
						<dd>The separator string used between ngram elements. Must be a
string constant, not a Tensor. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> pad_values
						</dt>
						<dd>A tuple of (left_pad_value, right_pad_value), a single string,
or None. If None, no padding will be added; if a single string, then that
string will be used for both left and right padding. Values must be Python
strings. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> padding_width
						</dt>
						<dd>If set, `padding_width` pad values will be added to both
sides of each sequence. Defaults to `ngram_width`-1. Must be greater than
0. (Note that 1-grams are never padded, regardless of this value.) 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> preserve_short_sequences
						</dt>
						<dd>If true, then ensure that at least one ngram is
generated for each input sequence.  In particular, if an input sequence is
shorter than `min(ngram_width) + 2*pad_width`, then generate a single
ngram containing the entire sequence.  If false, then no ngrams are
generated for these short input sequences. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>The op name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A RaggedTensor of ngrams. If `data.shape=[D1...DN, S]`, then
`output.shape=[D1...DN, NUM_NGRAMS]`, where
`NUM_NGRAMS=S-ngram_width+1+2*padding_width`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="ngrams" class="method">
		<h4>
			<span title="System.object">object</span> <strong>ngrams</strong>(<span title="System.int">int</span> data, <span title="System.int">int</span> ngram_width, <span title="System.string">string</span> separator, <span title="System.object">object</span> pad_values, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> padding_width, <span title="System.bool">bool</span> preserve_short_sequences, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Create a tensor of n-grams based on `data`. <p></p> Creates a tensor of n-grams based on `data`. The n-grams are created by
joining windows of `width` adjacent strings from the inner axis of `data`
using `separator`. <p></p> The input data can be padded on both the start and end of the sequence, if
desired, using the `pad_values` argument. If set, `pad_values` should contain
either a tuple of strings or a single string; the 0th element of the tuple
will be used to pad the left side of the sequence and the 1st element of the
tuple will be used to pad the right side of the sequence. The `padding_width`
arg controls how many padding values are added to each side; it defaults to
`ngram_width-1`. <p></p> If this op is configured to not have padding, or if it is configured to add
padding with `padding_width` set to less than ngram_width-1, it is possible
that a sequence, or a sequence plus padding, is smaller than the ngram
width. In that case, no ngrams will be generated for that sequence. This can
be prevented by setting `preserve_short_sequences`, which will cause the op
to always generate at least one ngram per non-empty sequence. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> data
						</dt>
						<dd>A Tensor or RaggedTensor containing the source data for the ngrams. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> ngram_width
						</dt>
						<dd>The width(s) of the ngrams to create. If this is a list or
tuple, the op will return ngrams of all specified arities in list order.
Values must be non-Tensor integers greater than 0. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> separator
						</dt>
						<dd>The separator string used between ngram elements. Must be a
string constant, not a Tensor. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> pad_values
						</dt>
						<dd>A tuple of (left_pad_value, right_pad_value), a single string,
or None. If None, no padding will be added; if a single string, then that
string will be used for both left and right padding. Values must be Python
strings. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> padding_width
						</dt>
						<dd>If set, `padding_width` pad values will be added to both
sides of each sequence. Defaults to `ngram_width`-1. Must be greater than
0. (Note that 1-grams are never padded, regardless of this value.) 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> preserve_short_sequences
						</dt>
						<dd>If true, then ensure that at least one ngram is
generated for each input sequence.  In particular, if an input sequence is
shorter than `min(ngram_width) + 2*pad_width`, then generate a single
ngram containing the entire sequence.  If false, then no ngrams are
generated for these short input sequences. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>The op name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A RaggedTensor of ngrams. If `data.shape=[D1...DN, S]`, then
`output.shape=[D1...DN, NUM_NGRAMS]`, where
`NUM_NGRAMS=S-ngram_width+1+2*padding_width`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="ngrams" class="method">
		<h4>
			<span title="System.object">object</span> <strong>ngrams</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> data, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> ngram_width, <span title="System.Byte[]">Byte[]</span> separator, <span title="System.object">object</span> pad_values, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> padding_width, <span title="System.bool">bool</span> preserve_short_sequences, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Create a tensor of n-grams based on `data`. <p></p> Creates a tensor of n-grams based on `data`. The n-grams are created by
joining windows of `width` adjacent strings from the inner axis of `data`
using `separator`. <p></p> The input data can be padded on both the start and end of the sequence, if
desired, using the `pad_values` argument. If set, `pad_values` should contain
either a tuple of strings or a single string; the 0th element of the tuple
will be used to pad the left side of the sequence and the 1st element of the
tuple will be used to pad the right side of the sequence. The `padding_width`
arg controls how many padding values are added to each side; it defaults to
`ngram_width-1`. <p></p> If this op is configured to not have padding, or if it is configured to add
padding with `padding_width` set to less than ngram_width-1, it is possible
that a sequence, or a sequence plus padding, is smaller than the ngram
width. In that case, no ngrams will be generated for that sequence. This can
be prevented by setting `preserve_short_sequences`, which will cause the op
to always generate at least one ngram per non-empty sequence. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> data
						</dt>
						<dd>A Tensor or RaggedTensor containing the source data for the ngrams. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> ngram_width
						</dt>
						<dd>The width(s) of the ngrams to create. If this is a list or
tuple, the op will return ngrams of all specified arities in list order.
Values must be non-Tensor integers greater than 0. 
						</dd>
						<dt>
							<code><span title="System.Byte[]">Byte[]</span></code> separator
						</dt>
						<dd>The separator string used between ngram elements. Must be a
string constant, not a Tensor. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> pad_values
						</dt>
						<dd>A tuple of (left_pad_value, right_pad_value), a single string,
or None. If None, no padding will be added; if a single string, then that
string will be used for both left and right padding. Values must be Python
strings. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> padding_width
						</dt>
						<dd>If set, `padding_width` pad values will be added to both
sides of each sequence. Defaults to `ngram_width`-1. Must be greater than
0. (Note that 1-grams are never padded, regardless of this value.) 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> preserve_short_sequences
						</dt>
						<dd>If true, then ensure that at least one ngram is
generated for each input sequence.  In particular, if an input sequence is
shorter than `min(ngram_width) + 2*pad_width`, then generate a single
ngram containing the entire sequence.  If false, then no ngrams are
generated for these short input sequences. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>The op name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A RaggedTensor of ngrams. If `data.shape=[D1...DN, S]`, then
`output.shape=[D1...DN, NUM_NGRAMS]`, where
`NUM_NGRAMS=S-ngram_width+1+2*padding_width`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="ngrams" class="method">
		<h4>
			<span title="System.object">object</span> <strong>ngrams</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> data, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> ngram_width, <span title="System.string">string</span> separator, <span title="System.object">object</span> pad_values, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> padding_width, <span title="System.bool">bool</span> preserve_short_sequences, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Create a tensor of n-grams based on `data`. <p></p> Creates a tensor of n-grams based on `data`. The n-grams are created by
joining windows of `width` adjacent strings from the inner axis of `data`
using `separator`. <p></p> The input data can be padded on both the start and end of the sequence, if
desired, using the `pad_values` argument. If set, `pad_values` should contain
either a tuple of strings or a single string; the 0th element of the tuple
will be used to pad the left side of the sequence and the 1st element of the
tuple will be used to pad the right side of the sequence. The `padding_width`
arg controls how many padding values are added to each side; it defaults to
`ngram_width-1`. <p></p> If this op is configured to not have padding, or if it is configured to add
padding with `padding_width` set to less than ngram_width-1, it is possible
that a sequence, or a sequence plus padding, is smaller than the ngram
width. In that case, no ngrams will be generated for that sequence. This can
be prevented by setting `preserve_short_sequences`, which will cause the op
to always generate at least one ngram per non-empty sequence. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> data
						</dt>
						<dd>A Tensor or RaggedTensor containing the source data for the ngrams. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> ngram_width
						</dt>
						<dd>The width(s) of the ngrams to create. If this is a list or
tuple, the op will return ngrams of all specified arities in list order.
Values must be non-Tensor integers greater than 0. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> separator
						</dt>
						<dd>The separator string used between ngram elements. Must be a
string constant, not a Tensor. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> pad_values
						</dt>
						<dd>A tuple of (left_pad_value, right_pad_value), a single string,
or None. If None, no padding will be added; if a single string, then that
string will be used for both left and right padding. Values must be Python
strings. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> padding_width
						</dt>
						<dd>If set, `padding_width` pad values will be added to both
sides of each sequence. Defaults to `ngram_width`-1. Must be greater than
0. (Note that 1-grams are never padded, regardless of this value.) 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> preserve_short_sequences
						</dt>
						<dd>If true, then ensure that at least one ngram is
generated for each input sequence.  In particular, if an input sequence is
shorter than `min(ngram_width) + 2*pad_width`, then generate a single
ngram containing the entire sequence.  If false, then no ngrams are
generated for these short input sequences. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>The op name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A RaggedTensor of ngrams. If `data.shape=[D1...DN, S]`, then
`output.shape=[D1...DN, NUM_NGRAMS]`, where
`NUM_NGRAMS=S-ngram_width+1+2*padding_width`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="ngrams" class="method">
		<h4>
			<span title="System.object">object</span> <strong>ngrams</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> data, <span title="System.int">int</span> ngram_width, <span title="System.Byte[]">Byte[]</span> separator, <span title="System.object">object</span> pad_values, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> padding_width, <span title="System.bool">bool</span> preserve_short_sequences, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Create a tensor of n-grams based on `data`. <p></p> Creates a tensor of n-grams based on `data`. The n-grams are created by
joining windows of `width` adjacent strings from the inner axis of `data`
using `separator`. <p></p> The input data can be padded on both the start and end of the sequence, if
desired, using the `pad_values` argument. If set, `pad_values` should contain
either a tuple of strings or a single string; the 0th element of the tuple
will be used to pad the left side of the sequence and the 1st element of the
tuple will be used to pad the right side of the sequence. The `padding_width`
arg controls how many padding values are added to each side; it defaults to
`ngram_width-1`. <p></p> If this op is configured to not have padding, or if it is configured to add
padding with `padding_width` set to less than ngram_width-1, it is possible
that a sequence, or a sequence plus padding, is smaller than the ngram
width. In that case, no ngrams will be generated for that sequence. This can
be prevented by setting `preserve_short_sequences`, which will cause the op
to always generate at least one ngram per non-empty sequence. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> data
						</dt>
						<dd>A Tensor or RaggedTensor containing the source data for the ngrams. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> ngram_width
						</dt>
						<dd>The width(s) of the ngrams to create. If this is a list or
tuple, the op will return ngrams of all specified arities in list order.
Values must be non-Tensor integers greater than 0. 
						</dd>
						<dt>
							<code><span title="System.Byte[]">Byte[]</span></code> separator
						</dt>
						<dd>The separator string used between ngram elements. Must be a
string constant, not a Tensor. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> pad_values
						</dt>
						<dd>A tuple of (left_pad_value, right_pad_value), a single string,
or None. If None, no padding will be added; if a single string, then that
string will be used for both left and right padding. Values must be Python
strings. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> padding_width
						</dt>
						<dd>If set, `padding_width` pad values will be added to both
sides of each sequence. Defaults to `ngram_width`-1. Must be greater than
0. (Note that 1-grams are never padded, regardless of this value.) 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> preserve_short_sequences
						</dt>
						<dd>If true, then ensure that at least one ngram is
generated for each input sequence.  In particular, if an input sequence is
shorter than `min(ngram_width) + 2*pad_width`, then generate a single
ngram containing the entire sequence.  If false, then no ngrams are
generated for these short input sequences. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>The op name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A RaggedTensor of ngrams. If `data.shape=[D1...DN, S]`, then
`output.shape=[D1...DN, NUM_NGRAMS]`, where
`NUM_NGRAMS=S-ngram_width+1+2*padding_width`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="ngrams" class="method">
		<h4>
			<span title="System.object">object</span> <strong>ngrams</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> data, <span title="System.int">int</span> ngram_width, <span title="System.string">string</span> separator, <span title="System.object">object</span> pad_values, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> padding_width, <span title="System.bool">bool</span> preserve_short_sequences, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Create a tensor of n-grams based on `data`. <p></p> Creates a tensor of n-grams based on `data`. The n-grams are created by
joining windows of `width` adjacent strings from the inner axis of `data`
using `separator`. <p></p> The input data can be padded on both the start and end of the sequence, if
desired, using the `pad_values` argument. If set, `pad_values` should contain
either a tuple of strings or a single string; the 0th element of the tuple
will be used to pad the left side of the sequence and the 1st element of the
tuple will be used to pad the right side of the sequence. The `padding_width`
arg controls how many padding values are added to each side; it defaults to
`ngram_width-1`. <p></p> If this op is configured to not have padding, or if it is configured to add
padding with `padding_width` set to less than ngram_width-1, it is possible
that a sequence, or a sequence plus padding, is smaller than the ngram
width. In that case, no ngrams will be generated for that sequence. This can
be prevented by setting `preserve_short_sequences`, which will cause the op
to always generate at least one ngram per non-empty sequence. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> data
						</dt>
						<dd>A Tensor or RaggedTensor containing the source data for the ngrams. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> ngram_width
						</dt>
						<dd>The width(s) of the ngrams to create. If this is a list or
tuple, the op will return ngrams of all specified arities in list order.
Values must be non-Tensor integers greater than 0. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> separator
						</dt>
						<dd>The separator string used between ngram elements. Must be a
string constant, not a Tensor. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> pad_values
						</dt>
						<dd>A tuple of (left_pad_value, right_pad_value), a single string,
or None. If None, no padding will be added; if a single string, then that
string will be used for both left and right padding. Values must be Python
strings. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> padding_width
						</dt>
						<dd>If set, `padding_width` pad values will be added to both
sides of each sequence. Defaults to `ngram_width`-1. Must be greater than
0. (Note that 1-grams are never padded, regardless of this value.) 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> preserve_short_sequences
						</dt>
						<dd>If true, then ensure that at least one ngram is
generated for each input sequence.  In particular, if an input sequence is
shorter than `min(ngram_width) + 2*pad_width`, then generate a single
ngram containing the entire sequence.  If false, then no ngrams are
generated for these short input sequences. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>The op name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A RaggedTensor of ngrams. If `data.shape=[D1...DN, S]`, then
`output.shape=[D1...DN, NUM_NGRAMS]`, where
`NUM_NGRAMS=S-ngram_width+1+2*padding_width`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="ngrams" class="method">
		<h4>
			<span title="System.object">object</span> <strong>ngrams</strong>(<span title="System.object">object</span> data, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> ngram_width, <span title="System.Byte[]">Byte[]</span> separator, <span title="System.object">object</span> pad_values, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> padding_width, <span title="System.bool">bool</span> preserve_short_sequences, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Create a tensor of n-grams based on `data`. <p></p> Creates a tensor of n-grams based on `data`. The n-grams are created by
joining windows of `width` adjacent strings from the inner axis of `data`
using `separator`. <p></p> The input data can be padded on both the start and end of the sequence, if
desired, using the `pad_values` argument. If set, `pad_values` should contain
either a tuple of strings or a single string; the 0th element of the tuple
will be used to pad the left side of the sequence and the 1st element of the
tuple will be used to pad the right side of the sequence. The `padding_width`
arg controls how many padding values are added to each side; it defaults to
`ngram_width-1`. <p></p> If this op is configured to not have padding, or if it is configured to add
padding with `padding_width` set to less than ngram_width-1, it is possible
that a sequence, or a sequence plus padding, is smaller than the ngram
width. In that case, no ngrams will be generated for that sequence. This can
be prevented by setting `preserve_short_sequences`, which will cause the op
to always generate at least one ngram per non-empty sequence. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> data
						</dt>
						<dd>A Tensor or RaggedTensor containing the source data for the ngrams. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> ngram_width
						</dt>
						<dd>The width(s) of the ngrams to create. If this is a list or
tuple, the op will return ngrams of all specified arities in list order.
Values must be non-Tensor integers greater than 0. 
						</dd>
						<dt>
							<code><span title="System.Byte[]">Byte[]</span></code> separator
						</dt>
						<dd>The separator string used between ngram elements. Must be a
string constant, not a Tensor. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> pad_values
						</dt>
						<dd>A tuple of (left_pad_value, right_pad_value), a single string,
or None. If None, no padding will be added; if a single string, then that
string will be used for both left and right padding. Values must be Python
strings. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> padding_width
						</dt>
						<dd>If set, `padding_width` pad values will be added to both
sides of each sequence. Defaults to `ngram_width`-1. Must be greater than
0. (Note that 1-grams are never padded, regardless of this value.) 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> preserve_short_sequences
						</dt>
						<dd>If true, then ensure that at least one ngram is
generated for each input sequence.  In particular, if an input sequence is
shorter than `min(ngram_width) + 2*pad_width`, then generate a single
ngram containing the entire sequence.  If false, then no ngrams are
generated for these short input sequences. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>The op name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A RaggedTensor of ngrams. If `data.shape=[D1...DN, S]`, then
`output.shape=[D1...DN, NUM_NGRAMS]`, where
`NUM_NGRAMS=S-ngram_width+1+2*padding_width`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="ngrams" class="method">
		<h4>
			<span title="System.object">object</span> <strong>ngrams</strong>(<span title="System.object">object</span> data, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> ngram_width, <span title="System.string">string</span> separator, <span title="System.object">object</span> pad_values, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> padding_width, <span title="System.bool">bool</span> preserve_short_sequences, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Create a tensor of n-grams based on `data`. <p></p> Creates a tensor of n-grams based on `data`. The n-grams are created by
joining windows of `width` adjacent strings from the inner axis of `data`
using `separator`. <p></p> The input data can be padded on both the start and end of the sequence, if
desired, using the `pad_values` argument. If set, `pad_values` should contain
either a tuple of strings or a single string; the 0th element of the tuple
will be used to pad the left side of the sequence and the 1st element of the
tuple will be used to pad the right side of the sequence. The `padding_width`
arg controls how many padding values are added to each side; it defaults to
`ngram_width-1`. <p></p> If this op is configured to not have padding, or if it is configured to add
padding with `padding_width` set to less than ngram_width-1, it is possible
that a sequence, or a sequence plus padding, is smaller than the ngram
width. In that case, no ngrams will be generated for that sequence. This can
be prevented by setting `preserve_short_sequences`, which will cause the op
to always generate at least one ngram per non-empty sequence. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> data
						</dt>
						<dd>A Tensor or RaggedTensor containing the source data for the ngrams. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> ngram_width
						</dt>
						<dd>The width(s) of the ngrams to create. If this is a list or
tuple, the op will return ngrams of all specified arities in list order.
Values must be non-Tensor integers greater than 0. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> separator
						</dt>
						<dd>The separator string used between ngram elements. Must be a
string constant, not a Tensor. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> pad_values
						</dt>
						<dd>A tuple of (left_pad_value, right_pad_value), a single string,
or None. If None, no padding will be added; if a single string, then that
string will be used for both left and right padding. Values must be Python
strings. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> padding_width
						</dt>
						<dd>If set, `padding_width` pad values will be added to both
sides of each sequence. Defaults to `ngram_width`-1. Must be greater than
0. (Note that 1-grams are never padded, regardless of this value.) 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> preserve_short_sequences
						</dt>
						<dd>If true, then ensure that at least one ngram is
generated for each input sequence.  In particular, if an input sequence is
shorter than `min(ngram_width) + 2*pad_width`, then generate a single
ngram containing the entire sequence.  If false, then no ngrams are
generated for these short input sequences. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>The op name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A RaggedTensor of ngrams. If `data.shape=[D1...DN, S]`, then
`output.shape=[D1...DN, NUM_NGRAMS]`, where
`NUM_NGRAMS=S-ngram_width+1+2*padding_width`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="ngrams" class="method">
		<h4>
			<span title="System.object">object</span> <strong>ngrams</strong>(<span title="System.object">object</span> data, <span title="System.int">int</span> ngram_width, <span title="System.Byte[]">Byte[]</span> separator, <span title="System.object">object</span> pad_values, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> padding_width, <span title="System.bool">bool</span> preserve_short_sequences, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Create a tensor of n-grams based on `data`. <p></p> Creates a tensor of n-grams based on `data`. The n-grams are created by
joining windows of `width` adjacent strings from the inner axis of `data`
using `separator`. <p></p> The input data can be padded on both the start and end of the sequence, if
desired, using the `pad_values` argument. If set, `pad_values` should contain
either a tuple of strings or a single string; the 0th element of the tuple
will be used to pad the left side of the sequence and the 1st element of the
tuple will be used to pad the right side of the sequence. The `padding_width`
arg controls how many padding values are added to each side; it defaults to
`ngram_width-1`. <p></p> If this op is configured to not have padding, or if it is configured to add
padding with `padding_width` set to less than ngram_width-1, it is possible
that a sequence, or a sequence plus padding, is smaller than the ngram
width. In that case, no ngrams will be generated for that sequence. This can
be prevented by setting `preserve_short_sequences`, which will cause the op
to always generate at least one ngram per non-empty sequence. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> data
						</dt>
						<dd>A Tensor or RaggedTensor containing the source data for the ngrams. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> ngram_width
						</dt>
						<dd>The width(s) of the ngrams to create. If this is a list or
tuple, the op will return ngrams of all specified arities in list order.
Values must be non-Tensor integers greater than 0. 
						</dd>
						<dt>
							<code><span title="System.Byte[]">Byte[]</span></code> separator
						</dt>
						<dd>The separator string used between ngram elements. Must be a
string constant, not a Tensor. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> pad_values
						</dt>
						<dd>A tuple of (left_pad_value, right_pad_value), a single string,
or None. If None, no padding will be added; if a single string, then that
string will be used for both left and right padding. Values must be Python
strings. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> padding_width
						</dt>
						<dd>If set, `padding_width` pad values will be added to both
sides of each sequence. Defaults to `ngram_width`-1. Must be greater than
0. (Note that 1-grams are never padded, regardless of this value.) 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> preserve_short_sequences
						</dt>
						<dd>If true, then ensure that at least one ngram is
generated for each input sequence.  In particular, if an input sequence is
shorter than `min(ngram_width) + 2*pad_width`, then generate a single
ngram containing the entire sequence.  If false, then no ngrams are
generated for these short input sequences. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>The op name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A RaggedTensor of ngrams. If `data.shape=[D1...DN, S]`, then
`output.shape=[D1...DN, NUM_NGRAMS]`, where
`NUM_NGRAMS=S-ngram_width+1+2*padding_width`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="ngrams" class="method">
		<h4>
			<span title="System.object">object</span> <strong>ngrams</strong>(<span title="System.object">object</span> data, <span title="System.int">int</span> ngram_width, <span title="System.string">string</span> separator, <span title="System.object">object</span> pad_values, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> padding_width, <span title="System.bool">bool</span> preserve_short_sequences, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Create a tensor of n-grams based on `data`. <p></p> Creates a tensor of n-grams based on `data`. The n-grams are created by
joining windows of `width` adjacent strings from the inner axis of `data`
using `separator`. <p></p> The input data can be padded on both the start and end of the sequence, if
desired, using the `pad_values` argument. If set, `pad_values` should contain
either a tuple of strings or a single string; the 0th element of the tuple
will be used to pad the left side of the sequence and the 1st element of the
tuple will be used to pad the right side of the sequence. The `padding_width`
arg controls how many padding values are added to each side; it defaults to
`ngram_width-1`. <p></p> If this op is configured to not have padding, or if it is configured to add
padding with `padding_width` set to less than ngram_width-1, it is possible
that a sequence, or a sequence plus padding, is smaller than the ngram
width. In that case, no ngrams will be generated for that sequence. This can
be prevented by setting `preserve_short_sequences`, which will cause the op
to always generate at least one ngram per non-empty sequence. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> data
						</dt>
						<dd>A Tensor or RaggedTensor containing the source data for the ngrams. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> ngram_width
						</dt>
						<dd>The width(s) of the ngrams to create. If this is a list or
tuple, the op will return ngrams of all specified arities in list order.
Values must be non-Tensor integers greater than 0. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> separator
						</dt>
						<dd>The separator string used between ngram elements. Must be a
string constant, not a Tensor. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> pad_values
						</dt>
						<dd>A tuple of (left_pad_value, right_pad_value), a single string,
or None. If None, no padding will be added; if a single string, then that
string will be used for both left and right padding. Values must be Python
strings. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> padding_width
						</dt>
						<dd>If set, `padding_width` pad values will be added to both
sides of each sequence. Defaults to `ngram_width`-1. Must be greater than
0. (Note that 1-grams are never padded, regardless of this value.) 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> preserve_short_sequences
						</dt>
						<dd>If true, then ensure that at least one ngram is
generated for each input sequence.  In particular, if an input sequence is
shorter than `min(ngram_width) + 2*pad_width`, then generate a single
ngram containing the entire sequence.  If false, then no ngrams are
generated for these short input sequences. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>The op name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A RaggedTensor of ngrams. If `data.shape=[D1...DN, S]`, then
`output.shape=[D1...DN, NUM_NGRAMS]`, where
`NUM_NGRAMS=S-ngram_width+1+2*padding_width`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="ngrams_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>ngrams_dyn</strong>(<span title="System.object">object</span> data, <span title="System.object">object</span> ngram_width, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> separator, <span title="System.object">object</span> pad_values, <span title="System.object">object</span> padding_width, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> preserve_short_sequences, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Create a tensor of n-grams based on `data`. <p></p> Creates a tensor of n-grams based on `data`. The n-grams are created by
joining windows of `width` adjacent strings from the inner axis of `data`
using `separator`. <p></p> The input data can be padded on both the start and end of the sequence, if
desired, using the `pad_values` argument. If set, `pad_values` should contain
either a tuple of strings or a single string; the 0th element of the tuple
will be used to pad the left side of the sequence and the 1st element of the
tuple will be used to pad the right side of the sequence. The `padding_width`
arg controls how many padding values are added to each side; it defaults to
`ngram_width-1`. <p></p> If this op is configured to not have padding, or if it is configured to add
padding with `padding_width` set to less than ngram_width-1, it is possible
that a sequence, or a sequence plus padding, is smaller than the ngram
width. In that case, no ngrams will be generated for that sequence. This can
be prevented by setting `preserve_short_sequences`, which will cause the op
to always generate at least one ngram per non-empty sequence. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> data
						</dt>
						<dd>A Tensor or RaggedTensor containing the source data for the ngrams. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> ngram_width
						</dt>
						<dd>The width(s) of the ngrams to create. If this is a list or
tuple, the op will return ngrams of all specified arities in list order.
Values must be non-Tensor integers greater than 0. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> separator
						</dt>
						<dd>The separator string used between ngram elements. Must be a
string constant, not a Tensor. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> pad_values
						</dt>
						<dd>A tuple of (left_pad_value, right_pad_value), a single string,
or None. If None, no padding will be added; if a single string, then that
string will be used for both left and right padding. Values must be Python
strings. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> padding_width
						</dt>
						<dd>If set, `padding_width` pad values will be added to both
sides of each sequence. Defaults to `ngram_width`-1. Must be greater than
0. (Note that 1-grams are never padded, regardless of this value.) 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> preserve_short_sequences
						</dt>
						<dd>If true, then ensure that at least one ngram is
generated for each input sequence.  In particular, if an input sequence is
shorter than `min(ngram_width) + 2*pad_width`, then generate a single
ngram containing the entire sequence.  If false, then no ngrams are
generated for these short input sequences. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>The op name. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A RaggedTensor of ngrams. If `data.shape=[D1...DN, S]`, then
`output.shape=[D1...DN, NUM_NGRAMS]`, where
`NUM_NGRAMS=S-ngram_width+1+2*padding_width`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="regex_full_match" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>regex_full_match</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> input, <span title="System.string">string</span> pattern, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Check if the input matches the regex pattern. <p></p> The input is a string tensor of any shape. The pattern is a scalar
string tensor which is applied to every element of the input tensor.
The boolean values (True or False) of the output tensor indicate
if the input matches the regex pattern provided. <p></p> The pattern follows the re2 syntax (https://github.com/google/re2/wiki/Syntax) 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> input
						</dt>
						<dd>A `Tensor` of type `string`.
A string tensor of the text to be processed. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> pattern
						</dt>
						<dd>A `Tensor` of type `string`.
A scalar string tensor containing the regular expression to match the input. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of type `bool`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="regex_full_match" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>regex_full_match</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> input, <span title="System.ValueTuple<Byte[], string>">ValueTuple&lt;Byte[], string&gt;</span> pattern, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Check if the input matches the regex pattern. <p></p> The input is a string tensor of any shape. The pattern is a scalar
string tensor which is applied to every element of the input tensor.
The boolean values (True or False) of the output tensor indicate
if the input matches the regex pattern provided. <p></p> The pattern follows the re2 syntax (https://github.com/google/re2/wiki/Syntax) 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> input
						</dt>
						<dd>A `Tensor` of type `string`.
A string tensor of the text to be processed. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<Byte[], string>">ValueTuple&lt;Byte[], string&gt;</span></code> pattern
						</dt>
						<dd>A `Tensor` of type `string`.
A scalar string tensor containing the regular expression to match the input. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of type `bool`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="split" class="method">
		<h4>
			<span title="System.object">object</span> <strong>split</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> input, <span title="System.object">object</span> sep, <span title="System.int">int</span> maxsplit, <span title="System.string">string</span> result_type, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> source, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Split elements of `input` based on `sep`. <p></p> Let N be the size of `input` (typically N will be the batch size). Split each
element of `input` based on `sep` and return a `SparseTensor` or
`RaggedTensor` containing the split tokens. Empty tokens are ignored. <p></p> Examples:
If `sep` is given, consecutive delimiters are not grouped together and are
deemed to delimit empty strings. For example, `input` of `"1<>2<><>3"` and
`sep` of `"<>"` returns `["1", "2", "", "3"]`. If `sep` is None or an empty
string, consecutive whitespace are regarded as a single separator, and the
result will contain no empty strings at the start or end if the string has
leading or trailing whitespace. <p></p> Note that the above mentioned behavior matches python's str.split. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> input
						</dt>
						<dd>A string `Tensor` of rank `N`, the strings to split.  If
`rank(input)` is not known statically, then it is assumed to be `1`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> sep
						</dt>
						<dd>`0-D` string `Tensor`, the delimiter character. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> maxsplit
						</dt>
						<dd>An `int`. If `maxsplit > 0`, limit of the split of the result. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> result_type
						</dt>
						<dd>The tensor type for the result: one of `"RaggedTensor"` or
`"SparseTensor"`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> source
						</dt>
						<dd>alias for "input" argument. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `SparseTensor` or `RaggedTensor` of rank `N+1`, the strings split
according to the delimiter. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> tf.strings.split(['hello world', 'a b c'])
            tf.SparseTensor(indices=[[0, 0], [0, 1], [1, 0], [1, 1], [1, 2]],
                            values=['hello', 'world', 'a', 'b', 'c']
                            dense_shape=[2, 3]) <p></p> >>> tf.strings.split(['hello world', 'a b c'], result_type="RaggedTensor")
<tf.RaggedTensor [['hello', 'world'], ['a', 'b', 'c']]> </pre>
</div>
		</div>
	</div>
	<div id="split" class="method">
		<h4>
			<span title="System.object">object</span> <strong>split</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> input, <span title="System.object">object</span> sep, <span title="System.int">int</span> maxsplit, <span title="System.string">string</span> result_type, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> source, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Split elements of `input` based on `sep`. <p></p> Let N be the size of `input` (typically N will be the batch size). Split each
element of `input` based on `sep` and return a `SparseTensor` or
`RaggedTensor` containing the split tokens. Empty tokens are ignored. <p></p> Examples:
If `sep` is given, consecutive delimiters are not grouped together and are
deemed to delimit empty strings. For example, `input` of `"1<>2<><>3"` and
`sep` of `"<>"` returns `["1", "2", "", "3"]`. If `sep` is None or an empty
string, consecutive whitespace are regarded as a single separator, and the
result will contain no empty strings at the start or end if the string has
leading or trailing whitespace. <p></p> Note that the above mentioned behavior matches python's str.split. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> input
						</dt>
						<dd>A string `Tensor` of rank `N`, the strings to split.  If
`rank(input)` is not known statically, then it is assumed to be `1`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> sep
						</dt>
						<dd>`0-D` string `Tensor`, the delimiter character. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> maxsplit
						</dt>
						<dd>An `int`. If `maxsplit > 0`, limit of the split of the result. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> result_type
						</dt>
						<dd>The tensor type for the result: one of `"RaggedTensor"` or
`"SparseTensor"`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> source
						</dt>
						<dd>alias for "input" argument. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `SparseTensor` or `RaggedTensor` of rank `N+1`, the strings split
according to the delimiter. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> tf.strings.split(['hello world', 'a b c'])
            tf.SparseTensor(indices=[[0, 0], [0, 1], [1, 0], [1, 1], [1, 2]],
                            values=['hello', 'world', 'a', 'b', 'c']
                            dense_shape=[2, 3]) <p></p> >>> tf.strings.split(['hello world', 'a b c'], result_type="RaggedTensor")
<tf.RaggedTensor [['hello', 'world'], ['a', 'b', 'c']]> </pre>
</div>
		</div>
	</div>
	<div id="split" class="method">
		<h4>
			<span title="System.object">object</span> <strong>split</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> input, <span title="System.object">object</span> sep, <span title="System.int">int</span> maxsplit, <span title="System.string">string</span> result_type, <span title="System.int">int</span> source, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Split elements of `input` based on `sep`. <p></p> Let N be the size of `input` (typically N will be the batch size). Split each
element of `input` based on `sep` and return a `SparseTensor` or
`RaggedTensor` containing the split tokens. Empty tokens are ignored. <p></p> Examples:
If `sep` is given, consecutive delimiters are not grouped together and are
deemed to delimit empty strings. For example, `input` of `"1<>2<><>3"` and
`sep` of `"<>"` returns `["1", "2", "", "3"]`. If `sep` is None or an empty
string, consecutive whitespace are regarded as a single separator, and the
result will contain no empty strings at the start or end if the string has
leading or trailing whitespace. <p></p> Note that the above mentioned behavior matches python's str.split. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> input
						</dt>
						<dd>A string `Tensor` of rank `N`, the strings to split.  If
`rank(input)` is not known statically, then it is assumed to be `1`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> sep
						</dt>
						<dd>`0-D` string `Tensor`, the delimiter character. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> maxsplit
						</dt>
						<dd>An `int`. If `maxsplit > 0`, limit of the split of the result. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> result_type
						</dt>
						<dd>The tensor type for the result: one of `"RaggedTensor"` or
`"SparseTensor"`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> source
						</dt>
						<dd>alias for "input" argument. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `SparseTensor` or `RaggedTensor` of rank `N+1`, the strings split
according to the delimiter. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> tf.strings.split(['hello world', 'a b c'])
            tf.SparseTensor(indices=[[0, 0], [0, 1], [1, 0], [1, 1], [1, 2]],
                            values=['hello', 'world', 'a', 'b', 'c']
                            dense_shape=[2, 3]) <p></p> >>> tf.strings.split(['hello world', 'a b c'], result_type="RaggedTensor")
<tf.RaggedTensor [['hello', 'world'], ['a', 'b', 'c']]> </pre>
</div>
		</div>
	</div>
	<div id="split" class="method">
		<h4>
			<span title="System.object">object</span> <strong>split</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> input, <span title="System.object">object</span> sep, <span title="System.int">int</span> maxsplit, <span title="System.string">string</span> result_type, <span title="System.int">int</span> source, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Split elements of `input` based on `sep`. <p></p> Let N be the size of `input` (typically N will be the batch size). Split each
element of `input` based on `sep` and return a `SparseTensor` or
`RaggedTensor` containing the split tokens. Empty tokens are ignored. <p></p> Examples:
If `sep` is given, consecutive delimiters are not grouped together and are
deemed to delimit empty strings. For example, `input` of `"1<>2<><>3"` and
`sep` of `"<>"` returns `["1", "2", "", "3"]`. If `sep` is None or an empty
string, consecutive whitespace are regarded as a single separator, and the
result will contain no empty strings at the start or end if the string has
leading or trailing whitespace. <p></p> Note that the above mentioned behavior matches python's str.split. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> input
						</dt>
						<dd>A string `Tensor` of rank `N`, the strings to split.  If
`rank(input)` is not known statically, then it is assumed to be `1`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> sep
						</dt>
						<dd>`0-D` string `Tensor`, the delimiter character. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> maxsplit
						</dt>
						<dd>An `int`. If `maxsplit > 0`, limit of the split of the result. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> result_type
						</dt>
						<dd>The tensor type for the result: one of `"RaggedTensor"` or
`"SparseTensor"`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> source
						</dt>
						<dd>alias for "input" argument. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `SparseTensor` or `RaggedTensor` of rank `N+1`, the strings split
according to the delimiter. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> tf.strings.split(['hello world', 'a b c'])
            tf.SparseTensor(indices=[[0, 0], [0, 1], [1, 0], [1, 1], [1, 2]],
                            values=['hello', 'world', 'a', 'b', 'c']
                            dense_shape=[2, 3]) <p></p> >>> tf.strings.split(['hello world', 'a b c'], result_type="RaggedTensor")
<tf.RaggedTensor [['hello', 'world'], ['a', 'b', 'c']]> </pre>
</div>
		</div>
	</div>
	<div id="split" class="method">
		<h4>
			<span title="System.object">object</span> <strong>split</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> input, <span title="System.object">object</span> sep, <span title="System.int">int</span> maxsplit, <span title="System.string">string</span> result_type, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> source, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Split elements of `input` based on `sep`. <p></p> Let N be the size of `input` (typically N will be the batch size). Split each
element of `input` based on `sep` and return a `SparseTensor` or
`RaggedTensor` containing the split tokens. Empty tokens are ignored. <p></p> Examples:
If `sep` is given, consecutive delimiters are not grouped together and are
deemed to delimit empty strings. For example, `input` of `"1<>2<><>3"` and
`sep` of `"<>"` returns `["1", "2", "", "3"]`. If `sep` is None or an empty
string, consecutive whitespace are regarded as a single separator, and the
result will contain no empty strings at the start or end if the string has
leading or trailing whitespace. <p></p> Note that the above mentioned behavior matches python's str.split. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> input
						</dt>
						<dd>A string `Tensor` of rank `N`, the strings to split.  If
`rank(input)` is not known statically, then it is assumed to be `1`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> sep
						</dt>
						<dd>`0-D` string `Tensor`, the delimiter character. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> maxsplit
						</dt>
						<dd>An `int`. If `maxsplit > 0`, limit of the split of the result. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> result_type
						</dt>
						<dd>The tensor type for the result: one of `"RaggedTensor"` or
`"SparseTensor"`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> source
						</dt>
						<dd>alias for "input" argument. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `SparseTensor` or `RaggedTensor` of rank `N+1`, the strings split
according to the delimiter. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> tf.strings.split(['hello world', 'a b c'])
            tf.SparseTensor(indices=[[0, 0], [0, 1], [1, 0], [1, 1], [1, 2]],
                            values=['hello', 'world', 'a', 'b', 'c']
                            dense_shape=[2, 3]) <p></p> >>> tf.strings.split(['hello world', 'a b c'], result_type="RaggedTensor")
<tf.RaggedTensor [['hello', 'world'], ['a', 'b', 'c']]> </pre>
</div>
		</div>
	</div>
	<div id="split" class="method">
		<h4>
			<span title="System.object">object</span> <strong>split</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> input, <span title="System.object">object</span> sep, <span title="System.int">int</span> maxsplit, <span title="System.string">string</span> result_type, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> source, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Split elements of `input` based on `sep`. <p></p> Let N be the size of `input` (typically N will be the batch size). Split each
element of `input` based on `sep` and return a `SparseTensor` or
`RaggedTensor` containing the split tokens. Empty tokens are ignored. <p></p> Examples:
If `sep` is given, consecutive delimiters are not grouped together and are
deemed to delimit empty strings. For example, `input` of `"1<>2<><>3"` and
`sep` of `"<>"` returns `["1", "2", "", "3"]`. If `sep` is None or an empty
string, consecutive whitespace are regarded as a single separator, and the
result will contain no empty strings at the start or end if the string has
leading or trailing whitespace. <p></p> Note that the above mentioned behavior matches python's str.split. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> input
						</dt>
						<dd>A string `Tensor` of rank `N`, the strings to split.  If
`rank(input)` is not known statically, then it is assumed to be `1`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> sep
						</dt>
						<dd>`0-D` string `Tensor`, the delimiter character. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> maxsplit
						</dt>
						<dd>An `int`. If `maxsplit > 0`, limit of the split of the result. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> result_type
						</dt>
						<dd>The tensor type for the result: one of `"RaggedTensor"` or
`"SparseTensor"`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> source
						</dt>
						<dd>alias for "input" argument. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `SparseTensor` or `RaggedTensor` of rank `N+1`, the strings split
according to the delimiter. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> tf.strings.split(['hello world', 'a b c'])
            tf.SparseTensor(indices=[[0, 0], [0, 1], [1, 0], [1, 1], [1, 2]],
                            values=['hello', 'world', 'a', 'b', 'c']
                            dense_shape=[2, 3]) <p></p> >>> tf.strings.split(['hello world', 'a b c'], result_type="RaggedTensor")
<tf.RaggedTensor [['hello', 'world'], ['a', 'b', 'c']]> </pre>
</div>
		</div>
	</div>
	<div id="split" class="method">
		<h4>
			<span title="System.object">object</span> <strong>split</strong>(<span title="System.int">int</span> input, <span title="System.object">object</span> sep, <span title="System.int">int</span> maxsplit, <span title="System.string">string</span> result_type, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> source, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Split elements of `input` based on `sep`. <p></p> Let N be the size of `input` (typically N will be the batch size). Split each
element of `input` based on `sep` and return a `SparseTensor` or
`RaggedTensor` containing the split tokens. Empty tokens are ignored. <p></p> Examples:
If `sep` is given, consecutive delimiters are not grouped together and are
deemed to delimit empty strings. For example, `input` of `"1<>2<><>3"` and
`sep` of `"<>"` returns `["1", "2", "", "3"]`. If `sep` is None or an empty
string, consecutive whitespace are regarded as a single separator, and the
result will contain no empty strings at the start or end if the string has
leading or trailing whitespace. <p></p> Note that the above mentioned behavior matches python's str.split. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> input
						</dt>
						<dd>A string `Tensor` of rank `N`, the strings to split.  If
`rank(input)` is not known statically, then it is assumed to be `1`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> sep
						</dt>
						<dd>`0-D` string `Tensor`, the delimiter character. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> maxsplit
						</dt>
						<dd>An `int`. If `maxsplit > 0`, limit of the split of the result. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> result_type
						</dt>
						<dd>The tensor type for the result: one of `"RaggedTensor"` or
`"SparseTensor"`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> source
						</dt>
						<dd>alias for "input" argument. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `SparseTensor` or `RaggedTensor` of rank `N+1`, the strings split
according to the delimiter. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> tf.strings.split(['hello world', 'a b c'])
            tf.SparseTensor(indices=[[0, 0], [0, 1], [1, 0], [1, 1], [1, 2]],
                            values=['hello', 'world', 'a', 'b', 'c']
                            dense_shape=[2, 3]) <p></p> >>> tf.strings.split(['hello world', 'a b c'], result_type="RaggedTensor")
<tf.RaggedTensor [['hello', 'world'], ['a', 'b', 'c']]> </pre>
</div>
		</div>
	</div>
	<div id="split" class="method">
		<h4>
			<span title="System.object">object</span> <strong>split</strong>(<span title="System.int">int</span> input, <span title="System.object">object</span> sep, <span title="System.int">int</span> maxsplit, <span title="System.string">string</span> result_type, <span title="System.int">int</span> source, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Split elements of `input` based on `sep`. <p></p> Let N be the size of `input` (typically N will be the batch size). Split each
element of `input` based on `sep` and return a `SparseTensor` or
`RaggedTensor` containing the split tokens. Empty tokens are ignored. <p></p> Examples:
If `sep` is given, consecutive delimiters are not grouped together and are
deemed to delimit empty strings. For example, `input` of `"1<>2<><>3"` and
`sep` of `"<>"` returns `["1", "2", "", "3"]`. If `sep` is None or an empty
string, consecutive whitespace are regarded as a single separator, and the
result will contain no empty strings at the start or end if the string has
leading or trailing whitespace. <p></p> Note that the above mentioned behavior matches python's str.split. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> input
						</dt>
						<dd>A string `Tensor` of rank `N`, the strings to split.  If
`rank(input)` is not known statically, then it is assumed to be `1`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> sep
						</dt>
						<dd>`0-D` string `Tensor`, the delimiter character. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> maxsplit
						</dt>
						<dd>An `int`. If `maxsplit > 0`, limit of the split of the result. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> result_type
						</dt>
						<dd>The tensor type for the result: one of `"RaggedTensor"` or
`"SparseTensor"`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> source
						</dt>
						<dd>alias for "input" argument. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `SparseTensor` or `RaggedTensor` of rank `N+1`, the strings split
according to the delimiter. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> tf.strings.split(['hello world', 'a b c'])
            tf.SparseTensor(indices=[[0, 0], [0, 1], [1, 0], [1, 1], [1, 2]],
                            values=['hello', 'world', 'a', 'b', 'c']
                            dense_shape=[2, 3]) <p></p> >>> tf.strings.split(['hello world', 'a b c'], result_type="RaggedTensor")
<tf.RaggedTensor [['hello', 'world'], ['a', 'b', 'c']]> </pre>
</div>
		</div>
	</div>
	<div id="split" class="method">
		<h4>
			<span title="System.object">object</span> <strong>split</strong>(<span title="System.int">int</span> input, <span title="System.object">object</span> sep, <span title="System.int">int</span> maxsplit, <span title="System.string">string</span> result_type, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> source, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Split elements of `input` based on `sep`. <p></p> Let N be the size of `input` (typically N will be the batch size). Split each
element of `input` based on `sep` and return a `SparseTensor` or
`RaggedTensor` containing the split tokens. Empty tokens are ignored. <p></p> Examples:
If `sep` is given, consecutive delimiters are not grouped together and are
deemed to delimit empty strings. For example, `input` of `"1<>2<><>3"` and
`sep` of `"<>"` returns `["1", "2", "", "3"]`. If `sep` is None or an empty
string, consecutive whitespace are regarded as a single separator, and the
result will contain no empty strings at the start or end if the string has
leading or trailing whitespace. <p></p> Note that the above mentioned behavior matches python's str.split. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> input
						</dt>
						<dd>A string `Tensor` of rank `N`, the strings to split.  If
`rank(input)` is not known statically, then it is assumed to be `1`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> sep
						</dt>
						<dd>`0-D` string `Tensor`, the delimiter character. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> maxsplit
						</dt>
						<dd>An `int`. If `maxsplit > 0`, limit of the split of the result. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> result_type
						</dt>
						<dd>The tensor type for the result: one of `"RaggedTensor"` or
`"SparseTensor"`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> source
						</dt>
						<dd>alias for "input" argument. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `SparseTensor` or `RaggedTensor` of rank `N+1`, the strings split
according to the delimiter. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> tf.strings.split(['hello world', 'a b c'])
            tf.SparseTensor(indices=[[0, 0], [0, 1], [1, 0], [1, 1], [1, 2]],
                            values=['hello', 'world', 'a', 'b', 'c']
                            dense_shape=[2, 3]) <p></p> >>> tf.strings.split(['hello world', 'a b c'], result_type="RaggedTensor")
<tf.RaggedTensor [['hello', 'world'], ['a', 'b', 'c']]> </pre>
</div>
		</div>
	</div>
	<div id="split_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>split_dyn</strong>(<span title="System.object">object</span> input, <span title="System.object">object</span> sep, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> maxsplit, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> result_type, <span title="System.object">object</span> source, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Split elements of `input` based on `sep`. <p></p> Let N be the size of `input` (typically N will be the batch size). Split each
element of `input` based on `sep` and return a `SparseTensor` or
`RaggedTensor` containing the split tokens. Empty tokens are ignored. <p></p> Examples:
If `sep` is given, consecutive delimiters are not grouped together and are
deemed to delimit empty strings. For example, `input` of `"1<>2<><>3"` and
`sep` of `"<>"` returns `["1", "2", "", "3"]`. If `sep` is None or an empty
string, consecutive whitespace are regarded as a single separator, and the
result will contain no empty strings at the start or end if the string has
leading or trailing whitespace. <p></p> Note that the above mentioned behavior matches python's str.split. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> input
						</dt>
						<dd>A string `Tensor` of rank `N`, the strings to split.  If
`rank(input)` is not known statically, then it is assumed to be `1`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> sep
						</dt>
						<dd>`0-D` string `Tensor`, the delimiter character. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> maxsplit
						</dt>
						<dd>An `int`. If `maxsplit > 0`, limit of the split of the result. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> result_type
						</dt>
						<dd>The tensor type for the result: one of `"RaggedTensor"` or
`"SparseTensor"`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> source
						</dt>
						<dd>alias for "input" argument. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `SparseTensor` or `RaggedTensor` of rank `N+1`, the strings split
according to the delimiter. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> tf.strings.split(['hello world', 'a b c'])
            tf.SparseTensor(indices=[[0, 0], [0, 1], [1, 0], [1, 1], [1, 2]],
                            values=['hello', 'world', 'a', 'b', 'c']
                            dense_shape=[2, 3]) <p></p> >>> tf.strings.split(['hello world', 'a b c'], result_type="RaggedTensor")
<tf.RaggedTensor [['hello', 'world'], ['a', 'b', 'c']]> </pre>
</div>
		</div>
	</div>
	<div id="substr" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>substr</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> input, <a href="../numpy/ndarray.htm">ndarray</a> pos, <a href="../numpy/ndarray.htm">ndarray</a> len, <span title="System.string">string</span> name, <span title="System.string">string</span> unit)
		</h4>
		<div class="content">Return substrings from `Tensor` of strings. <p></p> For each string in the input `Tensor`, creates a substring starting at index
`pos` with a total length of `len`. <p></p> If `len` defines a substring that would extend beyond the length of the input
string, then as many characters as possible are used. <p></p> A negative `pos` indicates distance within the string backwards from the end. <p></p> If `pos` specifies an index which is out of range for any of the input strings,
then an `InvalidArgumentError` is thrown. <p></p> `pos` and `len` must have the same shape, otherwise a `ValueError` is thrown on
Op creation. <p></p> *NOTE*: `Substr` supports broadcasting up to two dimensions. More about
broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html) <p></p> --- <p></p> Examples <p></p> Using scalar `pos` and `len`:
Using `pos` and `len` with same shape as `input`:
Broadcasting `pos` and `len` onto `input`: <p></p> ```
input = [[b'ten', b'eleven', b'twelve'],
[b'thirteen', b'fourteen', b'fifteen'],
[b'sixteen', b'seventeen', b'eighteen'],
[b'nineteen', b'twenty', b'twentyone']]
position = [1, 2, 3]
length =   [1, 2, 3] <p></p> output = [[b'e', b'ev', b'lve'],
[b'h', b'ur', b'tee'],
[b'i', b've', b'hte'],
[b'i', b'en', b'nty']]
``` <p></p> Broadcasting `input` onto `pos` and `len`: <p></p> ```
input = b'thirteen'
position = [1, 5, 7]
length =   [3, 2, 1] <p></p> output = [b'hir', b'ee', b'n']
``` 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> input
						</dt>
						<dd>A `Tensor` of type `string`. Tensor of strings 
						</dd>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> pos
						</dt>
						<dd>A `Tensor`. Must be one of the following types: `int32`, `int64`.
Scalar defining the position of first character in each substring 
						</dd>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> len
						</dt>
						<dd>A `Tensor`. Must have the same type as `pos`.
Scalar defining the number of characters to include in each substring 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> unit
						</dt>
						<dd>An optional `string` from: `"BYTE", "UTF8_CHAR"`. Defaults to `"BYTE"`.
The unit that is used to create the substring.  One of: `"BYTE"` (for
defining position and length by bytes) or `"UTF8_CHAR"` (for the UTF-8
encoded Unicode code points).  The default is `"BYTE"`. Results are undefined if
`unit=UTF8_CHAR` and the `input` strings do not contain structurally valid
UTF-8. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of type `string`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>input = [b'Hello', b'World']
            position = 1
            length = 3 <p></p> output = [b'ell', b'orl'] </pre>
</div>
		</div>
	</div>
	<div id="substr" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>substr</strong>(<span title="System.Byte[]">Byte[]</span> input, <a href="../numpy/ndarray.htm">ndarray</a> pos, <a href="../numpy/ndarray.htm">ndarray</a> len, <span title="System.string">string</span> name, <span title="System.string">string</span> unit)
		</h4>
		<div class="content">Return substrings from `Tensor` of strings. <p></p> For each string in the input `Tensor`, creates a substring starting at index
`pos` with a total length of `len`. <p></p> If `len` defines a substring that would extend beyond the length of the input
string, then as many characters as possible are used. <p></p> A negative `pos` indicates distance within the string backwards from the end. <p></p> If `pos` specifies an index which is out of range for any of the input strings,
then an `InvalidArgumentError` is thrown. <p></p> `pos` and `len` must have the same shape, otherwise a `ValueError` is thrown on
Op creation. <p></p> *NOTE*: `Substr` supports broadcasting up to two dimensions. More about
broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html) <p></p> --- <p></p> Examples <p></p> Using scalar `pos` and `len`:
Using `pos` and `len` with same shape as `input`:
Broadcasting `pos` and `len` onto `input`: <p></p> ```
input = [[b'ten', b'eleven', b'twelve'],
[b'thirteen', b'fourteen', b'fifteen'],
[b'sixteen', b'seventeen', b'eighteen'],
[b'nineteen', b'twenty', b'twentyone']]
position = [1, 2, 3]
length =   [1, 2, 3] <p></p> output = [[b'e', b'ev', b'lve'],
[b'h', b'ur', b'tee'],
[b'i', b've', b'hte'],
[b'i', b'en', b'nty']]
``` <p></p> Broadcasting `input` onto `pos` and `len`: <p></p> ```
input = b'thirteen'
position = [1, 5, 7]
length =   [3, 2, 1] <p></p> output = [b'hir', b'ee', b'n']
``` 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Byte[]">Byte[]</span></code> input
						</dt>
						<dd>A `Tensor` of type `string`. Tensor of strings 
						</dd>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> pos
						</dt>
						<dd>A `Tensor`. Must be one of the following types: `int32`, `int64`.
Scalar defining the position of first character in each substring 
						</dd>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> len
						</dt>
						<dd>A `Tensor`. Must have the same type as `pos`.
Scalar defining the number of characters to include in each substring 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> unit
						</dt>
						<dd>An optional `string` from: `"BYTE", "UTF8_CHAR"`. Defaults to `"BYTE"`.
The unit that is used to create the substring.  One of: `"BYTE"` (for
defining position and length by bytes) or `"UTF8_CHAR"` (for the UTF-8
encoded Unicode code points).  The default is `"BYTE"`. Results are undefined if
`unit=UTF8_CHAR` and the `input` strings do not contain structurally valid
UTF-8. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of type `string`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>input = [b'Hello', b'World']
            position = 1
            length = 3 <p></p> output = [b'ell', b'orl'] </pre>
</div>
		</div>
	</div>
	<div id="substr" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>substr</strong>(<a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> input, <span title="System.double">double</span> pos, <span title="System.double">double</span> len, <span title="System.string">string</span> name, <span title="System.string">string</span> unit)
		</h4>
		<div class="content">Return substrings from `Tensor` of strings. <p></p> For each string in the input `Tensor`, creates a substring starting at index
`pos` with a total length of `len`. <p></p> If `len` defines a substring that would extend beyond the length of the input
string, then as many characters as possible are used. <p></p> A negative `pos` indicates distance within the string backwards from the end. <p></p> If `pos` specifies an index which is out of range for any of the input strings,
then an `InvalidArgumentError` is thrown. <p></p> `pos` and `len` must have the same shape, otherwise a `ValueError` is thrown on
Op creation. <p></p> *NOTE*: `Substr` supports broadcasting up to two dimensions. More about
broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html) <p></p> --- <p></p> Examples <p></p> Using scalar `pos` and `len`:
Using `pos` and `len` with same shape as `input`:
Broadcasting `pos` and `len` onto `input`: <p></p> ```
input = [[b'ten', b'eleven', b'twelve'],
[b'thirteen', b'fourteen', b'fifteen'],
[b'sixteen', b'seventeen', b'eighteen'],
[b'nineteen', b'twenty', b'twentyone']]
position = [1, 2, 3]
length =   [1, 2, 3] <p></p> output = [[b'e', b'ev', b'lve'],
[b'h', b'ur', b'tee'],
[b'i', b've', b'hte'],
[b'i', b'en', b'nty']]
``` <p></p> Broadcasting `input` onto `pos` and `len`: <p></p> ```
input = b'thirteen'
position = [1, 5, 7]
length =   [3, 2, 1] <p></p> output = [b'hir', b'ee', b'n']
``` 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> input
						</dt>
						<dd>A `Tensor` of type `string`. Tensor of strings 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> pos
						</dt>
						<dd>A `Tensor`. Must be one of the following types: `int32`, `int64`.
Scalar defining the position of first character in each substring 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> len
						</dt>
						<dd>A `Tensor`. Must have the same type as `pos`.
Scalar defining the number of characters to include in each substring 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> unit
						</dt>
						<dd>An optional `string` from: `"BYTE", "UTF8_CHAR"`. Defaults to `"BYTE"`.
The unit that is used to create the substring.  One of: `"BYTE"` (for
defining position and length by bytes) or `"UTF8_CHAR"` (for the UTF-8
encoded Unicode code points).  The default is `"BYTE"`. Results are undefined if
`unit=UTF8_CHAR` and the `input` strings do not contain structurally valid
UTF-8. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of type `string`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>input = [b'Hello', b'World']
            position = 1
            length = 3 <p></p> output = [b'ell', b'orl'] </pre>
</div>
		</div>
	</div>
	<div id="substr" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>substr</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> input, <span title="System.int">int</span> pos, <span title="System.int">int</span> len, <span title="System.string">string</span> name, <span title="System.string">string</span> unit)
		</h4>
		<div class="content">Return substrings from `Tensor` of strings. <p></p> For each string in the input `Tensor`, creates a substring starting at index
`pos` with a total length of `len`. <p></p> If `len` defines a substring that would extend beyond the length of the input
string, then as many characters as possible are used. <p></p> A negative `pos` indicates distance within the string backwards from the end. <p></p> If `pos` specifies an index which is out of range for any of the input strings,
then an `InvalidArgumentError` is thrown. <p></p> `pos` and `len` must have the same shape, otherwise a `ValueError` is thrown on
Op creation. <p></p> *NOTE*: `Substr` supports broadcasting up to two dimensions. More about
broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html) <p></p> --- <p></p> Examples <p></p> Using scalar `pos` and `len`:
Using `pos` and `len` with same shape as `input`:
Broadcasting `pos` and `len` onto `input`: <p></p> ```
input = [[b'ten', b'eleven', b'twelve'],
[b'thirteen', b'fourteen', b'fifteen'],
[b'sixteen', b'seventeen', b'eighteen'],
[b'nineteen', b'twenty', b'twentyone']]
position = [1, 2, 3]
length =   [1, 2, 3] <p></p> output = [[b'e', b'ev', b'lve'],
[b'h', b'ur', b'tee'],
[b'i', b've', b'hte'],
[b'i', b'en', b'nty']]
``` <p></p> Broadcasting `input` onto `pos` and `len`: <p></p> ```
input = b'thirteen'
position = [1, 5, 7]
length =   [3, 2, 1] <p></p> output = [b'hir', b'ee', b'n']
``` 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> input
						</dt>
						<dd>A `Tensor` of type `string`. Tensor of strings 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> pos
						</dt>
						<dd>A `Tensor`. Must be one of the following types: `int32`, `int64`.
Scalar defining the position of first character in each substring 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> len
						</dt>
						<dd>A `Tensor`. Must have the same type as `pos`.
Scalar defining the number of characters to include in each substring 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> unit
						</dt>
						<dd>An optional `string` from: `"BYTE", "UTF8_CHAR"`. Defaults to `"BYTE"`.
The unit that is used to create the substring.  One of: `"BYTE"` (for
defining position and length by bytes) or `"UTF8_CHAR"` (for the UTF-8
encoded Unicode code points).  The default is `"BYTE"`. Results are undefined if
`unit=UTF8_CHAR` and the `input` strings do not contain structurally valid
UTF-8. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of type `string`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>input = [b'Hello', b'World']
            position = 1
            length = 3 <p></p> output = [b'ell', b'orl'] </pre>
</div>
		</div>
	</div>
	<div id="substr" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>substr</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> input, <span title="System.int">int</span> pos, <a href="../numpy/ndarray.htm">ndarray</a> len, <span title="System.string">string</span> name, <span title="System.string">string</span> unit)
		</h4>
		<div class="content">Return substrings from `Tensor` of strings. <p></p> For each string in the input `Tensor`, creates a substring starting at index
`pos` with a total length of `len`. <p></p> If `len` defines a substring that would extend beyond the length of the input
string, then as many characters as possible are used. <p></p> A negative `pos` indicates distance within the string backwards from the end. <p></p> If `pos` specifies an index which is out of range for any of the input strings,
then an `InvalidArgumentError` is thrown. <p></p> `pos` and `len` must have the same shape, otherwise a `ValueError` is thrown on
Op creation. <p></p> *NOTE*: `Substr` supports broadcasting up to two dimensions. More about
broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html) <p></p> --- <p></p> Examples <p></p> Using scalar `pos` and `len`:
Using `pos` and `len` with same shape as `input`:
Broadcasting `pos` and `len` onto `input`: <p></p> ```
input = [[b'ten', b'eleven', b'twelve'],
[b'thirteen', b'fourteen', b'fifteen'],
[b'sixteen', b'seventeen', b'eighteen'],
[b'nineteen', b'twenty', b'twentyone']]
position = [1, 2, 3]
length =   [1, 2, 3] <p></p> output = [[b'e', b'ev', b'lve'],
[b'h', b'ur', b'tee'],
[b'i', b've', b'hte'],
[b'i', b'en', b'nty']]
``` <p></p> Broadcasting `input` onto `pos` and `len`: <p></p> ```
input = b'thirteen'
position = [1, 5, 7]
length =   [3, 2, 1] <p></p> output = [b'hir', b'ee', b'n']
``` 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> input
						</dt>
						<dd>A `Tensor` of type `string`. Tensor of strings 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> pos
						</dt>
						<dd>A `Tensor`. Must be one of the following types: `int32`, `int64`.
Scalar defining the position of first character in each substring 
						</dd>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> len
						</dt>
						<dd>A `Tensor`. Must have the same type as `pos`.
Scalar defining the number of characters to include in each substring 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> unit
						</dt>
						<dd>An optional `string` from: `"BYTE", "UTF8_CHAR"`. Defaults to `"BYTE"`.
The unit that is used to create the substring.  One of: `"BYTE"` (for
defining position and length by bytes) or `"UTF8_CHAR"` (for the UTF-8
encoded Unicode code points).  The default is `"BYTE"`. Results are undefined if
`unit=UTF8_CHAR` and the `input` strings do not contain structurally valid
UTF-8. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of type `string`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>input = [b'Hello', b'World']
            position = 1
            length = 3 <p></p> output = [b'ell', b'orl'] </pre>
</div>
		</div>
	</div>
	<div id="substr" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>substr</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> input, <span title="System.int">int</span> pos, <span title="System.double">double</span> len, <span title="System.string">string</span> name, <span title="System.string">string</span> unit)
		</h4>
		<div class="content">Return substrings from `Tensor` of strings. <p></p> For each string in the input `Tensor`, creates a substring starting at index
`pos` with a total length of `len`. <p></p> If `len` defines a substring that would extend beyond the length of the input
string, then as many characters as possible are used. <p></p> A negative `pos` indicates distance within the string backwards from the end. <p></p> If `pos` specifies an index which is out of range for any of the input strings,
then an `InvalidArgumentError` is thrown. <p></p> `pos` and `len` must have the same shape, otherwise a `ValueError` is thrown on
Op creation. <p></p> *NOTE*: `Substr` supports broadcasting up to two dimensions. More about
broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html) <p></p> --- <p></p> Examples <p></p> Using scalar `pos` and `len`:
Using `pos` and `len` with same shape as `input`:
Broadcasting `pos` and `len` onto `input`: <p></p> ```
input = [[b'ten', b'eleven', b'twelve'],
[b'thirteen', b'fourteen', b'fifteen'],
[b'sixteen', b'seventeen', b'eighteen'],
[b'nineteen', b'twenty', b'twentyone']]
position = [1, 2, 3]
length =   [1, 2, 3] <p></p> output = [[b'e', b'ev', b'lve'],
[b'h', b'ur', b'tee'],
[b'i', b've', b'hte'],
[b'i', b'en', b'nty']]
``` <p></p> Broadcasting `input` onto `pos` and `len`: <p></p> ```
input = b'thirteen'
position = [1, 5, 7]
length =   [3, 2, 1] <p></p> output = [b'hir', b'ee', b'n']
``` 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> input
						</dt>
						<dd>A `Tensor` of type `string`. Tensor of strings 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> pos
						</dt>
						<dd>A `Tensor`. Must be one of the following types: `int32`, `int64`.
Scalar defining the position of first character in each substring 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> len
						</dt>
						<dd>A `Tensor`. Must have the same type as `pos`.
Scalar defining the number of characters to include in each substring 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> unit
						</dt>
						<dd>An optional `string` from: `"BYTE", "UTF8_CHAR"`. Defaults to `"BYTE"`.
The unit that is used to create the substring.  One of: `"BYTE"` (for
defining position and length by bytes) or `"UTF8_CHAR"` (for the UTF-8
encoded Unicode code points).  The default is `"BYTE"`. Results are undefined if
`unit=UTF8_CHAR` and the `input` strings do not contain structurally valid
UTF-8. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of type `string`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>input = [b'Hello', b'World']
            position = 1
            length = 3 <p></p> output = [b'ell', b'orl'] </pre>
</div>
		</div>
	</div>
	<div id="substr" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>substr</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> input, <a href="../numpy/ndarray.htm">ndarray</a> pos, <span title="System.int">int</span> len, <span title="System.string">string</span> name, <span title="System.string">string</span> unit)
		</h4>
		<div class="content">Return substrings from `Tensor` of strings. <p></p> For each string in the input `Tensor`, creates a substring starting at index
`pos` with a total length of `len`. <p></p> If `len` defines a substring that would extend beyond the length of the input
string, then as many characters as possible are used. <p></p> A negative `pos` indicates distance within the string backwards from the end. <p></p> If `pos` specifies an index which is out of range for any of the input strings,
then an `InvalidArgumentError` is thrown. <p></p> `pos` and `len` must have the same shape, otherwise a `ValueError` is thrown on
Op creation. <p></p> *NOTE*: `Substr` supports broadcasting up to two dimensions. More about
broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html) <p></p> --- <p></p> Examples <p></p> Using scalar `pos` and `len`:
Using `pos` and `len` with same shape as `input`:
Broadcasting `pos` and `len` onto `input`: <p></p> ```
input = [[b'ten', b'eleven', b'twelve'],
[b'thirteen', b'fourteen', b'fifteen'],
[b'sixteen', b'seventeen', b'eighteen'],
[b'nineteen', b'twenty', b'twentyone']]
position = [1, 2, 3]
length =   [1, 2, 3] <p></p> output = [[b'e', b'ev', b'lve'],
[b'h', b'ur', b'tee'],
[b'i', b've', b'hte'],
[b'i', b'en', b'nty']]
``` <p></p> Broadcasting `input` onto `pos` and `len`: <p></p> ```
input = b'thirteen'
position = [1, 5, 7]
length =   [3, 2, 1] <p></p> output = [b'hir', b'ee', b'n']
``` 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> input
						</dt>
						<dd>A `Tensor` of type `string`. Tensor of strings 
						</dd>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> pos
						</dt>
						<dd>A `Tensor`. Must be one of the following types: `int32`, `int64`.
Scalar defining the position of first character in each substring 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> len
						</dt>
						<dd>A `Tensor`. Must have the same type as `pos`.
Scalar defining the number of characters to include in each substring 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> unit
						</dt>
						<dd>An optional `string` from: `"BYTE", "UTF8_CHAR"`. Defaults to `"BYTE"`.
The unit that is used to create the substring.  One of: `"BYTE"` (for
defining position and length by bytes) or `"UTF8_CHAR"` (for the UTF-8
encoded Unicode code points).  The default is `"BYTE"`. Results are undefined if
`unit=UTF8_CHAR` and the `input` strings do not contain structurally valid
UTF-8. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of type `string`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>input = [b'Hello', b'World']
            position = 1
            length = 3 <p></p> output = [b'ell', b'orl'] </pre>
</div>
		</div>
	</div>
	<div id="substr" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>substr</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> input, <a href="../numpy/ndarray.htm">ndarray</a> pos, <a href="../numpy/ndarray.htm">ndarray</a> len, <span title="System.string">string</span> name, <span title="System.string">string</span> unit)
		</h4>
		<div class="content">Return substrings from `Tensor` of strings. <p></p> For each string in the input `Tensor`, creates a substring starting at index
`pos` with a total length of `len`. <p></p> If `len` defines a substring that would extend beyond the length of the input
string, then as many characters as possible are used. <p></p> A negative `pos` indicates distance within the string backwards from the end. <p></p> If `pos` specifies an index which is out of range for any of the input strings,
then an `InvalidArgumentError` is thrown. <p></p> `pos` and `len` must have the same shape, otherwise a `ValueError` is thrown on
Op creation. <p></p> *NOTE*: `Substr` supports broadcasting up to two dimensions. More about
broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html) <p></p> --- <p></p> Examples <p></p> Using scalar `pos` and `len`:
Using `pos` and `len` with same shape as `input`:
Broadcasting `pos` and `len` onto `input`: <p></p> ```
input = [[b'ten', b'eleven', b'twelve'],
[b'thirteen', b'fourteen', b'fifteen'],
[b'sixteen', b'seventeen', b'eighteen'],
[b'nineteen', b'twenty', b'twentyone']]
position = [1, 2, 3]
length =   [1, 2, 3] <p></p> output = [[b'e', b'ev', b'lve'],
[b'h', b'ur', b'tee'],
[b'i', b've', b'hte'],
[b'i', b'en', b'nty']]
``` <p></p> Broadcasting `input` onto `pos` and `len`: <p></p> ```
input = b'thirteen'
position = [1, 5, 7]
length =   [3, 2, 1] <p></p> output = [b'hir', b'ee', b'n']
``` 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> input
						</dt>
						<dd>A `Tensor` of type `string`. Tensor of strings 
						</dd>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> pos
						</dt>
						<dd>A `Tensor`. Must be one of the following types: `int32`, `int64`.
Scalar defining the position of first character in each substring 
						</dd>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> len
						</dt>
						<dd>A `Tensor`. Must have the same type as `pos`.
Scalar defining the number of characters to include in each substring 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> unit
						</dt>
						<dd>An optional `string` from: `"BYTE", "UTF8_CHAR"`. Defaults to `"BYTE"`.
The unit that is used to create the substring.  One of: `"BYTE"` (for
defining position and length by bytes) or `"UTF8_CHAR"` (for the UTF-8
encoded Unicode code points).  The default is `"BYTE"`. Results are undefined if
`unit=UTF8_CHAR` and the `input` strings do not contain structurally valid
UTF-8. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of type `string`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>input = [b'Hello', b'World']
            position = 1
            length = 3 <p></p> output = [b'ell', b'orl'] </pre>
</div>
		</div>
	</div>
	<div id="substr" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>substr</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> input, <a href="../numpy/ndarray.htm">ndarray</a> pos, <span title="System.double">double</span> len, <span title="System.string">string</span> name, <span title="System.string">string</span> unit)
		</h4>
		<div class="content">Return substrings from `Tensor` of strings. <p></p> For each string in the input `Tensor`, creates a substring starting at index
`pos` with a total length of `len`. <p></p> If `len` defines a substring that would extend beyond the length of the input
string, then as many characters as possible are used. <p></p> A negative `pos` indicates distance within the string backwards from the end. <p></p> If `pos` specifies an index which is out of range for any of the input strings,
then an `InvalidArgumentError` is thrown. <p></p> `pos` and `len` must have the same shape, otherwise a `ValueError` is thrown on
Op creation. <p></p> *NOTE*: `Substr` supports broadcasting up to two dimensions. More about
broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html) <p></p> --- <p></p> Examples <p></p> Using scalar `pos` and `len`:
Using `pos` and `len` with same shape as `input`:
Broadcasting `pos` and `len` onto `input`: <p></p> ```
input = [[b'ten', b'eleven', b'twelve'],
[b'thirteen', b'fourteen', b'fifteen'],
[b'sixteen', b'seventeen', b'eighteen'],
[b'nineteen', b'twenty', b'twentyone']]
position = [1, 2, 3]
length =   [1, 2, 3] <p></p> output = [[b'e', b'ev', b'lve'],
[b'h', b'ur', b'tee'],
[b'i', b've', b'hte'],
[b'i', b'en', b'nty']]
``` <p></p> Broadcasting `input` onto `pos` and `len`: <p></p> ```
input = b'thirteen'
position = [1, 5, 7]
length =   [3, 2, 1] <p></p> output = [b'hir', b'ee', b'n']
``` 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> input
						</dt>
						<dd>A `Tensor` of type `string`. Tensor of strings 
						</dd>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> pos
						</dt>
						<dd>A `Tensor`. Must be one of the following types: `int32`, `int64`.
Scalar defining the position of first character in each substring 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> len
						</dt>
						<dd>A `Tensor`. Must have the same type as `pos`.
Scalar defining the number of characters to include in each substring 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> unit
						</dt>
						<dd>An optional `string` from: `"BYTE", "UTF8_CHAR"`. Defaults to `"BYTE"`.
The unit that is used to create the substring.  One of: `"BYTE"` (for
defining position and length by bytes) or `"UTF8_CHAR"` (for the UTF-8
encoded Unicode code points).  The default is `"BYTE"`. Results are undefined if
`unit=UTF8_CHAR` and the `input` strings do not contain structurally valid
UTF-8. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of type `string`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>input = [b'Hello', b'World']
            position = 1
            length = 3 <p></p> output = [b'ell', b'orl'] </pre>
</div>
		</div>
	</div>
	<div id="substr" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>substr</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> input, <span title="System.double">double</span> pos, <span title="System.int">int</span> len, <span title="System.string">string</span> name, <span title="System.string">string</span> unit)
		</h4>
		<div class="content">Return substrings from `Tensor` of strings. <p></p> For each string in the input `Tensor`, creates a substring starting at index
`pos` with a total length of `len`. <p></p> If `len` defines a substring that would extend beyond the length of the input
string, then as many characters as possible are used. <p></p> A negative `pos` indicates distance within the string backwards from the end. <p></p> If `pos` specifies an index which is out of range for any of the input strings,
then an `InvalidArgumentError` is thrown. <p></p> `pos` and `len` must have the same shape, otherwise a `ValueError` is thrown on
Op creation. <p></p> *NOTE*: `Substr` supports broadcasting up to two dimensions. More about
broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html) <p></p> --- <p></p> Examples <p></p> Using scalar `pos` and `len`:
Using `pos` and `len` with same shape as `input`:
Broadcasting `pos` and `len` onto `input`: <p></p> ```
input = [[b'ten', b'eleven', b'twelve'],
[b'thirteen', b'fourteen', b'fifteen'],
[b'sixteen', b'seventeen', b'eighteen'],
[b'nineteen', b'twenty', b'twentyone']]
position = [1, 2, 3]
length =   [1, 2, 3] <p></p> output = [[b'e', b'ev', b'lve'],
[b'h', b'ur', b'tee'],
[b'i', b've', b'hte'],
[b'i', b'en', b'nty']]
``` <p></p> Broadcasting `input` onto `pos` and `len`: <p></p> ```
input = b'thirteen'
position = [1, 5, 7]
length =   [3, 2, 1] <p></p> output = [b'hir', b'ee', b'n']
``` 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> input
						</dt>
						<dd>A `Tensor` of type `string`. Tensor of strings 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> pos
						</dt>
						<dd>A `Tensor`. Must be one of the following types: `int32`, `int64`.
Scalar defining the position of first character in each substring 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> len
						</dt>
						<dd>A `Tensor`. Must have the same type as `pos`.
Scalar defining the number of characters to include in each substring 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> unit
						</dt>
						<dd>An optional `string` from: `"BYTE", "UTF8_CHAR"`. Defaults to `"BYTE"`.
The unit that is used to create the substring.  One of: `"BYTE"` (for
defining position and length by bytes) or `"UTF8_CHAR"` (for the UTF-8
encoded Unicode code points).  The default is `"BYTE"`. Results are undefined if
`unit=UTF8_CHAR` and the `input` strings do not contain structurally valid
UTF-8. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of type `string`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>input = [b'Hello', b'World']
            position = 1
            length = 3 <p></p> output = [b'ell', b'orl'] </pre>
</div>
		</div>
	</div>
	<div id="substr" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>substr</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> input, <span title="System.double">double</span> pos, <a href="../numpy/ndarray.htm">ndarray</a> len, <span title="System.string">string</span> name, <span title="System.string">string</span> unit)
		</h4>
		<div class="content">Return substrings from `Tensor` of strings. <p></p> For each string in the input `Tensor`, creates a substring starting at index
`pos` with a total length of `len`. <p></p> If `len` defines a substring that would extend beyond the length of the input
string, then as many characters as possible are used. <p></p> A negative `pos` indicates distance within the string backwards from the end. <p></p> If `pos` specifies an index which is out of range for any of the input strings,
then an `InvalidArgumentError` is thrown. <p></p> `pos` and `len` must have the same shape, otherwise a `ValueError` is thrown on
Op creation. <p></p> *NOTE*: `Substr` supports broadcasting up to two dimensions. More about
broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html) <p></p> --- <p></p> Examples <p></p> Using scalar `pos` and `len`:
Using `pos` and `len` with same shape as `input`:
Broadcasting `pos` and `len` onto `input`: <p></p> ```
input = [[b'ten', b'eleven', b'twelve'],
[b'thirteen', b'fourteen', b'fifteen'],
[b'sixteen', b'seventeen', b'eighteen'],
[b'nineteen', b'twenty', b'twentyone']]
position = [1, 2, 3]
length =   [1, 2, 3] <p></p> output = [[b'e', b'ev', b'lve'],
[b'h', b'ur', b'tee'],
[b'i', b've', b'hte'],
[b'i', b'en', b'nty']]
``` <p></p> Broadcasting `input` onto `pos` and `len`: <p></p> ```
input = b'thirteen'
position = [1, 5, 7]
length =   [3, 2, 1] <p></p> output = [b'hir', b'ee', b'n']
``` 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> input
						</dt>
						<dd>A `Tensor` of type `string`. Tensor of strings 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> pos
						</dt>
						<dd>A `Tensor`. Must be one of the following types: `int32`, `int64`.
Scalar defining the position of first character in each substring 
						</dd>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> len
						</dt>
						<dd>A `Tensor`. Must have the same type as `pos`.
Scalar defining the number of characters to include in each substring 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> unit
						</dt>
						<dd>An optional `string` from: `"BYTE", "UTF8_CHAR"`. Defaults to `"BYTE"`.
The unit that is used to create the substring.  One of: `"BYTE"` (for
defining position and length by bytes) or `"UTF8_CHAR"` (for the UTF-8
encoded Unicode code points).  The default is `"BYTE"`. Results are undefined if
`unit=UTF8_CHAR` and the `input` strings do not contain structurally valid
UTF-8. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of type `string`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>input = [b'Hello', b'World']
            position = 1
            length = 3 <p></p> output = [b'ell', b'orl'] </pre>
</div>
		</div>
	</div>
	<div id="substr" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>substr</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> input, <span title="System.double">double</span> pos, <span title="System.double">double</span> len, <span title="System.string">string</span> name, <span title="System.string">string</span> unit)
		</h4>
		<div class="content">Return substrings from `Tensor` of strings. <p></p> For each string in the input `Tensor`, creates a substring starting at index
`pos` with a total length of `len`. <p></p> If `len` defines a substring that would extend beyond the length of the input
string, then as many characters as possible are used. <p></p> A negative `pos` indicates distance within the string backwards from the end. <p></p> If `pos` specifies an index which is out of range for any of the input strings,
then an `InvalidArgumentError` is thrown. <p></p> `pos` and `len` must have the same shape, otherwise a `ValueError` is thrown on
Op creation. <p></p> *NOTE*: `Substr` supports broadcasting up to two dimensions. More about
broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html) <p></p> --- <p></p> Examples <p></p> Using scalar `pos` and `len`:
Using `pos` and `len` with same shape as `input`:
Broadcasting `pos` and `len` onto `input`: <p></p> ```
input = [[b'ten', b'eleven', b'twelve'],
[b'thirteen', b'fourteen', b'fifteen'],
[b'sixteen', b'seventeen', b'eighteen'],
[b'nineteen', b'twenty', b'twentyone']]
position = [1, 2, 3]
length =   [1, 2, 3] <p></p> output = [[b'e', b'ev', b'lve'],
[b'h', b'ur', b'tee'],
[b'i', b've', b'hte'],
[b'i', b'en', b'nty']]
``` <p></p> Broadcasting `input` onto `pos` and `len`: <p></p> ```
input = b'thirteen'
position = [1, 5, 7]
length =   [3, 2, 1] <p></p> output = [b'hir', b'ee', b'n']
``` 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> input
						</dt>
						<dd>A `Tensor` of type `string`. Tensor of strings 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> pos
						</dt>
						<dd>A `Tensor`. Must be one of the following types: `int32`, `int64`.
Scalar defining the position of first character in each substring 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> len
						</dt>
						<dd>A `Tensor`. Must have the same type as `pos`.
Scalar defining the number of characters to include in each substring 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> unit
						</dt>
						<dd>An optional `string` from: `"BYTE", "UTF8_CHAR"`. Defaults to `"BYTE"`.
The unit that is used to create the substring.  One of: `"BYTE"` (for
defining position and length by bytes) or `"UTF8_CHAR"` (for the UTF-8
encoded Unicode code points).  The default is `"BYTE"`. Results are undefined if
`unit=UTF8_CHAR` and the `input` strings do not contain structurally valid
UTF-8. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of type `string`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>input = [b'Hello', b'World']
            position = 1
            length = 3 <p></p> output = [b'ell', b'orl'] </pre>
</div>
		</div>
	</div>
	<div id="substr" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>substr</strong>(<span title="System.Byte[]">Byte[]</span> input, <a href="../numpy/ndarray.htm">ndarray</a> pos, <span title="System.double">double</span> len, <span title="System.string">string</span> name, <span title="System.string">string</span> unit)
		</h4>
		<div class="content">Return substrings from `Tensor` of strings. <p></p> For each string in the input `Tensor`, creates a substring starting at index
`pos` with a total length of `len`. <p></p> If `len` defines a substring that would extend beyond the length of the input
string, then as many characters as possible are used. <p></p> A negative `pos` indicates distance within the string backwards from the end. <p></p> If `pos` specifies an index which is out of range for any of the input strings,
then an `InvalidArgumentError` is thrown. <p></p> `pos` and `len` must have the same shape, otherwise a `ValueError` is thrown on
Op creation. <p></p> *NOTE*: `Substr` supports broadcasting up to two dimensions. More about
broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html) <p></p> --- <p></p> Examples <p></p> Using scalar `pos` and `len`:
Using `pos` and `len` with same shape as `input`:
Broadcasting `pos` and `len` onto `input`: <p></p> ```
input = [[b'ten', b'eleven', b'twelve'],
[b'thirteen', b'fourteen', b'fifteen'],
[b'sixteen', b'seventeen', b'eighteen'],
[b'nineteen', b'twenty', b'twentyone']]
position = [1, 2, 3]
length =   [1, 2, 3] <p></p> output = [[b'e', b'ev', b'lve'],
[b'h', b'ur', b'tee'],
[b'i', b've', b'hte'],
[b'i', b'en', b'nty']]
``` <p></p> Broadcasting `input` onto `pos` and `len`: <p></p> ```
input = b'thirteen'
position = [1, 5, 7]
length =   [3, 2, 1] <p></p> output = [b'hir', b'ee', b'n']
``` 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Byte[]">Byte[]</span></code> input
						</dt>
						<dd>A `Tensor` of type `string`. Tensor of strings 
						</dd>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> pos
						</dt>
						<dd>A `Tensor`. Must be one of the following types: `int32`, `int64`.
Scalar defining the position of first character in each substring 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> len
						</dt>
						<dd>A `Tensor`. Must have the same type as `pos`.
Scalar defining the number of characters to include in each substring 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> unit
						</dt>
						<dd>An optional `string` from: `"BYTE", "UTF8_CHAR"`. Defaults to `"BYTE"`.
The unit that is used to create the substring.  One of: `"BYTE"` (for
defining position and length by bytes) or `"UTF8_CHAR"` (for the UTF-8
encoded Unicode code points).  The default is `"BYTE"`. Results are undefined if
`unit=UTF8_CHAR` and the `input` strings do not contain structurally valid
UTF-8. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of type `string`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>input = [b'Hello', b'World']
            position = 1
            length = 3 <p></p> output = [b'ell', b'orl'] </pre>
</div>
		</div>
	</div>
	<div id="substr" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>substr</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> input, <span title="System.int">int</span> pos, <span title="System.int">int</span> len, <span title="System.string">string</span> name, <span title="System.string">string</span> unit)
		</h4>
		<div class="content">Return substrings from `Tensor` of strings. <p></p> For each string in the input `Tensor`, creates a substring starting at index
`pos` with a total length of `len`. <p></p> If `len` defines a substring that would extend beyond the length of the input
string, then as many characters as possible are used. <p></p> A negative `pos` indicates distance within the string backwards from the end. <p></p> If `pos` specifies an index which is out of range for any of the input strings,
then an `InvalidArgumentError` is thrown. <p></p> `pos` and `len` must have the same shape, otherwise a `ValueError` is thrown on
Op creation. <p></p> *NOTE*: `Substr` supports broadcasting up to two dimensions. More about
broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html) <p></p> --- <p></p> Examples <p></p> Using scalar `pos` and `len`:
Using `pos` and `len` with same shape as `input`:
Broadcasting `pos` and `len` onto `input`: <p></p> ```
input = [[b'ten', b'eleven', b'twelve'],
[b'thirteen', b'fourteen', b'fifteen'],
[b'sixteen', b'seventeen', b'eighteen'],
[b'nineteen', b'twenty', b'twentyone']]
position = [1, 2, 3]
length =   [1, 2, 3] <p></p> output = [[b'e', b'ev', b'lve'],
[b'h', b'ur', b'tee'],
[b'i', b've', b'hte'],
[b'i', b'en', b'nty']]
``` <p></p> Broadcasting `input` onto `pos` and `len`: <p></p> ```
input = b'thirteen'
position = [1, 5, 7]
length =   [3, 2, 1] <p></p> output = [b'hir', b'ee', b'n']
``` 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> input
						</dt>
						<dd>A `Tensor` of type `string`. Tensor of strings 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> pos
						</dt>
						<dd>A `Tensor`. Must be one of the following types: `int32`, `int64`.
Scalar defining the position of first character in each substring 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> len
						</dt>
						<dd>A `Tensor`. Must have the same type as `pos`.
Scalar defining the number of characters to include in each substring 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> unit
						</dt>
						<dd>An optional `string` from: `"BYTE", "UTF8_CHAR"`. Defaults to `"BYTE"`.
The unit that is used to create the substring.  One of: `"BYTE"` (for
defining position and length by bytes) or `"UTF8_CHAR"` (for the UTF-8
encoded Unicode code points).  The default is `"BYTE"`. Results are undefined if
`unit=UTF8_CHAR` and the `input` strings do not contain structurally valid
UTF-8. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of type `string`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>input = [b'Hello', b'World']
            position = 1
            length = 3 <p></p> output = [b'ell', b'orl'] </pre>
</div>
		</div>
	</div>
	<div id="substr" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>substr</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> input, <span title="System.int">int</span> pos, <span title="System.double">double</span> len, <span title="System.string">string</span> name, <span title="System.string">string</span> unit)
		</h4>
		<div class="content">Return substrings from `Tensor` of strings. <p></p> For each string in the input `Tensor`, creates a substring starting at index
`pos` with a total length of `len`. <p></p> If `len` defines a substring that would extend beyond the length of the input
string, then as many characters as possible are used. <p></p> A negative `pos` indicates distance within the string backwards from the end. <p></p> If `pos` specifies an index which is out of range for any of the input strings,
then an `InvalidArgumentError` is thrown. <p></p> `pos` and `len` must have the same shape, otherwise a `ValueError` is thrown on
Op creation. <p></p> *NOTE*: `Substr` supports broadcasting up to two dimensions. More about
broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html) <p></p> --- <p></p> Examples <p></p> Using scalar `pos` and `len`:
Using `pos` and `len` with same shape as `input`:
Broadcasting `pos` and `len` onto `input`: <p></p> ```
input = [[b'ten', b'eleven', b'twelve'],
[b'thirteen', b'fourteen', b'fifteen'],
[b'sixteen', b'seventeen', b'eighteen'],
[b'nineteen', b'twenty', b'twentyone']]
position = [1, 2, 3]
length =   [1, 2, 3] <p></p> output = [[b'e', b'ev', b'lve'],
[b'h', b'ur', b'tee'],
[b'i', b've', b'hte'],
[b'i', b'en', b'nty']]
``` <p></p> Broadcasting `input` onto `pos` and `len`: <p></p> ```
input = b'thirteen'
position = [1, 5, 7]
length =   [3, 2, 1] <p></p> output = [b'hir', b'ee', b'n']
``` 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> input
						</dt>
						<dd>A `Tensor` of type `string`. Tensor of strings 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> pos
						</dt>
						<dd>A `Tensor`. Must be one of the following types: `int32`, `int64`.
Scalar defining the position of first character in each substring 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> len
						</dt>
						<dd>A `Tensor`. Must have the same type as `pos`.
Scalar defining the number of characters to include in each substring 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> unit
						</dt>
						<dd>An optional `string` from: `"BYTE", "UTF8_CHAR"`. Defaults to `"BYTE"`.
The unit that is used to create the substring.  One of: `"BYTE"` (for
defining position and length by bytes) or `"UTF8_CHAR"` (for the UTF-8
encoded Unicode code points).  The default is `"BYTE"`. Results are undefined if
`unit=UTF8_CHAR` and the `input` strings do not contain structurally valid
UTF-8. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of type `string`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>input = [b'Hello', b'World']
            position = 1
            length = 3 <p></p> output = [b'ell', b'orl'] </pre>
</div>
		</div>
	</div>
	<div id="substr" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>substr</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> input, <a href="../numpy/ndarray.htm">ndarray</a> pos, <span title="System.int">int</span> len, <span title="System.string">string</span> name, <span title="System.string">string</span> unit)
		</h4>
		<div class="content">Return substrings from `Tensor` of strings. <p></p> For each string in the input `Tensor`, creates a substring starting at index
`pos` with a total length of `len`. <p></p> If `len` defines a substring that would extend beyond the length of the input
string, then as many characters as possible are used. <p></p> A negative `pos` indicates distance within the string backwards from the end. <p></p> If `pos` specifies an index which is out of range for any of the input strings,
then an `InvalidArgumentError` is thrown. <p></p> `pos` and `len` must have the same shape, otherwise a `ValueError` is thrown on
Op creation. <p></p> *NOTE*: `Substr` supports broadcasting up to two dimensions. More about
broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html) <p></p> --- <p></p> Examples <p></p> Using scalar `pos` and `len`:
Using `pos` and `len` with same shape as `input`:
Broadcasting `pos` and `len` onto `input`: <p></p> ```
input = [[b'ten', b'eleven', b'twelve'],
[b'thirteen', b'fourteen', b'fifteen'],
[b'sixteen', b'seventeen', b'eighteen'],
[b'nineteen', b'twenty', b'twentyone']]
position = [1, 2, 3]
length =   [1, 2, 3] <p></p> output = [[b'e', b'ev', b'lve'],
[b'h', b'ur', b'tee'],
[b'i', b've', b'hte'],
[b'i', b'en', b'nty']]
``` <p></p> Broadcasting `input` onto `pos` and `len`: <p></p> ```
input = b'thirteen'
position = [1, 5, 7]
length =   [3, 2, 1] <p></p> output = [b'hir', b'ee', b'n']
``` 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> input
						</dt>
						<dd>A `Tensor` of type `string`. Tensor of strings 
						</dd>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> pos
						</dt>
						<dd>A `Tensor`. Must be one of the following types: `int32`, `int64`.
Scalar defining the position of first character in each substring 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> len
						</dt>
						<dd>A `Tensor`. Must have the same type as `pos`.
Scalar defining the number of characters to include in each substring 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> unit
						</dt>
						<dd>An optional `string` from: `"BYTE", "UTF8_CHAR"`. Defaults to `"BYTE"`.
The unit that is used to create the substring.  One of: `"BYTE"` (for
defining position and length by bytes) or `"UTF8_CHAR"` (for the UTF-8
encoded Unicode code points).  The default is `"BYTE"`. Results are undefined if
`unit=UTF8_CHAR` and the `input` strings do not contain structurally valid
UTF-8. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of type `string`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>input = [b'Hello', b'World']
            position = 1
            length = 3 <p></p> output = [b'ell', b'orl'] </pre>
</div>
		</div>
	</div>
	<div id="substr" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>substr</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> input, <a href="../numpy/ndarray.htm">ndarray</a> pos, <span title="System.double">double</span> len, <span title="System.string">string</span> name, <span title="System.string">string</span> unit)
		</h4>
		<div class="content">Return substrings from `Tensor` of strings. <p></p> For each string in the input `Tensor`, creates a substring starting at index
`pos` with a total length of `len`. <p></p> If `len` defines a substring that would extend beyond the length of the input
string, then as many characters as possible are used. <p></p> A negative `pos` indicates distance within the string backwards from the end. <p></p> If `pos` specifies an index which is out of range for any of the input strings,
then an `InvalidArgumentError` is thrown. <p></p> `pos` and `len` must have the same shape, otherwise a `ValueError` is thrown on
Op creation. <p></p> *NOTE*: `Substr` supports broadcasting up to two dimensions. More about
broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html) <p></p> --- <p></p> Examples <p></p> Using scalar `pos` and `len`:
Using `pos` and `len` with same shape as `input`:
Broadcasting `pos` and `len` onto `input`: <p></p> ```
input = [[b'ten', b'eleven', b'twelve'],
[b'thirteen', b'fourteen', b'fifteen'],
[b'sixteen', b'seventeen', b'eighteen'],
[b'nineteen', b'twenty', b'twentyone']]
position = [1, 2, 3]
length =   [1, 2, 3] <p></p> output = [[b'e', b'ev', b'lve'],
[b'h', b'ur', b'tee'],
[b'i', b've', b'hte'],
[b'i', b'en', b'nty']]
``` <p></p> Broadcasting `input` onto `pos` and `len`: <p></p> ```
input = b'thirteen'
position = [1, 5, 7]
length =   [3, 2, 1] <p></p> output = [b'hir', b'ee', b'n']
``` 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> input
						</dt>
						<dd>A `Tensor` of type `string`. Tensor of strings 
						</dd>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> pos
						</dt>
						<dd>A `Tensor`. Must be one of the following types: `int32`, `int64`.
Scalar defining the position of first character in each substring 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> len
						</dt>
						<dd>A `Tensor`. Must have the same type as `pos`.
Scalar defining the number of characters to include in each substring 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> unit
						</dt>
						<dd>An optional `string` from: `"BYTE", "UTF8_CHAR"`. Defaults to `"BYTE"`.
The unit that is used to create the substring.  One of: `"BYTE"` (for
defining position and length by bytes) or `"UTF8_CHAR"` (for the UTF-8
encoded Unicode code points).  The default is `"BYTE"`. Results are undefined if
`unit=UTF8_CHAR` and the `input` strings do not contain structurally valid
UTF-8. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of type `string`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>input = [b'Hello', b'World']
            position = 1
            length = 3 <p></p> output = [b'ell', b'orl'] </pre>
</div>
		</div>
	</div>
	<div id="substr" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>substr</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> input, <span title="System.double">double</span> pos, <span title="System.int">int</span> len, <span title="System.string">string</span> name, <span title="System.string">string</span> unit)
		</h4>
		<div class="content">Return substrings from `Tensor` of strings. <p></p> For each string in the input `Tensor`, creates a substring starting at index
`pos` with a total length of `len`. <p></p> If `len` defines a substring that would extend beyond the length of the input
string, then as many characters as possible are used. <p></p> A negative `pos` indicates distance within the string backwards from the end. <p></p> If `pos` specifies an index which is out of range for any of the input strings,
then an `InvalidArgumentError` is thrown. <p></p> `pos` and `len` must have the same shape, otherwise a `ValueError` is thrown on
Op creation. <p></p> *NOTE*: `Substr` supports broadcasting up to two dimensions. More about
broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html) <p></p> --- <p></p> Examples <p></p> Using scalar `pos` and `len`:
Using `pos` and `len` with same shape as `input`:
Broadcasting `pos` and `len` onto `input`: <p></p> ```
input = [[b'ten', b'eleven', b'twelve'],
[b'thirteen', b'fourteen', b'fifteen'],
[b'sixteen', b'seventeen', b'eighteen'],
[b'nineteen', b'twenty', b'twentyone']]
position = [1, 2, 3]
length =   [1, 2, 3] <p></p> output = [[b'e', b'ev', b'lve'],
[b'h', b'ur', b'tee'],
[b'i', b've', b'hte'],
[b'i', b'en', b'nty']]
``` <p></p> Broadcasting `input` onto `pos` and `len`: <p></p> ```
input = b'thirteen'
position = [1, 5, 7]
length =   [3, 2, 1] <p></p> output = [b'hir', b'ee', b'n']
``` 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> input
						</dt>
						<dd>A `Tensor` of type `string`. Tensor of strings 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> pos
						</dt>
						<dd>A `Tensor`. Must be one of the following types: `int32`, `int64`.
Scalar defining the position of first character in each substring 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> len
						</dt>
						<dd>A `Tensor`. Must have the same type as `pos`.
Scalar defining the number of characters to include in each substring 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> unit
						</dt>
						<dd>An optional `string` from: `"BYTE", "UTF8_CHAR"`. Defaults to `"BYTE"`.
The unit that is used to create the substring.  One of: `"BYTE"` (for
defining position and length by bytes) or `"UTF8_CHAR"` (for the UTF-8
encoded Unicode code points).  The default is `"BYTE"`. Results are undefined if
`unit=UTF8_CHAR` and the `input` strings do not contain structurally valid
UTF-8. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of type `string`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>input = [b'Hello', b'World']
            position = 1
            length = 3 <p></p> output = [b'ell', b'orl'] </pre>
</div>
		</div>
	</div>
	<div id="substr" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>substr</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> input, <span title="System.double">double</span> pos, <a href="../numpy/ndarray.htm">ndarray</a> len, <span title="System.string">string</span> name, <span title="System.string">string</span> unit)
		</h4>
		<div class="content">Return substrings from `Tensor` of strings. <p></p> For each string in the input `Tensor`, creates a substring starting at index
`pos` with a total length of `len`. <p></p> If `len` defines a substring that would extend beyond the length of the input
string, then as many characters as possible are used. <p></p> A negative `pos` indicates distance within the string backwards from the end. <p></p> If `pos` specifies an index which is out of range for any of the input strings,
then an `InvalidArgumentError` is thrown. <p></p> `pos` and `len` must have the same shape, otherwise a `ValueError` is thrown on
Op creation. <p></p> *NOTE*: `Substr` supports broadcasting up to two dimensions. More about
broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html) <p></p> --- <p></p> Examples <p></p> Using scalar `pos` and `len`:
Using `pos` and `len` with same shape as `input`:
Broadcasting `pos` and `len` onto `input`: <p></p> ```
input = [[b'ten', b'eleven', b'twelve'],
[b'thirteen', b'fourteen', b'fifteen'],
[b'sixteen', b'seventeen', b'eighteen'],
[b'nineteen', b'twenty', b'twentyone']]
position = [1, 2, 3]
length =   [1, 2, 3] <p></p> output = [[b'e', b'ev', b'lve'],
[b'h', b'ur', b'tee'],
[b'i', b've', b'hte'],
[b'i', b'en', b'nty']]
``` <p></p> Broadcasting `input` onto `pos` and `len`: <p></p> ```
input = b'thirteen'
position = [1, 5, 7]
length =   [3, 2, 1] <p></p> output = [b'hir', b'ee', b'n']
``` 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> input
						</dt>
						<dd>A `Tensor` of type `string`. Tensor of strings 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> pos
						</dt>
						<dd>A `Tensor`. Must be one of the following types: `int32`, `int64`.
Scalar defining the position of first character in each substring 
						</dd>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> len
						</dt>
						<dd>A `Tensor`. Must have the same type as `pos`.
Scalar defining the number of characters to include in each substring 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> unit
						</dt>
						<dd>An optional `string` from: `"BYTE", "UTF8_CHAR"`. Defaults to `"BYTE"`.
The unit that is used to create the substring.  One of: `"BYTE"` (for
defining position and length by bytes) or `"UTF8_CHAR"` (for the UTF-8
encoded Unicode code points).  The default is `"BYTE"`. Results are undefined if
`unit=UTF8_CHAR` and the `input` strings do not contain structurally valid
UTF-8. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of type `string`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>input = [b'Hello', b'World']
            position = 1
            length = 3 <p></p> output = [b'ell', b'orl'] </pre>
</div>
		</div>
	</div>
	<div id="substr" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>substr</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> input, <span title="System.double">double</span> pos, <span title="System.double">double</span> len, <span title="System.string">string</span> name, <span title="System.string">string</span> unit)
		</h4>
		<div class="content">Return substrings from `Tensor` of strings. <p></p> For each string in the input `Tensor`, creates a substring starting at index
`pos` with a total length of `len`. <p></p> If `len` defines a substring that would extend beyond the length of the input
string, then as many characters as possible are used. <p></p> A negative `pos` indicates distance within the string backwards from the end. <p></p> If `pos` specifies an index which is out of range for any of the input strings,
then an `InvalidArgumentError` is thrown. <p></p> `pos` and `len` must have the same shape, otherwise a `ValueError` is thrown on
Op creation. <p></p> *NOTE*: `Substr` supports broadcasting up to two dimensions. More about
broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html) <p></p> --- <p></p> Examples <p></p> Using scalar `pos` and `len`:
Using `pos` and `len` with same shape as `input`:
Broadcasting `pos` and `len` onto `input`: <p></p> ```
input = [[b'ten', b'eleven', b'twelve'],
[b'thirteen', b'fourteen', b'fifteen'],
[b'sixteen', b'seventeen', b'eighteen'],
[b'nineteen', b'twenty', b'twentyone']]
position = [1, 2, 3]
length =   [1, 2, 3] <p></p> output = [[b'e', b'ev', b'lve'],
[b'h', b'ur', b'tee'],
[b'i', b've', b'hte'],
[b'i', b'en', b'nty']]
``` <p></p> Broadcasting `input` onto `pos` and `len`: <p></p> ```
input = b'thirteen'
position = [1, 5, 7]
length =   [3, 2, 1] <p></p> output = [b'hir', b'ee', b'n']
``` 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> input
						</dt>
						<dd>A `Tensor` of type `string`. Tensor of strings 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> pos
						</dt>
						<dd>A `Tensor`. Must be one of the following types: `int32`, `int64`.
Scalar defining the position of first character in each substring 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> len
						</dt>
						<dd>A `Tensor`. Must have the same type as `pos`.
Scalar defining the number of characters to include in each substring 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> unit
						</dt>
						<dd>An optional `string` from: `"BYTE", "UTF8_CHAR"`. Defaults to `"BYTE"`.
The unit that is used to create the substring.  One of: `"BYTE"` (for
defining position and length by bytes) or `"UTF8_CHAR"` (for the UTF-8
encoded Unicode code points).  The default is `"BYTE"`. Results are undefined if
`unit=UTF8_CHAR` and the `input` strings do not contain structurally valid
UTF-8. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of type `string`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>input = [b'Hello', b'World']
            position = 1
            length = 3 <p></p> output = [b'ell', b'orl'] </pre>
</div>
		</div>
	</div>
	<div id="substr" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>substr</strong>(<span title="System.Byte[]">Byte[]</span> input, <span title="System.int">int</span> pos, <span title="System.int">int</span> len, <span title="System.string">string</span> name, <span title="System.string">string</span> unit)
		</h4>
		<div class="content">Return substrings from `Tensor` of strings. <p></p> For each string in the input `Tensor`, creates a substring starting at index
`pos` with a total length of `len`. <p></p> If `len` defines a substring that would extend beyond the length of the input
string, then as many characters as possible are used. <p></p> A negative `pos` indicates distance within the string backwards from the end. <p></p> If `pos` specifies an index which is out of range for any of the input strings,
then an `InvalidArgumentError` is thrown. <p></p> `pos` and `len` must have the same shape, otherwise a `ValueError` is thrown on
Op creation. <p></p> *NOTE*: `Substr` supports broadcasting up to two dimensions. More about
broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html) <p></p> --- <p></p> Examples <p></p> Using scalar `pos` and `len`:
Using `pos` and `len` with same shape as `input`:
Broadcasting `pos` and `len` onto `input`: <p></p> ```
input = [[b'ten', b'eleven', b'twelve'],
[b'thirteen', b'fourteen', b'fifteen'],
[b'sixteen', b'seventeen', b'eighteen'],
[b'nineteen', b'twenty', b'twentyone']]
position = [1, 2, 3]
length =   [1, 2, 3] <p></p> output = [[b'e', b'ev', b'lve'],
[b'h', b'ur', b'tee'],
[b'i', b've', b'hte'],
[b'i', b'en', b'nty']]
``` <p></p> Broadcasting `input` onto `pos` and `len`: <p></p> ```
input = b'thirteen'
position = [1, 5, 7]
length =   [3, 2, 1] <p></p> output = [b'hir', b'ee', b'n']
``` 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Byte[]">Byte[]</span></code> input
						</dt>
						<dd>A `Tensor` of type `string`. Tensor of strings 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> pos
						</dt>
						<dd>A `Tensor`. Must be one of the following types: `int32`, `int64`.
Scalar defining the position of first character in each substring 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> len
						</dt>
						<dd>A `Tensor`. Must have the same type as `pos`.
Scalar defining the number of characters to include in each substring 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> unit
						</dt>
						<dd>An optional `string` from: `"BYTE", "UTF8_CHAR"`. Defaults to `"BYTE"`.
The unit that is used to create the substring.  One of: `"BYTE"` (for
defining position and length by bytes) or `"UTF8_CHAR"` (for the UTF-8
encoded Unicode code points).  The default is `"BYTE"`. Results are undefined if
`unit=UTF8_CHAR` and the `input` strings do not contain structurally valid
UTF-8. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of type `string`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>input = [b'Hello', b'World']
            position = 1
            length = 3 <p></p> output = [b'ell', b'orl'] </pre>
</div>
		</div>
	</div>
	<div id="substr" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>substr</strong>(<span title="System.Byte[]">Byte[]</span> input, <span title="System.int">int</span> pos, <a href="../numpy/ndarray.htm">ndarray</a> len, <span title="System.string">string</span> name, <span title="System.string">string</span> unit)
		</h4>
		<div class="content">Return substrings from `Tensor` of strings. <p></p> For each string in the input `Tensor`, creates a substring starting at index
`pos` with a total length of `len`. <p></p> If `len` defines a substring that would extend beyond the length of the input
string, then as many characters as possible are used. <p></p> A negative `pos` indicates distance within the string backwards from the end. <p></p> If `pos` specifies an index which is out of range for any of the input strings,
then an `InvalidArgumentError` is thrown. <p></p> `pos` and `len` must have the same shape, otherwise a `ValueError` is thrown on
Op creation. <p></p> *NOTE*: `Substr` supports broadcasting up to two dimensions. More about
broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html) <p></p> --- <p></p> Examples <p></p> Using scalar `pos` and `len`:
Using `pos` and `len` with same shape as `input`:
Broadcasting `pos` and `len` onto `input`: <p></p> ```
input = [[b'ten', b'eleven', b'twelve'],
[b'thirteen', b'fourteen', b'fifteen'],
[b'sixteen', b'seventeen', b'eighteen'],
[b'nineteen', b'twenty', b'twentyone']]
position = [1, 2, 3]
length =   [1, 2, 3] <p></p> output = [[b'e', b'ev', b'lve'],
[b'h', b'ur', b'tee'],
[b'i', b've', b'hte'],
[b'i', b'en', b'nty']]
``` <p></p> Broadcasting `input` onto `pos` and `len`: <p></p> ```
input = b'thirteen'
position = [1, 5, 7]
length =   [3, 2, 1] <p></p> output = [b'hir', b'ee', b'n']
``` 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Byte[]">Byte[]</span></code> input
						</dt>
						<dd>A `Tensor` of type `string`. Tensor of strings 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> pos
						</dt>
						<dd>A `Tensor`. Must be one of the following types: `int32`, `int64`.
Scalar defining the position of first character in each substring 
						</dd>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> len
						</dt>
						<dd>A `Tensor`. Must have the same type as `pos`.
Scalar defining the number of characters to include in each substring 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> unit
						</dt>
						<dd>An optional `string` from: `"BYTE", "UTF8_CHAR"`. Defaults to `"BYTE"`.
The unit that is used to create the substring.  One of: `"BYTE"` (for
defining position and length by bytes) or `"UTF8_CHAR"` (for the UTF-8
encoded Unicode code points).  The default is `"BYTE"`. Results are undefined if
`unit=UTF8_CHAR` and the `input` strings do not contain structurally valid
UTF-8. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of type `string`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>input = [b'Hello', b'World']
            position = 1
            length = 3 <p></p> output = [b'ell', b'orl'] </pre>
</div>
		</div>
	</div>
	<div id="substr" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>substr</strong>(<span title="System.Byte[]">Byte[]</span> input, <span title="System.int">int</span> pos, <span title="System.double">double</span> len, <span title="System.string">string</span> name, <span title="System.string">string</span> unit)
		</h4>
		<div class="content">Return substrings from `Tensor` of strings. <p></p> For each string in the input `Tensor`, creates a substring starting at index
`pos` with a total length of `len`. <p></p> If `len` defines a substring that would extend beyond the length of the input
string, then as many characters as possible are used. <p></p> A negative `pos` indicates distance within the string backwards from the end. <p></p> If `pos` specifies an index which is out of range for any of the input strings,
then an `InvalidArgumentError` is thrown. <p></p> `pos` and `len` must have the same shape, otherwise a `ValueError` is thrown on
Op creation. <p></p> *NOTE*: `Substr` supports broadcasting up to two dimensions. More about
broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html) <p></p> --- <p></p> Examples <p></p> Using scalar `pos` and `len`:
Using `pos` and `len` with same shape as `input`:
Broadcasting `pos` and `len` onto `input`: <p></p> ```
input = [[b'ten', b'eleven', b'twelve'],
[b'thirteen', b'fourteen', b'fifteen'],
[b'sixteen', b'seventeen', b'eighteen'],
[b'nineteen', b'twenty', b'twentyone']]
position = [1, 2, 3]
length =   [1, 2, 3] <p></p> output = [[b'e', b'ev', b'lve'],
[b'h', b'ur', b'tee'],
[b'i', b've', b'hte'],
[b'i', b'en', b'nty']]
``` <p></p> Broadcasting `input` onto `pos` and `len`: <p></p> ```
input = b'thirteen'
position = [1, 5, 7]
length =   [3, 2, 1] <p></p> output = [b'hir', b'ee', b'n']
``` 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Byte[]">Byte[]</span></code> input
						</dt>
						<dd>A `Tensor` of type `string`. Tensor of strings 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> pos
						</dt>
						<dd>A `Tensor`. Must be one of the following types: `int32`, `int64`.
Scalar defining the position of first character in each substring 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> len
						</dt>
						<dd>A `Tensor`. Must have the same type as `pos`.
Scalar defining the number of characters to include in each substring 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> unit
						</dt>
						<dd>An optional `string` from: `"BYTE", "UTF8_CHAR"`. Defaults to `"BYTE"`.
The unit that is used to create the substring.  One of: `"BYTE"` (for
defining position and length by bytes) or `"UTF8_CHAR"` (for the UTF-8
encoded Unicode code points).  The default is `"BYTE"`. Results are undefined if
`unit=UTF8_CHAR` and the `input` strings do not contain structurally valid
UTF-8. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of type `string`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>input = [b'Hello', b'World']
            position = 1
            length = 3 <p></p> output = [b'ell', b'orl'] </pre>
</div>
		</div>
	</div>
	<div id="substr" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>substr</strong>(<span title="System.Byte[]">Byte[]</span> input, <a href="../numpy/ndarray.htm">ndarray</a> pos, <span title="System.int">int</span> len, <span title="System.string">string</span> name, <span title="System.string">string</span> unit)
		</h4>
		<div class="content">Return substrings from `Tensor` of strings. <p></p> For each string in the input `Tensor`, creates a substring starting at index
`pos` with a total length of `len`. <p></p> If `len` defines a substring that would extend beyond the length of the input
string, then as many characters as possible are used. <p></p> A negative `pos` indicates distance within the string backwards from the end. <p></p> If `pos` specifies an index which is out of range for any of the input strings,
then an `InvalidArgumentError` is thrown. <p></p> `pos` and `len` must have the same shape, otherwise a `ValueError` is thrown on
Op creation. <p></p> *NOTE*: `Substr` supports broadcasting up to two dimensions. More about
broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html) <p></p> --- <p></p> Examples <p></p> Using scalar `pos` and `len`:
Using `pos` and `len` with same shape as `input`:
Broadcasting `pos` and `len` onto `input`: <p></p> ```
input = [[b'ten', b'eleven', b'twelve'],
[b'thirteen', b'fourteen', b'fifteen'],
[b'sixteen', b'seventeen', b'eighteen'],
[b'nineteen', b'twenty', b'twentyone']]
position = [1, 2, 3]
length =   [1, 2, 3] <p></p> output = [[b'e', b'ev', b'lve'],
[b'h', b'ur', b'tee'],
[b'i', b've', b'hte'],
[b'i', b'en', b'nty']]
``` <p></p> Broadcasting `input` onto `pos` and `len`: <p></p> ```
input = b'thirteen'
position = [1, 5, 7]
length =   [3, 2, 1] <p></p> output = [b'hir', b'ee', b'n']
``` 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Byte[]">Byte[]</span></code> input
						</dt>
						<dd>A `Tensor` of type `string`. Tensor of strings 
						</dd>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> pos
						</dt>
						<dd>A `Tensor`. Must be one of the following types: `int32`, `int64`.
Scalar defining the position of first character in each substring 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> len
						</dt>
						<dd>A `Tensor`. Must have the same type as `pos`.
Scalar defining the number of characters to include in each substring 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> unit
						</dt>
						<dd>An optional `string` from: `"BYTE", "UTF8_CHAR"`. Defaults to `"BYTE"`.
The unit that is used to create the substring.  One of: `"BYTE"` (for
defining position and length by bytes) or `"UTF8_CHAR"` (for the UTF-8
encoded Unicode code points).  The default is `"BYTE"`. Results are undefined if
`unit=UTF8_CHAR` and the `input` strings do not contain structurally valid
UTF-8. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of type `string`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>input = [b'Hello', b'World']
            position = 1
            length = 3 <p></p> output = [b'ell', b'orl'] </pre>
</div>
		</div>
	</div>
	<div id="substr" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>substr</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> input, <span title="System.int">int</span> pos, <a href="../numpy/ndarray.htm">ndarray</a> len, <span title="System.string">string</span> name, <span title="System.string">string</span> unit)
		</h4>
		<div class="content">Return substrings from `Tensor` of strings. <p></p> For each string in the input `Tensor`, creates a substring starting at index
`pos` with a total length of `len`. <p></p> If `len` defines a substring that would extend beyond the length of the input
string, then as many characters as possible are used. <p></p> A negative `pos` indicates distance within the string backwards from the end. <p></p> If `pos` specifies an index which is out of range for any of the input strings,
then an `InvalidArgumentError` is thrown. <p></p> `pos` and `len` must have the same shape, otherwise a `ValueError` is thrown on
Op creation. <p></p> *NOTE*: `Substr` supports broadcasting up to two dimensions. More about
broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html) <p></p> --- <p></p> Examples <p></p> Using scalar `pos` and `len`:
Using `pos` and `len` with same shape as `input`:
Broadcasting `pos` and `len` onto `input`: <p></p> ```
input = [[b'ten', b'eleven', b'twelve'],
[b'thirteen', b'fourteen', b'fifteen'],
[b'sixteen', b'seventeen', b'eighteen'],
[b'nineteen', b'twenty', b'twentyone']]
position = [1, 2, 3]
length =   [1, 2, 3] <p></p> output = [[b'e', b'ev', b'lve'],
[b'h', b'ur', b'tee'],
[b'i', b've', b'hte'],
[b'i', b'en', b'nty']]
``` <p></p> Broadcasting `input` onto `pos` and `len`: <p></p> ```
input = b'thirteen'
position = [1, 5, 7]
length =   [3, 2, 1] <p></p> output = [b'hir', b'ee', b'n']
``` 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> input
						</dt>
						<dd>A `Tensor` of type `string`. Tensor of strings 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> pos
						</dt>
						<dd>A `Tensor`. Must be one of the following types: `int32`, `int64`.
Scalar defining the position of first character in each substring 
						</dd>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> len
						</dt>
						<dd>A `Tensor`. Must have the same type as `pos`.
Scalar defining the number of characters to include in each substring 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> unit
						</dt>
						<dd>An optional `string` from: `"BYTE", "UTF8_CHAR"`. Defaults to `"BYTE"`.
The unit that is used to create the substring.  One of: `"BYTE"` (for
defining position and length by bytes) or `"UTF8_CHAR"` (for the UTF-8
encoded Unicode code points).  The default is `"BYTE"`. Results are undefined if
`unit=UTF8_CHAR` and the `input` strings do not contain structurally valid
UTF-8. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of type `string`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>input = [b'Hello', b'World']
            position = 1
            length = 3 <p></p> output = [b'ell', b'orl'] </pre>
</div>
		</div>
	</div>
	<div id="substr" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>substr</strong>(<span title="System.Byte[]">Byte[]</span> input, <span title="System.double">double</span> pos, <span title="System.int">int</span> len, <span title="System.string">string</span> name, <span title="System.string">string</span> unit)
		</h4>
		<div class="content">Return substrings from `Tensor` of strings. <p></p> For each string in the input `Tensor`, creates a substring starting at index
`pos` with a total length of `len`. <p></p> If `len` defines a substring that would extend beyond the length of the input
string, then as many characters as possible are used. <p></p> A negative `pos` indicates distance within the string backwards from the end. <p></p> If `pos` specifies an index which is out of range for any of the input strings,
then an `InvalidArgumentError` is thrown. <p></p> `pos` and `len` must have the same shape, otherwise a `ValueError` is thrown on
Op creation. <p></p> *NOTE*: `Substr` supports broadcasting up to two dimensions. More about
broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html) <p></p> --- <p></p> Examples <p></p> Using scalar `pos` and `len`:
Using `pos` and `len` with same shape as `input`:
Broadcasting `pos` and `len` onto `input`: <p></p> ```
input = [[b'ten', b'eleven', b'twelve'],
[b'thirteen', b'fourteen', b'fifteen'],
[b'sixteen', b'seventeen', b'eighteen'],
[b'nineteen', b'twenty', b'twentyone']]
position = [1, 2, 3]
length =   [1, 2, 3] <p></p> output = [[b'e', b'ev', b'lve'],
[b'h', b'ur', b'tee'],
[b'i', b've', b'hte'],
[b'i', b'en', b'nty']]
``` <p></p> Broadcasting `input` onto `pos` and `len`: <p></p> ```
input = b'thirteen'
position = [1, 5, 7]
length =   [3, 2, 1] <p></p> output = [b'hir', b'ee', b'n']
``` 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Byte[]">Byte[]</span></code> input
						</dt>
						<dd>A `Tensor` of type `string`. Tensor of strings 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> pos
						</dt>
						<dd>A `Tensor`. Must be one of the following types: `int32`, `int64`.
Scalar defining the position of first character in each substring 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> len
						</dt>
						<dd>A `Tensor`. Must have the same type as `pos`.
Scalar defining the number of characters to include in each substring 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> unit
						</dt>
						<dd>An optional `string` from: `"BYTE", "UTF8_CHAR"`. Defaults to `"BYTE"`.
The unit that is used to create the substring.  One of: `"BYTE"` (for
defining position and length by bytes) or `"UTF8_CHAR"` (for the UTF-8
encoded Unicode code points).  The default is `"BYTE"`. Results are undefined if
`unit=UTF8_CHAR` and the `input` strings do not contain structurally valid
UTF-8. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of type `string`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>input = [b'Hello', b'World']
            position = 1
            length = 3 <p></p> output = [b'ell', b'orl'] </pre>
</div>
		</div>
	</div>
	<div id="substr" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>substr</strong>(<a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> input, <span title="System.double">double</span> pos, <span title="System.int">int</span> len, <span title="System.string">string</span> name, <span title="System.string">string</span> unit)
		</h4>
		<div class="content">Return substrings from `Tensor` of strings. <p></p> For each string in the input `Tensor`, creates a substring starting at index
`pos` with a total length of `len`. <p></p> If `len` defines a substring that would extend beyond the length of the input
string, then as many characters as possible are used. <p></p> A negative `pos` indicates distance within the string backwards from the end. <p></p> If `pos` specifies an index which is out of range for any of the input strings,
then an `InvalidArgumentError` is thrown. <p></p> `pos` and `len` must have the same shape, otherwise a `ValueError` is thrown on
Op creation. <p></p> *NOTE*: `Substr` supports broadcasting up to two dimensions. More about
broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html) <p></p> --- <p></p> Examples <p></p> Using scalar `pos` and `len`:
Using `pos` and `len` with same shape as `input`:
Broadcasting `pos` and `len` onto `input`: <p></p> ```
input = [[b'ten', b'eleven', b'twelve'],
[b'thirteen', b'fourteen', b'fifteen'],
[b'sixteen', b'seventeen', b'eighteen'],
[b'nineteen', b'twenty', b'twentyone']]
position = [1, 2, 3]
length =   [1, 2, 3] <p></p> output = [[b'e', b'ev', b'lve'],
[b'h', b'ur', b'tee'],
[b'i', b've', b'hte'],
[b'i', b'en', b'nty']]
``` <p></p> Broadcasting `input` onto `pos` and `len`: <p></p> ```
input = b'thirteen'
position = [1, 5, 7]
length =   [3, 2, 1] <p></p> output = [b'hir', b'ee', b'n']
``` 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> input
						</dt>
						<dd>A `Tensor` of type `string`. Tensor of strings 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> pos
						</dt>
						<dd>A `Tensor`. Must be one of the following types: `int32`, `int64`.
Scalar defining the position of first character in each substring 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> len
						</dt>
						<dd>A `Tensor`. Must have the same type as `pos`.
Scalar defining the number of characters to include in each substring 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> unit
						</dt>
						<dd>An optional `string` from: `"BYTE", "UTF8_CHAR"`. Defaults to `"BYTE"`.
The unit that is used to create the substring.  One of: `"BYTE"` (for
defining position and length by bytes) or `"UTF8_CHAR"` (for the UTF-8
encoded Unicode code points).  The default is `"BYTE"`. Results are undefined if
`unit=UTF8_CHAR` and the `input` strings do not contain structurally valid
UTF-8. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of type `string`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>input = [b'Hello', b'World']
            position = 1
            length = 3 <p></p> output = [b'ell', b'orl'] </pre>
</div>
		</div>
	</div>
	<div id="substr" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>substr</strong>(<span title="System.Byte[]">Byte[]</span> input, <span title="System.double">double</span> pos, <span title="System.double">double</span> len, <span title="System.string">string</span> name, <span title="System.string">string</span> unit)
		</h4>
		<div class="content">Return substrings from `Tensor` of strings. <p></p> For each string in the input `Tensor`, creates a substring starting at index
`pos` with a total length of `len`. <p></p> If `len` defines a substring that would extend beyond the length of the input
string, then as many characters as possible are used. <p></p> A negative `pos` indicates distance within the string backwards from the end. <p></p> If `pos` specifies an index which is out of range for any of the input strings,
then an `InvalidArgumentError` is thrown. <p></p> `pos` and `len` must have the same shape, otherwise a `ValueError` is thrown on
Op creation. <p></p> *NOTE*: `Substr` supports broadcasting up to two dimensions. More about
broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html) <p></p> --- <p></p> Examples <p></p> Using scalar `pos` and `len`:
Using `pos` and `len` with same shape as `input`:
Broadcasting `pos` and `len` onto `input`: <p></p> ```
input = [[b'ten', b'eleven', b'twelve'],
[b'thirteen', b'fourteen', b'fifteen'],
[b'sixteen', b'seventeen', b'eighteen'],
[b'nineteen', b'twenty', b'twentyone']]
position = [1, 2, 3]
length =   [1, 2, 3] <p></p> output = [[b'e', b'ev', b'lve'],
[b'h', b'ur', b'tee'],
[b'i', b've', b'hte'],
[b'i', b'en', b'nty']]
``` <p></p> Broadcasting `input` onto `pos` and `len`: <p></p> ```
input = b'thirteen'
position = [1, 5, 7]
length =   [3, 2, 1] <p></p> output = [b'hir', b'ee', b'n']
``` 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Byte[]">Byte[]</span></code> input
						</dt>
						<dd>A `Tensor` of type `string`. Tensor of strings 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> pos
						</dt>
						<dd>A `Tensor`. Must be one of the following types: `int32`, `int64`.
Scalar defining the position of first character in each substring 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> len
						</dt>
						<dd>A `Tensor`. Must have the same type as `pos`.
Scalar defining the number of characters to include in each substring 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> unit
						</dt>
						<dd>An optional `string` from: `"BYTE", "UTF8_CHAR"`. Defaults to `"BYTE"`.
The unit that is used to create the substring.  One of: `"BYTE"` (for
defining position and length by bytes) or `"UTF8_CHAR"` (for the UTF-8
encoded Unicode code points).  The default is `"BYTE"`. Results are undefined if
`unit=UTF8_CHAR` and the `input` strings do not contain structurally valid
UTF-8. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of type `string`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>input = [b'Hello', b'World']
            position = 1
            length = 3 <p></p> output = [b'ell', b'orl'] </pre>
</div>
		</div>
	</div>
	<div id="substr" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>substr</strong>(<a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> input, <span title="System.int">int</span> pos, <span title="System.int">int</span> len, <span title="System.string">string</span> name, <span title="System.string">string</span> unit)
		</h4>
		<div class="content">Return substrings from `Tensor` of strings. <p></p> For each string in the input `Tensor`, creates a substring starting at index
`pos` with a total length of `len`. <p></p> If `len` defines a substring that would extend beyond the length of the input
string, then as many characters as possible are used. <p></p> A negative `pos` indicates distance within the string backwards from the end. <p></p> If `pos` specifies an index which is out of range for any of the input strings,
then an `InvalidArgumentError` is thrown. <p></p> `pos` and `len` must have the same shape, otherwise a `ValueError` is thrown on
Op creation. <p></p> *NOTE*: `Substr` supports broadcasting up to two dimensions. More about
broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html) <p></p> --- <p></p> Examples <p></p> Using scalar `pos` and `len`:
Using `pos` and `len` with same shape as `input`:
Broadcasting `pos` and `len` onto `input`: <p></p> ```
input = [[b'ten', b'eleven', b'twelve'],
[b'thirteen', b'fourteen', b'fifteen'],
[b'sixteen', b'seventeen', b'eighteen'],
[b'nineteen', b'twenty', b'twentyone']]
position = [1, 2, 3]
length =   [1, 2, 3] <p></p> output = [[b'e', b'ev', b'lve'],
[b'h', b'ur', b'tee'],
[b'i', b've', b'hte'],
[b'i', b'en', b'nty']]
``` <p></p> Broadcasting `input` onto `pos` and `len`: <p></p> ```
input = b'thirteen'
position = [1, 5, 7]
length =   [3, 2, 1] <p></p> output = [b'hir', b'ee', b'n']
``` 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> input
						</dt>
						<dd>A `Tensor` of type `string`. Tensor of strings 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> pos
						</dt>
						<dd>A `Tensor`. Must be one of the following types: `int32`, `int64`.
Scalar defining the position of first character in each substring 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> len
						</dt>
						<dd>A `Tensor`. Must have the same type as `pos`.
Scalar defining the number of characters to include in each substring 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> unit
						</dt>
						<dd>An optional `string` from: `"BYTE", "UTF8_CHAR"`. Defaults to `"BYTE"`.
The unit that is used to create the substring.  One of: `"BYTE"` (for
defining position and length by bytes) or `"UTF8_CHAR"` (for the UTF-8
encoded Unicode code points).  The default is `"BYTE"`. Results are undefined if
`unit=UTF8_CHAR` and the `input` strings do not contain structurally valid
UTF-8. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of type `string`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>input = [b'Hello', b'World']
            position = 1
            length = 3 <p></p> output = [b'ell', b'orl'] </pre>
</div>
		</div>
	</div>
	<div id="substr" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>substr</strong>(<a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> input, <span title="System.int">int</span> pos, <a href="../numpy/ndarray.htm">ndarray</a> len, <span title="System.string">string</span> name, <span title="System.string">string</span> unit)
		</h4>
		<div class="content">Return substrings from `Tensor` of strings. <p></p> For each string in the input `Tensor`, creates a substring starting at index
`pos` with a total length of `len`. <p></p> If `len` defines a substring that would extend beyond the length of the input
string, then as many characters as possible are used. <p></p> A negative `pos` indicates distance within the string backwards from the end. <p></p> If `pos` specifies an index which is out of range for any of the input strings,
then an `InvalidArgumentError` is thrown. <p></p> `pos` and `len` must have the same shape, otherwise a `ValueError` is thrown on
Op creation. <p></p> *NOTE*: `Substr` supports broadcasting up to two dimensions. More about
broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html) <p></p> --- <p></p> Examples <p></p> Using scalar `pos` and `len`:
Using `pos` and `len` with same shape as `input`:
Broadcasting `pos` and `len` onto `input`: <p></p> ```
input = [[b'ten', b'eleven', b'twelve'],
[b'thirteen', b'fourteen', b'fifteen'],
[b'sixteen', b'seventeen', b'eighteen'],
[b'nineteen', b'twenty', b'twentyone']]
position = [1, 2, 3]
length =   [1, 2, 3] <p></p> output = [[b'e', b'ev', b'lve'],
[b'h', b'ur', b'tee'],
[b'i', b've', b'hte'],
[b'i', b'en', b'nty']]
``` <p></p> Broadcasting `input` onto `pos` and `len`: <p></p> ```
input = b'thirteen'
position = [1, 5, 7]
length =   [3, 2, 1] <p></p> output = [b'hir', b'ee', b'n']
``` 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> input
						</dt>
						<dd>A `Tensor` of type `string`. Tensor of strings 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> pos
						</dt>
						<dd>A `Tensor`. Must be one of the following types: `int32`, `int64`.
Scalar defining the position of first character in each substring 
						</dd>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> len
						</dt>
						<dd>A `Tensor`. Must have the same type as `pos`.
Scalar defining the number of characters to include in each substring 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> unit
						</dt>
						<dd>An optional `string` from: `"BYTE", "UTF8_CHAR"`. Defaults to `"BYTE"`.
The unit that is used to create the substring.  One of: `"BYTE"` (for
defining position and length by bytes) or `"UTF8_CHAR"` (for the UTF-8
encoded Unicode code points).  The default is `"BYTE"`. Results are undefined if
`unit=UTF8_CHAR` and the `input` strings do not contain structurally valid
UTF-8. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of type `string`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>input = [b'Hello', b'World']
            position = 1
            length = 3 <p></p> output = [b'ell', b'orl'] </pre>
</div>
		</div>
	</div>
	<div id="substr" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>substr</strong>(<a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> input, <span title="System.int">int</span> pos, <span title="System.double">double</span> len, <span title="System.string">string</span> name, <span title="System.string">string</span> unit)
		</h4>
		<div class="content">Return substrings from `Tensor` of strings. <p></p> For each string in the input `Tensor`, creates a substring starting at index
`pos` with a total length of `len`. <p></p> If `len` defines a substring that would extend beyond the length of the input
string, then as many characters as possible are used. <p></p> A negative `pos` indicates distance within the string backwards from the end. <p></p> If `pos` specifies an index which is out of range for any of the input strings,
then an `InvalidArgumentError` is thrown. <p></p> `pos` and `len` must have the same shape, otherwise a `ValueError` is thrown on
Op creation. <p></p> *NOTE*: `Substr` supports broadcasting up to two dimensions. More about
broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html) <p></p> --- <p></p> Examples <p></p> Using scalar `pos` and `len`:
Using `pos` and `len` with same shape as `input`:
Broadcasting `pos` and `len` onto `input`: <p></p> ```
input = [[b'ten', b'eleven', b'twelve'],
[b'thirteen', b'fourteen', b'fifteen'],
[b'sixteen', b'seventeen', b'eighteen'],
[b'nineteen', b'twenty', b'twentyone']]
position = [1, 2, 3]
length =   [1, 2, 3] <p></p> output = [[b'e', b'ev', b'lve'],
[b'h', b'ur', b'tee'],
[b'i', b've', b'hte'],
[b'i', b'en', b'nty']]
``` <p></p> Broadcasting `input` onto `pos` and `len`: <p></p> ```
input = b'thirteen'
position = [1, 5, 7]
length =   [3, 2, 1] <p></p> output = [b'hir', b'ee', b'n']
``` 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> input
						</dt>
						<dd>A `Tensor` of type `string`. Tensor of strings 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> pos
						</dt>
						<dd>A `Tensor`. Must be one of the following types: `int32`, `int64`.
Scalar defining the position of first character in each substring 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> len
						</dt>
						<dd>A `Tensor`. Must have the same type as `pos`.
Scalar defining the number of characters to include in each substring 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> unit
						</dt>
						<dd>An optional `string` from: `"BYTE", "UTF8_CHAR"`. Defaults to `"BYTE"`.
The unit that is used to create the substring.  One of: `"BYTE"` (for
defining position and length by bytes) or `"UTF8_CHAR"` (for the UTF-8
encoded Unicode code points).  The default is `"BYTE"`. Results are undefined if
`unit=UTF8_CHAR` and the `input` strings do not contain structurally valid
UTF-8. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of type `string`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>input = [b'Hello', b'World']
            position = 1
            length = 3 <p></p> output = [b'ell', b'orl'] </pre>
</div>
		</div>
	</div>
	<div id="substr" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>substr</strong>(<span title="System.Byte[]">Byte[]</span> input, <span title="System.double">double</span> pos, <a href="../numpy/ndarray.htm">ndarray</a> len, <span title="System.string">string</span> name, <span title="System.string">string</span> unit)
		</h4>
		<div class="content">Return substrings from `Tensor` of strings. <p></p> For each string in the input `Tensor`, creates a substring starting at index
`pos` with a total length of `len`. <p></p> If `len` defines a substring that would extend beyond the length of the input
string, then as many characters as possible are used. <p></p> A negative `pos` indicates distance within the string backwards from the end. <p></p> If `pos` specifies an index which is out of range for any of the input strings,
then an `InvalidArgumentError` is thrown. <p></p> `pos` and `len` must have the same shape, otherwise a `ValueError` is thrown on
Op creation. <p></p> *NOTE*: `Substr` supports broadcasting up to two dimensions. More about
broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html) <p></p> --- <p></p> Examples <p></p> Using scalar `pos` and `len`:
Using `pos` and `len` with same shape as `input`:
Broadcasting `pos` and `len` onto `input`: <p></p> ```
input = [[b'ten', b'eleven', b'twelve'],
[b'thirteen', b'fourteen', b'fifteen'],
[b'sixteen', b'seventeen', b'eighteen'],
[b'nineteen', b'twenty', b'twentyone']]
position = [1, 2, 3]
length =   [1, 2, 3] <p></p> output = [[b'e', b'ev', b'lve'],
[b'h', b'ur', b'tee'],
[b'i', b've', b'hte'],
[b'i', b'en', b'nty']]
``` <p></p> Broadcasting `input` onto `pos` and `len`: <p></p> ```
input = b'thirteen'
position = [1, 5, 7]
length =   [3, 2, 1] <p></p> output = [b'hir', b'ee', b'n']
``` 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Byte[]">Byte[]</span></code> input
						</dt>
						<dd>A `Tensor` of type `string`. Tensor of strings 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> pos
						</dt>
						<dd>A `Tensor`. Must be one of the following types: `int32`, `int64`.
Scalar defining the position of first character in each substring 
						</dd>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> len
						</dt>
						<dd>A `Tensor`. Must have the same type as `pos`.
Scalar defining the number of characters to include in each substring 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> unit
						</dt>
						<dd>An optional `string` from: `"BYTE", "UTF8_CHAR"`. Defaults to `"BYTE"`.
The unit that is used to create the substring.  One of: `"BYTE"` (for
defining position and length by bytes) or `"UTF8_CHAR"` (for the UTF-8
encoded Unicode code points).  The default is `"BYTE"`. Results are undefined if
`unit=UTF8_CHAR` and the `input` strings do not contain structurally valid
UTF-8. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of type `string`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>input = [b'Hello', b'World']
            position = 1
            length = 3 <p></p> output = [b'ell', b'orl'] </pre>
</div>
		</div>
	</div>
	<div id="substr" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>substr</strong>(<a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> input, <a href="../numpy/ndarray.htm">ndarray</a> pos, <span title="System.int">int</span> len, <span title="System.string">string</span> name, <span title="System.string">string</span> unit)
		</h4>
		<div class="content">Return substrings from `Tensor` of strings. <p></p> For each string in the input `Tensor`, creates a substring starting at index
`pos` with a total length of `len`. <p></p> If `len` defines a substring that would extend beyond the length of the input
string, then as many characters as possible are used. <p></p> A negative `pos` indicates distance within the string backwards from the end. <p></p> If `pos` specifies an index which is out of range for any of the input strings,
then an `InvalidArgumentError` is thrown. <p></p> `pos` and `len` must have the same shape, otherwise a `ValueError` is thrown on
Op creation. <p></p> *NOTE*: `Substr` supports broadcasting up to two dimensions. More about
broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html) <p></p> --- <p></p> Examples <p></p> Using scalar `pos` and `len`:
Using `pos` and `len` with same shape as `input`:
Broadcasting `pos` and `len` onto `input`: <p></p> ```
input = [[b'ten', b'eleven', b'twelve'],
[b'thirteen', b'fourteen', b'fifteen'],
[b'sixteen', b'seventeen', b'eighteen'],
[b'nineteen', b'twenty', b'twentyone']]
position = [1, 2, 3]
length =   [1, 2, 3] <p></p> output = [[b'e', b'ev', b'lve'],
[b'h', b'ur', b'tee'],
[b'i', b've', b'hte'],
[b'i', b'en', b'nty']]
``` <p></p> Broadcasting `input` onto `pos` and `len`: <p></p> ```
input = b'thirteen'
position = [1, 5, 7]
length =   [3, 2, 1] <p></p> output = [b'hir', b'ee', b'n']
``` 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> input
						</dt>
						<dd>A `Tensor` of type `string`. Tensor of strings 
						</dd>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> pos
						</dt>
						<dd>A `Tensor`. Must be one of the following types: `int32`, `int64`.
Scalar defining the position of first character in each substring 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> len
						</dt>
						<dd>A `Tensor`. Must have the same type as `pos`.
Scalar defining the number of characters to include in each substring 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> unit
						</dt>
						<dd>An optional `string` from: `"BYTE", "UTF8_CHAR"`. Defaults to `"BYTE"`.
The unit that is used to create the substring.  One of: `"BYTE"` (for
defining position and length by bytes) or `"UTF8_CHAR"` (for the UTF-8
encoded Unicode code points).  The default is `"BYTE"`. Results are undefined if
`unit=UTF8_CHAR` and the `input` strings do not contain structurally valid
UTF-8. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of type `string`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>input = [b'Hello', b'World']
            position = 1
            length = 3 <p></p> output = [b'ell', b'orl'] </pre>
</div>
		</div>
	</div>
	<div id="substr" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>substr</strong>(<a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> input, <a href="../numpy/ndarray.htm">ndarray</a> pos, <a href="../numpy/ndarray.htm">ndarray</a> len, <span title="System.string">string</span> name, <span title="System.string">string</span> unit)
		</h4>
		<div class="content">Return substrings from `Tensor` of strings. <p></p> For each string in the input `Tensor`, creates a substring starting at index
`pos` with a total length of `len`. <p></p> If `len` defines a substring that would extend beyond the length of the input
string, then as many characters as possible are used. <p></p> A negative `pos` indicates distance within the string backwards from the end. <p></p> If `pos` specifies an index which is out of range for any of the input strings,
then an `InvalidArgumentError` is thrown. <p></p> `pos` and `len` must have the same shape, otherwise a `ValueError` is thrown on
Op creation. <p></p> *NOTE*: `Substr` supports broadcasting up to two dimensions. More about
broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html) <p></p> --- <p></p> Examples <p></p> Using scalar `pos` and `len`:
Using `pos` and `len` with same shape as `input`:
Broadcasting `pos` and `len` onto `input`: <p></p> ```
input = [[b'ten', b'eleven', b'twelve'],
[b'thirteen', b'fourteen', b'fifteen'],
[b'sixteen', b'seventeen', b'eighteen'],
[b'nineteen', b'twenty', b'twentyone']]
position = [1, 2, 3]
length =   [1, 2, 3] <p></p> output = [[b'e', b'ev', b'lve'],
[b'h', b'ur', b'tee'],
[b'i', b've', b'hte'],
[b'i', b'en', b'nty']]
``` <p></p> Broadcasting `input` onto `pos` and `len`: <p></p> ```
input = b'thirteen'
position = [1, 5, 7]
length =   [3, 2, 1] <p></p> output = [b'hir', b'ee', b'n']
``` 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> input
						</dt>
						<dd>A `Tensor` of type `string`. Tensor of strings 
						</dd>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> pos
						</dt>
						<dd>A `Tensor`. Must be one of the following types: `int32`, `int64`.
Scalar defining the position of first character in each substring 
						</dd>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> len
						</dt>
						<dd>A `Tensor`. Must have the same type as `pos`.
Scalar defining the number of characters to include in each substring 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> unit
						</dt>
						<dd>An optional `string` from: `"BYTE", "UTF8_CHAR"`. Defaults to `"BYTE"`.
The unit that is used to create the substring.  One of: `"BYTE"` (for
defining position and length by bytes) or `"UTF8_CHAR"` (for the UTF-8
encoded Unicode code points).  The default is `"BYTE"`. Results are undefined if
`unit=UTF8_CHAR` and the `input` strings do not contain structurally valid
UTF-8. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of type `string`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>input = [b'Hello', b'World']
            position = 1
            length = 3 <p></p> output = [b'ell', b'orl'] </pre>
</div>
		</div>
	</div>
	<div id="substr" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>substr</strong>(<a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> input, <a href="../numpy/ndarray.htm">ndarray</a> pos, <span title="System.double">double</span> len, <span title="System.string">string</span> name, <span title="System.string">string</span> unit)
		</h4>
		<div class="content">Return substrings from `Tensor` of strings. <p></p> For each string in the input `Tensor`, creates a substring starting at index
`pos` with a total length of `len`. <p></p> If `len` defines a substring that would extend beyond the length of the input
string, then as many characters as possible are used. <p></p> A negative `pos` indicates distance within the string backwards from the end. <p></p> If `pos` specifies an index which is out of range for any of the input strings,
then an `InvalidArgumentError` is thrown. <p></p> `pos` and `len` must have the same shape, otherwise a `ValueError` is thrown on
Op creation. <p></p> *NOTE*: `Substr` supports broadcasting up to two dimensions. More about
broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html) <p></p> --- <p></p> Examples <p></p> Using scalar `pos` and `len`:
Using `pos` and `len` with same shape as `input`:
Broadcasting `pos` and `len` onto `input`: <p></p> ```
input = [[b'ten', b'eleven', b'twelve'],
[b'thirteen', b'fourteen', b'fifteen'],
[b'sixteen', b'seventeen', b'eighteen'],
[b'nineteen', b'twenty', b'twentyone']]
position = [1, 2, 3]
length =   [1, 2, 3] <p></p> output = [[b'e', b'ev', b'lve'],
[b'h', b'ur', b'tee'],
[b'i', b've', b'hte'],
[b'i', b'en', b'nty']]
``` <p></p> Broadcasting `input` onto `pos` and `len`: <p></p> ```
input = b'thirteen'
position = [1, 5, 7]
length =   [3, 2, 1] <p></p> output = [b'hir', b'ee', b'n']
``` 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> input
						</dt>
						<dd>A `Tensor` of type `string`. Tensor of strings 
						</dd>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> pos
						</dt>
						<dd>A `Tensor`. Must be one of the following types: `int32`, `int64`.
Scalar defining the position of first character in each substring 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> len
						</dt>
						<dd>A `Tensor`. Must have the same type as `pos`.
Scalar defining the number of characters to include in each substring 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> unit
						</dt>
						<dd>An optional `string` from: `"BYTE", "UTF8_CHAR"`. Defaults to `"BYTE"`.
The unit that is used to create the substring.  One of: `"BYTE"` (for
defining position and length by bytes) or `"UTF8_CHAR"` (for the UTF-8
encoded Unicode code points).  The default is `"BYTE"`. Results are undefined if
`unit=UTF8_CHAR` and the `input` strings do not contain structurally valid
UTF-8. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of type `string`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>input = [b'Hello', b'World']
            position = 1
            length = 3 <p></p> output = [b'ell', b'orl'] </pre>
</div>
		</div>
	</div>
	<div id="substr" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>substr</strong>(<a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> input, <span title="System.double">double</span> pos, <a href="../numpy/ndarray.htm">ndarray</a> len, <span title="System.string">string</span> name, <span title="System.string">string</span> unit)
		</h4>
		<div class="content">Return substrings from `Tensor` of strings. <p></p> For each string in the input `Tensor`, creates a substring starting at index
`pos` with a total length of `len`. <p></p> If `len` defines a substring that would extend beyond the length of the input
string, then as many characters as possible are used. <p></p> A negative `pos` indicates distance within the string backwards from the end. <p></p> If `pos` specifies an index which is out of range for any of the input strings,
then an `InvalidArgumentError` is thrown. <p></p> `pos` and `len` must have the same shape, otherwise a `ValueError` is thrown on
Op creation. <p></p> *NOTE*: `Substr` supports broadcasting up to two dimensions. More about
broadcasting
[here](http://docs.scipy.org/doc/numpy/user/basics.broadcasting.html) <p></p> --- <p></p> Examples <p></p> Using scalar `pos` and `len`:
Using `pos` and `len` with same shape as `input`:
Broadcasting `pos` and `len` onto `input`: <p></p> ```
input = [[b'ten', b'eleven', b'twelve'],
[b'thirteen', b'fourteen', b'fifteen'],
[b'sixteen', b'seventeen', b'eighteen'],
[b'nineteen', b'twenty', b'twentyone']]
position = [1, 2, 3]
length =   [1, 2, 3] <p></p> output = [[b'e', b'ev', b'lve'],
[b'h', b'ur', b'tee'],
[b'i', b've', b'hte'],
[b'i', b'en', b'nty']]
``` <p></p> Broadcasting `input` onto `pos` and `len`: <p></p> ```
input = b'thirteen'
position = [1, 5, 7]
length =   [3, 2, 1] <p></p> output = [b'hir', b'ee', b'n']
``` 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> input
						</dt>
						<dd>A `Tensor` of type `string`. Tensor of strings 
						</dd>
						<dt>
							<code><span title="System.double">double</span></code> pos
						</dt>
						<dd>A `Tensor`. Must be one of the following types: `int32`, `int64`.
Scalar defining the position of first character in each substring 
						</dd>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> len
						</dt>
						<dd>A `Tensor`. Must have the same type as `pos`.
Scalar defining the number of characters to include in each substring 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> unit
						</dt>
						<dd>An optional `string` from: `"BYTE", "UTF8_CHAR"`. Defaults to `"BYTE"`.
The unit that is used to create the substring.  One of: `"BYTE"` (for
defining position and length by bytes) or `"UTF8_CHAR"` (for the UTF-8
encoded Unicode code points).  The default is `"BYTE"`. Results are undefined if
`unit=UTF8_CHAR` and the `input` strings do not contain structurally valid
UTF-8. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of type `string`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>input = [b'Hello', b'World']
            position = 1
            length = 3 <p></p> output = [b'ell', b'orl'] </pre>
</div>
		</div>
	</div>
	<div id="unicode_decode" class="method">
		<h4>
			<span title="System.object">object</span> <strong>unicode_decode</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> input, <span title="System.string">string</span> input_encoding, <span title="System.string">string</span> errors, <span title="System.int">int</span> replacement_char, <span title="System.bool">bool</span> replace_control_characters, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Decodes each string in `input` into a sequence of Unicode code points. <p></p> `result[i1...iN, j]` is the Unicode codepoint for the `j`th character in
`input[i1...iN]`, when decoded using `input_encoding`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> input
						</dt>
						<dd>An `N` dimensional potentially ragged `string` tensor with shape
`[D1...DN]`.  `N` must be statically known. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> input_encoding
						</dt>
						<dd>String name for the unicode encoding that should be used to
decode each string. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> errors
						</dt>
						<dd>Specifies the response when an input string can't be converted
using the indicated encoding. One of:
* `'strict'`: Raise an exception for any illegal substrings.
* `'replace'`: Replace illegal substrings with `replacement_char`.
* `'ignore'`: Skip illegal substrings. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> replacement_char
						</dt>
						<dd>The replacement codepoint to be used in place of invalid
substrings in `input` when `errors='replace'`; and in place of C0 control
characters in `input` when `replace_control_characters=True`. 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> replace_control_characters
						</dt>
						<dd>Whether to replace the C0 control characters
`(U+0000 - U+001F)` with the `replacement_char`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `N+1` dimensional `int32` tensor with shape `[D1...DN, (num_chars)]`.
The returned tensor is a <a href="..\..\tf\Tensor.md"><code>tf.Tensor</code></a> if `input` is a scalar, or a
<a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a> otherwise. <p></p> #### Example:
```python
>>> input = [s.encode('utf8') for s in (u'G\xf6\xf6dnight', u'\U0001f60a')]
>>> tf.strings.unicode_decode(input, 'UTF-8').tolist()
[[71, 246, 246, 100, 110, 105, 103, 104, 116], [128522]]
``` 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="unicode_decode" class="method">
		<h4>
			<span title="System.object">object</span> <strong>unicode_decode</strong>(<span title="System.Collections.Generic.IEnumerable<Byte[]>">IEnumerable&lt;Byte[]&gt;</span> input, <span title="System.string">string</span> input_encoding, <span title="System.string">string</span> errors, <span title="System.int">int</span> replacement_char, <span title="System.bool">bool</span> replace_control_characters, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Decodes each string in `input` into a sequence of Unicode code points. <p></p> `result[i1...iN, j]` is the Unicode codepoint for the `j`th character in
`input[i1...iN]`, when decoded using `input_encoding`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<Byte[]>">IEnumerable&lt;Byte[]&gt;</span></code> input
						</dt>
						<dd>An `N` dimensional potentially ragged `string` tensor with shape
`[D1...DN]`.  `N` must be statically known. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> input_encoding
						</dt>
						<dd>String name for the unicode encoding that should be used to
decode each string. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> errors
						</dt>
						<dd>Specifies the response when an input string can't be converted
using the indicated encoding. One of:
* `'strict'`: Raise an exception for any illegal substrings.
* `'replace'`: Replace illegal substrings with `replacement_char`.
* `'ignore'`: Skip illegal substrings. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> replacement_char
						</dt>
						<dd>The replacement codepoint to be used in place of invalid
substrings in `input` when `errors='replace'`; and in place of C0 control
characters in `input` when `replace_control_characters=True`. 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> replace_control_characters
						</dt>
						<dd>Whether to replace the C0 control characters
`(U+0000 - U+001F)` with the `replacement_char`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `N+1` dimensional `int32` tensor with shape `[D1...DN, (num_chars)]`.
The returned tensor is a <a href="..\..\tf\Tensor.md"><code>tf.Tensor</code></a> if `input` is a scalar, or a
<a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a> otherwise. <p></p> #### Example:
```python
>>> input = [s.encode('utf8') for s in (u'G\xf6\xf6dnight', u'\U0001f60a')]
>>> tf.strings.unicode_decode(input, 'UTF-8').tolist()
[[71, 246, 246, 100, 110, 105, 103, 104, 116], [128522]]
``` 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="unicode_decode" class="method">
		<h4>
			<span title="System.object">object</span> <strong>unicode_decode</strong>(<a href="../numpy/ndarray.htm">ndarray</a> input, <span title="System.string">string</span> input_encoding, <span title="System.string">string</span> errors, <span title="System.int">int</span> replacement_char, <span title="System.bool">bool</span> replace_control_characters, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Decodes each string in `input` into a sequence of Unicode code points. <p></p> `result[i1...iN, j]` is the Unicode codepoint for the `j`th character in
`input[i1...iN]`, when decoded using `input_encoding`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> input
						</dt>
						<dd>An `N` dimensional potentially ragged `string` tensor with shape
`[D1...DN]`.  `N` must be statically known. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> input_encoding
						</dt>
						<dd>String name for the unicode encoding that should be used to
decode each string. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> errors
						</dt>
						<dd>Specifies the response when an input string can't be converted
using the indicated encoding. One of:
* `'strict'`: Raise an exception for any illegal substrings.
* `'replace'`: Replace illegal substrings with `replacement_char`.
* `'ignore'`: Skip illegal substrings. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> replacement_char
						</dt>
						<dd>The replacement codepoint to be used in place of invalid
substrings in `input` when `errors='replace'`; and in place of C0 control
characters in `input` when `replace_control_characters=True`. 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> replace_control_characters
						</dt>
						<dd>Whether to replace the C0 control characters
`(U+0000 - U+001F)` with the `replacement_char`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `N+1` dimensional `int32` tensor with shape `[D1...DN, (num_chars)]`.
The returned tensor is a <a href="..\..\tf\Tensor.md"><code>tf.Tensor</code></a> if `input` is a scalar, or a
<a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a> otherwise. <p></p> #### Example:
```python
>>> input = [s.encode('utf8') for s in (u'G\xf6\xf6dnight', u'\U0001f60a')]
>>> tf.strings.unicode_decode(input, 'UTF-8').tolist()
[[71, 246, 246, 100, 110, 105, 103, 104, 116], [128522]]
``` 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="unicode_decode_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>unicode_decode_dyn</strong>(<span title="System.object">object</span> input, <span title="System.object">object</span> input_encoding, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> errors, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> replacement_char, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> replace_control_characters, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Decodes each string in `input` into a sequence of Unicode code points. <p></p> `result[i1...iN, j]` is the Unicode codepoint for the `j`th character in
`input[i1...iN]`, when decoded using `input_encoding`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> input
						</dt>
						<dd>An `N` dimensional potentially ragged `string` tensor with shape
`[D1...DN]`.  `N` must be statically known. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> input_encoding
						</dt>
						<dd>String name for the unicode encoding that should be used to
decode each string. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> errors
						</dt>
						<dd>Specifies the response when an input string can't be converted
using the indicated encoding. One of:
* `'strict'`: Raise an exception for any illegal substrings.
* `'replace'`: Replace illegal substrings with `replacement_char`.
* `'ignore'`: Skip illegal substrings. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> replacement_char
						</dt>
						<dd>The replacement codepoint to be used in place of invalid
substrings in `input` when `errors='replace'`; and in place of C0 control
characters in `input` when `replace_control_characters=True`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> replace_control_characters
						</dt>
						<dd>Whether to replace the C0 control characters
`(U+0000 - U+001F)` with the `replacement_char`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `N+1` dimensional `int32` tensor with shape `[D1...DN, (num_chars)]`.
The returned tensor is a <a href="..\..\tf\Tensor.md"><code>tf.Tensor</code></a> if `input` is a scalar, or a
<a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a> otherwise. <p></p> #### Example:
```python
>>> input = [s.encode('utf8') for s in (u'G\xf6\xf6dnight', u'\U0001f60a')]
>>> tf.strings.unicode_decode(input, 'UTF-8').tolist()
[[71, 246, 246, 100, 110, 105, 103, 104, 116], [128522]]
``` 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="unicode_decode_with_offsets" class="method">
		<h4>
			<span title="System.object">object</span> <strong>unicode_decode_with_offsets</strong>(<span title="System.Collections.Generic.IEnumerable<Byte[]>">IEnumerable&lt;Byte[]&gt;</span> input, <span title="System.string">string</span> input_encoding, <span title="System.string">string</span> errors, <span title="System.int">int</span> replacement_char, <span title="System.bool">bool</span> replace_control_characters, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Decodes each string into a sequence of code points with start offsets. <p></p> This op is similar to `tf.strings.decode(...)`, but it also returns the
start offset for each character in its respective string.  This information
can be used to align the characters with the original byte sequence. <p></p> Returns a tuple `(codepoints, start_offsets)` where: <p></p> * `codepoints[i1...iN, j]` is the Unicode codepoint for the `j`th character
in `input[i1...iN]`, when decoded using `input_encoding`.
* `start_offsets[i1...iN, j]` is the start byte offset for the `j`th
character in `input[i1...iN]`, when decoded using `input_encoding`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<Byte[]>">IEnumerable&lt;Byte[]&gt;</span></code> input
						</dt>
						<dd>An `N` dimensional potentially ragged `string` tensor with shape
`[D1...DN]`.  `N` must be statically known. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> input_encoding
						</dt>
						<dd>String name for the unicode encoding that should be used to
decode each string. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> errors
						</dt>
						<dd>Specifies the response when an input string can't be converted
using the indicated encoding. One of:
* `'strict'`: Raise an exception for any illegal substrings.
* `'replace'`: Replace illegal substrings with `replacement_char`.
* `'ignore'`: Skip illegal substrings. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> replacement_char
						</dt>
						<dd>The replacement codepoint to be used in place of invalid
substrings in `input` when `errors='replace'`; and in place of C0 control
characters in `input` when `replace_control_characters=True`. 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> replace_control_characters
						</dt>
						<dd>Whether to replace the C0 control characters
`(U+0000 - U+001F)` with the `replacement_char`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A tuple of `N+1` dimensional tensors `(codepoints, start_offsets)`. <p></p> * `codepoints` is an `int32` tensor with shape `[D1...DN, (num_chars)]`.
* `offsets` is an `int64` tensor with shape `[D1...DN, (num_chars)]`. <p></p> The returned tensors are <a href="..\..\tf\Tensor.md"><code>tf.Tensor</code></a>s if `input` is a scalar, or
<a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a>s otherwise. <p></p> #### Example:
```python
>>> input = [s.encode('utf8') for s in (u'G\xf6\xf6dnight', u'\U0001f60a')]
>>> result = tf.strings.unicode_decode_with_offsets(input, 'UTF-8')
>>> result[0].tolist()  # codepoints
[[71, 246, 246, 100, 110, 105, 103, 104, 116], [128522]]
>>> result[1].tolist()  # offsets
[[0, 1, 3, 5, 6, 7, 8, 9, 10], [0]]
``` 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="unicode_decode_with_offsets" class="method">
		<h4>
			<span title="System.object">object</span> <strong>unicode_decode_with_offsets</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> input, <span title="System.string">string</span> input_encoding, <span title="System.string">string</span> errors, <span title="System.int">int</span> replacement_char, <span title="System.bool">bool</span> replace_control_characters, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Decodes each string into a sequence of code points with start offsets. <p></p> This op is similar to `tf.strings.decode(...)`, but it also returns the
start offset for each character in its respective string.  This information
can be used to align the characters with the original byte sequence. <p></p> Returns a tuple `(codepoints, start_offsets)` where: <p></p> * `codepoints[i1...iN, j]` is the Unicode codepoint for the `j`th character
in `input[i1...iN]`, when decoded using `input_encoding`.
* `start_offsets[i1...iN, j]` is the start byte offset for the `j`th
character in `input[i1...iN]`, when decoded using `input_encoding`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> input
						</dt>
						<dd>An `N` dimensional potentially ragged `string` tensor with shape
`[D1...DN]`.  `N` must be statically known. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> input_encoding
						</dt>
						<dd>String name for the unicode encoding that should be used to
decode each string. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> errors
						</dt>
						<dd>Specifies the response when an input string can't be converted
using the indicated encoding. One of:
* `'strict'`: Raise an exception for any illegal substrings.
* `'replace'`: Replace illegal substrings with `replacement_char`.
* `'ignore'`: Skip illegal substrings. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> replacement_char
						</dt>
						<dd>The replacement codepoint to be used in place of invalid
substrings in `input` when `errors='replace'`; and in place of C0 control
characters in `input` when `replace_control_characters=True`. 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> replace_control_characters
						</dt>
						<dd>Whether to replace the C0 control characters
`(U+0000 - U+001F)` with the `replacement_char`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A tuple of `N+1` dimensional tensors `(codepoints, start_offsets)`. <p></p> * `codepoints` is an `int32` tensor with shape `[D1...DN, (num_chars)]`.
* `offsets` is an `int64` tensor with shape `[D1...DN, (num_chars)]`. <p></p> The returned tensors are <a href="..\..\tf\Tensor.md"><code>tf.Tensor</code></a>s if `input` is a scalar, or
<a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a>s otherwise. <p></p> #### Example:
```python
>>> input = [s.encode('utf8') for s in (u'G\xf6\xf6dnight', u'\U0001f60a')]
>>> result = tf.strings.unicode_decode_with_offsets(input, 'UTF-8')
>>> result[0].tolist()  # codepoints
[[71, 246, 246, 100, 110, 105, 103, 104, 116], [128522]]
>>> result[1].tolist()  # offsets
[[0, 1, 3, 5, 6, 7, 8, 9, 10], [0]]
``` 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="unicode_decode_with_offsets_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>unicode_decode_with_offsets_dyn</strong>(<span title="System.object">object</span> input, <span title="System.object">object</span> input_encoding, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> errors, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> replacement_char, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> replace_control_characters, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Decodes each string into a sequence of code points with start offsets. <p></p> This op is similar to `tf.strings.decode(...)`, but it also returns the
start offset for each character in its respective string.  This information
can be used to align the characters with the original byte sequence. <p></p> Returns a tuple `(codepoints, start_offsets)` where: <p></p> * `codepoints[i1...iN, j]` is the Unicode codepoint for the `j`th character
in `input[i1...iN]`, when decoded using `input_encoding`.
* `start_offsets[i1...iN, j]` is the start byte offset for the `j`th
character in `input[i1...iN]`, when decoded using `input_encoding`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> input
						</dt>
						<dd>An `N` dimensional potentially ragged `string` tensor with shape
`[D1...DN]`.  `N` must be statically known. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> input_encoding
						</dt>
						<dd>String name for the unicode encoding that should be used to
decode each string. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> errors
						</dt>
						<dd>Specifies the response when an input string can't be converted
using the indicated encoding. One of:
* `'strict'`: Raise an exception for any illegal substrings.
* `'replace'`: Replace illegal substrings with `replacement_char`.
* `'ignore'`: Skip illegal substrings. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> replacement_char
						</dt>
						<dd>The replacement codepoint to be used in place of invalid
substrings in `input` when `errors='replace'`; and in place of C0 control
characters in `input` when `replace_control_characters=True`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> replace_control_characters
						</dt>
						<dd>Whether to replace the C0 control characters
`(U+0000 - U+001F)` with the `replacement_char`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A tuple of `N+1` dimensional tensors `(codepoints, start_offsets)`. <p></p> * `codepoints` is an `int32` tensor with shape `[D1...DN, (num_chars)]`.
* `offsets` is an `int64` tensor with shape `[D1...DN, (num_chars)]`. <p></p> The returned tensors are <a href="..\..\tf\Tensor.md"><code>tf.Tensor</code></a>s if `input` is a scalar, or
<a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a>s otherwise. <p></p> #### Example:
```python
>>> input = [s.encode('utf8') for s in (u'G\xf6\xf6dnight', u'\U0001f60a')]
>>> result = tf.strings.unicode_decode_with_offsets(input, 'UTF-8')
>>> result[0].tolist()  # codepoints
[[71, 246, 246, 100, 110, 105, 103, 104, 116], [128522]]
>>> result[1].tolist()  # offsets
[[0, 1, 3, 5, 6, 7, 8, 9, 10], [0]]
``` 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="unicode_encode" class="method">
		<h4>
			<span title="System.object">object</span> <strong>unicode_encode</strong>(<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> input, <span title="System.string">string</span> output_encoding, <span title="System.string">string</span> errors, <span title="System.int">int</span> replacement_char, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Encodes each sequence of Unicode code points in `input` into a string. <p></p> `result[i1...iN]` is the string formed by concatenating the Unicode
codepoints `input[1...iN, :]`, encoded using `output_encoding`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code> input
						</dt>
						<dd>An `N+1` dimensional potentially ragged integer tensor with shape
`[D1...DN, num_chars]`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> output_encoding
						</dt>
						<dd>Unicode encoding that should be used to encode each
codepoint sequence.  Can be `"UTF-8"`, `"UTF-16-BE"`, or `"UTF-32-BE"`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> errors
						</dt>
						<dd>Specifies the response when an invalid codepoint is encountered
(optional). One of:
* `'replace'`: Replace invalid codepoint with the
`replacement_char`. (default)
* `'ignore'`: Skip invalid codepoints.
* `'strict'`: Raise an exception for any invalid codepoint. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> replacement_char
						</dt>
						<dd>The replacement character codepoint to be used in place of
any invalid input when `errors='replace'`. Any valid unicode codepoint may
be used. The default value is the default unicode replacement character
which is 0xFFFD (U+65533). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `N` dimensional `string` tensor with shape `[D1...DN]`. <p></p> #### Example:
```python
>>> input = [[71, 246, 246, 100, 110, 105, 103, 104, 116], [128522]]
>>> unicode_encode(input, 'UTF-8')
['G\xc3\xb6\xc3\xb6dnight', '\xf0\x9f\x98\x8a']
``` 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="unicode_encode" class="method">
		<h4>
			<span title="System.object">object</span> <strong>unicode_encode</strong>(<a href="../numpy/ndarray.htm">ndarray</a> input, <span title="System.string">string</span> output_encoding, <span title="System.string">string</span> errors, <span title="System.int">int</span> replacement_char, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Encodes each sequence of Unicode code points in `input` into a string. <p></p> `result[i1...iN]` is the string formed by concatenating the Unicode
codepoints `input[1...iN, :]`, encoded using `output_encoding`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> input
						</dt>
						<dd>An `N+1` dimensional potentially ragged integer tensor with shape
`[D1...DN, num_chars]`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> output_encoding
						</dt>
						<dd>Unicode encoding that should be used to encode each
codepoint sequence.  Can be `"UTF-8"`, `"UTF-16-BE"`, or `"UTF-32-BE"`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> errors
						</dt>
						<dd>Specifies the response when an invalid codepoint is encountered
(optional). One of:
* `'replace'`: Replace invalid codepoint with the
`replacement_char`. (default)
* `'ignore'`: Skip invalid codepoints.
* `'strict'`: Raise an exception for any invalid codepoint. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> replacement_char
						</dt>
						<dd>The replacement character codepoint to be used in place of
any invalid input when `errors='replace'`. Any valid unicode codepoint may
be used. The default value is the default unicode replacement character
which is 0xFFFD (U+65533). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `N` dimensional `string` tensor with shape `[D1...DN]`. <p></p> #### Example:
```python
>>> input = [[71, 246, 246, 100, 110, 105, 103, 104, 116], [128522]]
>>> unicode_encode(input, 'UTF-8')
['G\xc3\xb6\xc3\xb6dnight', '\xf0\x9f\x98\x8a']
``` 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="unicode_encode" class="method">
		<h4>
			<span title="System.object">object</span> <strong>unicode_encode</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> input, <span title="System.string">string</span> output_encoding, <span title="System.string">string</span> errors, <span title="System.int">int</span> replacement_char, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Encodes each sequence of Unicode code points in `input` into a string. <p></p> `result[i1...iN]` is the string formed by concatenating the Unicode
codepoints `input[1...iN, :]`, encoded using `output_encoding`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> input
						</dt>
						<dd>An `N+1` dimensional potentially ragged integer tensor with shape
`[D1...DN, num_chars]`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> output_encoding
						</dt>
						<dd>Unicode encoding that should be used to encode each
codepoint sequence.  Can be `"UTF-8"`, `"UTF-16-BE"`, or `"UTF-32-BE"`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> errors
						</dt>
						<dd>Specifies the response when an invalid codepoint is encountered
(optional). One of:
* `'replace'`: Replace invalid codepoint with the
`replacement_char`. (default)
* `'ignore'`: Skip invalid codepoints.
* `'strict'`: Raise an exception for any invalid codepoint. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> replacement_char
						</dt>
						<dd>The replacement character codepoint to be used in place of
any invalid input when `errors='replace'`. Any valid unicode codepoint may
be used. The default value is the default unicode replacement character
which is 0xFFFD (U+65533). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `N` dimensional `string` tensor with shape `[D1...DN]`. <p></p> #### Example:
```python
>>> input = [[71, 246, 246, 100, 110, 105, 103, 104, 116], [128522]]
>>> unicode_encode(input, 'UTF-8')
['G\xc3\xb6\xc3\xb6dnight', '\xf0\x9f\x98\x8a']
``` 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="unicode_encode" class="method">
		<h4>
			<span title="System.object">object</span> <strong>unicode_encode</strong>(<span title="System.int">int</span> input, <span title="System.string">string</span> output_encoding, <span title="System.string">string</span> errors, <span title="System.int">int</span> replacement_char, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Encodes each sequence of Unicode code points in `input` into a string. <p></p> `result[i1...iN]` is the string formed by concatenating the Unicode
codepoints `input[1...iN, :]`, encoded using `output_encoding`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> input
						</dt>
						<dd>An `N+1` dimensional potentially ragged integer tensor with shape
`[D1...DN, num_chars]`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> output_encoding
						</dt>
						<dd>Unicode encoding that should be used to encode each
codepoint sequence.  Can be `"UTF-8"`, `"UTF-16-BE"`, or `"UTF-32-BE"`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> errors
						</dt>
						<dd>Specifies the response when an invalid codepoint is encountered
(optional). One of:
* `'replace'`: Replace invalid codepoint with the
`replacement_char`. (default)
* `'ignore'`: Skip invalid codepoints.
* `'strict'`: Raise an exception for any invalid codepoint. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> replacement_char
						</dt>
						<dd>The replacement character codepoint to be used in place of
any invalid input when `errors='replace'`. Any valid unicode codepoint may
be used. The default value is the default unicode replacement character
which is 0xFFFD (U+65533). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `N` dimensional `string` tensor with shape `[D1...DN]`. <p></p> #### Example:
```python
>>> input = [[71, 246, 246, 100, 110, 105, 103, 104, 116], [128522]]
>>> unicode_encode(input, 'UTF-8')
['G\xc3\xb6\xc3\xb6dnight', '\xf0\x9f\x98\x8a']
``` 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="unicode_encode" class="method">
		<h4>
			<span title="System.object">object</span> <strong>unicode_encode</strong>(<span title="System.object">object</span> input, <span title="System.string">string</span> output_encoding, <span title="System.string">string</span> errors, <span title="System.int">int</span> replacement_char, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Encodes each sequence of Unicode code points in `input` into a string. <p></p> `result[i1...iN]` is the string formed by concatenating the Unicode
codepoints `input[1...iN, :]`, encoded using `output_encoding`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> input
						</dt>
						<dd>An `N+1` dimensional potentially ragged integer tensor with shape
`[D1...DN, num_chars]`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> output_encoding
						</dt>
						<dd>Unicode encoding that should be used to encode each
codepoint sequence.  Can be `"UTF-8"`, `"UTF-16-BE"`, or `"UTF-32-BE"`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> errors
						</dt>
						<dd>Specifies the response when an invalid codepoint is encountered
(optional). One of:
* `'replace'`: Replace invalid codepoint with the
`replacement_char`. (default)
* `'ignore'`: Skip invalid codepoints.
* `'strict'`: Raise an exception for any invalid codepoint. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> replacement_char
						</dt>
						<dd>The replacement character codepoint to be used in place of
any invalid input when `errors='replace'`. Any valid unicode codepoint may
be used. The default value is the default unicode replacement character
which is 0xFFFD (U+65533). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `N` dimensional `string` tensor with shape `[D1...DN]`. <p></p> #### Example:
```python
>>> input = [[71, 246, 246, 100, 110, 105, 103, 104, 116], [128522]]
>>> unicode_encode(input, 'UTF-8')
['G\xc3\xb6\xc3\xb6dnight', '\xf0\x9f\x98\x8a']
``` 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="unicode_encode" class="method">
		<h4>
			<span title="System.object">object</span> <strong>unicode_encode</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> input, <span title="System.string">string</span> output_encoding, <span title="System.string">string</span> errors, <span title="System.int">int</span> replacement_char, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Encodes each sequence of Unicode code points in `input` into a string. <p></p> `result[i1...iN]` is the string formed by concatenating the Unicode
codepoints `input[1...iN, :]`, encoded using `output_encoding`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> input
						</dt>
						<dd>An `N+1` dimensional potentially ragged integer tensor with shape
`[D1...DN, num_chars]`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> output_encoding
						</dt>
						<dd>Unicode encoding that should be used to encode each
codepoint sequence.  Can be `"UTF-8"`, `"UTF-16-BE"`, or `"UTF-32-BE"`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> errors
						</dt>
						<dd>Specifies the response when an invalid codepoint is encountered
(optional). One of:
* `'replace'`: Replace invalid codepoint with the
`replacement_char`. (default)
* `'ignore'`: Skip invalid codepoints.
* `'strict'`: Raise an exception for any invalid codepoint. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> replacement_char
						</dt>
						<dd>The replacement character codepoint to be used in place of
any invalid input when `errors='replace'`. Any valid unicode codepoint may
be used. The default value is the default unicode replacement character
which is 0xFFFD (U+65533). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `N` dimensional `string` tensor with shape `[D1...DN]`. <p></p> #### Example:
```python
>>> input = [[71, 246, 246, 100, 110, 105, 103, 104, 116], [128522]]
>>> unicode_encode(input, 'UTF-8')
['G\xc3\xb6\xc3\xb6dnight', '\xf0\x9f\x98\x8a']
``` 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="unicode_encode_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>unicode_encode_dyn</strong>(<span title="System.object">object</span> input, <span title="System.object">object</span> output_encoding, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> errors, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> replacement_char, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Encodes each sequence of Unicode code points in `input` into a string. <p></p> `result[i1...iN]` is the string formed by concatenating the Unicode
codepoints `input[1...iN, :]`, encoded using `output_encoding`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> input
						</dt>
						<dd>An `N+1` dimensional potentially ragged integer tensor with shape
`[D1...DN, num_chars]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> output_encoding
						</dt>
						<dd>Unicode encoding that should be used to encode each
codepoint sequence.  Can be `"UTF-8"`, `"UTF-16-BE"`, or `"UTF-32-BE"`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> errors
						</dt>
						<dd>Specifies the response when an invalid codepoint is encountered
(optional). One of:
* `'replace'`: Replace invalid codepoint with the
`replacement_char`. (default)
* `'ignore'`: Skip invalid codepoints.
* `'strict'`: Raise an exception for any invalid codepoint. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> replacement_char
						</dt>
						<dd>The replacement character codepoint to be used in place of
any invalid input when `errors='replace'`. Any valid unicode codepoint may
be used. The default value is the default unicode replacement character
which is 0xFFFD (U+65533). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `N` dimensional `string` tensor with shape `[D1...DN]`. <p></p> #### Example:
```python
>>> input = [[71, 246, 246, 100, 110, 105, 103, 104, 116], [128522]]
>>> unicode_encode(input, 'UTF-8')
['G\xc3\xb6\xc3\xb6dnight', '\xf0\x9f\x98\x8a']
``` 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="unicode_script" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>unicode_script</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> input, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Determine the script codes of a given tensor of Unicode integer code points. <p></p> This operation converts Unicode code points to script codes corresponding to
each code point. Script codes correspond to International Components for
Unicode (ICU) UScriptCode values. See http://icu-project.org/apiref/icu4c/uscript_8h.html.
Returns -1 (USCRIPT_INVALID_CODE) for invalid codepoints. Output shape will
match input shape. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> input
						</dt>
						<dd>A `Tensor` of type `int32`. A Tensor of int32 Unicode code points. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of type `int32`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="unicode_script_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>unicode_script_dyn</strong>(<span title="System.object">object</span> input, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Determine the script codes of a given tensor of Unicode integer code points. <p></p> This operation converts Unicode code points to script codes corresponding to
each code point. Script codes correspond to International Components for
Unicode (ICU) UScriptCode values. See http://icu-project.org/apiref/icu4c/uscript_8h.html.
Returns -1 (USCRIPT_INVALID_CODE) for invalid codepoints. Output shape will
match input shape. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> input
						</dt>
						<dd>A `Tensor` of type `int32`. A Tensor of int32 Unicode code points. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `Tensor` of type `int32`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="unicode_split" class="method">
		<h4>
			<span title="System.object">object</span> <strong>unicode_split</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> input, <span title="System.string">string</span> input_encoding, <span title="System.string">string</span> errors, <span title="System.int">int</span> replacement_char, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Splits each string in `input` into a sequence of Unicode code points. <p></p> `result[i1...iN, j]` is the substring of `input[i1...iN]` that encodes its
`j`th character, when decoded using `input_encoding`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> input
						</dt>
						<dd>An `N` dimensional potentially ragged `string` tensor with shape
`[D1...DN]`.  `N` must be statically known. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> input_encoding
						</dt>
						<dd>String name for the unicode encoding that should be used to
decode each string. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> errors
						</dt>
						<dd>Specifies the response when an input string can't be converted
using the indicated encoding. One of:
* `'strict'`: Raise an exception for any illegal substrings.
* `'replace'`: Replace illegal substrings with `replacement_char`.
* `'ignore'`: Skip illegal substrings. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> replacement_char
						</dt>
						<dd>The replacement codepoint to be used in place of invalid
substrings in `input` when `errors='replace'`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `N+1` dimensional `int32` tensor with shape `[D1...DN, (num_chars)]`.
The returned tensor is a <a href="..\..\tf\Tensor.md"><code>tf.Tensor</code></a> if `input` is a scalar, or a
<a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a> otherwise. <p></p> #### Example:
```python
>>> input = [s.encode('utf8') for s in (u'G\xf6\xf6dnight', u'\U0001f60a')]
>>> tf.strings.unicode_split(input, 'UTF-8').tolist()
[['G', '\xc3\xb6', '\xc3\xb6', 'd', 'n', 'i', 'g', 'h', 't'],
['\xf0\x9f\x98\x8a']]
``` 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="unicode_split" class="method">
		<h4>
			<span title="System.object">object</span> <strong>unicode_split</strong>(<span title="System.Collections.Generic.IEnumerable<Byte[]>">IEnumerable&lt;Byte[]&gt;</span> input, <span title="System.string">string</span> input_encoding, <span title="System.string">string</span> errors, <span title="System.int">int</span> replacement_char, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Splits each string in `input` into a sequence of Unicode code points. <p></p> `result[i1...iN, j]` is the substring of `input[i1...iN]` that encodes its
`j`th character, when decoded using `input_encoding`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<Byte[]>">IEnumerable&lt;Byte[]&gt;</span></code> input
						</dt>
						<dd>An `N` dimensional potentially ragged `string` tensor with shape
`[D1...DN]`.  `N` must be statically known. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> input_encoding
						</dt>
						<dd>String name for the unicode encoding that should be used to
decode each string. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> errors
						</dt>
						<dd>Specifies the response when an input string can't be converted
using the indicated encoding. One of:
* `'strict'`: Raise an exception for any illegal substrings.
* `'replace'`: Replace illegal substrings with `replacement_char`.
* `'ignore'`: Skip illegal substrings. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> replacement_char
						</dt>
						<dd>The replacement codepoint to be used in place of invalid
substrings in `input` when `errors='replace'`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `N+1` dimensional `int32` tensor with shape `[D1...DN, (num_chars)]`.
The returned tensor is a <a href="..\..\tf\Tensor.md"><code>tf.Tensor</code></a> if `input` is a scalar, or a
<a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a> otherwise. <p></p> #### Example:
```python
>>> input = [s.encode('utf8') for s in (u'G\xf6\xf6dnight', u'\U0001f60a')]
>>> tf.strings.unicode_split(input, 'UTF-8').tolist()
[['G', '\xc3\xb6', '\xc3\xb6', 'd', 'n', 'i', 'g', 'h', 't'],
['\xf0\x9f\x98\x8a']]
``` 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="unicode_split" class="method">
		<h4>
			<span title="System.object">object</span> <strong>unicode_split</strong>(<a href="../numpy/ndarray.htm">ndarray</a> input, <span title="System.string">string</span> input_encoding, <span title="System.string">string</span> errors, <span title="System.int">int</span> replacement_char, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Splits each string in `input` into a sequence of Unicode code points. <p></p> `result[i1...iN, j]` is the substring of `input[i1...iN]` that encodes its
`j`th character, when decoded using `input_encoding`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> input
						</dt>
						<dd>An `N` dimensional potentially ragged `string` tensor with shape
`[D1...DN]`.  `N` must be statically known. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> input_encoding
						</dt>
						<dd>String name for the unicode encoding that should be used to
decode each string. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> errors
						</dt>
						<dd>Specifies the response when an input string can't be converted
using the indicated encoding. One of:
* `'strict'`: Raise an exception for any illegal substrings.
* `'replace'`: Replace illegal substrings with `replacement_char`.
* `'ignore'`: Skip illegal substrings. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> replacement_char
						</dt>
						<dd>The replacement codepoint to be used in place of invalid
substrings in `input` when `errors='replace'`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `N+1` dimensional `int32` tensor with shape `[D1...DN, (num_chars)]`.
The returned tensor is a <a href="..\..\tf\Tensor.md"><code>tf.Tensor</code></a> if `input` is a scalar, or a
<a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a> otherwise. <p></p> #### Example:
```python
>>> input = [s.encode('utf8') for s in (u'G\xf6\xf6dnight', u'\U0001f60a')]
>>> tf.strings.unicode_split(input, 'UTF-8').tolist()
[['G', '\xc3\xb6', '\xc3\xb6', 'd', 'n', 'i', 'g', 'h', 't'],
['\xf0\x9f\x98\x8a']]
``` 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="unicode_split_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>unicode_split_dyn</strong>(<span title="System.object">object</span> input, <span title="System.object">object</span> input_encoding, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> errors, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> replacement_char, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Splits each string in `input` into a sequence of Unicode code points. <p></p> `result[i1...iN, j]` is the substring of `input[i1...iN]` that encodes its
`j`th character, when decoded using `input_encoding`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> input
						</dt>
						<dd>An `N` dimensional potentially ragged `string` tensor with shape
`[D1...DN]`.  `N` must be statically known. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> input_encoding
						</dt>
						<dd>String name for the unicode encoding that should be used to
decode each string. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> errors
						</dt>
						<dd>Specifies the response when an input string can't be converted
using the indicated encoding. One of:
* `'strict'`: Raise an exception for any illegal substrings.
* `'replace'`: Replace illegal substrings with `replacement_char`.
* `'ignore'`: Skip illegal substrings. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> replacement_char
						</dt>
						<dd>The replacement codepoint to be used in place of invalid
substrings in `input` when `errors='replace'`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `N+1` dimensional `int32` tensor with shape `[D1...DN, (num_chars)]`.
The returned tensor is a <a href="..\..\tf\Tensor.md"><code>tf.Tensor</code></a> if `input` is a scalar, or a
<a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a> otherwise. <p></p> #### Example:
```python
>>> input = [s.encode('utf8') for s in (u'G\xf6\xf6dnight', u'\U0001f60a')]
>>> tf.strings.unicode_split(input, 'UTF-8').tolist()
[['G', '\xc3\xb6', '\xc3\xb6', 'd', 'n', 'i', 'g', 'h', 't'],
['\xf0\x9f\x98\x8a']]
``` 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="unicode_split_with_offsets" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>unicode_split_with_offsets</strong>(<span title="System.Collections.Generic.IEnumerable<Byte[]>">IEnumerable&lt;Byte[]&gt;</span> input, <span title="System.string">string</span> input_encoding, <span title="System.string">string</span> errors, <span title="System.int">int</span> replacement_char, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Splits each string into a sequence of code points with start offsets. <p></p> This op is similar to `tf.strings.decode(...)`, but it also returns the
start offset for each character in its respective string.  This information
can be used to align the characters with the original byte sequence. <p></p> Returns a tuple `(chars, start_offsets)` where: <p></p> * `chars[i1...iN, j]` is the substring of `input[i1...iN]` that encodes its
`j`th character, when decoded using `input_encoding`.
* `start_offsets[i1...iN, j]` is the start byte offset for the `j`th
character in `input[i1...iN]`, when decoded using `input_encoding`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<Byte[]>">IEnumerable&lt;Byte[]&gt;</span></code> input
						</dt>
						<dd>An `N` dimensional potentially ragged `string` tensor with shape
`[D1...DN]`.  `N` must be statically known. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> input_encoding
						</dt>
						<dd>String name for the unicode encoding that should be used to
decode each string. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> errors
						</dt>
						<dd>Specifies the response when an input string can't be converted
using the indicated encoding. One of:
* `'strict'`: Raise an exception for any illegal substrings.
* `'replace'`: Replace illegal substrings with `replacement_char`.
* `'ignore'`: Skip illegal substrings. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> replacement_char
						</dt>
						<dd>The replacement codepoint to be used in place of invalid
substrings in `input` when `errors='replace'`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd>A tuple of `N+1` dimensional tensors `(codepoints, start_offsets)`. <p></p> * `codepoints` is an `int32` tensor with shape `[D1...DN, (num_chars)]`.
* `offsets` is an `int64` tensor with shape `[D1...DN, (num_chars)]`. <p></p> The returned tensors are <a href="..\..\tf\Tensor.md"><code>tf.Tensor</code></a>s if `input` is a scalar, or
<a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a>s otherwise. <p></p> #### Example:
```python
>>> input = [s.encode('utf8') for s in (u'G\xf6\xf6dnight', u'\U0001f60a')]
>>> result = tf.strings.unicode_split_with_offsets(input, 'UTF-8')
>>> result[0].tolist()  # character substrings
[['G', '\xc3\xb6', '\xc3\xb6', 'd', 'n', 'i', 'g', 'h', 't'],
['\xf0\x9f\x98\x8a']]
>>> result[1].tolist()  # offsets
[[0, 1, 3, 5, 6, 7, 8, 9, 10], [0]]
``` 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="unicode_split_with_offsets" class="method">
		<h4>
			<span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span> <strong>unicode_split_with_offsets</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> input, <span title="System.string">string</span> input_encoding, <span title="System.string">string</span> errors, <span title="System.int">int</span> replacement_char, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Splits each string into a sequence of code points with start offsets. <p></p> This op is similar to `tf.strings.decode(...)`, but it also returns the
start offset for each character in its respective string.  This information
can be used to align the characters with the original byte sequence. <p></p> Returns a tuple `(chars, start_offsets)` where: <p></p> * `chars[i1...iN, j]` is the substring of `input[i1...iN]` that encodes its
`j`th character, when decoded using `input_encoding`.
* `start_offsets[i1...iN, j]` is the start byte offset for the `j`th
character in `input[i1...iN]`, when decoded using `input_encoding`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> input
						</dt>
						<dd>An `N` dimensional potentially ragged `string` tensor with shape
`[D1...DN]`.  `N` must be statically known. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> input_encoding
						</dt>
						<dd>String name for the unicode encoding that should be used to
decode each string. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> errors
						</dt>
						<dd>Specifies the response when an input string can't be converted
using the indicated encoding. One of:
* `'strict'`: Raise an exception for any illegal substrings.
* `'replace'`: Replace illegal substrings with `replacement_char`.
* `'ignore'`: Skip illegal substrings. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> replacement_char
						</dt>
						<dd>The replacement codepoint to be used in place of invalid
substrings in `input` when `errors='replace'`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object, object>">ValueTuple&lt;object, object&gt;</span></code>
					</dt>
					<dd>A tuple of `N+1` dimensional tensors `(codepoints, start_offsets)`. <p></p> * `codepoints` is an `int32` tensor with shape `[D1...DN, (num_chars)]`.
* `offsets` is an `int64` tensor with shape `[D1...DN, (num_chars)]`. <p></p> The returned tensors are <a href="..\..\tf\Tensor.md"><code>tf.Tensor</code></a>s if `input` is a scalar, or
<a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a>s otherwise. <p></p> #### Example:
```python
>>> input = [s.encode('utf8') for s in (u'G\xf6\xf6dnight', u'\U0001f60a')]
>>> result = tf.strings.unicode_split_with_offsets(input, 'UTF-8')
>>> result[0].tolist()  # character substrings
[['G', '\xc3\xb6', '\xc3\xb6', 'd', 'n', 'i', 'g', 'h', 't'],
['\xf0\x9f\x98\x8a']]
>>> result[1].tolist()  # offsets
[[0, 1, 3, 5, 6, 7, 8, 9, 10], [0]]
``` 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="unicode_split_with_offsets_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>unicode_split_with_offsets_dyn</strong>(<span title="System.object">object</span> input, <span title="System.object">object</span> input_encoding, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> errors, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> replacement_char, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Splits each string into a sequence of code points with start offsets. <p></p> This op is similar to `tf.strings.decode(...)`, but it also returns the
start offset for each character in its respective string.  This information
can be used to align the characters with the original byte sequence. <p></p> Returns a tuple `(chars, start_offsets)` where: <p></p> * `chars[i1...iN, j]` is the substring of `input[i1...iN]` that encodes its
`j`th character, when decoded using `input_encoding`.
* `start_offsets[i1...iN, j]` is the start byte offset for the `j`th
character in `input[i1...iN]`, when decoded using `input_encoding`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> input
						</dt>
						<dd>An `N` dimensional potentially ragged `string` tensor with shape
`[D1...DN]`.  `N` must be statically known. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> input_encoding
						</dt>
						<dd>String name for the unicode encoding that should be used to
decode each string. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> errors
						</dt>
						<dd>Specifies the response when an input string can't be converted
using the indicated encoding. One of:
* `'strict'`: Raise an exception for any illegal substrings.
* `'replace'`: Replace illegal substrings with `replacement_char`.
* `'ignore'`: Skip illegal substrings. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> replacement_char
						</dt>
						<dd>The replacement codepoint to be used in place of invalid
substrings in `input` when `errors='replace'`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A tuple of `N+1` dimensional tensors `(codepoints, start_offsets)`. <p></p> * `codepoints` is an `int32` tensor with shape `[D1...DN, (num_chars)]`.
* `offsets` is an `int64` tensor with shape `[D1...DN, (num_chars)]`. <p></p> The returned tensors are <a href="..\..\tf\Tensor.md"><code>tf.Tensor</code></a>s if `input` is a scalar, or
<a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a>s otherwise. <p></p> #### Example:
```python
>>> input = [s.encode('utf8') for s in (u'G\xf6\xf6dnight', u'\U0001f60a')]
>>> result = tf.strings.unicode_split_with_offsets(input, 'UTF-8')
>>> result[0].tolist()  # character substrings
[['G', '\xc3\xb6', '\xc3\xb6', 'd', 'n', 'i', 'g', 'h', 't'],
['\xf0\x9f\x98\x8a']]
>>> result[1].tolist()  # offsets
[[0, 1, 3, 5, 6, 7, 8, 9, 10], [0]]
``` 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="unicode_transcode" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>unicode_transcode</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> input, <span title="System.string">string</span> input_encoding, <span title="System.string">string</span> output_encoding, <span title="System.string">string</span> errors, <span title="System.int">int</span> replacement_char, <span title="System.bool">bool</span> replace_control_characters, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Transcode the input text from a source encoding to a destination encoding. <p></p> The input is a string tensor of any shape. The output is a string tensor of
the same shape containing the transcoded strings. Output strings are always
valid unicode. If the input contains invalid encoding positions, the
`errors` attribute sets the policy for how to deal with them. If the default
error-handling policy is used, invalid formatting will be substituted in the
output by the `replacement_char`. If the errors policy is to `ignore`, any
invalid encoding positions in the input are skipped and not included in the
output. If it set to `strict` then any invalid formatting will result in an
InvalidArgument error. <p></p> This operation can be used with `output_encoding = input_encoding` to enforce
correct formatting for inputs even if they are already in the desired encoding. <p></p> If the input is prefixed by a Byte Order Mark needed to determine encoding
(e.g. if the encoding is UTF-16 and the BOM indicates big-endian), then that
BOM will be consumed and not emitted into the output. If the input encoding
is marked with an explicit endianness (e.g. UTF-16-BE), then the BOM is
interpreted as a non-breaking-space and is preserved in the output (including
always for UTF-8). <p></p> The end result is that if the input is marked as an explicit endianness the
transcoding is faithful to all codepoints in the source. If it is not marked
with an explicit endianness, the BOM is not considered part of the string itself
but as metadata, and so is not preserved in the output. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> input
						</dt>
						<dd>A `Tensor` of type `string`.
The text to be processed. Can have any shape. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> input_encoding
						</dt>
						<dd>A `string`.
Text encoding of the input strings. This is any of the encodings supported
by ICU ucnv algorithmic converters. Examples: `"UTF-16", "US ASCII", "UTF-8"`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> output_encoding
						</dt>
						<dd>A `string` from: `"UTF-8", "UTF-16-BE", "UTF-32-BE"`.
The unicode encoding to use in the output. Must be one of
`"UTF-8", "UTF-16-BE", "UTF-32-BE"`. Multi-byte encodings will be big-endian. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> errors
						</dt>
						<dd>An optional `string` from: `"strict", "replace", "ignore"`. Defaults to `"replace"`.
Error handling policy when there is invalid formatting found in the input.
The value of 'strict' will cause the operation to produce a InvalidArgument
error on any invalid input formatting. A value of 'replace' (the default) will
cause the operation to replace any invalid formatting in the input with the
`replacement_char` codepoint. A value of 'ignore' will cause the operation to
skip any invalid formatting in the input and produce no corresponding output
character. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> replacement_char
						</dt>
						<dd>An optional `int`. Defaults to `65533`.
The replacement character codepoint to be used in place of any invalid
formatting in the input when `errors='replace'`. Any valid unicode codepoint may
be used. The default value is the default unicode replacement character is
0xFFFD or U+65533.) <p></p> Note that for UTF-8, passing a replacement character expressible in 1 byte, such
as ' ', will preserve string alignment to the source since invalid bytes will be
replaced with a 1-byte replacement. For UTF-16-BE and UTF-16-LE, any 1 or 2 byte
replacement character will preserve byte alignment to the source. 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> replace_control_characters
						</dt>
						<dd>An optional `bool`. Defaults to `False`.
Whether to replace the C0 control characters (00-1F) with the
`replacement_char`. Default is false. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of type `string`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="unicode_transcode_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>unicode_transcode_dyn</strong>(<span title="System.object">object</span> input, <span title="System.object">object</span> input_encoding, <span title="System.object">object</span> output_encoding, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> errors, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> replacement_char, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> replace_control_characters, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Transcode the input text from a source encoding to a destination encoding. <p></p> The input is a string tensor of any shape. The output is a string tensor of
the same shape containing the transcoded strings. Output strings are always
valid unicode. If the input contains invalid encoding positions, the
`errors` attribute sets the policy for how to deal with them. If the default
error-handling policy is used, invalid formatting will be substituted in the
output by the `replacement_char`. If the errors policy is to `ignore`, any
invalid encoding positions in the input are skipped and not included in the
output. If it set to `strict` then any invalid formatting will result in an
InvalidArgument error. <p></p> This operation can be used with `output_encoding = input_encoding` to enforce
correct formatting for inputs even if they are already in the desired encoding. <p></p> If the input is prefixed by a Byte Order Mark needed to determine encoding
(e.g. if the encoding is UTF-16 and the BOM indicates big-endian), then that
BOM will be consumed and not emitted into the output. If the input encoding
is marked with an explicit endianness (e.g. UTF-16-BE), then the BOM is
interpreted as a non-breaking-space and is preserved in the output (including
always for UTF-8). <p></p> The end result is that if the input is marked as an explicit endianness the
transcoding is faithful to all codepoints in the source. If it is not marked
with an explicit endianness, the BOM is not considered part of the string itself
but as metadata, and so is not preserved in the output. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> input
						</dt>
						<dd>A `Tensor` of type `string`.
The text to be processed. Can have any shape. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> input_encoding
						</dt>
						<dd>A `string`.
Text encoding of the input strings. This is any of the encodings supported
by ICU ucnv algorithmic converters. Examples: `"UTF-16", "US ASCII", "UTF-8"`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> output_encoding
						</dt>
						<dd>A `string` from: `"UTF-8", "UTF-16-BE", "UTF-32-BE"`.
The unicode encoding to use in the output. Must be one of
`"UTF-8", "UTF-16-BE", "UTF-32-BE"`. Multi-byte encodings will be big-endian. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> errors
						</dt>
						<dd>An optional `string` from: `"strict", "replace", "ignore"`. Defaults to `"replace"`.
Error handling policy when there is invalid formatting found in the input.
The value of 'strict' will cause the operation to produce a InvalidArgument
error on any invalid input formatting. A value of 'replace' (the default) will
cause the operation to replace any invalid formatting in the input with the
`replacement_char` codepoint. A value of 'ignore' will cause the operation to
skip any invalid formatting in the input and produce no corresponding output
character. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> replacement_char
						</dt>
						<dd>An optional `int`. Defaults to `65533`.
The replacement character codepoint to be used in place of any invalid
formatting in the input when `errors='replace'`. Any valid unicode codepoint may
be used. The default value is the default unicode replacement character is
0xFFFD or U+65533.) <p></p> Note that for UTF-8, passing a replacement character expressible in 1 byte, such
as ' ', will preserve string alignment to the source since invalid bytes will be
replaced with a 1-byte replacement. For UTF-16-BE and UTF-16-LE, any 1 or 2 byte
replacement character will preserve byte alignment to the source. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> replace_control_characters
						</dt>
						<dd>An optional `bool`. Defaults to `False`.
Whether to replace the C0 control characters (00-1F) with the
`replacement_char`. Default is false. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `Tensor` of type `string`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="unsorted_segment_join" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>unsorted_segment_join</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> inputs, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> segment_ids, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> num_segments, <span title="System.string">string</span> separator, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Joins the elements of `inputs` based on `segment_ids`. <p></p> Computes the string join along segments of a tensor.
Given `segment_ids` with rank `N` and `data` with rank `N+M`: <p></p> `output[i, k1...kM] = strings.join([data[j1...jN, k1...kM])` <p></p> where the join is over all [j1...jN] such that segment_ids[j1...jN] = i.
Strings are joined in row-major order. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> inputs
						</dt>
						<dd>A `Tensor` of type `string`. The input to be joined. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> segment_ids
						</dt>
						<dd>A `Tensor`. Must be one of the following types: `int32`, `int64`.
A tensor whose shape is a prefix of data.shape.  Negative segment ids are not
supported. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> num_segments
						</dt>
						<dd>A `Tensor`. Must be one of the following types: `int32`, `int64`.
A scalar. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> separator
						</dt>
						<dd>An optional `string`. Defaults to `""`.
The separator to use when joining. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of type `string`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>inputs = [['Y', 'q', 'c'], ['Y', '6', '6'], ['p', 'G', 'a']]
            output_array = string_ops.unsorted_segment_join(inputs=inputs,
                                                            segment_ids=[1, 0, 1],
                                                            num_segments=2,
                                                            separator=':'))
            # output_array ==> [['Y', '6', '6'], ['Y:p', 'q:G', 'c:a']] <p></p> <p></p> inputs = ['this', 'is', 'a', 'test']
output_array = string_ops.unsorted_segment_join(inputs=inputs,
                                                segment_ids=[0, 0, 0, 0],
                                                num_segments=1,
                                                separator=':'))
# output_array ==> ['this:is:a:test'] </pre>
</div>
		</div>
	</div>
	<div id="unsorted_segment_join_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>unsorted_segment_join_dyn</strong>(<span title="System.object">object</span> inputs, <span title="System.object">object</span> segment_ids, <span title="System.object">object</span> num_segments, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> separator, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Joins the elements of `inputs` based on `segment_ids`. <p></p> Computes the string join along segments of a tensor.
Given `segment_ids` with rank `N` and `data` with rank `N+M`: <p></p> `output[i, k1...kM] = strings.join([data[j1...jN, k1...kM])` <p></p> where the join is over all [j1...jN] such that segment_ids[j1...jN] = i.
Strings are joined in row-major order. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> inputs
						</dt>
						<dd>A `Tensor` of type `string`. The input to be joined. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> segment_ids
						</dt>
						<dd>A `Tensor`. Must be one of the following types: `int32`, `int64`.
A tensor whose shape is a prefix of data.shape.  Negative segment ids are not
supported. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> num_segments
						</dt>
						<dd>A `Tensor`. Must be one of the following types: `int32`, `int64`.
A scalar. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> separator
						</dt>
						<dd>An optional `string`. Defaults to `""`.
The separator to use when joining. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `Tensor` of type `string`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>inputs = [['Y', 'q', 'c'], ['Y', '6', '6'], ['p', 'G', 'a']]
            output_array = string_ops.unsorted_segment_join(inputs=inputs,
                                                            segment_ids=[1, 0, 1],
                                                            num_segments=2,
                                                            separator=':'))
            # output_array ==> [['Y', '6', '6'], ['Y:p', 'q:G', 'c:a']] <p></p> <p></p> inputs = ['this', 'is', 'a', 'test']
output_array = string_ops.unsorted_segment_join(inputs=inputs,
                                                segment_ids=[0, 0, 0, 0],
                                                num_segments=1,
                                                separator=':'))
# output_array ==> ['this:is:a:test'] </pre>
</div>
		</div>
	</div>
	<div id="upper" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>upper</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> input, <span title="System.string">string</span> encoding, <span title="System.string">string</span> name)
		</h4>
		<div class="content">TODO: add doc. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> input
						</dt>
						<dd>A `Tensor` of type `string`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> encoding
						</dt>
						<dd>An optional `string`. Defaults to `""`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` of type `string`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="upper_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>upper_dyn</strong>(<span title="System.object">object</span> input, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> encoding, <span title="System.object">object</span> name)
		</h4>
		<div class="content">TODO: add doc. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> input
						</dt>
						<dd>A `Tensor` of type `string`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> encoding
						</dt>
						<dd>An optional `string`. Defaults to `""`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `Tensor` of type `string`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	
	<h3 class="section">Public properties</h3>

	<div id="bytes_split_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>bytes_split_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="format_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>format_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="length_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>length_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="lower_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>lower_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="ngrams_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>ngrams_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="regex_full_match_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>regex_full_match_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="split_fn_" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>split_fn_</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="substr_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>substr_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="unicode_decode_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>unicode_decode_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="unicode_decode_with_offsets_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>unicode_decode_with_offsets_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="unicode_encode_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>unicode_encode_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="unicode_script_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>unicode_script_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="unicode_split_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>unicode_split_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="unicode_split_with_offsets_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>unicode_split_with_offsets_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="unicode_transcode_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>unicode_transcode_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="unsorted_segment_join_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>unsorted_segment_join_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="upper_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>upper_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	</section>
	</article><footer>
	<span id="version">Built from v1.15.0.0 of LostTech.TensorFlow</span>
	<span id="docu-link">
		Generated by <a href="http://docu.jagregory.com">docu</a>
	</span>
</footer>
  </body>
</html>