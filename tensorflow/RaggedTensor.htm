<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
	<!--[if lt IE 9]>
	<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
    <title>RaggedTensor - LostTech.TensorFlow Documentation</title>
    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"/>
    <link type="text/css" rel="stylesheet" href="../main.css"/>
    <script type="text/javascript" src="../js/jquery-1.3.2.min.js"></script>
    <script type="text/javascript" src="../js/jquery.scrollTo-min.js"></script>
    <script type="text/javascript" src="../js/navigation.js"></script>
    <script type="text/javascript" src="../js/example.js"></script>
  </head>
  <body>
  	<header><h1>LostTech.TensorFlow : API Documentation</h1>
	</header>

    <nav id="namespaces">
      <iframe src="../namespaces.htm"></iframe>
    </nav><nav id="types">
  <h2 class="fixed">Types in tensorflow</h2>
	<div class="scroll">
		<ul>
				<li>
            <a href="../tensorflow/AggregationMethod.htm">AggregationMethod</a>
        </li>
				<li>
            <a href="../tensorflow/ConditionalAccumulator.htm">ConditionalAccumulator</a>
        </li>
				<li>
            <a href="../tensorflow/ConditionalAccumulatorBase.htm">ConditionalAccumulatorBase</a>
        </li>
				<li>
            <a href="../tensorflow/constant_initializer.htm">constant_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/CriticalSection.htm">CriticalSection</a>
        </li>
				<li>
            <a href="../tensorflow/DeviceSpec.htm">DeviceSpec</a>
        </li>
				<li>
            <a href="../tensorflow/Dimension.htm">Dimension</a>
        </li>
				<li>
            <a href="../tensorflow/DType.htm">DType</a>
        </li>
				<li>
            <a href="../tensorflow/FIFOQueue.htm">FIFOQueue</a>
        </li>
				<li>
            <a href="../tensorflow/FixedLenFeature.htm">FixedLenFeature</a>
        </li>
				<li>
            <a href="../tensorflow/FixedLengthRecordReader.htm">FixedLengthRecordReader</a>
        </li>
				<li>
            <a href="../tensorflow/FixedLenSequenceFeature.htm">FixedLenSequenceFeature</a>
        </li>
				<li>
            <a href="../tensorflow/glorot_normal_initializer.htm">glorot_normal_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/glorot_uniform_initializer.htm">glorot_uniform_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/GradientTape.htm">GradientTape</a>
        </li>
				<li>
            <a href="../tensorflow/Graph.htm">Graph</a>
        </li>
				<li>
            <a href="../tensorflow/Graph._ControlDependenciesController.htm">Graph._ControlDependenciesController</a>
        </li>
				<li>
            <a href="../tensorflow/Graph.I_ControlDependenciesController.htm">Graph.I_ControlDependenciesController</a>
        </li>
				<li>
            <a href="../tensorflow/GraphKeys.htm">GraphKeys</a>
        </li>
				<li>
            <a href="../tensorflow/HeadingAxes.htm">HeadingAxes</a>
        </li>
				<li>
            <a href="../tensorflow/IAggregationMethod.htm">IAggregationMethod</a>
        </li>
				<li>
            <a href="../tensorflow/IConditionalAccumulator.htm">IConditionalAccumulator</a>
        </li>
				<li>
            <a href="../tensorflow/IConditionalAccumulatorBase.htm">IConditionalAccumulatorBase</a>
        </li>
				<li>
            <a href="../tensorflow/Iconstant_initializer.htm">Iconstant_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/ICriticalSection.htm">ICriticalSection</a>
        </li>
				<li>
            <a href="../tensorflow/IdentityReader.htm">IdentityReader</a>
        </li>
				<li>
            <a href="../tensorflow/IDeviceSpec.htm">IDeviceSpec</a>
        </li>
				<li>
            <a href="../tensorflow/IDimension.htm">IDimension</a>
        </li>
				<li>
            <a href="../tensorflow/IDType.htm">IDType</a>
        </li>
				<li>
            <a href="../tensorflow/IFIFOQueue.htm">IFIFOQueue</a>
        </li>
				<li>
            <a href="../tensorflow/IFixedLenFeature.htm">IFixedLenFeature</a>
        </li>
				<li>
            <a href="../tensorflow/IFixedLengthRecordReader.htm">IFixedLengthRecordReader</a>
        </li>
				<li>
            <a href="../tensorflow/IFixedLenSequenceFeature.htm">IFixedLenSequenceFeature</a>
        </li>
				<li>
            <a href="../tensorflow/Iglorot_normal_initializer.htm">Iglorot_normal_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/Iglorot_uniform_initializer.htm">Iglorot_uniform_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/IGradientTape.htm">IGradientTape</a>
        </li>
				<li>
            <a href="../tensorflow/IGraph.htm">IGraph</a>
        </li>
				<li>
            <a href="../tensorflow/IGraphKeys.htm">IGraphKeys</a>
        </li>
				<li>
            <a href="../tensorflow/IIdentityReader.htm">IIdentityReader</a>
        </li>
				<li>
            <a href="../tensorflow/IIndexedSlices.htm">IIndexedSlices</a>
        </li>
				<li>
            <a href="../tensorflow/IIndexedSlicesSpec.htm">IIndexedSlicesSpec</a>
        </li>
				<li>
            <a href="../tensorflow/IInteractiveSession.htm">IInteractiveSession</a>
        </li>
				<li>
            <a href="../tensorflow/ILazyLoader.htm">ILazyLoader</a>
        </li>
				<li>
            <a href="../tensorflow/ILMDBReader.htm">ILMDBReader</a>
        </li>
				<li>
            <a href="../tensorflow/IModule.htm">IModule</a>
        </li>
				<li>
            <a href="../tensorflow/Iname_scope.htm">Iname_scope</a>
        </li>
				<li>
            <a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a>
        </li>
				<li>
            <a href="../tensorflow/IndexedSlicesSpec.htm">IndexedSlicesSpec</a>
        </li>
				<li>
            <a href="../tensorflow/InteractiveSession.htm">InteractiveSession</a>
        </li>
				<li>
            <a href="../tensorflow/Iones_initializer.htm">Iones_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/IOperation.htm">IOperation</a>
        </li>
				<li>
            <a href="../tensorflow/IOpError.htm">IOpError</a>
        </li>
				<li>
            <a href="../tensorflow/IOptionalSpec.htm">IOptionalSpec</a>
        </li>
				<li>
            <a href="../tensorflow/Iorthogonal_initializer.htm">Iorthogonal_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/IPaddingFIFOQueue.htm">IPaddingFIFOQueue</a>
        </li>
				<li>
            <a href="../tensorflow/IPriorityQueue.htm">IPriorityQueue</a>
        </li>
				<li>
            <a href="../tensorflow/IQueueBase.htm">IQueueBase</a>
        </li>
				<li>
            <a href="../tensorflow/IRaggedTensor.htm">IRaggedTensor</a>
        </li>
				<li>
            <a href="../tensorflow/IRaggedTensorSpec.htm">IRaggedTensorSpec</a>
        </li>
				<li>
            <a href="../tensorflow/Irandom_normal_initializer.htm">Irandom_normal_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/Irandom_uniform_initializer.htm">Irandom_uniform_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/IRandomShuffleQueue.htm">IRandomShuffleQueue</a>
        </li>
				<li>
            <a href="../tensorflow/IReaderBase.htm">IReaderBase</a>
        </li>
				<li>
            <a href="../tensorflow/IRegisterGradient.htm">IRegisterGradient</a>
        </li>
				<li>
            <a href="../tensorflow/ISession.htm">ISession</a>
        </li>
				<li>
            <a href="../tensorflow/ISparseConditionalAccumulator.htm">ISparseConditionalAccumulator</a>
        </li>
				<li>
            <a href="../tensorflow/ISparseFeature.htm">ISparseFeature</a>
        </li>
				<li>
            <a href="../tensorflow/ISparseTensor.htm">ISparseTensor</a>
        </li>
				<li>
            <a href="../tensorflow/ISparseTensorSpec.htm">ISparseTensorSpec</a>
        </li>
				<li>
            <a href="../tensorflow/ISparseTensorValue.htm">ISparseTensorValue</a>
        </li>
				<li>
            <a href="../tensorflow/ITensor.htm">ITensor</a>
        </li>
				<li>
            <a href="../tensorflow/ITensorArray.htm">ITensorArray</a>
        </li>
				<li>
            <a href="../tensorflow/ITensorArraySpec.htm">ITensorArraySpec</a>
        </li>
				<li>
            <a href="../tensorflow/ITensorShape.htm">ITensorShape</a>
        </li>
				<li>
            <a href="../tensorflow/ITensorSpec.htm">ITensorSpec</a>
        </li>
				<li>
            <a href="../tensorflow/ITextLineReader.htm">ITextLineReader</a>
        </li>
				<li>
            <a href="../tensorflow/ITFRecordReader.htm">ITFRecordReader</a>
        </li>
				<li>
            <a href="../tensorflow/Itruncated_normal_initializer.htm">Itruncated_normal_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/ITypeSpec.htm">ITypeSpec</a>
        </li>
				<li>
            <a href="../tensorflow/IUnconnectedGradients.htm">IUnconnectedGradients</a>
        </li>
				<li>
            <a href="../tensorflow/Iuniform_unit_scaling_initializer.htm">Iuniform_unit_scaling_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/IVariable.htm">IVariable</a>
        </li>
				<li>
            <a href="../tensorflow/Ivariable_scope.htm">Ivariable_scope</a>
        </li>
				<li>
            <a href="../tensorflow/IVariableScope.htm">IVariableScope</a>
        </li>
				<li>
            <a href="../tensorflow/Ivariance_scaling_initializer.htm">Ivariance_scaling_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/IVarLenFeature.htm">IVarLenFeature</a>
        </li>
				<li>
            <a href="../tensorflow/IWholeFileReader.htm">IWholeFileReader</a>
        </li>
				<li>
            <a href="../tensorflow/Izeros_initializer.htm">Izeros_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/LazyLoader.htm">LazyLoader</a>
        </li>
				<li>
            <a href="../tensorflow/LMDBReader.htm">LMDBReader</a>
        </li>
				<li>
            <a href="../tensorflow/Module.htm">Module</a>
        </li>
				<li>
            <a href="../tensorflow/name_scope.htm">name_scope</a>
        </li>
				<li>
            <a href="../tensorflow/ones_initializer.htm">ones_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/Operation.htm">Operation</a>
        </li>
				<li>
            <a href="../tensorflow/Operation._InputList.htm">Operation._InputList</a>
        </li>
				<li>
            <a href="../tensorflow/Operation.I_InputList.htm">Operation.I_InputList</a>
        </li>
				<li>
            <a href="../tensorflow/OpError.htm">OpError</a>
        </li>
				<li>
            <a href="../tensorflow/OptionalSpec.htm">OptionalSpec</a>
        </li>
				<li>
            <a href="../tensorflow/orthogonal_initializer.htm">orthogonal_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/PaddingFIFOQueue.htm">PaddingFIFOQueue</a>
        </li>
				<li>
            <a href="../tensorflow/PriorityQueue.htm">PriorityQueue</a>
        </li>
				<li>
            <a href="../tensorflow/QueueBase.htm">QueueBase</a>
        </li>
				<li>
            <a href="../tensorflow/RaggedTensor.htm" class="current">RaggedTensor</a>
        </li>
				<li>
            <a href="../tensorflow/RaggedTensorSpec.htm">RaggedTensorSpec</a>
        </li>
				<li>
            <a href="../tensorflow/random_normal_initializer.htm">random_normal_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/random_uniform_initializer.htm">random_uniform_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/RandomShuffleQueue.htm">RandomShuffleQueue</a>
        </li>
				<li>
            <a href="../tensorflow/ReaderBase.htm">ReaderBase</a>
        </li>
				<li>
            <a href="../tensorflow/RegisterGradient.htm">RegisterGradient</a>
        </li>
				<li>
            <a href="../tensorflow/Session.htm">Session</a>
        </li>
				<li>
            <a href="../tensorflow/SparseConditionalAccumulator.htm">SparseConditionalAccumulator</a>
        </li>
				<li>
            <a href="../tensorflow/SparseFeature.htm">SparseFeature</a>
        </li>
				<li>
            <a href="../tensorflow/SparseTensor.htm">SparseTensor</a>
        </li>
				<li>
            <a href="../tensorflow/SparseTensorSpec.htm">SparseTensorSpec</a>
        </li>
				<li>
            <a href="../tensorflow/SparseTensorValue.htm">SparseTensorValue</a>
        </li>
				<li>
            <a href="../tensorflow/Tensor.htm">Tensor</a>
        </li>
				<li>
            <a href="../tensorflow/Tensor`1.htm">Tensor&lt;T&gt;</a>
        </li>
				<li>
            <a href="../tensorflow/TensorArray.htm">TensorArray</a>
        </li>
				<li>
            <a href="../tensorflow/TensorArraySpec.htm">TensorArraySpec</a>
        </li>
				<li>
            <a href="../tensorflow/TensorDimension.htm">TensorDimension</a>
        </li>
				<li>
            <a href="../tensorflow/TensorDimensionSlice.htm">TensorDimensionSlice</a>
        </li>
				<li>
            <a href="../tensorflow/TensorShape.htm">TensorShape</a>
        </li>
				<li>
            <a href="../tensorflow/TensorSpec.htm">TensorSpec</a>
        </li>
				<li>
            <a href="../tensorflow/TextLineReader.htm">TextLineReader</a>
        </li>
				<li>
            <a href="../tensorflow/tf.htm">tf</a>
        </li>
				<li>
            <a href="../tensorflow/tf.audio.htm">tf.audio</a>
        </li>
				<li>
            <a href="../tensorflow/tf.autograph.htm">tf.autograph</a>
        </li>
				<li>
            <a href="../tensorflow/tf.autograph.experimental.htm">tf.autograph.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.bitwise.htm">tf.bitwise</a>
        </li>
				<li>
            <a href="../tensorflow/tf.compat.htm">tf.compat</a>
        </li>
				<li>
            <a href="../tensorflow/tf.config.htm">tf.config</a>
        </li>
				<li>
            <a href="../tensorflow/tf.config.experimental.htm">tf.config.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.config.optimizer.htm">tf.config.optimizer</a>
        </li>
				<li>
            <a href="../tensorflow/tf.config.threading.htm">tf.config.threading</a>
        </li>
				<li>
            <a href="../tensorflow/tf.data.htm">tf.data</a>
        </li>
				<li>
            <a href="../tensorflow/tf.data.experimental.htm">tf.data.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.debugging.htm">tf.debugging</a>
        </li>
				<li>
            <a href="../tensorflow/tf.distribute.htm">tf.distribute</a>
        </li>
				<li>
            <a href="../tensorflow/tf.distributions.htm">tf.distributions</a>
        </li>
				<li>
            <a href="../tensorflow/tf.errors.htm">tf.errors</a>
        </li>
				<li>
            <a href="../tensorflow/tf.estimator.htm">tf.estimator</a>
        </li>
				<li>
            <a href="../tensorflow/tf.estimator.experimental.htm">tf.estimator.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.estimator.export.htm">tf.estimator.export</a>
        </li>
				<li>
            <a href="../tensorflow/tf.estimator.inputs.htm">tf.estimator.inputs</a>
        </li>
				<li>
            <a href="../tensorflow/tf.experimental.htm">tf.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.feature_column.htm">tf.feature_column</a>
        </li>
				<li>
            <a href="../tensorflow/tf.gfile.htm">tf.gfile</a>
        </li>
				<li>
            <a href="../tensorflow/tf.graph_util.htm">tf.graph_util</a>
        </li>
				<li>
            <a href="../tensorflow/tf.image.htm">tf.image</a>
        </li>
				<li>
            <a href="../tensorflow/tf.initializers.htm">tf.initializers</a>
        </li>
				<li>
            <a href="../tensorflow/tf.io.htm">tf.io</a>
        </li>
				<li>
            <a href="../tensorflow/tf.io.gfile.htm">tf.io.gfile</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.htm">tf.keras</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.activations.htm">tf.keras.activations</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.htm">tf.keras.applications</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.densenet.htm">tf.keras.applications.densenet</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.imagenet_utils.htm">tf.keras.applications.imagenet_utils</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.inception_resnet_v2.htm">tf.keras.applications.inception_resnet_v2</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.inception_v3.htm">tf.keras.applications.inception_v3</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.mobilenet.htm">tf.keras.applications.mobilenet</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.mobilenet_v2.htm">tf.keras.applications.mobilenet_v2</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.nasnet.htm">tf.keras.applications.nasnet</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.resnet.htm">tf.keras.applications.resnet</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.resnet_v2.htm">tf.keras.applications.resnet_v2</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.vgg16.htm">tf.keras.applications.vgg16</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.vgg19.htm">tf.keras.applications.vgg19</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.xception.htm">tf.keras.applications.xception</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.backend.htm">tf.keras.backend</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.constraints.htm">tf.keras.constraints</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.datasets.htm">tf.keras.datasets</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.datasets.boston_housing.htm">tf.keras.datasets.boston_housing</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.datasets.cifar10.htm">tf.keras.datasets.cifar10</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.datasets.cifar100.htm">tf.keras.datasets.cifar100</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.datasets.fashion_mnist.htm">tf.keras.datasets.fashion_mnist</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.datasets.imdb.htm">tf.keras.datasets.imdb</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.datasets.mnist.htm">tf.keras.datasets.mnist</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.datasets.reuters.htm">tf.keras.datasets.reuters</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.estimator.htm">tf.keras.estimator</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.experimental.htm">tf.keras.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.initializers.htm">tf.keras.initializers</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.layers.htm">tf.keras.layers</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.losses.htm">tf.keras.losses</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.metrics.htm">tf.keras.metrics</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.mixed_precision.htm">tf.keras.mixed_precision</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.mixed_precision.experimental.htm">tf.keras.mixed_precision.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.models.htm">tf.keras.models</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.optimizers.htm">tf.keras.optimizers</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.optimizers.schedules.htm">tf.keras.optimizers.schedules</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.preprocessing.htm">tf.keras.preprocessing</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.preprocessing.image.htm">tf.keras.preprocessing.image</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.regularizers.htm">tf.keras.regularizers</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.utils.htm">tf.keras.utils</a>
        </li>
				<li>
            <a href="../tensorflow/tf.layers.htm">tf.layers</a>
        </li>
				<li>
            <a href="../tensorflow/tf.layers.experimental.htm">tf.layers.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.linalg.htm">tf.linalg</a>
        </li>
				<li>
            <a href="../tensorflow/tf.lite.htm">tf.lite</a>
        </li>
				<li>
            <a href="../tensorflow/tf.lite.experimental.htm">tf.lite.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.lite.experimental.microfrontend.htm">tf.lite.experimental.microfrontend</a>
        </li>
				<li>
            <a href="../tensorflow/tf.lite.experimental.microfrontend.python.htm">tf.lite.experimental.microfrontend.python</a>
        </li>
				<li>
            <a href="../tensorflow/tf.lite.experimental.microfrontend.python.ops.htm">tf.lite.experimental.microfrontend.python.ops</a>
        </li>
				<li>
            <a href="../tensorflow/tf.lite.experimental.nn.htm">tf.lite.experimental.nn</a>
        </li>
				<li>
            <a href="../tensorflow/tf.logging.htm">tf.logging</a>
        </li>
				<li>
            <a href="../tensorflow/tf.losses.htm">tf.losses</a>
        </li>
				<li>
            <a href="../tensorflow/tf.math.htm">tf.math</a>
        </li>
				<li>
            <a href="../tensorflow/tf.metrics.htm">tf.metrics</a>
        </li>
				<li>
            <a href="../tensorflow/tf.nest.htm">tf.nest</a>
        </li>
				<li>
            <a href="../tensorflow/tf.nn.htm">tf.nn</a>
        </li>
				<li>
            <a href="../tensorflow/tf.profiler.htm">tf.profiler</a>
        </li>
				<li>
            <a href="../tensorflow/tf.quantization.htm">tf.quantization</a>
        </li>
				<li>
            <a href="../tensorflow/tf.ragged.htm">tf.ragged</a>
        </li>
				<li>
            <a href="../tensorflow/tf.random.htm">tf.random</a>
        </li>
				<li>
            <a href="../tensorflow/tf.random.experimental.htm">tf.random.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.resource_loader.htm">tf.resource_loader</a>
        </li>
				<li>
            <a href="../tensorflow/tf.saved_model.htm">tf.saved_model</a>
        </li>
				<li>
            <a href="../tensorflow/tf.saved_model.main_op.htm">tf.saved_model.main_op</a>
        </li>
				<li>
            <a href="../tensorflow/tf.sets.htm">tf.sets</a>
        </li>
				<li>
            <a href="../tensorflow/tf.signal.htm">tf.signal</a>
        </li>
				<li>
            <a href="../tensorflow/tf.sparse.htm">tf.sparse</a>
        </li>
				<li>
            <a href="../tensorflow/tf.strings.htm">tf.strings</a>
        </li>
				<li>
            <a href="../tensorflow/tf.summary.htm">tf.summary</a>
        </li>
				<li>
            <a href="../tensorflow/tf.summary.experimental.htm">tf.summary.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.sysconfig.htm">tf.sysconfig</a>
        </li>
				<li>
            <a href="../tensorflow/tf.test.htm">tf.test</a>
        </li>
				<li>
            <a href="../tensorflow/tf.tpu.htm">tf.tpu</a>
        </li>
				<li>
            <a href="../tensorflow/tf.tpu.experimental.htm">tf.tpu.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.train.htm">tf.train</a>
        </li>
				<li>
            <a href="../tensorflow/tf.train.experimental.htm">tf.train.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.user_ops.htm">tf.user_ops</a>
        </li>
				<li>
            <a href="../tensorflow/tf.xla.htm">tf.xla</a>
        </li>
				<li>
            <a href="../tensorflow/tf.xla.experimental.htm">tf.xla.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/TFRecordReader.htm">TFRecordReader</a>
        </li>
				<li>
            <a href="../tensorflow/truncated_normal_initializer.htm">truncated_normal_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/TypeSpec.htm">TypeSpec</a>
        </li>
				<li>
            <a href="../tensorflow/UnconnectedGradients.htm">UnconnectedGradients</a>
        </li>
				<li>
            <a href="../tensorflow/uniform_unit_scaling_initializer.htm">uniform_unit_scaling_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/Variable.htm">Variable</a>
        </li>
				<li>
            <a href="../tensorflow/variable_scope.htm">variable_scope</a>
        </li>
				<li>
            <a href="../tensorflow/VariableAggregation.htm">VariableAggregation</a>
        </li>
				<li>
            <a href="../tensorflow/VariableScope.htm">VariableScope</a>
        </li>
				<li>
            <a href="../tensorflow/VariableSynchronization.htm">VariableSynchronization</a>
        </li>
				<li>
            <a href="../tensorflow/variance_scaling_initializer.htm">variance_scaling_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/VarLenFeature.htm">VarLenFeature</a>
        </li>
				<li>
            <a href="../tensorflow/WholeFileReader.htm">WholeFileReader</a>
        </li>
				<li>
            <a href="../tensorflow/zeros_initializer.htm">zeros_initializer</a>
        </li>
		</ul>
	</div>
</nav>
	<article>
    <header>
		<p class="class"><strong>Type</strong> RaggedTensor</p>
	</header>
	<section>
		<header>
		<p><strong>Namespace</strong> tensorflow</p>
		<p><strong>Parent</strong> <a href="../LostTech.Gradient/PythonObjectContainer.htm">PythonObjectContainer</a></p>
		<p><strong>Interfaces</strong> <a href="../tensorflow.python.framework.composite_tensor/CompositeTensor.htm">CompositeTensor</a>, <a href="../tensorflow/IRaggedTensor.htm">IRaggedTensor</a></p>
		</header>
    <div class="sub-header">
			<div id="summary">Represents a ragged tensor. <p></p> A `RaggedTensor` is a tensor with one or more *ragged dimensions*, which are
dimensions whose slices may have different lengths.  For example, the inner
(column) dimension of `rt=[[3, 1, 4, 1], [], [5, 9, 2], [6], []]` is ragged,
since the column slices (`rt[0, :]`,..., `rt[4, :]`) have different lengths.
Dimensions whose slices all have the same length are called *uniform
dimensions*.  The outermost dimension of a `RaggedTensor` is always uniform,
since it consists of a single slice (and so there is no possibility for
differing slice lengths). <p></p> The total number of dimensions in a `RaggedTensor` is called its *rank*,
and the number of ragged dimensions in a `RaggedTensor` is called its
*ragged-rank*.  A `RaggedTensor`'s ragged-rank is fixed at graph creation
time: it can't depend on the runtime values of `Tensor`s, and can't vary
dynamically for different session runs. <p></p> ### Potentially Ragged Tensors <p></p> Many ops support both `Tensor`s and `RaggedTensor`s.  The term "potentially
ragged tensor" may be used to refer to a tensor that might be either a
`Tensor` or a `RaggedTensor`.  The ragged-rank of a `Tensor` is zero. <p></p> ### Documenting RaggedTensor Shapes <p></p> When documenting the shape of a RaggedTensor, ragged dimensions can be
indicated by enclosing them in parentheses.  For example, the shape of
a 3-D `RaggedTensor` that stores the fixed-size word embedding for each
word in a sentence, for each sentence in a batch, could be written as
`[num_sentences, (num_words), embedding_size]`.  The parentheses around
`(num_words)` indicate that dimension is ragged, and that the length
of each element list in that dimension may vary for each item. <p></p> ### Component Tensors <p></p> Internally, a `RaggedTensor` consists of a concatenated list of values that
are partitioned into variable-length rows.  In particular, each `RaggedTensor`
consists of: <p></p> * A `values` tensor, which concatenates the variable-length rows into a
flattened list.  For example, the `values` tensor for
`[[3, 1, 4, 1], [], [5, 9, 2], [6], []]` is `[3, 1, 4, 1, 5, 9, 2, 6]`. <p></p> * A `row_splits` vector, which indicates how those flattened values are
divided into rows.  In particular, the values for row `rt[i]` are stored
in the slice `rt.values[rt.row_splits[i]:rt.row_splits[i+1]]`. <p></p> Example:
### Alternative Row-Partitioning Schemes <p></p> In addition to `row_splits`, ragged tensors provide support for four other
row-partitioning schemes: <p></p> * `row_lengths`: a vector with shape `[nrows]`, which specifies the length
of each row. <p></p> * `value_rowids` and `nrows`: `value_rowids` is a vector with shape
`[nvals]`, corresponding one-to-one with `values`, which specifies
each value's row index.  In particular, the row `rt[row]` consists of the
values `rt.values[j]` where `value_rowids[j]==row`.  `nrows` is an
integer scalar that specifies the number of rows in the
`RaggedTensor`. (`nrows` is used to indicate trailing empty rows.) <p></p> * `row_starts`: a vector with shape `[nrows]`, which specifies the start
offset of each row.  Equivalent to `row_splits[:-1]`. <p></p> * `row_limits`: a vector with shape `[nrows]`, which specifies the stop
offset of each row.  Equivalent to `row_splits[1:]`. <p></p> Example: The following ragged tensors are equivalent, and all represent the
nested list `[[3, 1, 4, 1], [], [5, 9, 2], [6], []]`.
### Multiple Ragged Dimensions <p></p> `RaggedTensor`s with multiple ragged dimensions can be defined by using
a nested `RaggedTensor` for the `values` tensor.  Each nested `RaggedTensor`
adds a single ragged dimension.
The factory function `RaggedTensor.from_nested_row_splits` may be used to
construct a `RaggedTensor` with multiple ragged dimensions directly, by
providing a list of `row_splits` tensors:
### Uniform Inner Dimensions <p></p> `RaggedTensor`s with uniform inner dimensions can be defined
by using a multidimensional `Tensor` for `values`.
### RaggedTensor Shape Restrictions <p></p> The shape of a RaggedTensor is currently restricted to have the following
form: <p></p> * A single uniform dimension
* Followed by one or more ragged dimensions
* Followed by zero or more uniform dimensions. <p></p> This restriction follows from the fact that each nested `RaggedTensor`
replaces the uniform outermost dimension of its `values` with a uniform
dimension followed by a ragged dimension. <div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> print(tf.RaggedTensor.from_row_splits(
           ...     values=[3, 1, 4, 1, 5, 9, 2, 6],
           ...     row_splits=[0, 4, 4, 7, 8, 8]))
            <tf.RaggedTensor [[3, 1, 4, 1], [], [5, 9, 2], [6], []]> </pre>
</div>
			</div>
		
		
			<h3 class="section">Methods</h3>
			<ul>
				<li><a href="../tensorflow/RaggedTensor.htm#__getitem__">__getitem__</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#bounding_shape">bounding_shape</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#bounding_shape">bounding_shape</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#bounding_shape_dyn">bounding_shape_dyn</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_nested_row_lengths_dyn``1">from_nested_row_lengths_dyn&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_nested_row_lengths``1">from_nested_row_lengths&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_nested_row_lengths``1">from_nested_row_lengths&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_nested_row_lengths``1">from_nested_row_lengths&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_nested_row_splits_dyn``1">from_nested_row_splits_dyn&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_nested_row_splits``1">from_nested_row_splits&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_nested_row_splits``1">from_nested_row_splits&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_nested_row_splits``1">from_nested_row_splits&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_nested_row_splits``1">from_nested_row_splits&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_nested_row_splits``1">from_nested_row_splits&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_nested_row_splits``1">from_nested_row_splits&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_nested_row_splits``1">from_nested_row_splits&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_nested_row_splits``1">from_nested_row_splits&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_nested_row_splits``1">from_nested_row_splits&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_nested_row_splits``1">from_nested_row_splits&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_nested_row_splits``1">from_nested_row_splits&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_nested_row_splits``1">from_nested_row_splits&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_nested_value_rowids_dyn``1">from_nested_value_rowids_dyn&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_nested_value_rowids``1">from_nested_value_rowids&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_nested_value_rowids``1">from_nested_value_rowids&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_nested_value_rowids``1">from_nested_value_rowids&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_nested_value_rowids``1">from_nested_value_rowids&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_nested_value_rowids``1">from_nested_value_rowids&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_nested_value_rowids``1">from_nested_value_rowids&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_nested_value_rowids``1">from_nested_value_rowids&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_nested_value_rowids``1">from_nested_value_rowids&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_row_lengths_dyn``1">from_row_lengths_dyn&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_row_lengths``1">from_row_lengths&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_row_lengths``1">from_row_lengths&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_row_lengths``1">from_row_lengths&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_row_lengths``1">from_row_lengths&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_row_lengths``1">from_row_lengths&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_row_lengths``1">from_row_lengths&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_row_lengths``1">from_row_lengths&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_row_lengths``1">from_row_lengths&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_row_lengths``1">from_row_lengths&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_row_lengths``1">from_row_lengths&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_row_lengths``1">from_row_lengths&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_row_lengths``1">from_row_lengths&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_row_lengths``1">from_row_lengths&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_row_lengths``1">from_row_lengths&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_row_limits_dyn``1">from_row_limits_dyn&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_row_limits``1">from_row_limits&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_row_limits``1">from_row_limits&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_row_limits``1">from_row_limits&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_row_limits``1">from_row_limits&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_row_splits_dyn``1">from_row_splits_dyn&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_row_splits``1">from_row_splits&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_row_splits``1">from_row_splits&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_row_splits``1">from_row_splits&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_row_splits``1">from_row_splits&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_row_splits``1">from_row_splits&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_row_starts_dyn``1">from_row_starts_dyn&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_row_starts``1">from_row_starts&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_row_starts``1">from_row_starts&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_row_starts``1">from_row_starts&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_row_starts``1">from_row_starts&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_row_starts``1">from_row_starts&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_row_starts``1">from_row_starts&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_row_starts``1">from_row_starts&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_row_starts``1">from_row_starts&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_row_starts``1">from_row_starts&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_row_starts``1">from_row_starts&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_row_starts``1">from_row_starts&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_row_starts``1">from_row_starts&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_sparse_dyn``1">from_sparse_dyn&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_sparse``1">from_sparse&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_tensor_dyn``1">from_tensor_dyn&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_tensor``1">from_tensor&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_tensor``1">from_tensor&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_tensor``1">from_tensor&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_tensor``1">from_tensor&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_tensor``1">from_tensor&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_tensor``1">from_tensor&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_tensor``1">from_tensor&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_tensor``1">from_tensor&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_tensor``1">from_tensor&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_tensor``1">from_tensor&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_tensor``1">from_tensor&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_tensor``1">from_tensor&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_tensor``1">from_tensor&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_tensor``1">from_tensor&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_tensor``1">from_tensor&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_tensor``1">from_tensor&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_tensor``1">from_tensor&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_tensor``1">from_tensor&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_tensor``1">from_tensor&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_tensor``1">from_tensor&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_tensor``1">from_tensor&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_tensor``1">from_tensor&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_tensor``1">from_tensor&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_tensor``1">from_tensor&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_value_rowids_dyn``1">from_value_rowids_dyn&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_value_rowids``1">from_value_rowids&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_value_rowids``1">from_value_rowids&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_value_rowids``1">from_value_rowids&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_value_rowids``1">from_value_rowids&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_value_rowids``1">from_value_rowids&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_value_rowids``1">from_value_rowids&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_value_rowids``1">from_value_rowids&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_value_rowids``1">from_value_rowids&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_value_rowids``1">from_value_rowids&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_value_rowids``1">from_value_rowids&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_value_rowids``1">from_value_rowids&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_value_rowids``1">from_value_rowids&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_value_rowids``1">from_value_rowids&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_value_rowids``1">from_value_rowids&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_value_rowids``1">from_value_rowids&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_value_rowids``1">from_value_rowids&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_value_rowids``1">from_value_rowids&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_value_rowids``1">from_value_rowids&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_value_rowids``1">from_value_rowids&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#from_value_rowids``1">from_value_rowids&lt;TClass&gt;</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#nested_row_lengths">nested_row_lengths</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#nested_row_lengths_dyn">nested_row_lengths_dyn</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#nested_value_rowids">nested_value_rowids</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#nested_value_rowids_dyn">nested_value_rowids_dyn</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#nrows">nrows</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#nrows">nrows</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#nrows">nrows</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#nrows_dyn">nrows_dyn</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#row_lengths">row_lengths</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#row_lengths_dyn">row_lengths_dyn</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#row_limits">row_limits</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#row_limits_dyn">row_limits_dyn</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#row_starts">row_starts</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#row_starts_dyn">row_starts_dyn</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#to_sparse">to_sparse</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#to_sparse_dyn">to_sparse_dyn</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#to_tensor">to_tensor</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#to_tensor">to_tensor</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#to_tensor">to_tensor</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#to_tensor">to_tensor</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#to_tensor">to_tensor</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#to_tensor_dyn">to_tensor_dyn</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#value_rowids">value_rowids</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#value_rowids_dyn">value_rowids_dyn</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#with_flat_values">with_flat_values</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#with_flat_values">with_flat_values</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#with_flat_values_dyn">with_flat_values_dyn</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#with_row_splits_dtype">with_row_splits_dtype</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#with_row_splits_dtype_dyn">with_row_splits_dtype_dyn</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#with_values">with_values</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#with_values">with_values</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#with_values">with_values</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#with_values_dyn">with_values_dyn</a></li>
			</ul>
		
			<h3 class="section">Properties</h3>
			<ul>
				<li><a href="../tensorflow/RaggedTensor.htm#dtype">dtype</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#dtype_dyn">dtype_dyn</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#flat_values">flat_values</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#flat_values_dyn">flat_values_dyn</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#Item">Item</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#nested_row_splits">nested_row_splits</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#nested_row_splits_dyn">nested_row_splits_dyn</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#PythonObject">PythonObject</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#ragged_rank">ragged_rank</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#ragged_rank_dyn">ragged_rank_dyn</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#row_splits">row_splits</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#row_splits_dyn">row_splits_dyn</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#shape">shape</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#shape_dyn">shape_dyn</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#values">values</a></li>
				<li><a href="../tensorflow/RaggedTensor.htm#values_dyn">values_dyn</a></li>
			</ul>
		
	</div>
	
	<h3 class="section">Public instance methods</h3>

	<div id="__getitem__" class="method">
		<h4>
			<span title="System.object">object</span> <strong>__getitem__</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> key)
		</h4>
		<div class="content">Returns the specified piece of this RaggedTensor. <p></p> Supports multidimensional indexing and slicing, with one restriction:
indexing into a ragged inner dimension is not allowed.  This case is
problematic because the indicated value may exist in some rows but not
others.  In such cases, it's not obvious whether we should (1) report an
IndexError; (2) use a default value; or (3) skip that value and return a
tensor with fewer rows than we started with.  Following the guiding
principles of Python ("In the face of ambiguity, refuse the temptation to
guess"), we simply disallow this operation. <p></p> Any dimensions added by `array_ops.newaxis` will be ragged if the following
dimension is ragged. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> key
						</dt>
						<dd>Indicates which piece of the RaggedTensor to return, using standard
Python semantics (e.g., negative values index from the end).  `key`
may have any of the following types: <p></p> * `int` constant
* Scalar integer `Tensor`
* `slice` containing integer constants and/or scalar integer
`Tensor`s
* `Ellipsis`
* <a href="..\tf\newaxis.md"><code>tf.newaxis</code></a>
* `tuple` containing any of the above (for multidimentional indexing) 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `Tensor` or `RaggedTensor` object.  Values that include at least one
ragged dimension are returned as `RaggedTensor`.  Values that include no
ragged dimensions are returned as `Tensor`.  See above for examples of
expressions that return `Tensor`s vs `RaggedTensor`s. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="bounding_shape" class="method">
		<h4>
			<span title="System.object">object</span> <strong>bounding_shape</strong>(<span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> axis, <span title="System.string">string</span> name, <span title="System.object">object</span> out_type)
		</h4>
		<div class="content">Returns the tight bounding box shape for this `RaggedTensor`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> axis
						</dt>
						<dd>An integer scalar or vector indicating which axes to return the
bounding box for.  If not specified, then the full bounding box is
returned. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> out_type
						</dt>
						<dd>`dtype` for the returned tensor.  Defaults to
`self.row_splits.dtype`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>An integer `Tensor` (`dtype=self.row_splits.dtype`).  If `axis` is not
specified, then `output` is a vector with
`output.shape=[self.shape.ndims]`.  If `axis` is a scalar, then the
`output` is a scalar.  If `axis` is a vector, then `output` is a vector,
where `output[i]` is the bounding size for dimension `axis[i]`. <p></p> #### Example:
```python
>>> rt = ragged.constant([[1, 2, 3, 4], [5], [], [6, 7, 8, 9], [10]])
>>> rt.bounding_shape()
[5, 4]
``` 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="bounding_shape" class="method">
		<h4>
			<span title="System.object">object</span> <strong>bounding_shape</strong>(<span title="System.int">int</span> axis, <span title="System.string">string</span> name, <span title="System.object">object</span> out_type)
		</h4>
		<div class="content">Returns the tight bounding box shape for this `RaggedTensor`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> axis
						</dt>
						<dd>An integer scalar or vector indicating which axes to return the
bounding box for.  If not specified, then the full bounding box is
returned. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> out_type
						</dt>
						<dd>`dtype` for the returned tensor.  Defaults to
`self.row_splits.dtype`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>An integer `Tensor` (`dtype=self.row_splits.dtype`).  If `axis` is not
specified, then `output` is a vector with
`output.shape=[self.shape.ndims]`.  If `axis` is a scalar, then the
`output` is a scalar.  If `axis` is a vector, then `output` is a vector,
where `output[i]` is the bounding size for dimension `axis[i]`. <p></p> #### Example:
```python
>>> rt = ragged.constant([[1, 2, 3, 4], [5], [], [6, 7, 8, 9], [10]])
>>> rt.bounding_shape()
[5, 4]
``` 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="bounding_shape_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>bounding_shape_dyn</strong>(<span title="System.object">object</span> axis, <span title="System.object">object</span> name, <span title="System.object">object</span> out_type)
		</h4>
		<div class="content">Returns the tight bounding box shape for this `RaggedTensor`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> axis
						</dt>
						<dd>An integer scalar or vector indicating which axes to return the
bounding box for.  If not specified, then the full bounding box is
returned. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> out_type
						</dt>
						<dd>`dtype` for the returned tensor.  Defaults to
`self.row_splits.dtype`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>An integer `Tensor` (`dtype=self.row_splits.dtype`).  If `axis` is not
specified, then `output` is a vector with
`output.shape=[self.shape.ndims]`.  If `axis` is a scalar, then the
`output` is a scalar.  If `axis` is a vector, then `output` is a vector,
where `output[i]` is the bounding size for dimension `axis[i]`. <p></p> #### Example:
```python
>>> rt = ragged.constant([[1, 2, 3, 4], [5], [], [6, 7, 8, 9], [10]])
>>> rt.bounding_shape()
[5, 4]
``` 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="nested_row_lengths" class="method">
		<h4>
			<span title="System.ValueTuple<object>">ValueTuple&lt;object&gt;</span> <strong>nested_row_lengths</strong>(<span title="System.string">string</span> name)
		</h4>
		<div class="content">Returns a tuple containing the row_lengths for all ragged dimensions. <p></p> `rt.nested_row_lengths()` is a tuple containing the `row_lengths` tensors
for all ragged dimensions in `rt`, ordered from outermost to innermost. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensors (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object>">ValueTuple&lt;object&gt;</span></code>
					</dt>
					<dd>A `tuple` of 1-D integer `Tensors`.  The length of the tuple is equal to
`self.ragged_rank`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="nested_row_lengths_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>nested_row_lengths_dyn</strong>(<span title="System.object">object</span> name)
		</h4>
		<div class="content">Returns a tuple containing the row_lengths for all ragged dimensions. <p></p> `rt.nested_row_lengths()` is a tuple containing the `row_lengths` tensors
for all ragged dimensions in `rt`, ordered from outermost to innermost. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>A name prefix for the returned tensors (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `tuple` of 1-D integer `Tensors`.  The length of the tuple is equal to
`self.ragged_rank`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="nested_value_rowids" class="method">
		<h4>
			<span title="System.ValueTuple<object>">ValueTuple&lt;object&gt;</span> <strong>nested_value_rowids</strong>(<span title="System.string">string</span> name)
		</h4>
		<div class="content">Returns a tuple containing the value_rowids for all ragged dimensions. <p></p> `rt.nested_value_rowids` is a tuple containing the `value_rowids` tensors
for
all ragged dimensions in `rt`, ordered from outermost to innermost.  In
particular, `rt.nested_value_rowids = (rt.value_rowids(),) + value_ids`
where: <p></p> * `value_ids = ()` if `rt.values` is a `Tensor`.
* `value_ids = rt.values.nested_value_rowids` otherwise. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensors (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.ValueTuple<object>">ValueTuple&lt;object&gt;</span></code>
					</dt>
					<dd>A `tuple` of 1-D integer `Tensor`s. <p></p> #### Example: <p></p> ```python
>>> rt = ragged.constant([[[[3, 1, 4, 1], [], [5, 9, 2]], [], [[6], []]]])
>>> for i, ids in enumerate(rt.nested_value_rowids()):
...   print('row ids for dimension %d: %s' % (i+1, ids))
row ids for dimension 1: [0]
row ids for dimension 2: [0, 0, 0, 2, 2]
row ids for dimension 3: [0, 0, 0, 0, 2, 2, 2, 3]
``` 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="nested_value_rowids_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>nested_value_rowids_dyn</strong>(<span title="System.object">object</span> name)
		</h4>
		<div class="content">Returns a tuple containing the value_rowids for all ragged dimensions. <p></p> `rt.nested_value_rowids` is a tuple containing the `value_rowids` tensors
for
all ragged dimensions in `rt`, ordered from outermost to innermost.  In
particular, `rt.nested_value_rowids = (rt.value_rowids(),) + value_ids`
where: <p></p> * `value_ids = ()` if `rt.values` is a `Tensor`.
* `value_ids = rt.values.nested_value_rowids` otherwise. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>A name prefix for the returned tensors (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `tuple` of 1-D integer `Tensor`s. <p></p> #### Example: <p></p> ```python
>>> rt = ragged.constant([[[[3, 1, 4, 1], [], [5, 9, 2]], [], [[6], []]]])
>>> for i, ids in enumerate(rt.nested_value_rowids()):
...   print('row ids for dimension %d: %s' % (i+1, ids))
row ids for dimension 1: [0]
row ids for dimension 2: [0, 0, 0, 2, 2]
row ids for dimension 3: [0, 0, 0, 0, 2, 2, 2, 3]
``` 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="nrows" class="method">
		<h4>
			<span title="System.object">object</span> <strong>nrows</strong>(<a href="../tensorflow/DType.htm">DType</a> out_type, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Returns the number of rows in this ragged tensor. <p></p> I.e., the size of the outermost dimension of the tensor. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/DType.htm">DType</a></code> out_type
						</dt>
						<dd>`dtype` for the returned tensor.  Defaults to
`self.row_splits.dtype`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A scalar `Tensor` with dtype `out_type`. <p></p> #### Example:
```python
>>> rt = ragged.constant([[3, 1, 4, 1], [], [5, 9, 2], [6], []])
>>> rt.nrows()  # rt has 5 rows.
5
``` 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="nrows" class="method">
		<h4>
			<span title="System.object">object</span> <strong>nrows</strong>(<a href="../numpy/dtype.htm">dtype</a> out_type, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Returns the number of rows in this ragged tensor. <p></p> I.e., the size of the outermost dimension of the tensor. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../numpy/dtype.htm">dtype</a></code> out_type
						</dt>
						<dd>`dtype` for the returned tensor.  Defaults to
`self.row_splits.dtype`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A scalar `Tensor` with dtype `out_type`. <p></p> #### Example:
```python
>>> rt = ragged.constant([[3, 1, 4, 1], [], [5, 9, 2], [6], []])
>>> rt.nrows()  # rt has 5 rows.
5
``` 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="nrows" class="method">
		<h4>
			<span title="System.object">object</span> <strong>nrows</strong>(<a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> out_type, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Returns the number of rows in this ragged tensor. <p></p> I.e., the size of the outermost dimension of the tensor. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> out_type
						</dt>
						<dd>`dtype` for the returned tensor.  Defaults to
`self.row_splits.dtype`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A scalar `Tensor` with dtype `out_type`. <p></p> #### Example:
```python
>>> rt = ragged.constant([[3, 1, 4, 1], [], [5, 9, 2], [6], []])
>>> rt.nrows()  # rt has 5 rows.
5
``` 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="nrows_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>nrows_dyn</strong>(<span title="System.object">object</span> out_type, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Returns the number of rows in this ragged tensor. <p></p> I.e., the size of the outermost dimension of the tensor. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> out_type
						</dt>
						<dd>`dtype` for the returned tensor.  Defaults to
`self.row_splits.dtype`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A scalar `Tensor` with dtype `out_type`. <p></p> #### Example:
```python
>>> rt = ragged.constant([[3, 1, 4, 1], [], [5, 9, 2], [6], []])
>>> rt.nrows()  # rt has 5 rows.
5
``` 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="row_lengths" class="method">
		<h4>
			<span title="System.object">object</span> <strong>row_lengths</strong>(<span title="System.int">int</span> axis, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Returns the lengths of the rows in this ragged tensor. <p></p> `rt.row_lengths()[i]` indicates the number of values in the
`i`th row of `rt`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> axis
						</dt>
						<dd>An integer constant indicating the axis whose row lengths should be
returned. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A potentially ragged integer Tensor with shape `self.shape[:axis]`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="row_lengths_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>row_lengths_dyn</strong>(<a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> axis, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Returns the lengths of the rows in this ragged tensor. <p></p> `rt.row_lengths()[i]` indicates the number of values in the
`i`th row of `rt`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> axis
						</dt>
						<dd>An integer constant indicating the axis whose row lengths should be
returned. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A potentially ragged integer Tensor with shape `self.shape[:axis]`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="row_limits" class="method">
		<h4>
			<span title="System.object">object</span> <strong>row_limits</strong>(<span title="System.string">string</span> name)
		</h4>
		<div class="content">Returns the limit indices for rows in this ragged tensor. <p></p> These indices specify where the values for each row end in
`self.values`.  `rt.row_limits(self)` is equal to `rt.row_splits[:-1]`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A 1-D integer Tensor with shape `[nrows]`.
The returned tensor is nonnegative, and is sorted in ascending order. <p></p> #### Example:
```python
>>> rt = ragged.constant([[3, 1, 4, 1], [], [5, 9, 2], [6], []])
>>> rt.values
tf.Tensor([3, 1, 4, 1, 5, 9, 2, 6])
>>> rt.row_limits()  # indices of row limits in rt.values
tf.Tensor([4, 4, 7, 8, 8])
``` 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="row_limits_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>row_limits_dyn</strong>(<span title="System.object">object</span> name)
		</h4>
		<div class="content">Returns the limit indices for rows in this ragged tensor. <p></p> These indices specify where the values for each row end in
`self.values`.  `rt.row_limits(self)` is equal to `rt.row_splits[:-1]`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A 1-D integer Tensor with shape `[nrows]`.
The returned tensor is nonnegative, and is sorted in ascending order. <p></p> #### Example:
```python
>>> rt = ragged.constant([[3, 1, 4, 1], [], [5, 9, 2], [6], []])
>>> rt.values
tf.Tensor([3, 1, 4, 1, 5, 9, 2, 6])
>>> rt.row_limits()  # indices of row limits in rt.values
tf.Tensor([4, 4, 7, 8, 8])
``` 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="row_starts" class="method">
		<h4>
			<span title="System.object">object</span> <strong>row_starts</strong>(<span title="System.string">string</span> name)
		</h4>
		<div class="content">Returns the start indices for rows in this ragged tensor. <p></p> These indices specify where the values for each row begin in
`self.values`.  `rt.row_starts()` is equal to `rt.row_splits[:-1]`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A 1-D integer Tensor with shape `[nrows]`.
The returned tensor is nonnegative, and is sorted in ascending order. <p></p> #### Example:
```python
>>> rt = ragged.constant([[3, 1, 4, 1], [], [5, 9, 2], [6], []])
>>> rt.values
tf.Tensor([3, 1, 4, 1, 5, 9, 2, 6])
>>> rt.row_starts()  # indices of row starts in rt.values
tf.Tensor([0, 4, 4, 7, 8])
``` 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="row_starts_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>row_starts_dyn</strong>(<span title="System.object">object</span> name)
		</h4>
		<div class="content">Returns the start indices for rows in this ragged tensor. <p></p> These indices specify where the values for each row begin in
`self.values`.  `rt.row_starts()` is equal to `rt.row_splits[:-1]`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A 1-D integer Tensor with shape `[nrows]`.
The returned tensor is nonnegative, and is sorted in ascending order. <p></p> #### Example:
```python
>>> rt = ragged.constant([[3, 1, 4, 1], [], [5, 9, 2], [6], []])
>>> rt.values
tf.Tensor([3, 1, 4, 1, 5, 9, 2, 6])
>>> rt.row_starts()  # indices of row starts in rt.values
tf.Tensor([0, 4, 4, 7, 8])
``` 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="to_sparse" class="method">
		<h4>
			<a href="../tensorflow/SparseTensor.htm">SparseTensor</a> <strong>to_sparse</strong>(<span title="System.string">string</span> name)
		</h4>
		<div class="content">Converts this `RaggedTensor` into a <a href="..\tf\sparse\SparseTensor.md"><code>tf.SparseTensor</code></a>. <p></p> Example: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensors (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/SparseTensor.htm">SparseTensor</a></code>
					</dt>
					<dd>A SparseTensor with the same values as `self`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> rt = ragged.constant([[1, 2, 3], [4], [], [5, 6]])
            >>> rt.to_sparse().eval()
            SparseTensorValue(indices=[[0, 0], [0, 1], [0, 2], [1, 0], [3, 0], [3, 1]],
                              values=[1, 2, 3, 4, 5, 6],
                              dense_shape=[4, 3]) </pre>
</div>
		</div>
	</div>
	<div id="to_sparse_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>to_sparse_dyn</strong>(<span title="System.object">object</span> name)
		</h4>
		<div class="content">Converts this `RaggedTensor` into a <a href="..\tf\sparse\SparseTensor.md"><code>tf.SparseTensor</code></a>. <p></p> Example: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>A name prefix for the returned tensors (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A SparseTensor with the same values as `self`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> rt = ragged.constant([[1, 2, 3], [4], [], [5, 6]])
            >>> rt.to_sparse().eval()
            SparseTensorValue(indices=[[0, 0], [0, 1], [0, 2], [1, 0], [3, 0], [3, 1]],
                              values=[1, 2, 3, 4, 5, 6],
                              dense_shape=[4, 3]) </pre>
</div>
		</div>
	</div>
	<div id="to_tensor" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>to_tensor</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> default_value, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Converts this `RaggedTensor` into a <a href="..\tf\Tensor.md"><code>tf.Tensor</code></a>. <p></p> Example: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> default_value
						</dt>
						<dd>Value to set for indices not specified in `self`. Defaults
to zero.  `default_value` must be broadcastable to
`self.shape[self.ragged_rank + 1:]`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensors (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` with shape `ragged.bounding_shape(self)` and the
values specified by the non-empty values in `self`.  Empty values are
assigned `default_value`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> rt = ragged.constant([[9, 8, 7], [], [6, 5], [4]])
            >>> print rt.to_tensor()
            [[9 8 7]
             [0 0 0]
             [6 5 0]
             [4 0 0]] </pre>
</div>
		</div>
	</div>
	<div id="to_tensor" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>to_tensor</strong>(<span title="System.bool">bool</span> default_value, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Converts this `RaggedTensor` into a <a href="..\tf\Tensor.md"><code>tf.Tensor</code></a>. <p></p> Example: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.bool">bool</span></code> default_value
						</dt>
						<dd>Value to set for indices not specified in `self`. Defaults
to zero.  `default_value` must be broadcastable to
`self.shape[self.ragged_rank + 1:]`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensors (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` with shape `ragged.bounding_shape(self)` and the
values specified by the non-empty values in `self`.  Empty values are
assigned `default_value`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> rt = ragged.constant([[9, 8, 7], [], [6, 5], [4]])
            >>> print rt.to_tensor()
            [[9 8 7]
             [0 0 0]
             [6 5 0]
             [4 0 0]] </pre>
</div>
		</div>
	</div>
	<div id="to_tensor" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>to_tensor</strong>(<span title="System.string">string</span> default_value, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Converts this `RaggedTensor` into a <a href="..\tf\Tensor.md"><code>tf.Tensor</code></a>. <p></p> Example: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.string">string</span></code> default_value
						</dt>
						<dd>Value to set for indices not specified in `self`. Defaults
to zero.  `default_value` must be broadcastable to
`self.shape[self.ragged_rank + 1:]`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensors (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` with shape `ragged.bounding_shape(self)` and the
values specified by the non-empty values in `self`.  Empty values are
assigned `default_value`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> rt = ragged.constant([[9, 8, 7], [], [6, 5], [4]])
            >>> print rt.to_tensor()
            [[9 8 7]
             [0 0 0]
             [6 5 0]
             [4 0 0]] </pre>
</div>
		</div>
	</div>
	<div id="to_tensor" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>to_tensor</strong>(<span title="System.int">int</span> default_value, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Converts this `RaggedTensor` into a <a href="..\tf\Tensor.md"><code>tf.Tensor</code></a>. <p></p> Example: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> default_value
						</dt>
						<dd>Value to set for indices not specified in `self`. Defaults
to zero.  `default_value` must be broadcastable to
`self.shape[self.ragged_rank + 1:]`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensors (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` with shape `ragged.bounding_shape(self)` and the
values specified by the non-empty values in `self`.  Empty values are
assigned `default_value`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> rt = ragged.constant([[9, 8, 7], [], [6, 5], [4]])
            >>> print rt.to_tensor()
            [[9 8 7]
             [0 0 0]
             [6 5 0]
             [4 0 0]] </pre>
</div>
		</div>
	</div>
	<div id="to_tensor" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>to_tensor</strong>(<span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> default_value, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Converts this `RaggedTensor` into a <a href="..\tf\Tensor.md"><code>tf.Tensor</code></a>. <p></p> Example: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> default_value
						</dt>
						<dd>Value to set for indices not specified in `self`. Defaults
to zero.  `default_value` must be broadcastable to
`self.shape[self.ragged_rank + 1:]`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensors (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A `Tensor` with shape `ragged.bounding_shape(self)` and the
values specified by the non-empty values in `self`.  Empty values are
assigned `default_value`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> rt = ragged.constant([[9, 8, 7], [], [6, 5], [4]])
            >>> print rt.to_tensor()
            [[9 8 7]
             [0 0 0]
             [6 5 0]
             [4 0 0]] </pre>
</div>
		</div>
	</div>
	<div id="to_tensor_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>to_tensor_dyn</strong>(<span title="System.object">object</span> default_value, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Converts this `RaggedTensor` into a <a href="..\tf\Tensor.md"><code>tf.Tensor</code></a>. <p></p> Example: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> default_value
						</dt>
						<dd>Value to set for indices not specified in `self`. Defaults
to zero.  `default_value` must be broadcastable to
`self.shape[self.ragged_rank + 1:]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>A name prefix for the returned tensors (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `Tensor` with shape `ragged.bounding_shape(self)` and the
values specified by the non-empty values in `self`.  Empty values are
assigned `default_value`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> rt = ragged.constant([[9, 8, 7], [], [6, 5], [4]])
            >>> print rt.to_tensor()
            [[9 8 7]
             [0 0 0]
             [6 5 0]
             [4 0 0]] </pre>
</div>
		</div>
	</div>
	<div id="value_rowids" class="method">
		<h4>
			<span title="System.object">object</span> <strong>value_rowids</strong>(<span title="System.string">string</span> name)
		</h4>
		<div class="content">Returns the row indices for the `values` in this ragged tensor. <p></p> `rt.value_rowids()` corresponds one-to-one with the outermost dimension of
`rt.values`, and specifies the row containing each value.  In particular,
the row `rt[row]` consists of the values `rt.values[j]` where
`rt.value_rowids()[j] == row`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A 1-D integer `Tensor` with shape `self.values.shape[:1]`.
The returned tensor is nonnegative, and is sorted in ascending order. <p></p> #### Example:
```python
>>> rt = ragged.constant([[3, 1, 4, 1], [], [5, 9, 2], [6], []])
>>> rt.values
tf.Tensor([3, 1, 4, 1, 5, 9, 2, 6])
>>> rt.value_rowids()
tf.Tensor([0, 0, 0, 0, 2, 2, 2, 3])  # corresponds 1:1 with rt.values
``` 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="value_rowids_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>value_rowids_dyn</strong>(<span title="System.object">object</span> name)
		</h4>
		<div class="content">Returns the row indices for the `values` in this ragged tensor. <p></p> `rt.value_rowids()` corresponds one-to-one with the outermost dimension of
`rt.values`, and specifies the row containing each value.  In particular,
the row `rt[row]` consists of the values `rt.values[j]` where
`rt.value_rowids()[j] == row`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A 1-D integer `Tensor` with shape `self.values.shape[:1]`.
The returned tensor is nonnegative, and is sorted in ascending order. <p></p> #### Example:
```python
>>> rt = ragged.constant([[3, 1, 4, 1], [], [5, 9, 2], [6], []])
>>> rt.values
tf.Tensor([3, 1, 4, 1, 5, 9, 2, 6])
>>> rt.value_rowids()
tf.Tensor([0, 0, 0, 0, 2, 2, 2, 3])  # corresponds 1:1 with rt.values
``` 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="with_flat_values" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>with_flat_values</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> new_values)
		</h4>
		<div class="content">Returns a copy of `self` with `flat_values` replaced by `new_value`. <p></p> Preserves cached row-partitioning tensors such as `self.cached_nrows` and
`self.cached_value_rowids` if they have values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> new_values
						</dt>
						<dd>Potentially ragged tensor that should replace
`self.flat_values`.  Must have `rank > 0`, and must have the same
number of rows as `self.flat_values`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A `RaggedTensor`.
`result.rank = self.ragged_rank + new_values.rank`.
`result.ragged_rank = self.ragged_rank + new_values.ragged_rank`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="with_flat_values" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>with_flat_values</strong>(<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> new_values)
		</h4>
		<div class="content">Returns a copy of `self` with `flat_values` replaced by `new_value`. <p></p> Preserves cached row-partitioning tensors such as `self.cached_nrows` and
`self.cached_value_rowids` if they have values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code> new_values
						</dt>
						<dd>Potentially ragged tensor that should replace
`self.flat_values`.  Must have `rank > 0`, and must have the same
number of rows as `self.flat_values`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A `RaggedTensor`.
`result.rank = self.ragged_rank + new_values.rank`.
`result.ragged_rank = self.ragged_rank + new_values.ragged_rank`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="with_flat_values_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>with_flat_values_dyn</strong>(<span title="System.object">object</span> new_values)
		</h4>
		<div class="content">Returns a copy of `self` with `flat_values` replaced by `new_value`. <p></p> Preserves cached row-partitioning tensors such as `self.cached_nrows` and
`self.cached_value_rowids` if they have values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> new_values
						</dt>
						<dd>Potentially ragged tensor that should replace
`self.flat_values`.  Must have `rank > 0`, and must have the same
number of rows as `self.flat_values`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `RaggedTensor`.
`result.rank = self.ragged_rank + new_values.rank`.
`result.ragged_rank = self.ragged_rank + new_values.ragged_rank`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="with_row_splits_dtype" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>with_row_splits_dtype</strong>(<a href="../tensorflow/DType.htm">DType</a> dtype)
		</h4>
		<div class="content">Returns a copy of this RaggedTensor with the given `row_splits` dtype. <p></p> For RaggedTensors with multiple ragged dimensions, the `row_splits` for all
nested `RaggedTensor` objects are cast to the given dtype. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/DType.htm">DType</a></code> dtype
						</dt>
						<dd>The dtype for `row_splits`.  One of <a href="..\tf\dtypes\int32.md"><code>tf.int32</code></a> or <a href="..\tf\dtypes\int64.md"><code>tf.int64</code></a>. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A copy of this RaggedTensor, with the `row_splits` cast to the given
type. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="with_row_splits_dtype_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>with_row_splits_dtype_dyn</strong>(<span title="System.object">object</span> dtype)
		</h4>
		<div class="content">Returns a copy of this RaggedTensor with the given `row_splits` dtype. <p></p> For RaggedTensors with multiple ragged dimensions, the `row_splits` for all
nested `RaggedTensor` objects are cast to the given dtype. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> dtype
						</dt>
						<dd>The dtype for `row_splits`.  One of <a href="..\tf\dtypes\int32.md"><code>tf.int32</code></a> or <a href="..\tf\dtypes\int64.md"><code>tf.int64</code></a>. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A copy of this RaggedTensor, with the `row_splits` cast to the given
type. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="with_values" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>with_values</strong>(<span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> new_values)
		</h4>
		<div class="content">Returns a copy of `self` with `values` replaced by `new_value`. <p></p> Preserves cached row-partitioning tensors such as `self.cached_nrows` and
`self.cached_value_rowids` if they have values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> new_values
						</dt>
						<dd>Potentially ragged tensor to use as the `values` for the
returned `RaggedTensor`.  Must have `rank > 0`, and must have the same
number of rows as `self.values`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = 1 + new_values.rank`.
`result.ragged_rank = 1 + new_values.ragged_rank` 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="with_values" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>with_values</strong>(<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> new_values)
		</h4>
		<div class="content">Returns a copy of `self` with `values` replaced by `new_value`. <p></p> Preserves cached row-partitioning tensors such as `self.cached_nrows` and
`self.cached_value_rowids` if they have values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code> new_values
						</dt>
						<dd>Potentially ragged tensor to use as the `values` for the
returned `RaggedTensor`.  Must have `rank > 0`, and must have the same
number of rows as `self.values`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = 1 + new_values.rank`.
`result.ragged_rank = 1 + new_values.ragged_rank` 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="with_values" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>with_values</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> new_values)
		</h4>
		<div class="content">Returns a copy of `self` with `values` replaced by `new_value`. <p></p> Preserves cached row-partitioning tensors such as `self.cached_nrows` and
`self.cached_value_rowids` if they have values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> new_values
						</dt>
						<dd>Potentially ragged tensor to use as the `values` for the
returned `RaggedTensor`.  Must have `rank > 0`, and must have the same
number of rows as `self.values`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = 1 + new_values.rank`.
`result.ragged_rank = 1 + new_values.ragged_rank` 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="with_values_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>with_values_dyn</strong>(<span title="System.object">object</span> new_values)
		</h4>
		<div class="content">Returns a copy of `self` with `values` replaced by `new_value`. <p></p> Preserves cached row-partitioning tensors such as `self.cached_nrows` and
`self.cached_value_rowids` if they have values. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> new_values
						</dt>
						<dd>Potentially ragged tensor to use as the `values` for the
returned `RaggedTensor`.  Must have `rank > 0`, and must have the same
number of rows as `self.values`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = 1 + new_values.rank`.
`result.ragged_rank = 1 + new_values.ragged_rank` 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	
	<h3 class="section">Public static methods</h3>

	<div id="from_nested_row_lengths_dyn``1" class="method">
		<h4>
			<span title="System.object">object</span> <strong>from_nested_row_lengths_dyn&lt;TClass&gt;</strong>(<span title="System.object">object</span> flat_values, <span title="System.object">object</span> nested_row_lengths, <span title="System.object">object</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` from a nested list of `row_lengths` tensors. <p></p> Equivalent to: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> flat_values
						</dt>
						<dd>A potentially ragged tensor. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> nested_row_lengths
						</dt>
						<dd>A list of 1-D integer tensors.  The `i`th tensor is
used as the `row_lengths` for the `i`th ragged dimension. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `RaggedTensor` (or `flat_values` if `nested_row_lengths` is empty). 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = flat_values
            for row_lengths in reversed(nested_row_lengths):
              result = from_row_lengths(result, row_lengths) </pre>
</div>
		</div>
	</div>
	<div id="from_nested_row_lengths``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_nested_row_lengths&lt;TClass&gt;</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> flat_values, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> nested_row_lengths, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` from a nested list of `row_lengths` tensors. <p></p> Equivalent to: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> flat_values
						</dt>
						<dd>A potentially ragged tensor. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> nested_row_lengths
						</dt>
						<dd>A list of 1-D integer tensors.  The `i`th tensor is
used as the `row_lengths` for the `i`th ragged dimension. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor` (or `flat_values` if `nested_row_lengths` is empty). 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = flat_values
            for row_lengths in reversed(nested_row_lengths):
              result = from_row_lengths(result, row_lengths) </pre>
</div>
		</div>
	</div>
	<div id="from_nested_row_lengths``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_nested_row_lengths&lt;TClass&gt;</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> flat_values, <span title="System.ValueTuple<IEnumerable<object>, object>">ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;</span> nested_row_lengths, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` from a nested list of `row_lengths` tensors. <p></p> Equivalent to: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> flat_values
						</dt>
						<dd>A potentially ragged tensor. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<IEnumerable<object>, object>">ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;</span></code> nested_row_lengths
						</dt>
						<dd>A list of 1-D integer tensors.  The `i`th tensor is
used as the `row_lengths` for the `i`th ragged dimension. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor` (or `flat_values` if `nested_row_lengths` is empty). 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = flat_values
            for row_lengths in reversed(nested_row_lengths):
              result = from_row_lengths(result, row_lengths) </pre>
</div>
		</div>
	</div>
	<div id="from_nested_row_lengths``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_nested_row_lengths&lt;TClass&gt;</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> flat_values, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> nested_row_lengths, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` from a nested list of `row_lengths` tensors. <p></p> Equivalent to: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> flat_values
						</dt>
						<dd>A potentially ragged tensor. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> nested_row_lengths
						</dt>
						<dd>A list of 1-D integer tensors.  The `i`th tensor is
used as the `row_lengths` for the `i`th ragged dimension. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor` (or `flat_values` if `nested_row_lengths` is empty). 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = flat_values
            for row_lengths in reversed(nested_row_lengths):
              result = from_row_lengths(result, row_lengths) </pre>
</div>
		</div>
	</div>
	<div id="from_nested_row_splits_dyn``1" class="method">
		<h4>
			<span title="System.object">object</span> <strong>from_nested_row_splits_dyn&lt;TClass&gt;</strong>(<span title="System.object">object</span> flat_values, <span title="System.object">object</span> nested_row_splits, <span title="System.object">object</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` from a nested list of `row_splits` tensors. <p></p> Equivalent to: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> flat_values
						</dt>
						<dd>A potentially ragged tensor. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> nested_row_splits
						</dt>
						<dd>A list of 1-D integer tensors.  The `i`th tensor is
used as the `row_splits` for the `i`th ragged dimension. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form a
valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `RaggedTensor` (or `flat_values` if `nested_row_splits` is empty). 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = flat_values
            for row_splits in reversed(nested_row_splits):
              result = from_row_splits(result, row_splits) </pre>
</div>
		</div>
	</div>
	<div id="from_nested_row_splits``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_nested_row_splits&lt;TClass&gt;</strong>(<span title="System.Collections.Generic.IEnumerable<PythonClassContainer>">IEnumerable&lt;PythonClassContainer&gt;</span> flat_values, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> nested_row_splits, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` from a nested list of `row_splits` tensors. <p></p> Equivalent to: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<PythonClassContainer>">IEnumerable&lt;PythonClassContainer&gt;</span></code> flat_values
						</dt>
						<dd>A potentially ragged tensor. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> nested_row_splits
						</dt>
						<dd>A list of 1-D integer tensors.  The `i`th tensor is
used as the `row_splits` for the `i`th ragged dimension. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form a
valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor` (or `flat_values` if `nested_row_splits` is empty). 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = flat_values
            for row_splits in reversed(nested_row_splits):
              result = from_row_splits(result, row_splits) </pre>
</div>
		</div>
	</div>
	<div id="from_nested_row_splits``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_nested_row_splits&lt;TClass&gt;</strong>(<a href="../tensorflow.python.framework.composite_tensor/CompositeTensor.htm">CompositeTensor</a> flat_values, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> nested_row_splits, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` from a nested list of `row_splits` tensors. <p></p> Equivalent to: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow.python.framework.composite_tensor/CompositeTensor.htm">CompositeTensor</a></code> flat_values
						</dt>
						<dd>A potentially ragged tensor. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> nested_row_splits
						</dt>
						<dd>A list of 1-D integer tensors.  The `i`th tensor is
used as the `row_splits` for the `i`th ragged dimension. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form a
valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor` (or `flat_values` if `nested_row_splits` is empty). 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = flat_values
            for row_splits in reversed(nested_row_splits):
              result = from_row_splits(result, row_splits) </pre>
</div>
		</div>
	</div>
	<div id="from_nested_row_splits``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_nested_row_splits&lt;TClass&gt;</strong>(<a href="../tensorflow.python.framework.composite_tensor/CompositeTensor.htm">CompositeTensor</a> flat_values, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> nested_row_splits, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` from a nested list of `row_splits` tensors. <p></p> Equivalent to: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow.python.framework.composite_tensor/CompositeTensor.htm">CompositeTensor</a></code> flat_values
						</dt>
						<dd>A potentially ragged tensor. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> nested_row_splits
						</dt>
						<dd>A list of 1-D integer tensors.  The `i`th tensor is
used as the `row_splits` for the `i`th ragged dimension. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form a
valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor` (or `flat_values` if `nested_row_splits` is empty). 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = flat_values
            for row_splits in reversed(nested_row_splits):
              result = from_row_splits(result, row_splits) </pre>
</div>
		</div>
	</div>
	<div id="from_nested_row_splits``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_nested_row_splits&lt;TClass&gt;</strong>(<span title="System.Collections.Generic.IEnumerable<PythonClassContainer>">IEnumerable&lt;PythonClassContainer&gt;</span> flat_values, <span title="System.ValueTuple<IEnumerable<int>, object>">ValueTuple&lt;IEnumerable&lt;int&gt;, object&gt;</span> nested_row_splits, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` from a nested list of `row_splits` tensors. <p></p> Equivalent to: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<PythonClassContainer>">IEnumerable&lt;PythonClassContainer&gt;</span></code> flat_values
						</dt>
						<dd>A potentially ragged tensor. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<IEnumerable<int>, object>">ValueTuple&lt;IEnumerable&lt;int&gt;, object&gt;</span></code> nested_row_splits
						</dt>
						<dd>A list of 1-D integer tensors.  The `i`th tensor is
used as the `row_splits` for the `i`th ragged dimension. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form a
valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor` (or `flat_values` if `nested_row_splits` is empty). 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = flat_values
            for row_splits in reversed(nested_row_splits):
              result = from_row_splits(result, row_splits) </pre>
</div>
		</div>
	</div>
	<div id="from_nested_row_splits``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_nested_row_splits&lt;TClass&gt;</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> flat_values, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> nested_row_splits, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` from a nested list of `row_splits` tensors. <p></p> Equivalent to: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> flat_values
						</dt>
						<dd>A potentially ragged tensor. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> nested_row_splits
						</dt>
						<dd>A list of 1-D integer tensors.  The `i`th tensor is
used as the `row_splits` for the `i`th ragged dimension. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form a
valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor` (or `flat_values` if `nested_row_splits` is empty). 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = flat_values
            for row_splits in reversed(nested_row_splits):
              result = from_row_splits(result, row_splits) </pre>
</div>
		</div>
	</div>
	<div id="from_nested_row_splits``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_nested_row_splits&lt;TClass&gt;</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> flat_values, <span title="System.ValueTuple<IEnumerable<int>, object>">ValueTuple&lt;IEnumerable&lt;int&gt;, object&gt;</span> nested_row_splits, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` from a nested list of `row_splits` tensors. <p></p> Equivalent to: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> flat_values
						</dt>
						<dd>A potentially ragged tensor. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<IEnumerable<int>, object>">ValueTuple&lt;IEnumerable&lt;int&gt;, object&gt;</span></code> nested_row_splits
						</dt>
						<dd>A list of 1-D integer tensors.  The `i`th tensor is
used as the `row_splits` for the `i`th ragged dimension. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form a
valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor` (or `flat_values` if `nested_row_splits` is empty). 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = flat_values
            for row_splits in reversed(nested_row_splits):
              result = from_row_splits(result, row_splits) </pre>
</div>
		</div>
	</div>
	<div id="from_nested_row_splits``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_nested_row_splits&lt;TClass&gt;</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> flat_values, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> nested_row_splits, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` from a nested list of `row_splits` tensors. <p></p> Equivalent to: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> flat_values
						</dt>
						<dd>A potentially ragged tensor. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> nested_row_splits
						</dt>
						<dd>A list of 1-D integer tensors.  The `i`th tensor is
used as the `row_splits` for the `i`th ragged dimension. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form a
valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor` (or `flat_values` if `nested_row_splits` is empty). 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = flat_values
            for row_splits in reversed(nested_row_splits):
              result = from_row_splits(result, row_splits) </pre>
</div>
		</div>
	</div>
	<div id="from_nested_row_splits``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_nested_row_splits&lt;TClass&gt;</strong>(<a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> flat_values, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> nested_row_splits, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` from a nested list of `row_splits` tensors. <p></p> Equivalent to: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> flat_values
						</dt>
						<dd>A potentially ragged tensor. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> nested_row_splits
						</dt>
						<dd>A list of 1-D integer tensors.  The `i`th tensor is
used as the `row_splits` for the `i`th ragged dimension. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form a
valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor` (or `flat_values` if `nested_row_splits` is empty). 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = flat_values
            for row_splits in reversed(nested_row_splits):
              result = from_row_splits(result, row_splits) </pre>
</div>
		</div>
	</div>
	<div id="from_nested_row_splits``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_nested_row_splits&lt;TClass&gt;</strong>(<a href="../tensorflow.python.framework.composite_tensor/CompositeTensor.htm">CompositeTensor</a> flat_values, <span title="System.ValueTuple<IEnumerable<int>, object>">ValueTuple&lt;IEnumerable&lt;int&gt;, object&gt;</span> nested_row_splits, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` from a nested list of `row_splits` tensors. <p></p> Equivalent to: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow.python.framework.composite_tensor/CompositeTensor.htm">CompositeTensor</a></code> flat_values
						</dt>
						<dd>A potentially ragged tensor. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<IEnumerable<int>, object>">ValueTuple&lt;IEnumerable&lt;int&gt;, object&gt;</span></code> nested_row_splits
						</dt>
						<dd>A list of 1-D integer tensors.  The `i`th tensor is
used as the `row_splits` for the `i`th ragged dimension. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form a
valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor` (or `flat_values` if `nested_row_splits` is empty). 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = flat_values
            for row_splits in reversed(nested_row_splits):
              result = from_row_splits(result, row_splits) </pre>
</div>
		</div>
	</div>
	<div id="from_nested_row_splits``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_nested_row_splits&lt;TClass&gt;</strong>(<a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> flat_values, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> nested_row_splits, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` from a nested list of `row_splits` tensors. <p></p> Equivalent to: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> flat_values
						</dt>
						<dd>A potentially ragged tensor. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> nested_row_splits
						</dt>
						<dd>A list of 1-D integer tensors.  The `i`th tensor is
used as the `row_splits` for the `i`th ragged dimension. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form a
valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor` (or `flat_values` if `nested_row_splits` is empty). 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = flat_values
            for row_splits in reversed(nested_row_splits):
              result = from_row_splits(result, row_splits) </pre>
</div>
		</div>
	</div>
	<div id="from_nested_row_splits``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_nested_row_splits&lt;TClass&gt;</strong>(<span title="System.Collections.Generic.IEnumerable<PythonClassContainer>">IEnumerable&lt;PythonClassContainer&gt;</span> flat_values, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> nested_row_splits, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` from a nested list of `row_splits` tensors. <p></p> Equivalent to: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<PythonClassContainer>">IEnumerable&lt;PythonClassContainer&gt;</span></code> flat_values
						</dt>
						<dd>A potentially ragged tensor. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> nested_row_splits
						</dt>
						<dd>A list of 1-D integer tensors.  The `i`th tensor is
used as the `row_splits` for the `i`th ragged dimension. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form a
valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor` (or `flat_values` if `nested_row_splits` is empty). 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = flat_values
            for row_splits in reversed(nested_row_splits):
              result = from_row_splits(result, row_splits) </pre>
</div>
		</div>
	</div>
	<div id="from_nested_row_splits``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_nested_row_splits&lt;TClass&gt;</strong>(<a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> flat_values, <span title="System.ValueTuple<IEnumerable<int>, object>">ValueTuple&lt;IEnumerable&lt;int&gt;, object&gt;</span> nested_row_splits, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` from a nested list of `row_splits` tensors. <p></p> Equivalent to: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> flat_values
						</dt>
						<dd>A potentially ragged tensor. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<IEnumerable<int>, object>">ValueTuple&lt;IEnumerable&lt;int&gt;, object&gt;</span></code> nested_row_splits
						</dt>
						<dd>A list of 1-D integer tensors.  The `i`th tensor is
used as the `row_splits` for the `i`th ragged dimension. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form a
valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor` (or `flat_values` if `nested_row_splits` is empty). 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = flat_values
            for row_splits in reversed(nested_row_splits):
              result = from_row_splits(result, row_splits) </pre>
</div>
		</div>
	</div>
	<div id="from_nested_value_rowids_dyn``1" class="method">
		<h4>
			<span title="System.object">object</span> <strong>from_nested_value_rowids_dyn&lt;TClass&gt;</strong>(<span title="System.object">object</span> flat_values, <span title="System.object">object</span> nested_value_rowids, <span title="System.object">object</span> nested_nrows, <span title="System.object">object</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` from a nested list of `value_rowids` tensors. <p></p> Equivalent to: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> flat_values
						</dt>
						<dd>A potentially ragged tensor. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> nested_value_rowids
						</dt>
						<dd>A list of 1-D integer tensors.  The `i`th tensor is
used as the `value_rowids` for the `i`th ragged dimension. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> nested_nrows
						</dt>
						<dd>A list of integer scalars.  The `i`th scalar is used as the
`nrows` for the `i`th ragged dimension. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `RaggedTensor` (or `flat_values` if `nested_value_rowids` is empty). 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = flat_values
            for (rowids, nrows) in reversed(zip(nested_value_rowids, nested_nrows)):
              result = from_value_rowids(result, rowids, nrows) </pre>
</div>
		</div>
	</div>
	<div id="from_nested_value_rowids``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_nested_value_rowids&lt;TClass&gt;</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> flat_values, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> nested_value_rowids, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> nested_nrows, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` from a nested list of `value_rowids` tensors. <p></p> Equivalent to: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> flat_values
						</dt>
						<dd>A potentially ragged tensor. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> nested_value_rowids
						</dt>
						<dd>A list of 1-D integer tensors.  The `i`th tensor is
used as the `value_rowids` for the `i`th ragged dimension. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> nested_nrows
						</dt>
						<dd>A list of integer scalars.  The `i`th scalar is used as the
`nrows` for the `i`th ragged dimension. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor` (or `flat_values` if `nested_value_rowids` is empty). 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = flat_values
            for (rowids, nrows) in reversed(zip(nested_value_rowids, nested_nrows)):
              result = from_value_rowids(result, rowids, nrows) </pre>
</div>
		</div>
	</div>
	<div id="from_nested_value_rowids``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_nested_value_rowids&lt;TClass&gt;</strong>(<span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> flat_values, <span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span> nested_value_rowids, <span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span> nested_nrows, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` from a nested list of `value_rowids` tensors. <p></p> Equivalent to: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> flat_values
						</dt>
						<dd>A potentially ragged tensor. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span></code> nested_value_rowids
						</dt>
						<dd>A list of 1-D integer tensors.  The `i`th tensor is
used as the `value_rowids` for the `i`th ragged dimension. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span></code> nested_nrows
						</dt>
						<dd>A list of integer scalars.  The `i`th scalar is used as the
`nrows` for the `i`th ragged dimension. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor` (or `flat_values` if `nested_value_rowids` is empty). 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = flat_values
            for (rowids, nrows) in reversed(zip(nested_value_rowids, nested_nrows)):
              result = from_value_rowids(result, rowids, nrows) </pre>
</div>
		</div>
	</div>
	<div id="from_nested_value_rowids``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_nested_value_rowids&lt;TClass&gt;</strong>(<span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> flat_values, <span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span> nested_value_rowids, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> nested_nrows, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` from a nested list of `value_rowids` tensors. <p></p> Equivalent to: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> flat_values
						</dt>
						<dd>A potentially ragged tensor. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span></code> nested_value_rowids
						</dt>
						<dd>A list of 1-D integer tensors.  The `i`th tensor is
used as the `value_rowids` for the `i`th ragged dimension. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> nested_nrows
						</dt>
						<dd>A list of integer scalars.  The `i`th scalar is used as the
`nrows` for the `i`th ragged dimension. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor` (or `flat_values` if `nested_value_rowids` is empty). 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = flat_values
            for (rowids, nrows) in reversed(zip(nested_value_rowids, nested_nrows)):
              result = from_value_rowids(result, rowids, nrows) </pre>
</div>
		</div>
	</div>
	<div id="from_nested_value_rowids``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_nested_value_rowids&lt;TClass&gt;</strong>(<span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> flat_values, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> nested_value_rowids, <span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span> nested_nrows, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` from a nested list of `value_rowids` tensors. <p></p> Equivalent to: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> flat_values
						</dt>
						<dd>A potentially ragged tensor. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> nested_value_rowids
						</dt>
						<dd>A list of 1-D integer tensors.  The `i`th tensor is
used as the `value_rowids` for the `i`th ragged dimension. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span></code> nested_nrows
						</dt>
						<dd>A list of integer scalars.  The `i`th scalar is used as the
`nrows` for the `i`th ragged dimension. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor` (or `flat_values` if `nested_value_rowids` is empty). 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = flat_values
            for (rowids, nrows) in reversed(zip(nested_value_rowids, nested_nrows)):
              result = from_value_rowids(result, rowids, nrows) </pre>
</div>
		</div>
	</div>
	<div id="from_nested_value_rowids``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_nested_value_rowids&lt;TClass&gt;</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> flat_values, <span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span> nested_value_rowids, <span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span> nested_nrows, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` from a nested list of `value_rowids` tensors. <p></p> Equivalent to: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> flat_values
						</dt>
						<dd>A potentially ragged tensor. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span></code> nested_value_rowids
						</dt>
						<dd>A list of 1-D integer tensors.  The `i`th tensor is
used as the `value_rowids` for the `i`th ragged dimension. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span></code> nested_nrows
						</dt>
						<dd>A list of integer scalars.  The `i`th scalar is used as the
`nrows` for the `i`th ragged dimension. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor` (or `flat_values` if `nested_value_rowids` is empty). 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = flat_values
            for (rowids, nrows) in reversed(zip(nested_value_rowids, nested_nrows)):
              result = from_value_rowids(result, rowids, nrows) </pre>
</div>
		</div>
	</div>
	<div id="from_nested_value_rowids``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_nested_value_rowids&lt;TClass&gt;</strong>(<span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> flat_values, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> nested_value_rowids, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> nested_nrows, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` from a nested list of `value_rowids` tensors. <p></p> Equivalent to: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> flat_values
						</dt>
						<dd>A potentially ragged tensor. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> nested_value_rowids
						</dt>
						<dd>A list of 1-D integer tensors.  The `i`th tensor is
used as the `value_rowids` for the `i`th ragged dimension. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> nested_nrows
						</dt>
						<dd>A list of integer scalars.  The `i`th scalar is used as the
`nrows` for the `i`th ragged dimension. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor` (or `flat_values` if `nested_value_rowids` is empty). 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = flat_values
            for (rowids, nrows) in reversed(zip(nested_value_rowids, nested_nrows)):
              result = from_value_rowids(result, rowids, nrows) </pre>
</div>
		</div>
	</div>
	<div id="from_nested_value_rowids``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_nested_value_rowids&lt;TClass&gt;</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> flat_values, <span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span> nested_value_rowids, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> nested_nrows, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` from a nested list of `value_rowids` tensors. <p></p> Equivalent to: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> flat_values
						</dt>
						<dd>A potentially ragged tensor. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span></code> nested_value_rowids
						</dt>
						<dd>A list of 1-D integer tensors.  The `i`th tensor is
used as the `value_rowids` for the `i`th ragged dimension. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> nested_nrows
						</dt>
						<dd>A list of integer scalars.  The `i`th scalar is used as the
`nrows` for the `i`th ragged dimension. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor` (or `flat_values` if `nested_value_rowids` is empty). 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = flat_values
            for (rowids, nrows) in reversed(zip(nested_value_rowids, nested_nrows)):
              result = from_value_rowids(result, rowids, nrows) </pre>
</div>
		</div>
	</div>
	<div id="from_nested_value_rowids``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_nested_value_rowids&lt;TClass&gt;</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> flat_values, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> nested_value_rowids, <span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span> nested_nrows, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` from a nested list of `value_rowids` tensors. <p></p> Equivalent to: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> flat_values
						</dt>
						<dd>A potentially ragged tensor. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> nested_value_rowids
						</dt>
						<dd>A list of 1-D integer tensors.  The `i`th tensor is
used as the `value_rowids` for the `i`th ragged dimension. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span></code> nested_nrows
						</dt>
						<dd>A list of integer scalars.  The `i`th scalar is used as the
`nrows` for the `i`th ragged dimension. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor` (or `flat_values` if `nested_value_rowids` is empty). 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = flat_values
            for (rowids, nrows) in reversed(zip(nested_value_rowids, nested_nrows)):
              result = from_value_rowids(result, rowids, nrows) </pre>
</div>
		</div>
	</div>
	<div id="from_row_lengths_dyn``1" class="method">
		<h4>
			<span title="System.object">object</span> <strong>from_row_lengths_dyn&lt;TClass&gt;</strong>(<span title="System.object">object</span> values, <span title="System.object">object</span> row_lengths, <span title="System.object">object</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` with rows partitioned by `row_lengths`. <p></p> The returned `RaggedTensor` corresponds with the python list defined by: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> values
						</dt>
						<dd>A potentially ragged tensor with shape `[nvals,...]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> row_lengths
						</dt>
						<dd>A 1-D integer tensor with shape `[nrows]`.  Must be
nonnegative.  `sum(row_lengths)` must be `nvals`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = values.rank + 1`.
`result.ragged_rank = values.ragged_rank + 1`. <p></p> #### Example:
```python
>>> print(tf.RaggedTensor.from_row_lengths(
...     values=[3, 1, 4, 1, 5, 9, 2, 6],
...     row_lengths=[4, 0, 3, 1, 0]))
<tf.RaggedTensor [[3, 1, 4, 1], [], [5, 9, 2], [6], []])>
``` 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = [[values.pop(0) for i in range(length)]
                      for length in row_lengths] </pre>
</div>
		</div>
	</div>
	<div id="from_row_lengths``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_row_lengths&lt;TClass&gt;</strong>(<span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> values, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> row_lengths, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` with rows partitioned by `row_lengths`. <p></p> The returned `RaggedTensor` corresponds with the python list defined by: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> values
						</dt>
						<dd>A potentially ragged tensor with shape `[nvals,...]`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> row_lengths
						</dt>
						<dd>A 1-D integer tensor with shape `[nrows]`.  Must be
nonnegative.  `sum(row_lengths)` must be `nvals`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = values.rank + 1`.
`result.ragged_rank = values.ragged_rank + 1`. <p></p> #### Example:
```python
>>> print(tf.RaggedTensor.from_row_lengths(
...     values=[3, 1, 4, 1, 5, 9, 2, 6],
...     row_lengths=[4, 0, 3, 1, 0]))
<tf.RaggedTensor [[3, 1, 4, 1], [], [5, 9, 2], [6], []])>
``` 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = [[values.pop(0) for i in range(length)]
                      for length in row_lengths] </pre>
</div>
		</div>
	</div>
	<div id="from_row_lengths``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_row_lengths&lt;TClass&gt;</strong>(<span title="System.string">string</span> values, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> row_lengths, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` with rows partitioned by `row_lengths`. <p></p> The returned `RaggedTensor` corresponds with the python list defined by: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.string">string</span></code> values
						</dt>
						<dd>A potentially ragged tensor with shape `[nvals,...]`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> row_lengths
						</dt>
						<dd>A 1-D integer tensor with shape `[nrows]`.  Must be
nonnegative.  `sum(row_lengths)` must be `nvals`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = values.rank + 1`.
`result.ragged_rank = values.ragged_rank + 1`. <p></p> #### Example:
```python
>>> print(tf.RaggedTensor.from_row_lengths(
...     values=[3, 1, 4, 1, 5, 9, 2, 6],
...     row_lengths=[4, 0, 3, 1, 0]))
<tf.RaggedTensor [[3, 1, 4, 1], [], [5, 9, 2], [6], []])>
``` 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = [[values.pop(0) for i in range(length)]
                      for length in row_lengths] </pre>
</div>
		</div>
	</div>
	<div id="from_row_lengths``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_row_lengths&lt;TClass&gt;</strong>(<span title="System.string">string</span> values, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> row_lengths, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` with rows partitioned by `row_lengths`. <p></p> The returned `RaggedTensor` corresponds with the python list defined by: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.string">string</span></code> values
						</dt>
						<dd>A potentially ragged tensor with shape `[nvals,...]`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> row_lengths
						</dt>
						<dd>A 1-D integer tensor with shape `[nrows]`.  Must be
nonnegative.  `sum(row_lengths)` must be `nvals`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = values.rank + 1`.
`result.ragged_rank = values.ragged_rank + 1`. <p></p> #### Example:
```python
>>> print(tf.RaggedTensor.from_row_lengths(
...     values=[3, 1, 4, 1, 5, 9, 2, 6],
...     row_lengths=[4, 0, 3, 1, 0]))
<tf.RaggedTensor [[3, 1, 4, 1], [], [5, 9, 2], [6], []])>
``` 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = [[values.pop(0) for i in range(length)]
                      for length in row_lengths] </pre>
</div>
		</div>
	</div>
	<div id="from_row_lengths``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_row_lengths&lt;TClass&gt;</strong>(<span title="System.object">object</span> values, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> row_lengths, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` with rows partitioned by `row_lengths`. <p></p> The returned `RaggedTensor` corresponds with the python list defined by: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> values
						</dt>
						<dd>A potentially ragged tensor with shape `[nvals,...]`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> row_lengths
						</dt>
						<dd>A 1-D integer tensor with shape `[nrows]`.  Must be
nonnegative.  `sum(row_lengths)` must be `nvals`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = values.rank + 1`.
`result.ragged_rank = values.ragged_rank + 1`. <p></p> #### Example:
```python
>>> print(tf.RaggedTensor.from_row_lengths(
...     values=[3, 1, 4, 1, 5, 9, 2, 6],
...     row_lengths=[4, 0, 3, 1, 0]))
<tf.RaggedTensor [[3, 1, 4, 1], [], [5, 9, 2], [6], []])>
``` 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = [[values.pop(0) for i in range(length)]
                      for length in row_lengths] </pre>
</div>
		</div>
	</div>
	<div id="from_row_lengths``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_row_lengths&lt;TClass&gt;</strong>(<span title="System.object">object</span> values, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> row_lengths, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` with rows partitioned by `row_lengths`. <p></p> The returned `RaggedTensor` corresponds with the python list defined by: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> values
						</dt>
						<dd>A potentially ragged tensor with shape `[nvals,...]`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> row_lengths
						</dt>
						<dd>A 1-D integer tensor with shape `[nrows]`.  Must be
nonnegative.  `sum(row_lengths)` must be `nvals`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = values.rank + 1`.
`result.ragged_rank = values.ragged_rank + 1`. <p></p> #### Example:
```python
>>> print(tf.RaggedTensor.from_row_lengths(
...     values=[3, 1, 4, 1, 5, 9, 2, 6],
...     row_lengths=[4, 0, 3, 1, 0]))
<tf.RaggedTensor [[3, 1, 4, 1], [], [5, 9, 2], [6], []])>
``` 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = [[values.pop(0) for i in range(length)]
                      for length in row_lengths] </pre>
</div>
		</div>
	</div>
	<div id="from_row_lengths``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_row_lengths&lt;TClass&gt;</strong>(<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> values, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> row_lengths, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` with rows partitioned by `row_lengths`. <p></p> The returned `RaggedTensor` corresponds with the python list defined by: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code> values
						</dt>
						<dd>A potentially ragged tensor with shape `[nvals,...]`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> row_lengths
						</dt>
						<dd>A 1-D integer tensor with shape `[nrows]`.  Must be
nonnegative.  `sum(row_lengths)` must be `nvals`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = values.rank + 1`.
`result.ragged_rank = values.ragged_rank + 1`. <p></p> #### Example:
```python
>>> print(tf.RaggedTensor.from_row_lengths(
...     values=[3, 1, 4, 1, 5, 9, 2, 6],
...     row_lengths=[4, 0, 3, 1, 0]))
<tf.RaggedTensor [[3, 1, 4, 1], [], [5, 9, 2], [6], []])>
``` 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = [[values.pop(0) for i in range(length)]
                      for length in row_lengths] </pre>
</div>
		</div>
	</div>
	<div id="from_row_lengths``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_row_lengths&lt;TClass&gt;</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> values, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> row_lengths, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` with rows partitioned by `row_lengths`. <p></p> The returned `RaggedTensor` corresponds with the python list defined by: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> values
						</dt>
						<dd>A potentially ragged tensor with shape `[nvals,...]`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> row_lengths
						</dt>
						<dd>A 1-D integer tensor with shape `[nrows]`.  Must be
nonnegative.  `sum(row_lengths)` must be `nvals`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = values.rank + 1`.
`result.ragged_rank = values.ragged_rank + 1`. <p></p> #### Example:
```python
>>> print(tf.RaggedTensor.from_row_lengths(
...     values=[3, 1, 4, 1, 5, 9, 2, 6],
...     row_lengths=[4, 0, 3, 1, 0]))
<tf.RaggedTensor [[3, 1, 4, 1], [], [5, 9, 2], [6], []])>
``` 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = [[values.pop(0) for i in range(length)]
                      for length in row_lengths] </pre>
</div>
		</div>
	</div>
	<div id="from_row_lengths``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_row_lengths&lt;TClass&gt;</strong>(<a href="../tensorflow/DType.htm">DType</a> values, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> row_lengths, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` with rows partitioned by `row_lengths`. <p></p> The returned `RaggedTensor` corresponds with the python list defined by: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/DType.htm">DType</a></code> values
						</dt>
						<dd>A potentially ragged tensor with shape `[nvals,...]`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> row_lengths
						</dt>
						<dd>A 1-D integer tensor with shape `[nrows]`.  Must be
nonnegative.  `sum(row_lengths)` must be `nvals`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = values.rank + 1`.
`result.ragged_rank = values.ragged_rank + 1`. <p></p> #### Example:
```python
>>> print(tf.RaggedTensor.from_row_lengths(
...     values=[3, 1, 4, 1, 5, 9, 2, 6],
...     row_lengths=[4, 0, 3, 1, 0]))
<tf.RaggedTensor [[3, 1, 4, 1], [], [5, 9, 2], [6], []])>
``` 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = [[values.pop(0) for i in range(length)]
                      for length in row_lengths] </pre>
</div>
		</div>
	</div>
	<div id="from_row_lengths``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_row_lengths&lt;TClass&gt;</strong>(<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> values, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> row_lengths, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` with rows partitioned by `row_lengths`. <p></p> The returned `RaggedTensor` corresponds with the python list defined by: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code> values
						</dt>
						<dd>A potentially ragged tensor with shape `[nvals,...]`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> row_lengths
						</dt>
						<dd>A 1-D integer tensor with shape `[nrows]`.  Must be
nonnegative.  `sum(row_lengths)` must be `nvals`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = values.rank + 1`.
`result.ragged_rank = values.ragged_rank + 1`. <p></p> #### Example:
```python
>>> print(tf.RaggedTensor.from_row_lengths(
...     values=[3, 1, 4, 1, 5, 9, 2, 6],
...     row_lengths=[4, 0, 3, 1, 0]))
<tf.RaggedTensor [[3, 1, 4, 1], [], [5, 9, 2], [6], []])>
``` 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = [[values.pop(0) for i in range(length)]
                      for length in row_lengths] </pre>
</div>
		</div>
	</div>
	<div id="from_row_lengths``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_row_lengths&lt;TClass&gt;</strong>(<span title="System.int">int</span> values, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> row_lengths, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` with rows partitioned by `row_lengths`. <p></p> The returned `RaggedTensor` corresponds with the python list defined by: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> values
						</dt>
						<dd>A potentially ragged tensor with shape `[nvals,...]`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> row_lengths
						</dt>
						<dd>A 1-D integer tensor with shape `[nrows]`.  Must be
nonnegative.  `sum(row_lengths)` must be `nvals`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = values.rank + 1`.
`result.ragged_rank = values.ragged_rank + 1`. <p></p> #### Example:
```python
>>> print(tf.RaggedTensor.from_row_lengths(
...     values=[3, 1, 4, 1, 5, 9, 2, 6],
...     row_lengths=[4, 0, 3, 1, 0]))
<tf.RaggedTensor [[3, 1, 4, 1], [], [5, 9, 2], [6], []])>
``` 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = [[values.pop(0) for i in range(length)]
                      for length in row_lengths] </pre>
</div>
		</div>
	</div>
	<div id="from_row_lengths``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_row_lengths&lt;TClass&gt;</strong>(<span title="System.int">int</span> values, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> row_lengths, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` with rows partitioned by `row_lengths`. <p></p> The returned `RaggedTensor` corresponds with the python list defined by: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> values
						</dt>
						<dd>A potentially ragged tensor with shape `[nvals,...]`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> row_lengths
						</dt>
						<dd>A 1-D integer tensor with shape `[nrows]`.  Must be
nonnegative.  `sum(row_lengths)` must be `nvals`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = values.rank + 1`.
`result.ragged_rank = values.ragged_rank + 1`. <p></p> #### Example:
```python
>>> print(tf.RaggedTensor.from_row_lengths(
...     values=[3, 1, 4, 1, 5, 9, 2, 6],
...     row_lengths=[4, 0, 3, 1, 0]))
<tf.RaggedTensor [[3, 1, 4, 1], [], [5, 9, 2], [6], []])>
``` 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = [[values.pop(0) for i in range(length)]
                      for length in row_lengths] </pre>
</div>
		</div>
	</div>
	<div id="from_row_lengths``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_row_lengths&lt;TClass&gt;</strong>(<span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> values, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> row_lengths, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` with rows partitioned by `row_lengths`. <p></p> The returned `RaggedTensor` corresponds with the python list defined by: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> values
						</dt>
						<dd>A potentially ragged tensor with shape `[nvals,...]`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> row_lengths
						</dt>
						<dd>A 1-D integer tensor with shape `[nrows]`.  Must be
nonnegative.  `sum(row_lengths)` must be `nvals`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = values.rank + 1`.
`result.ragged_rank = values.ragged_rank + 1`. <p></p> #### Example:
```python
>>> print(tf.RaggedTensor.from_row_lengths(
...     values=[3, 1, 4, 1, 5, 9, 2, 6],
...     row_lengths=[4, 0, 3, 1, 0]))
<tf.RaggedTensor [[3, 1, 4, 1], [], [5, 9, 2], [6], []])>
``` 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = [[values.pop(0) for i in range(length)]
                      for length in row_lengths] </pre>
</div>
		</div>
	</div>
	<div id="from_row_lengths``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_row_lengths&lt;TClass&gt;</strong>(<a href="../tensorflow/DType.htm">DType</a> values, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> row_lengths, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` with rows partitioned by `row_lengths`. <p></p> The returned `RaggedTensor` corresponds with the python list defined by: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/DType.htm">DType</a></code> values
						</dt>
						<dd>A potentially ragged tensor with shape `[nvals,...]`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> row_lengths
						</dt>
						<dd>A 1-D integer tensor with shape `[nrows]`.  Must be
nonnegative.  `sum(row_lengths)` must be `nvals`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = values.rank + 1`.
`result.ragged_rank = values.ragged_rank + 1`. <p></p> #### Example:
```python
>>> print(tf.RaggedTensor.from_row_lengths(
...     values=[3, 1, 4, 1, 5, 9, 2, 6],
...     row_lengths=[4, 0, 3, 1, 0]))
<tf.RaggedTensor [[3, 1, 4, 1], [], [5, 9, 2], [6], []])>
``` 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = [[values.pop(0) for i in range(length)]
                      for length in row_lengths] </pre>
</div>
		</div>
	</div>
	<div id="from_row_lengths``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_row_lengths&lt;TClass&gt;</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> values, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> row_lengths, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` with rows partitioned by `row_lengths`. <p></p> The returned `RaggedTensor` corresponds with the python list defined by: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> values
						</dt>
						<dd>A potentially ragged tensor with shape `[nvals,...]`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> row_lengths
						</dt>
						<dd>A 1-D integer tensor with shape `[nrows]`.  Must be
nonnegative.  `sum(row_lengths)` must be `nvals`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = values.rank + 1`.
`result.ragged_rank = values.ragged_rank + 1`. <p></p> #### Example:
```python
>>> print(tf.RaggedTensor.from_row_lengths(
...     values=[3, 1, 4, 1, 5, 9, 2, 6],
...     row_lengths=[4, 0, 3, 1, 0]))
<tf.RaggedTensor [[3, 1, 4, 1], [], [5, 9, 2], [6], []])>
``` 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = [[values.pop(0) for i in range(length)]
                      for length in row_lengths] </pre>
</div>
		</div>
	</div>
	<div id="from_row_limits_dyn``1" class="method">
		<h4>
			<span title="System.object">object</span> <strong>from_row_limits_dyn&lt;TClass&gt;</strong>(<span title="System.object">object</span> values, <span title="System.object">object</span> row_limits, <span title="System.object">object</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` with rows partitioned by `row_limits`. <p></p> Equivalent to: `from_row_splits(values, concat([0, row_limits]))`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> values
						</dt>
						<dd>A potentially ragged tensor with shape `[nvals,...]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> row_limits
						</dt>
						<dd>A 1-D integer tensor with shape `[nrows]`.  Must be sorted in
ascending order.  If `nrows>0`, then `row_limits[-1]` must be `nvals`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = values.rank + 1`.
`result.ragged_rank = values.ragged_rank + 1`. <p></p> #### Example:
```python
>>> print(tf.RaggedTensor.from_row_limits(
...     values=[3, 1, 4, 1, 5, 9, 2, 6],
...     row_limits=[4, 4, 7, 8, 8]))
<tf.RaggedTensor [[3, 1, 4, 1], [], [5, 9, 2], [6], []]>
``` 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="from_row_limits``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_row_limits&lt;TClass&gt;</strong>(<span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> values, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> row_limits, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` with rows partitioned by `row_limits`. <p></p> Equivalent to: `from_row_splits(values, concat([0, row_limits]))`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> values
						</dt>
						<dd>A potentially ragged tensor with shape `[nvals,...]`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> row_limits
						</dt>
						<dd>A 1-D integer tensor with shape `[nrows]`.  Must be sorted in
ascending order.  If `nrows>0`, then `row_limits[-1]` must be `nvals`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = values.rank + 1`.
`result.ragged_rank = values.ragged_rank + 1`. <p></p> #### Example:
```python
>>> print(tf.RaggedTensor.from_row_limits(
...     values=[3, 1, 4, 1, 5, 9, 2, 6],
...     row_limits=[4, 4, 7, 8, 8]))
<tf.RaggedTensor [[3, 1, 4, 1], [], [5, 9, 2], [6], []]>
``` 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="from_row_limits``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_row_limits&lt;TClass&gt;</strong>(<span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> values, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> row_limits, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` with rows partitioned by `row_limits`. <p></p> Equivalent to: `from_row_splits(values, concat([0, row_limits]))`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> values
						</dt>
						<dd>A potentially ragged tensor with shape `[nvals,...]`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> row_limits
						</dt>
						<dd>A 1-D integer tensor with shape `[nrows]`.  Must be sorted in
ascending order.  If `nrows>0`, then `row_limits[-1]` must be `nvals`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = values.rank + 1`.
`result.ragged_rank = values.ragged_rank + 1`. <p></p> #### Example:
```python
>>> print(tf.RaggedTensor.from_row_limits(
...     values=[3, 1, 4, 1, 5, 9, 2, 6],
...     row_limits=[4, 4, 7, 8, 8]))
<tf.RaggedTensor [[3, 1, 4, 1], [], [5, 9, 2], [6], []]>
``` 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="from_row_limits``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_row_limits&lt;TClass&gt;</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> values, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> row_limits, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` with rows partitioned by `row_limits`. <p></p> Equivalent to: `from_row_splits(values, concat([0, row_limits]))`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> values
						</dt>
						<dd>A potentially ragged tensor with shape `[nvals,...]`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> row_limits
						</dt>
						<dd>A 1-D integer tensor with shape `[nrows]`.  Must be sorted in
ascending order.  If `nrows>0`, then `row_limits[-1]` must be `nvals`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = values.rank + 1`.
`result.ragged_rank = values.ragged_rank + 1`. <p></p> #### Example:
```python
>>> print(tf.RaggedTensor.from_row_limits(
...     values=[3, 1, 4, 1, 5, 9, 2, 6],
...     row_limits=[4, 4, 7, 8, 8]))
<tf.RaggedTensor [[3, 1, 4, 1], [], [5, 9, 2], [6], []]>
``` 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="from_row_limits``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_row_limits&lt;TClass&gt;</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> values, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> row_limits, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` with rows partitioned by `row_limits`. <p></p> Equivalent to: `from_row_splits(values, concat([0, row_limits]))`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> values
						</dt>
						<dd>A potentially ragged tensor with shape `[nvals,...]`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> row_limits
						</dt>
						<dd>A 1-D integer tensor with shape `[nrows]`.  Must be sorted in
ascending order.  If `nrows>0`, then `row_limits[-1]` must be `nvals`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = values.rank + 1`.
`result.ragged_rank = values.ragged_rank + 1`. <p></p> #### Example:
```python
>>> print(tf.RaggedTensor.from_row_limits(
...     values=[3, 1, 4, 1, 5, 9, 2, 6],
...     row_limits=[4, 4, 7, 8, 8]))
<tf.RaggedTensor [[3, 1, 4, 1], [], [5, 9, 2], [6], []]>
``` 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="from_row_splits_dyn``1" class="method">
		<h4>
			<span title="System.object">object</span> <strong>from_row_splits_dyn&lt;TClass&gt;</strong>(<span title="System.object">object</span> values, <span title="System.object">object</span> row_splits, <span title="System.object">object</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` with rows partitioned by `row_splits`. <p></p> The returned `RaggedTensor` corresponds with the python list defined by: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> values
						</dt>
						<dd>A potentially ragged tensor with shape `[nvals,...]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> row_splits
						</dt>
						<dd>A 1-D integer tensor with shape `[nrows+1]`.  Must not be
empty, and must be sorted in ascending order.  `row_splits[0]` must be
zero and `row_splits[-1]` must be `nvals`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = values.rank + 1`.
`result.ragged_rank = values.ragged_rank + 1`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = [values[row_splits[i]:row_splits[i + 1]]
                      for i in range(len(row_splits) - 1)] </pre>
</div>
		</div>
	</div>
	<div id="from_row_splits``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_row_splits&lt;TClass&gt;</strong>(<span title="System.object">object</span> values, <span title="System.ValueTuple<IEnumerable<object>, object>">ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;</span> row_splits, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` with rows partitioned by `row_splits`. <p></p> The returned `RaggedTensor` corresponds with the python list defined by: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> values
						</dt>
						<dd>A potentially ragged tensor with shape `[nvals,...]`. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<IEnumerable<object>, object>">ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;</span></code> row_splits
						</dt>
						<dd>A 1-D integer tensor with shape `[nrows+1]`.  Must not be
empty, and must be sorted in ascending order.  `row_splits[0]` must be
zero and `row_splits[-1]` must be `nvals`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = values.rank + 1`.
`result.ragged_rank = values.ragged_rank + 1`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = [values[row_splits[i]:row_splits[i + 1]]
                      for i in range(len(row_splits) - 1)] </pre>
</div>
		</div>
	</div>
	<div id="from_row_splits``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_row_splits&lt;TClass&gt;</strong>(<span title="System.object">object</span> values, <a href="../tensorflow/TensorSpec.htm">TensorSpec</a> row_splits, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` with rows partitioned by `row_splits`. <p></p> The returned `RaggedTensor` corresponds with the python list defined by: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> values
						</dt>
						<dd>A potentially ragged tensor with shape `[nvals,...]`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/TensorSpec.htm">TensorSpec</a></code> row_splits
						</dt>
						<dd>A 1-D integer tensor with shape `[nrows+1]`.  Must not be
empty, and must be sorted in ascending order.  `row_splits[0]` must be
zero and `row_splits[-1]` must be `nvals`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = values.rank + 1`.
`result.ragged_rank = values.ragged_rank + 1`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = [values[row_splits[i]:row_splits[i + 1]]
                      for i in range(len(row_splits) - 1)] </pre>
</div>
		</div>
	</div>
	<div id="from_row_splits``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_row_splits&lt;TClass&gt;</strong>(<span title="System.object">object</span> values, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> row_splits, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` with rows partitioned by `row_splits`. <p></p> The returned `RaggedTensor` corresponds with the python list defined by: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> values
						</dt>
						<dd>A potentially ragged tensor with shape `[nvals,...]`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> row_splits
						</dt>
						<dd>A 1-D integer tensor with shape `[nrows+1]`.  Must not be
empty, and must be sorted in ascending order.  `row_splits[0]` must be
zero and `row_splits[-1]` must be `nvals`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = values.rank + 1`.
`result.ragged_rank = values.ragged_rank + 1`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = [values[row_splits[i]:row_splits[i + 1]]
                      for i in range(len(row_splits) - 1)] </pre>
</div>
		</div>
	</div>
	<div id="from_row_splits``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_row_splits&lt;TClass&gt;</strong>(<span title="System.object">object</span> values, <a href="../numpy/ndarray.htm">ndarray</a> row_splits, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` with rows partitioned by `row_splits`. <p></p> The returned `RaggedTensor` corresponds with the python list defined by: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> values
						</dt>
						<dd>A potentially ragged tensor with shape `[nvals,...]`. 
						</dd>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> row_splits
						</dt>
						<dd>A 1-D integer tensor with shape `[nrows+1]`.  Must not be
empty, and must be sorted in ascending order.  `row_splits[0]` must be
zero and `row_splits[-1]` must be `nvals`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = values.rank + 1`.
`result.ragged_rank = values.ragged_rank + 1`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = [values[row_splits[i]:row_splits[i + 1]]
                      for i in range(len(row_splits) - 1)] </pre>
</div>
		</div>
	</div>
	<div id="from_row_splits``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_row_splits&lt;TClass&gt;</strong>(<span title="System.object">object</span> values, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> row_splits, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` with rows partitioned by `row_splits`. <p></p> The returned `RaggedTensor` corresponds with the python list defined by: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> values
						</dt>
						<dd>A potentially ragged tensor with shape `[nvals,...]`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> row_splits
						</dt>
						<dd>A 1-D integer tensor with shape `[nrows+1]`.  Must not be
empty, and must be sorted in ascending order.  `row_splits[0]` must be
zero and `row_splits[-1]` must be `nvals`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = values.rank + 1`.
`result.ragged_rank = values.ragged_rank + 1`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = [values[row_splits[i]:row_splits[i + 1]]
                      for i in range(len(row_splits) - 1)] </pre>
</div>
		</div>
	</div>
	<div id="from_row_starts_dyn``1" class="method">
		<h4>
			<span title="System.object">object</span> <strong>from_row_starts_dyn&lt;TClass&gt;</strong>(<span title="System.object">object</span> values, <span title="System.object">object</span> row_starts, <span title="System.object">object</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` with rows partitioned by `row_starts`. <p></p> Equivalent to: `from_row_splits(values, concat([row_starts, nvals]))`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> values
						</dt>
						<dd>A potentially ragged tensor with shape `[nvals,...]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> row_starts
						</dt>
						<dd>A 1-D integer tensor with shape `[nrows]`.  Must be
nonnegative and sorted in ascending order.  If `nrows>0`, then
`row_starts[0]` must be zero. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = values.rank + 1`.
`result.ragged_rank = values.ragged_rank + 1`. <p></p> #### Example:
```python
>>> print(tf.RaggedTensor.from_row_starts(
...     values=[3, 1, 4, 1, 5, 9, 2, 6],
...     row_starts=[0, 4, 4, 7, 8]))
<tf.RaggedTensor [[3, 1, 4, 1], [], [5, 9, 2], [6], []]>
``` 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="from_row_starts``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_row_starts&lt;TClass&gt;</strong>(<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> values, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> row_starts, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` with rows partitioned by `row_starts`. <p></p> Equivalent to: `from_row_splits(values, concat([row_starts, nvals]))`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code> values
						</dt>
						<dd>A potentially ragged tensor with shape `[nvals,...]`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> row_starts
						</dt>
						<dd>A 1-D integer tensor with shape `[nrows]`.  Must be
nonnegative and sorted in ascending order.  If `nrows>0`, then
`row_starts[0]` must be zero. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = values.rank + 1`.
`result.ragged_rank = values.ragged_rank + 1`. <p></p> #### Example:
```python
>>> print(tf.RaggedTensor.from_row_starts(
...     values=[3, 1, 4, 1, 5, 9, 2, 6],
...     row_starts=[0, 4, 4, 7, 8]))
<tf.RaggedTensor [[3, 1, 4, 1], [], [5, 9, 2], [6], []]>
``` 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="from_row_starts``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_row_starts&lt;TClass&gt;</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> values, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> row_starts, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` with rows partitioned by `row_starts`. <p></p> Equivalent to: `from_row_splits(values, concat([row_starts, nvals]))`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> values
						</dt>
						<dd>A potentially ragged tensor with shape `[nvals,...]`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> row_starts
						</dt>
						<dd>A 1-D integer tensor with shape `[nrows]`.  Must be
nonnegative and sorted in ascending order.  If `nrows>0`, then
`row_starts[0]` must be zero. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = values.rank + 1`.
`result.ragged_rank = values.ragged_rank + 1`. <p></p> #### Example:
```python
>>> print(tf.RaggedTensor.from_row_starts(
...     values=[3, 1, 4, 1, 5, 9, 2, 6],
...     row_starts=[0, 4, 4, 7, 8]))
<tf.RaggedTensor [[3, 1, 4, 1], [], [5, 9, 2], [6], []]>
``` 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="from_row_starts``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_row_starts&lt;TClass&gt;</strong>(<a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> values, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> row_starts, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` with rows partitioned by `row_starts`. <p></p> Equivalent to: `from_row_splits(values, concat([row_starts, nvals]))`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> values
						</dt>
						<dd>A potentially ragged tensor with shape `[nvals,...]`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> row_starts
						</dt>
						<dd>A 1-D integer tensor with shape `[nrows]`.  Must be
nonnegative and sorted in ascending order.  If `nrows>0`, then
`row_starts[0]` must be zero. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = values.rank + 1`.
`result.ragged_rank = values.ragged_rank + 1`. <p></p> #### Example:
```python
>>> print(tf.RaggedTensor.from_row_starts(
...     values=[3, 1, 4, 1, 5, 9, 2, 6],
...     row_starts=[0, 4, 4, 7, 8]))
<tf.RaggedTensor [[3, 1, 4, 1], [], [5, 9, 2], [6], []]>
``` 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="from_row_starts``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_row_starts&lt;TClass&gt;</strong>(<span title="System.int">int</span> values, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> row_starts, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` with rows partitioned by `row_starts`. <p></p> Equivalent to: `from_row_splits(values, concat([row_starts, nvals]))`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> values
						</dt>
						<dd>A potentially ragged tensor with shape `[nvals,...]`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> row_starts
						</dt>
						<dd>A 1-D integer tensor with shape `[nrows]`.  Must be
nonnegative and sorted in ascending order.  If `nrows>0`, then
`row_starts[0]` must be zero. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = values.rank + 1`.
`result.ragged_rank = values.ragged_rank + 1`. <p></p> #### Example:
```python
>>> print(tf.RaggedTensor.from_row_starts(
...     values=[3, 1, 4, 1, 5, 9, 2, 6],
...     row_starts=[0, 4, 4, 7, 8]))
<tf.RaggedTensor [[3, 1, 4, 1], [], [5, 9, 2], [6], []]>
``` 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="from_row_starts``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_row_starts&lt;TClass&gt;</strong>(<a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> values, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> row_starts, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` with rows partitioned by `row_starts`. <p></p> Equivalent to: `from_row_splits(values, concat([row_starts, nvals]))`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> values
						</dt>
						<dd>A potentially ragged tensor with shape `[nvals,...]`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> row_starts
						</dt>
						<dd>A 1-D integer tensor with shape `[nrows]`.  Must be
nonnegative and sorted in ascending order.  If `nrows>0`, then
`row_starts[0]` must be zero. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = values.rank + 1`.
`result.ragged_rank = values.ragged_rank + 1`. <p></p> #### Example:
```python
>>> print(tf.RaggedTensor.from_row_starts(
...     values=[3, 1, 4, 1, 5, 9, 2, 6],
...     row_starts=[0, 4, 4, 7, 8]))
<tf.RaggedTensor [[3, 1, 4, 1], [], [5, 9, 2], [6], []]>
``` 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="from_row_starts``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_row_starts&lt;TClass&gt;</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> values, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> row_starts, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` with rows partitioned by `row_starts`. <p></p> Equivalent to: `from_row_splits(values, concat([row_starts, nvals]))`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> values
						</dt>
						<dd>A potentially ragged tensor with shape `[nvals,...]`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> row_starts
						</dt>
						<dd>A 1-D integer tensor with shape `[nrows]`.  Must be
nonnegative and sorted in ascending order.  If `nrows>0`, then
`row_starts[0]` must be zero. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = values.rank + 1`.
`result.ragged_rank = values.ragged_rank + 1`. <p></p> #### Example:
```python
>>> print(tf.RaggedTensor.from_row_starts(
...     values=[3, 1, 4, 1, 5, 9, 2, 6],
...     row_starts=[0, 4, 4, 7, 8]))
<tf.RaggedTensor [[3, 1, 4, 1], [], [5, 9, 2], [6], []]>
``` 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="from_row_starts``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_row_starts&lt;TClass&gt;</strong>(<a href="../tensorflow.test/TestCase.htm">TestCase</a> values, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> row_starts, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` with rows partitioned by `row_starts`. <p></p> Equivalent to: `from_row_splits(values, concat([row_starts, nvals]))`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow.test/TestCase.htm">TestCase</a></code> values
						</dt>
						<dd>A potentially ragged tensor with shape `[nvals,...]`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> row_starts
						</dt>
						<dd>A 1-D integer tensor with shape `[nrows]`.  Must be
nonnegative and sorted in ascending order.  If `nrows>0`, then
`row_starts[0]` must be zero. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = values.rank + 1`.
`result.ragged_rank = values.ragged_rank + 1`. <p></p> #### Example:
```python
>>> print(tf.RaggedTensor.from_row_starts(
...     values=[3, 1, 4, 1, 5, 9, 2, 6],
...     row_starts=[0, 4, 4, 7, 8]))
<tf.RaggedTensor [[3, 1, 4, 1], [], [5, 9, 2], [6], []]>
``` 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="from_row_starts``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_row_starts&lt;TClass&gt;</strong>(<span title="System.int">int</span> values, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> row_starts, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` with rows partitioned by `row_starts`. <p></p> Equivalent to: `from_row_splits(values, concat([row_starts, nvals]))`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> values
						</dt>
						<dd>A potentially ragged tensor with shape `[nvals,...]`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> row_starts
						</dt>
						<dd>A 1-D integer tensor with shape `[nrows]`.  Must be
nonnegative and sorted in ascending order.  If `nrows>0`, then
`row_starts[0]` must be zero. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = values.rank + 1`.
`result.ragged_rank = values.ragged_rank + 1`. <p></p> #### Example:
```python
>>> print(tf.RaggedTensor.from_row_starts(
...     values=[3, 1, 4, 1, 5, 9, 2, 6],
...     row_starts=[0, 4, 4, 7, 8]))
<tf.RaggedTensor [[3, 1, 4, 1], [], [5, 9, 2], [6], []]>
``` 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="from_row_starts``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_row_starts&lt;TClass&gt;</strong>(<a href="../tensorflow.test/TestCase.htm">TestCase</a> values, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> row_starts, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` with rows partitioned by `row_starts`. <p></p> Equivalent to: `from_row_splits(values, concat([row_starts, nvals]))`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow.test/TestCase.htm">TestCase</a></code> values
						</dt>
						<dd>A potentially ragged tensor with shape `[nvals,...]`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> row_starts
						</dt>
						<dd>A 1-D integer tensor with shape `[nrows]`.  Must be
nonnegative and sorted in ascending order.  If `nrows>0`, then
`row_starts[0]` must be zero. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = values.rank + 1`.
`result.ragged_rank = values.ragged_rank + 1`. <p></p> #### Example:
```python
>>> print(tf.RaggedTensor.from_row_starts(
...     values=[3, 1, 4, 1, 5, 9, 2, 6],
...     row_starts=[0, 4, 4, 7, 8]))
<tf.RaggedTensor [[3, 1, 4, 1], [], [5, 9, 2], [6], []]>
``` 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="from_row_starts``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_row_starts&lt;TClass&gt;</strong>(<span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> values, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> row_starts, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` with rows partitioned by `row_starts`. <p></p> Equivalent to: `from_row_splits(values, concat([row_starts, nvals]))`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> values
						</dt>
						<dd>A potentially ragged tensor with shape `[nvals,...]`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> row_starts
						</dt>
						<dd>A 1-D integer tensor with shape `[nrows]`.  Must be
nonnegative and sorted in ascending order.  If `nrows>0`, then
`row_starts[0]` must be zero. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = values.rank + 1`.
`result.ragged_rank = values.ragged_rank + 1`. <p></p> #### Example:
```python
>>> print(tf.RaggedTensor.from_row_starts(
...     values=[3, 1, 4, 1, 5, 9, 2, 6],
...     row_starts=[0, 4, 4, 7, 8]))
<tf.RaggedTensor [[3, 1, 4, 1], [], [5, 9, 2], [6], []]>
``` 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="from_row_starts``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_row_starts&lt;TClass&gt;</strong>(<span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> values, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> row_starts, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` with rows partitioned by `row_starts`. <p></p> Equivalent to: `from_row_splits(values, concat([row_starts, nvals]))`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> values
						</dt>
						<dd>A potentially ragged tensor with shape `[nvals,...]`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> row_starts
						</dt>
						<dd>A 1-D integer tensor with shape `[nrows]`.  Must be
nonnegative and sorted in ascending order.  If `nrows>0`, then
`row_starts[0]` must be zero. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = values.rank + 1`.
`result.ragged_rank = values.ragged_rank + 1`. <p></p> #### Example:
```python
>>> print(tf.RaggedTensor.from_row_starts(
...     values=[3, 1, 4, 1, 5, 9, 2, 6],
...     row_starts=[0, 4, 4, 7, 8]))
<tf.RaggedTensor [[3, 1, 4, 1], [], [5, 9, 2], [6], []]>
``` 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="from_row_starts``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_row_starts&lt;TClass&gt;</strong>(<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> values, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> row_starts, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` with rows partitioned by `row_starts`. <p></p> Equivalent to: `from_row_splits(values, concat([row_starts, nvals]))`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code> values
						</dt>
						<dd>A potentially ragged tensor with shape `[nvals,...]`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> row_starts
						</dt>
						<dd>A 1-D integer tensor with shape `[nrows]`.  Must be
nonnegative and sorted in ascending order.  If `nrows>0`, then
`row_starts[0]` must be zero. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = values.rank + 1`.
`result.ragged_rank = values.ragged_rank + 1`. <p></p> #### Example:
```python
>>> print(tf.RaggedTensor.from_row_starts(
...     values=[3, 1, 4, 1, 5, 9, 2, 6],
...     row_starts=[0, 4, 4, 7, 8]))
<tf.RaggedTensor [[3, 1, 4, 1], [], [5, 9, 2], [6], []]>
``` 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="from_sparse_dyn``1" class="method">
		<h4>
			<span title="System.object">object</span> <strong>from_sparse_dyn&lt;TClass&gt;</strong>(<span title="System.object">object</span> st_input, <span title="System.object">object</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> row_splits_dtype)
		</h4>
		<div class="content">Converts a 2D <a href="..\tf\sparse\SparseTensor.md"><code>tf.SparseTensor</code></a> to a `RaggedTensor`. <p></p> Each row of the `output` `RaggedTensor` will contain the explicit values
from the same row in `st_input`.  `st_input` must be ragged-right.  If not
it is not ragged-right, then an error will be generated. <p></p> Example:
Currently, only two-dimensional `SparseTensors` are supported. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> st_input
						</dt>
						<dd>The sparse tensor to convert.  Must have rank 2. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>A name prefix for the returned tensors (optional). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> row_splits_dtype
						</dt>
						<dd>`dtype` for the returned `RaggedTensor`'s `row_splits`
tensor.  One of <a href="..\tf\dtypes\int32.md"><code>tf.int32</code></a> or <a href="..\tf\dtypes\int64.md"><code>tf.int64</code></a>. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `RaggedTensor` with the same values as `st_input`.
`output.ragged_rank = rank(st_input) - 1`.
`output.shape = [st_input.dense_shape[0], None]`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> st = SparseTensor(indices=[[0, 1], [0, 2], [0, 3], [1, 0], [3, 0]],
           ...                   values=[1, 2, 3, 4, 5],
           ...                   dense_shape=[4, 3])
            >>> rt.RaggedTensor.from_sparse(st).eval().tolist()
            [[1, 2, 3], [4], [], [5]] </pre>
</div>
		</div>
	</div>
	<div id="from_sparse``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_sparse&lt;TClass&gt;</strong>(<a href="../tensorflow/SparseTensor.htm">SparseTensor</a> st_input, <span title="System.string">string</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> row_splits_dtype)
		</h4>
		<div class="content">Converts a 2D <a href="..\tf\sparse\SparseTensor.md"><code>tf.SparseTensor</code></a> to a `RaggedTensor`. <p></p> Each row of the `output` `RaggedTensor` will contain the explicit values
from the same row in `st_input`.  `st_input` must be ragged-right.  If not
it is not ragged-right, then an error will be generated. <p></p> Example:
Currently, only two-dimensional `SparseTensors` are supported. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/SparseTensor.htm">SparseTensor</a></code> st_input
						</dt>
						<dd>The sparse tensor to convert.  Must have rank 2. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensors (optional). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> row_splits_dtype
						</dt>
						<dd>`dtype` for the returned `RaggedTensor`'s `row_splits`
tensor.  One of <a href="..\tf\dtypes\int32.md"><code>tf.int32</code></a> or <a href="..\tf\dtypes\int64.md"><code>tf.int64</code></a>. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor` with the same values as `st_input`.
`output.ragged_rank = rank(st_input) - 1`.
`output.shape = [st_input.dense_shape[0], None]`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> st = SparseTensor(indices=[[0, 1], [0, 2], [0, 3], [1, 0], [3, 0]],
           ...                   values=[1, 2, 3, 4, 5],
           ...                   dense_shape=[4, 3])
            >>> rt.RaggedTensor.from_sparse(st).eval().tolist()
            [[1, 2, 3], [4], [], [5]] </pre>
</div>
		</div>
	</div>
	<div id="from_tensor_dyn``1" class="method">
		<h4>
			<span title="System.object">object</span> <strong>from_tensor_dyn&lt;TClass&gt;</strong>(<span title="System.object">object</span> tensor, <span title="System.object">object</span> lengths, <span title="System.object">object</span> padding, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> ragged_rank, <span title="System.object">object</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> row_splits_dtype)
		</h4>
		<div class="content">Converts a <a href="..\tf\Tensor.md"><code>tf.Tensor</code></a> into a `RaggedTensor`. <p></p> The set of absent/default values may be specified using a vector of lengths
or a padding value (but not both).  If `lengths` is specified, then the
output tensor will satisfy `output[row] = tensor[row][:lengths[row]]`. If
'lengths' is a list of lists or tuple of lists, those lists will be used
as nested row lengths. If `padding` is specified, then any row *suffix*
consisting entirely of `padding` will be excluded from the returned
`RaggedTensor`.  If neither `lengths` nor `padding` is specified, then the
returned `RaggedTensor` will have no absent/default values. <p></p> Examples: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> tensor
						</dt>
						<dd>The `Tensor` to convert.  Must have rank `ragged_rank + 1` or
higher. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> lengths
						</dt>
						<dd>An optional set of row lengths, specified using a 1-D integer
`Tensor` whose length is equal to `tensor.shape[0]` (the number of rows
in `tensor`).  If specified, then `output[row]` will contain
`tensor[row][:lengths[row]]`.  Negative lengths are treated as zero. You
may optionally pass a list or tuple of lengths to this argument, which
will be used as nested row lengths to construct a ragged tensor with
multiple ragged dimensions. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> padding
						</dt>
						<dd>An optional padding value.  If specified, then any row suffix
consisting entirely of `padding` will be excluded from the returned
RaggedTensor.  `padding` is a `Tensor` with the same dtype as `tensor`
and with `shape=tensor.shape[ragged_rank + 1:]`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> ragged_rank
						</dt>
						<dd>Integer specifying the ragged rank for the returned
`RaggedTensor`.  Must be greater than zero. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>A name prefix for the returned tensors (optional). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> row_splits_dtype
						</dt>
						<dd>`dtype` for the returned `RaggedTensor`'s `row_splits`
tensor.  One of <a href="..\tf\dtypes\int32.md"><code>tf.int32</code></a> or <a href="..\tf\dtypes\int64.md"><code>tf.int64</code></a>. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `RaggedTensor` with the specified `ragged_rank`.  The shape of the
returned ragged tensor is compatible with the shape of `tensor`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> dt = tf.constant([[5, 7, 0], [0, 3, 0], [6, 0, 0]])
            >>> tf.RaggedTensor.from_tensor(dt)
            <tf.RaggedTensor [[5, 7, 0], [0, 3, 0], [6, 0, 0]]>
            >>> tf.RaggedTensor.from_tensor(dt, lengths=[1, 0, 3])
            <tf.RaggedTensor [[5], [], [6, 0, 0]]> <p></p> >>> tf.RaggedTensor.from_tensor(dt, padding=0)
<tf.RaggedTensor [[5, 7], [0, 3], [6]]> <p></p> >>> dt = tf.constant([[[5, 0], [7, 0], [0, 0]],
                      [[0, 0], [3, 0], [0, 0]],
                      [[6, 0], [0, 0], [0, 0]]])
>>> tf.RaggedTensor.from_tensor(dt, lengths=([2, 0, 3], [1, 1, 2, 0, 1]))
<tf.RaggedTensor [[[5], [7]], [], [[6, 0], [], [0]]]> </pre>
</div>
		</div>
	</div>
	<div id="from_tensor``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_tensor&lt;TClass&gt;</strong>(<span title="System.object">object</span> tensor, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> lengths, <span title="System.int">int</span> padding, <span title="System.int">int</span> ragged_rank, <span title="System.string">string</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> row_splits_dtype)
		</h4>
		<div class="content">Converts a <a href="..\tf\Tensor.md"><code>tf.Tensor</code></a> into a `RaggedTensor`. <p></p> The set of absent/default values may be specified using a vector of lengths
or a padding value (but not both).  If `lengths` is specified, then the
output tensor will satisfy `output[row] = tensor[row][:lengths[row]]`. If
'lengths' is a list of lists or tuple of lists, those lists will be used
as nested row lengths. If `padding` is specified, then any row *suffix*
consisting entirely of `padding` will be excluded from the returned
`RaggedTensor`.  If neither `lengths` nor `padding` is specified, then the
returned `RaggedTensor` will have no absent/default values. <p></p> Examples: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> tensor
						</dt>
						<dd>The `Tensor` to convert.  Must have rank `ragged_rank + 1` or
higher. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> lengths
						</dt>
						<dd>An optional set of row lengths, specified using a 1-D integer
`Tensor` whose length is equal to `tensor.shape[0]` (the number of rows
in `tensor`).  If specified, then `output[row]` will contain
`tensor[row][:lengths[row]]`.  Negative lengths are treated as zero. You
may optionally pass a list or tuple of lengths to this argument, which
will be used as nested row lengths to construct a ragged tensor with
multiple ragged dimensions. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> padding
						</dt>
						<dd>An optional padding value.  If specified, then any row suffix
consisting entirely of `padding` will be excluded from the returned
RaggedTensor.  `padding` is a `Tensor` with the same dtype as `tensor`
and with `shape=tensor.shape[ragged_rank + 1:]`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> ragged_rank
						</dt>
						<dd>Integer specifying the ragged rank for the returned
`RaggedTensor`.  Must be greater than zero. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensors (optional). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> row_splits_dtype
						</dt>
						<dd>`dtype` for the returned `RaggedTensor`'s `row_splits`
tensor.  One of <a href="..\tf\dtypes\int32.md"><code>tf.int32</code></a> or <a href="..\tf\dtypes\int64.md"><code>tf.int64</code></a>. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor` with the specified `ragged_rank`.  The shape of the
returned ragged tensor is compatible with the shape of `tensor`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> dt = tf.constant([[5, 7, 0], [0, 3, 0], [6, 0, 0]])
            >>> tf.RaggedTensor.from_tensor(dt)
            <tf.RaggedTensor [[5, 7, 0], [0, 3, 0], [6, 0, 0]]>
            >>> tf.RaggedTensor.from_tensor(dt, lengths=[1, 0, 3])
            <tf.RaggedTensor [[5], [], [6, 0, 0]]> <p></p> >>> tf.RaggedTensor.from_tensor(dt, padding=0)
<tf.RaggedTensor [[5, 7], [0, 3], [6]]> <p></p> >>> dt = tf.constant([[[5, 0], [7, 0], [0, 0]],
                      [[0, 0], [3, 0], [0, 0]],
                      [[6, 0], [0, 0], [0, 0]]])
>>> tf.RaggedTensor.from_tensor(dt, lengths=([2, 0, 3], [1, 1, 2, 0, 1]))
<tf.RaggedTensor [[[5], [7]], [], [[6, 0], [], [0]]]> </pre>
</div>
		</div>
	</div>
	<div id="from_tensor``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_tensor&lt;TClass&gt;</strong>(<span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span> tensor, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> lengths, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> padding, <span title="System.int">int</span> ragged_rank, <span title="System.string">string</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> row_splits_dtype)
		</h4>
		<div class="content">Converts a <a href="..\tf\Tensor.md"><code>tf.Tensor</code></a> into a `RaggedTensor`. <p></p> The set of absent/default values may be specified using a vector of lengths
or a padding value (but not both).  If `lengths` is specified, then the
output tensor will satisfy `output[row] = tensor[row][:lengths[row]]`. If
'lengths' is a list of lists or tuple of lists, those lists will be used
as nested row lengths. If `padding` is specified, then any row *suffix*
consisting entirely of `padding` will be excluded from the returned
`RaggedTensor`.  If neither `lengths` nor `padding` is specified, then the
returned `RaggedTensor` will have no absent/default values. <p></p> Examples: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span></code> tensor
						</dt>
						<dd>The `Tensor` to convert.  Must have rank `ragged_rank + 1` or
higher. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> lengths
						</dt>
						<dd>An optional set of row lengths, specified using a 1-D integer
`Tensor` whose length is equal to `tensor.shape[0]` (the number of rows
in `tensor`).  If specified, then `output[row]` will contain
`tensor[row][:lengths[row]]`.  Negative lengths are treated as zero. You
may optionally pass a list or tuple of lengths to this argument, which
will be used as nested row lengths to construct a ragged tensor with
multiple ragged dimensions. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> padding
						</dt>
						<dd>An optional padding value.  If specified, then any row suffix
consisting entirely of `padding` will be excluded from the returned
RaggedTensor.  `padding` is a `Tensor` with the same dtype as `tensor`
and with `shape=tensor.shape[ragged_rank + 1:]`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> ragged_rank
						</dt>
						<dd>Integer specifying the ragged rank for the returned
`RaggedTensor`.  Must be greater than zero. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensors (optional). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> row_splits_dtype
						</dt>
						<dd>`dtype` for the returned `RaggedTensor`'s `row_splits`
tensor.  One of <a href="..\tf\dtypes\int32.md"><code>tf.int32</code></a> or <a href="..\tf\dtypes\int64.md"><code>tf.int64</code></a>. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor` with the specified `ragged_rank`.  The shape of the
returned ragged tensor is compatible with the shape of `tensor`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> dt = tf.constant([[5, 7, 0], [0, 3, 0], [6, 0, 0]])
            >>> tf.RaggedTensor.from_tensor(dt)
            <tf.RaggedTensor [[5, 7, 0], [0, 3, 0], [6, 0, 0]]>
            >>> tf.RaggedTensor.from_tensor(dt, lengths=[1, 0, 3])
            <tf.RaggedTensor [[5], [], [6, 0, 0]]> <p></p> >>> tf.RaggedTensor.from_tensor(dt, padding=0)
<tf.RaggedTensor [[5, 7], [0, 3], [6]]> <p></p> >>> dt = tf.constant([[[5, 0], [7, 0], [0, 0]],
                      [[0, 0], [3, 0], [0, 0]],
                      [[6, 0], [0, 0], [0, 0]]])
>>> tf.RaggedTensor.from_tensor(dt, lengths=([2, 0, 3], [1, 1, 2, 0, 1]))
<tf.RaggedTensor [[[5], [7]], [], [[6, 0], [], [0]]]> </pre>
</div>
		</div>
	</div>
	<div id="from_tensor``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_tensor&lt;TClass&gt;</strong>(<span title="System.object">object</span> tensor, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> lengths, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> padding, <a href="../tensorflow/Dimension.htm">Dimension</a> ragged_rank, <span title="System.string">string</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> row_splits_dtype)
		</h4>
		<div class="content">Converts a <a href="..\tf\Tensor.md"><code>tf.Tensor</code></a> into a `RaggedTensor`. <p></p> The set of absent/default values may be specified using a vector of lengths
or a padding value (but not both).  If `lengths` is specified, then the
output tensor will satisfy `output[row] = tensor[row][:lengths[row]]`. If
'lengths' is a list of lists or tuple of lists, those lists will be used
as nested row lengths. If `padding` is specified, then any row *suffix*
consisting entirely of `padding` will be excluded from the returned
`RaggedTensor`.  If neither `lengths` nor `padding` is specified, then the
returned `RaggedTensor` will have no absent/default values. <p></p> Examples: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> tensor
						</dt>
						<dd>The `Tensor` to convert.  Must have rank `ragged_rank + 1` or
higher. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> lengths
						</dt>
						<dd>An optional set of row lengths, specified using a 1-D integer
`Tensor` whose length is equal to `tensor.shape[0]` (the number of rows
in `tensor`).  If specified, then `output[row]` will contain
`tensor[row][:lengths[row]]`.  Negative lengths are treated as zero. You
may optionally pass a list or tuple of lengths to this argument, which
will be used as nested row lengths to construct a ragged tensor with
multiple ragged dimensions. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> padding
						</dt>
						<dd>An optional padding value.  If specified, then any row suffix
consisting entirely of `padding` will be excluded from the returned
RaggedTensor.  `padding` is a `Tensor` with the same dtype as `tensor`
and with `shape=tensor.shape[ragged_rank + 1:]`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/Dimension.htm">Dimension</a></code> ragged_rank
						</dt>
						<dd>Integer specifying the ragged rank for the returned
`RaggedTensor`.  Must be greater than zero. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensors (optional). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> row_splits_dtype
						</dt>
						<dd>`dtype` for the returned `RaggedTensor`'s `row_splits`
tensor.  One of <a href="..\tf\dtypes\int32.md"><code>tf.int32</code></a> or <a href="..\tf\dtypes\int64.md"><code>tf.int64</code></a>. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor` with the specified `ragged_rank`.  The shape of the
returned ragged tensor is compatible with the shape of `tensor`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> dt = tf.constant([[5, 7, 0], [0, 3, 0], [6, 0, 0]])
            >>> tf.RaggedTensor.from_tensor(dt)
            <tf.RaggedTensor [[5, 7, 0], [0, 3, 0], [6, 0, 0]]>
            >>> tf.RaggedTensor.from_tensor(dt, lengths=[1, 0, 3])
            <tf.RaggedTensor [[5], [], [6, 0, 0]]> <p></p> >>> tf.RaggedTensor.from_tensor(dt, padding=0)
<tf.RaggedTensor [[5, 7], [0, 3], [6]]> <p></p> >>> dt = tf.constant([[[5, 0], [7, 0], [0, 0]],
                      [[0, 0], [3, 0], [0, 0]],
                      [[6, 0], [0, 0], [0, 0]]])
>>> tf.RaggedTensor.from_tensor(dt, lengths=([2, 0, 3], [1, 1, 2, 0, 1]))
<tf.RaggedTensor [[[5], [7]], [], [[6, 0], [], [0]]]> </pre>
</div>
		</div>
	</div>
	<div id="from_tensor``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_tensor&lt;TClass&gt;</strong>(<span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span> tensor, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> lengths, <span title="System.int">int</span> padding, <a href="../tensorflow/Dimension.htm">Dimension</a> ragged_rank, <span title="System.string">string</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> row_splits_dtype)
		</h4>
		<div class="content">Converts a <a href="..\tf\Tensor.md"><code>tf.Tensor</code></a> into a `RaggedTensor`. <p></p> The set of absent/default values may be specified using a vector of lengths
or a padding value (but not both).  If `lengths` is specified, then the
output tensor will satisfy `output[row] = tensor[row][:lengths[row]]`. If
'lengths' is a list of lists or tuple of lists, those lists will be used
as nested row lengths. If `padding` is specified, then any row *suffix*
consisting entirely of `padding` will be excluded from the returned
`RaggedTensor`.  If neither `lengths` nor `padding` is specified, then the
returned `RaggedTensor` will have no absent/default values. <p></p> Examples: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span></code> tensor
						</dt>
						<dd>The `Tensor` to convert.  Must have rank `ragged_rank + 1` or
higher. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> lengths
						</dt>
						<dd>An optional set of row lengths, specified using a 1-D integer
`Tensor` whose length is equal to `tensor.shape[0]` (the number of rows
in `tensor`).  If specified, then `output[row]` will contain
`tensor[row][:lengths[row]]`.  Negative lengths are treated as zero. You
may optionally pass a list or tuple of lengths to this argument, which
will be used as nested row lengths to construct a ragged tensor with
multiple ragged dimensions. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> padding
						</dt>
						<dd>An optional padding value.  If specified, then any row suffix
consisting entirely of `padding` will be excluded from the returned
RaggedTensor.  `padding` is a `Tensor` with the same dtype as `tensor`
and with `shape=tensor.shape[ragged_rank + 1:]`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/Dimension.htm">Dimension</a></code> ragged_rank
						</dt>
						<dd>Integer specifying the ragged rank for the returned
`RaggedTensor`.  Must be greater than zero. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensors (optional). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> row_splits_dtype
						</dt>
						<dd>`dtype` for the returned `RaggedTensor`'s `row_splits`
tensor.  One of <a href="..\tf\dtypes\int32.md"><code>tf.int32</code></a> or <a href="..\tf\dtypes\int64.md"><code>tf.int64</code></a>. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor` with the specified `ragged_rank`.  The shape of the
returned ragged tensor is compatible with the shape of `tensor`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> dt = tf.constant([[5, 7, 0], [0, 3, 0], [6, 0, 0]])
            >>> tf.RaggedTensor.from_tensor(dt)
            <tf.RaggedTensor [[5, 7, 0], [0, 3, 0], [6, 0, 0]]>
            >>> tf.RaggedTensor.from_tensor(dt, lengths=[1, 0, 3])
            <tf.RaggedTensor [[5], [], [6, 0, 0]]> <p></p> >>> tf.RaggedTensor.from_tensor(dt, padding=0)
<tf.RaggedTensor [[5, 7], [0, 3], [6]]> <p></p> >>> dt = tf.constant([[[5, 0], [7, 0], [0, 0]],
                      [[0, 0], [3, 0], [0, 0]],
                      [[6, 0], [0, 0], [0, 0]]])
>>> tf.RaggedTensor.from_tensor(dt, lengths=([2, 0, 3], [1, 1, 2, 0, 1]))
<tf.RaggedTensor [[[5], [7]], [], [[6, 0], [], [0]]]> </pre>
</div>
		</div>
	</div>
	<div id="from_tensor``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_tensor&lt;TClass&gt;</strong>(<span title="System.object">object</span> tensor, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> lengths, <span title="System.int">int</span> padding, <a href="../tensorflow/Dimension.htm">Dimension</a> ragged_rank, <span title="System.string">string</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> row_splits_dtype)
		</h4>
		<div class="content">Converts a <a href="..\tf\Tensor.md"><code>tf.Tensor</code></a> into a `RaggedTensor`. <p></p> The set of absent/default values may be specified using a vector of lengths
or a padding value (but not both).  If `lengths` is specified, then the
output tensor will satisfy `output[row] = tensor[row][:lengths[row]]`. If
'lengths' is a list of lists or tuple of lists, those lists will be used
as nested row lengths. If `padding` is specified, then any row *suffix*
consisting entirely of `padding` will be excluded from the returned
`RaggedTensor`.  If neither `lengths` nor `padding` is specified, then the
returned `RaggedTensor` will have no absent/default values. <p></p> Examples: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> tensor
						</dt>
						<dd>The `Tensor` to convert.  Must have rank `ragged_rank + 1` or
higher. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> lengths
						</dt>
						<dd>An optional set of row lengths, specified using a 1-D integer
`Tensor` whose length is equal to `tensor.shape[0]` (the number of rows
in `tensor`).  If specified, then `output[row]` will contain
`tensor[row][:lengths[row]]`.  Negative lengths are treated as zero. You
may optionally pass a list or tuple of lengths to this argument, which
will be used as nested row lengths to construct a ragged tensor with
multiple ragged dimensions. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> padding
						</dt>
						<dd>An optional padding value.  If specified, then any row suffix
consisting entirely of `padding` will be excluded from the returned
RaggedTensor.  `padding` is a `Tensor` with the same dtype as `tensor`
and with `shape=tensor.shape[ragged_rank + 1:]`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/Dimension.htm">Dimension</a></code> ragged_rank
						</dt>
						<dd>Integer specifying the ragged rank for the returned
`RaggedTensor`.  Must be greater than zero. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensors (optional). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> row_splits_dtype
						</dt>
						<dd>`dtype` for the returned `RaggedTensor`'s `row_splits`
tensor.  One of <a href="..\tf\dtypes\int32.md"><code>tf.int32</code></a> or <a href="..\tf\dtypes\int64.md"><code>tf.int64</code></a>. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor` with the specified `ragged_rank`.  The shape of the
returned ragged tensor is compatible with the shape of `tensor`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> dt = tf.constant([[5, 7, 0], [0, 3, 0], [6, 0, 0]])
            >>> tf.RaggedTensor.from_tensor(dt)
            <tf.RaggedTensor [[5, 7, 0], [0, 3, 0], [6, 0, 0]]>
            >>> tf.RaggedTensor.from_tensor(dt, lengths=[1, 0, 3])
            <tf.RaggedTensor [[5], [], [6, 0, 0]]> <p></p> >>> tf.RaggedTensor.from_tensor(dt, padding=0)
<tf.RaggedTensor [[5, 7], [0, 3], [6]]> <p></p> >>> dt = tf.constant([[[5, 0], [7, 0], [0, 0]],
                      [[0, 0], [3, 0], [0, 0]],
                      [[6, 0], [0, 0], [0, 0]]])
>>> tf.RaggedTensor.from_tensor(dt, lengths=([2, 0, 3], [1, 1, 2, 0, 1]))
<tf.RaggedTensor [[[5], [7]], [], [[6, 0], [], [0]]]> </pre>
</div>
		</div>
	</div>
	<div id="from_tensor``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_tensor&lt;TClass&gt;</strong>(<span title="System.object">object</span> tensor, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> lengths, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> padding, <span title="System.int">int</span> ragged_rank, <span title="System.string">string</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> row_splits_dtype)
		</h4>
		<div class="content">Converts a <a href="..\tf\Tensor.md"><code>tf.Tensor</code></a> into a `RaggedTensor`. <p></p> The set of absent/default values may be specified using a vector of lengths
or a padding value (but not both).  If `lengths` is specified, then the
output tensor will satisfy `output[row] = tensor[row][:lengths[row]]`. If
'lengths' is a list of lists or tuple of lists, those lists will be used
as nested row lengths. If `padding` is specified, then any row *suffix*
consisting entirely of `padding` will be excluded from the returned
`RaggedTensor`.  If neither `lengths` nor `padding` is specified, then the
returned `RaggedTensor` will have no absent/default values. <p></p> Examples: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> tensor
						</dt>
						<dd>The `Tensor` to convert.  Must have rank `ragged_rank + 1` or
higher. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> lengths
						</dt>
						<dd>An optional set of row lengths, specified using a 1-D integer
`Tensor` whose length is equal to `tensor.shape[0]` (the number of rows
in `tensor`).  If specified, then `output[row]` will contain
`tensor[row][:lengths[row]]`.  Negative lengths are treated as zero. You
may optionally pass a list or tuple of lengths to this argument, which
will be used as nested row lengths to construct a ragged tensor with
multiple ragged dimensions. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> padding
						</dt>
						<dd>An optional padding value.  If specified, then any row suffix
consisting entirely of `padding` will be excluded from the returned
RaggedTensor.  `padding` is a `Tensor` with the same dtype as `tensor`
and with `shape=tensor.shape[ragged_rank + 1:]`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> ragged_rank
						</dt>
						<dd>Integer specifying the ragged rank for the returned
`RaggedTensor`.  Must be greater than zero. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensors (optional). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> row_splits_dtype
						</dt>
						<dd>`dtype` for the returned `RaggedTensor`'s `row_splits`
tensor.  One of <a href="..\tf\dtypes\int32.md"><code>tf.int32</code></a> or <a href="..\tf\dtypes\int64.md"><code>tf.int64</code></a>. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor` with the specified `ragged_rank`.  The shape of the
returned ragged tensor is compatible with the shape of `tensor`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> dt = tf.constant([[5, 7, 0], [0, 3, 0], [6, 0, 0]])
            >>> tf.RaggedTensor.from_tensor(dt)
            <tf.RaggedTensor [[5, 7, 0], [0, 3, 0], [6, 0, 0]]>
            >>> tf.RaggedTensor.from_tensor(dt, lengths=[1, 0, 3])
            <tf.RaggedTensor [[5], [], [6, 0, 0]]> <p></p> >>> tf.RaggedTensor.from_tensor(dt, padding=0)
<tf.RaggedTensor [[5, 7], [0, 3], [6]]> <p></p> >>> dt = tf.constant([[[5, 0], [7, 0], [0, 0]],
                      [[0, 0], [3, 0], [0, 0]],
                      [[6, 0], [0, 0], [0, 0]]])
>>> tf.RaggedTensor.from_tensor(dt, lengths=([2, 0, 3], [1, 1, 2, 0, 1]))
<tf.RaggedTensor [[[5], [7]], [], [[6, 0], [], [0]]]> </pre>
</div>
		</div>
	</div>
	<div id="from_tensor``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_tensor&lt;TClass&gt;</strong>(<span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span> tensor, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> lengths, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> padding, <a href="../tensorflow/Dimension.htm">Dimension</a> ragged_rank, <span title="System.string">string</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> row_splits_dtype)
		</h4>
		<div class="content">Converts a <a href="..\tf\Tensor.md"><code>tf.Tensor</code></a> into a `RaggedTensor`. <p></p> The set of absent/default values may be specified using a vector of lengths
or a padding value (but not both).  If `lengths` is specified, then the
output tensor will satisfy `output[row] = tensor[row][:lengths[row]]`. If
'lengths' is a list of lists or tuple of lists, those lists will be used
as nested row lengths. If `padding` is specified, then any row *suffix*
consisting entirely of `padding` will be excluded from the returned
`RaggedTensor`.  If neither `lengths` nor `padding` is specified, then the
returned `RaggedTensor` will have no absent/default values. <p></p> Examples: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span></code> tensor
						</dt>
						<dd>The `Tensor` to convert.  Must have rank `ragged_rank + 1` or
higher. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> lengths
						</dt>
						<dd>An optional set of row lengths, specified using a 1-D integer
`Tensor` whose length is equal to `tensor.shape[0]` (the number of rows
in `tensor`).  If specified, then `output[row]` will contain
`tensor[row][:lengths[row]]`.  Negative lengths are treated as zero. You
may optionally pass a list or tuple of lengths to this argument, which
will be used as nested row lengths to construct a ragged tensor with
multiple ragged dimensions. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> padding
						</dt>
						<dd>An optional padding value.  If specified, then any row suffix
consisting entirely of `padding` will be excluded from the returned
RaggedTensor.  `padding` is a `Tensor` with the same dtype as `tensor`
and with `shape=tensor.shape[ragged_rank + 1:]`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/Dimension.htm">Dimension</a></code> ragged_rank
						</dt>
						<dd>Integer specifying the ragged rank for the returned
`RaggedTensor`.  Must be greater than zero. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensors (optional). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> row_splits_dtype
						</dt>
						<dd>`dtype` for the returned `RaggedTensor`'s `row_splits`
tensor.  One of <a href="..\tf\dtypes\int32.md"><code>tf.int32</code></a> or <a href="..\tf\dtypes\int64.md"><code>tf.int64</code></a>. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor` with the specified `ragged_rank`.  The shape of the
returned ragged tensor is compatible with the shape of `tensor`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> dt = tf.constant([[5, 7, 0], [0, 3, 0], [6, 0, 0]])
            >>> tf.RaggedTensor.from_tensor(dt)
            <tf.RaggedTensor [[5, 7, 0], [0, 3, 0], [6, 0, 0]]>
            >>> tf.RaggedTensor.from_tensor(dt, lengths=[1, 0, 3])
            <tf.RaggedTensor [[5], [], [6, 0, 0]]> <p></p> >>> tf.RaggedTensor.from_tensor(dt, padding=0)
<tf.RaggedTensor [[5, 7], [0, 3], [6]]> <p></p> >>> dt = tf.constant([[[5, 0], [7, 0], [0, 0]],
                      [[0, 0], [3, 0], [0, 0]],
                      [[6, 0], [0, 0], [0, 0]]])
>>> tf.RaggedTensor.from_tensor(dt, lengths=([2, 0, 3], [1, 1, 2, 0, 1]))
<tf.RaggedTensor [[[5], [7]], [], [[6, 0], [], [0]]]> </pre>
</div>
		</div>
	</div>
	<div id="from_tensor``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_tensor&lt;TClass&gt;</strong>(<span title="System.object">object</span> tensor, <span title="System.ValueTuple<IEnumerable<object>, object>">ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;</span> lengths, <span title="System.int">int</span> padding, <a href="../tensorflow/Dimension.htm">Dimension</a> ragged_rank, <span title="System.string">string</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> row_splits_dtype)
		</h4>
		<div class="content">Converts a <a href="..\tf\Tensor.md"><code>tf.Tensor</code></a> into a `RaggedTensor`. <p></p> The set of absent/default values may be specified using a vector of lengths
or a padding value (but not both).  If `lengths` is specified, then the
output tensor will satisfy `output[row] = tensor[row][:lengths[row]]`. If
'lengths' is a list of lists or tuple of lists, those lists will be used
as nested row lengths. If `padding` is specified, then any row *suffix*
consisting entirely of `padding` will be excluded from the returned
`RaggedTensor`.  If neither `lengths` nor `padding` is specified, then the
returned `RaggedTensor` will have no absent/default values. <p></p> Examples: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> tensor
						</dt>
						<dd>The `Tensor` to convert.  Must have rank `ragged_rank + 1` or
higher. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<IEnumerable<object>, object>">ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;</span></code> lengths
						</dt>
						<dd>An optional set of row lengths, specified using a 1-D integer
`Tensor` whose length is equal to `tensor.shape[0]` (the number of rows
in `tensor`).  If specified, then `output[row]` will contain
`tensor[row][:lengths[row]]`.  Negative lengths are treated as zero. You
may optionally pass a list or tuple of lengths to this argument, which
will be used as nested row lengths to construct a ragged tensor with
multiple ragged dimensions. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> padding
						</dt>
						<dd>An optional padding value.  If specified, then any row suffix
consisting entirely of `padding` will be excluded from the returned
RaggedTensor.  `padding` is a `Tensor` with the same dtype as `tensor`
and with `shape=tensor.shape[ragged_rank + 1:]`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/Dimension.htm">Dimension</a></code> ragged_rank
						</dt>
						<dd>Integer specifying the ragged rank for the returned
`RaggedTensor`.  Must be greater than zero. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensors (optional). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> row_splits_dtype
						</dt>
						<dd>`dtype` for the returned `RaggedTensor`'s `row_splits`
tensor.  One of <a href="..\tf\dtypes\int32.md"><code>tf.int32</code></a> or <a href="..\tf\dtypes\int64.md"><code>tf.int64</code></a>. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor` with the specified `ragged_rank`.  The shape of the
returned ragged tensor is compatible with the shape of `tensor`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> dt = tf.constant([[5, 7, 0], [0, 3, 0], [6, 0, 0]])
            >>> tf.RaggedTensor.from_tensor(dt)
            <tf.RaggedTensor [[5, 7, 0], [0, 3, 0], [6, 0, 0]]>
            >>> tf.RaggedTensor.from_tensor(dt, lengths=[1, 0, 3])
            <tf.RaggedTensor [[5], [], [6, 0, 0]]> <p></p> >>> tf.RaggedTensor.from_tensor(dt, padding=0)
<tf.RaggedTensor [[5, 7], [0, 3], [6]]> <p></p> >>> dt = tf.constant([[[5, 0], [7, 0], [0, 0]],
                      [[0, 0], [3, 0], [0, 0]],
                      [[6, 0], [0, 0], [0, 0]]])
>>> tf.RaggedTensor.from_tensor(dt, lengths=([2, 0, 3], [1, 1, 2, 0, 1]))
<tf.RaggedTensor [[[5], [7]], [], [[6, 0], [], [0]]]> </pre>
</div>
		</div>
	</div>
	<div id="from_tensor``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_tensor&lt;TClass&gt;</strong>(<span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span> tensor, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> lengths, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> padding, <span title="System.int">int</span> ragged_rank, <span title="System.string">string</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> row_splits_dtype)
		</h4>
		<div class="content">Converts a <a href="..\tf\Tensor.md"><code>tf.Tensor</code></a> into a `RaggedTensor`. <p></p> The set of absent/default values may be specified using a vector of lengths
or a padding value (but not both).  If `lengths` is specified, then the
output tensor will satisfy `output[row] = tensor[row][:lengths[row]]`. If
'lengths' is a list of lists or tuple of lists, those lists will be used
as nested row lengths. If `padding` is specified, then any row *suffix*
consisting entirely of `padding` will be excluded from the returned
`RaggedTensor`.  If neither `lengths` nor `padding` is specified, then the
returned `RaggedTensor` will have no absent/default values. <p></p> Examples: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span></code> tensor
						</dt>
						<dd>The `Tensor` to convert.  Must have rank `ragged_rank + 1` or
higher. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> lengths
						</dt>
						<dd>An optional set of row lengths, specified using a 1-D integer
`Tensor` whose length is equal to `tensor.shape[0]` (the number of rows
in `tensor`).  If specified, then `output[row]` will contain
`tensor[row][:lengths[row]]`.  Negative lengths are treated as zero. You
may optionally pass a list or tuple of lengths to this argument, which
will be used as nested row lengths to construct a ragged tensor with
multiple ragged dimensions. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> padding
						</dt>
						<dd>An optional padding value.  If specified, then any row suffix
consisting entirely of `padding` will be excluded from the returned
RaggedTensor.  `padding` is a `Tensor` with the same dtype as `tensor`
and with `shape=tensor.shape[ragged_rank + 1:]`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> ragged_rank
						</dt>
						<dd>Integer specifying the ragged rank for the returned
`RaggedTensor`.  Must be greater than zero. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensors (optional). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> row_splits_dtype
						</dt>
						<dd>`dtype` for the returned `RaggedTensor`'s `row_splits`
tensor.  One of <a href="..\tf\dtypes\int32.md"><code>tf.int32</code></a> or <a href="..\tf\dtypes\int64.md"><code>tf.int64</code></a>. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor` with the specified `ragged_rank`.  The shape of the
returned ragged tensor is compatible with the shape of `tensor`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> dt = tf.constant([[5, 7, 0], [0, 3, 0], [6, 0, 0]])
            >>> tf.RaggedTensor.from_tensor(dt)
            <tf.RaggedTensor [[5, 7, 0], [0, 3, 0], [6, 0, 0]]>
            >>> tf.RaggedTensor.from_tensor(dt, lengths=[1, 0, 3])
            <tf.RaggedTensor [[5], [], [6, 0, 0]]> <p></p> >>> tf.RaggedTensor.from_tensor(dt, padding=0)
<tf.RaggedTensor [[5, 7], [0, 3], [6]]> <p></p> >>> dt = tf.constant([[[5, 0], [7, 0], [0, 0]],
                      [[0, 0], [3, 0], [0, 0]],
                      [[6, 0], [0, 0], [0, 0]]])
>>> tf.RaggedTensor.from_tensor(dt, lengths=([2, 0, 3], [1, 1, 2, 0, 1]))
<tf.RaggedTensor [[[5], [7]], [], [[6, 0], [], [0]]]> </pre>
</div>
		</div>
	</div>
	<div id="from_tensor``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_tensor&lt;TClass&gt;</strong>(<span title="System.object">object</span> tensor, <span title="System.ValueTuple<IEnumerable<object>, object>">ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;</span> lengths, <span title="System.int">int</span> padding, <span title="System.int">int</span> ragged_rank, <span title="System.string">string</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> row_splits_dtype)
		</h4>
		<div class="content">Converts a <a href="..\tf\Tensor.md"><code>tf.Tensor</code></a> into a `RaggedTensor`. <p></p> The set of absent/default values may be specified using a vector of lengths
or a padding value (but not both).  If `lengths` is specified, then the
output tensor will satisfy `output[row] = tensor[row][:lengths[row]]`. If
'lengths' is a list of lists or tuple of lists, those lists will be used
as nested row lengths. If `padding` is specified, then any row *suffix*
consisting entirely of `padding` will be excluded from the returned
`RaggedTensor`.  If neither `lengths` nor `padding` is specified, then the
returned `RaggedTensor` will have no absent/default values. <p></p> Examples: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> tensor
						</dt>
						<dd>The `Tensor` to convert.  Must have rank `ragged_rank + 1` or
higher. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<IEnumerable<object>, object>">ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;</span></code> lengths
						</dt>
						<dd>An optional set of row lengths, specified using a 1-D integer
`Tensor` whose length is equal to `tensor.shape[0]` (the number of rows
in `tensor`).  If specified, then `output[row]` will contain
`tensor[row][:lengths[row]]`.  Negative lengths are treated as zero. You
may optionally pass a list or tuple of lengths to this argument, which
will be used as nested row lengths to construct a ragged tensor with
multiple ragged dimensions. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> padding
						</dt>
						<dd>An optional padding value.  If specified, then any row suffix
consisting entirely of `padding` will be excluded from the returned
RaggedTensor.  `padding` is a `Tensor` with the same dtype as `tensor`
and with `shape=tensor.shape[ragged_rank + 1:]`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> ragged_rank
						</dt>
						<dd>Integer specifying the ragged rank for the returned
`RaggedTensor`.  Must be greater than zero. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensors (optional). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> row_splits_dtype
						</dt>
						<dd>`dtype` for the returned `RaggedTensor`'s `row_splits`
tensor.  One of <a href="..\tf\dtypes\int32.md"><code>tf.int32</code></a> or <a href="..\tf\dtypes\int64.md"><code>tf.int64</code></a>. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor` with the specified `ragged_rank`.  The shape of the
returned ragged tensor is compatible with the shape of `tensor`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> dt = tf.constant([[5, 7, 0], [0, 3, 0], [6, 0, 0]])
            >>> tf.RaggedTensor.from_tensor(dt)
            <tf.RaggedTensor [[5, 7, 0], [0, 3, 0], [6, 0, 0]]>
            >>> tf.RaggedTensor.from_tensor(dt, lengths=[1, 0, 3])
            <tf.RaggedTensor [[5], [], [6, 0, 0]]> <p></p> >>> tf.RaggedTensor.from_tensor(dt, padding=0)
<tf.RaggedTensor [[5, 7], [0, 3], [6]]> <p></p> >>> dt = tf.constant([[[5, 0], [7, 0], [0, 0]],
                      [[0, 0], [3, 0], [0, 0]],
                      [[6, 0], [0, 0], [0, 0]]])
>>> tf.RaggedTensor.from_tensor(dt, lengths=([2, 0, 3], [1, 1, 2, 0, 1]))
<tf.RaggedTensor [[[5], [7]], [], [[6, 0], [], [0]]]> </pre>
</div>
		</div>
	</div>
	<div id="from_tensor``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_tensor&lt;TClass&gt;</strong>(<span title="System.object">object</span> tensor, <span title="System.ValueTuple<IEnumerable<object>, object>">ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;</span> lengths, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> padding, <a href="../tensorflow/Dimension.htm">Dimension</a> ragged_rank, <span title="System.string">string</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> row_splits_dtype)
		</h4>
		<div class="content">Converts a <a href="..\tf\Tensor.md"><code>tf.Tensor</code></a> into a `RaggedTensor`. <p></p> The set of absent/default values may be specified using a vector of lengths
or a padding value (but not both).  If `lengths` is specified, then the
output tensor will satisfy `output[row] = tensor[row][:lengths[row]]`. If
'lengths' is a list of lists or tuple of lists, those lists will be used
as nested row lengths. If `padding` is specified, then any row *suffix*
consisting entirely of `padding` will be excluded from the returned
`RaggedTensor`.  If neither `lengths` nor `padding` is specified, then the
returned `RaggedTensor` will have no absent/default values. <p></p> Examples: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> tensor
						</dt>
						<dd>The `Tensor` to convert.  Must have rank `ragged_rank + 1` or
higher. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<IEnumerable<object>, object>">ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;</span></code> lengths
						</dt>
						<dd>An optional set of row lengths, specified using a 1-D integer
`Tensor` whose length is equal to `tensor.shape[0]` (the number of rows
in `tensor`).  If specified, then `output[row]` will contain
`tensor[row][:lengths[row]]`.  Negative lengths are treated as zero. You
may optionally pass a list or tuple of lengths to this argument, which
will be used as nested row lengths to construct a ragged tensor with
multiple ragged dimensions. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> padding
						</dt>
						<dd>An optional padding value.  If specified, then any row suffix
consisting entirely of `padding` will be excluded from the returned
RaggedTensor.  `padding` is a `Tensor` with the same dtype as `tensor`
and with `shape=tensor.shape[ragged_rank + 1:]`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/Dimension.htm">Dimension</a></code> ragged_rank
						</dt>
						<dd>Integer specifying the ragged rank for the returned
`RaggedTensor`.  Must be greater than zero. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensors (optional). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> row_splits_dtype
						</dt>
						<dd>`dtype` for the returned `RaggedTensor`'s `row_splits`
tensor.  One of <a href="..\tf\dtypes\int32.md"><code>tf.int32</code></a> or <a href="..\tf\dtypes\int64.md"><code>tf.int64</code></a>. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor` with the specified `ragged_rank`.  The shape of the
returned ragged tensor is compatible with the shape of `tensor`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> dt = tf.constant([[5, 7, 0], [0, 3, 0], [6, 0, 0]])
            >>> tf.RaggedTensor.from_tensor(dt)
            <tf.RaggedTensor [[5, 7, 0], [0, 3, 0], [6, 0, 0]]>
            >>> tf.RaggedTensor.from_tensor(dt, lengths=[1, 0, 3])
            <tf.RaggedTensor [[5], [], [6, 0, 0]]> <p></p> >>> tf.RaggedTensor.from_tensor(dt, padding=0)
<tf.RaggedTensor [[5, 7], [0, 3], [6]]> <p></p> >>> dt = tf.constant([[[5, 0], [7, 0], [0, 0]],
                      [[0, 0], [3, 0], [0, 0]],
                      [[6, 0], [0, 0], [0, 0]]])
>>> tf.RaggedTensor.from_tensor(dt, lengths=([2, 0, 3], [1, 1, 2, 0, 1]))
<tf.RaggedTensor [[[5], [7]], [], [[6, 0], [], [0]]]> </pre>
</div>
		</div>
	</div>
	<div id="from_tensor``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_tensor&lt;TClass&gt;</strong>(<span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span> tensor, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> lengths, <span title="System.int">int</span> padding, <span title="System.int">int</span> ragged_rank, <span title="System.string">string</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> row_splits_dtype)
		</h4>
		<div class="content">Converts a <a href="..\tf\Tensor.md"><code>tf.Tensor</code></a> into a `RaggedTensor`. <p></p> The set of absent/default values may be specified using a vector of lengths
or a padding value (but not both).  If `lengths` is specified, then the
output tensor will satisfy `output[row] = tensor[row][:lengths[row]]`. If
'lengths' is a list of lists or tuple of lists, those lists will be used
as nested row lengths. If `padding` is specified, then any row *suffix*
consisting entirely of `padding` will be excluded from the returned
`RaggedTensor`.  If neither `lengths` nor `padding` is specified, then the
returned `RaggedTensor` will have no absent/default values. <p></p> Examples: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span></code> tensor
						</dt>
						<dd>The `Tensor` to convert.  Must have rank `ragged_rank + 1` or
higher. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> lengths
						</dt>
						<dd>An optional set of row lengths, specified using a 1-D integer
`Tensor` whose length is equal to `tensor.shape[0]` (the number of rows
in `tensor`).  If specified, then `output[row]` will contain
`tensor[row][:lengths[row]]`.  Negative lengths are treated as zero. You
may optionally pass a list or tuple of lengths to this argument, which
will be used as nested row lengths to construct a ragged tensor with
multiple ragged dimensions. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> padding
						</dt>
						<dd>An optional padding value.  If specified, then any row suffix
consisting entirely of `padding` will be excluded from the returned
RaggedTensor.  `padding` is a `Tensor` with the same dtype as `tensor`
and with `shape=tensor.shape[ragged_rank + 1:]`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> ragged_rank
						</dt>
						<dd>Integer specifying the ragged rank for the returned
`RaggedTensor`.  Must be greater than zero. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensors (optional). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> row_splits_dtype
						</dt>
						<dd>`dtype` for the returned `RaggedTensor`'s `row_splits`
tensor.  One of <a href="..\tf\dtypes\int32.md"><code>tf.int32</code></a> or <a href="..\tf\dtypes\int64.md"><code>tf.int64</code></a>. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor` with the specified `ragged_rank`.  The shape of the
returned ragged tensor is compatible with the shape of `tensor`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> dt = tf.constant([[5, 7, 0], [0, 3, 0], [6, 0, 0]])
            >>> tf.RaggedTensor.from_tensor(dt)
            <tf.RaggedTensor [[5, 7, 0], [0, 3, 0], [6, 0, 0]]>
            >>> tf.RaggedTensor.from_tensor(dt, lengths=[1, 0, 3])
            <tf.RaggedTensor [[5], [], [6, 0, 0]]> <p></p> >>> tf.RaggedTensor.from_tensor(dt, padding=0)
<tf.RaggedTensor [[5, 7], [0, 3], [6]]> <p></p> >>> dt = tf.constant([[[5, 0], [7, 0], [0, 0]],
                      [[0, 0], [3, 0], [0, 0]],
                      [[6, 0], [0, 0], [0, 0]]])
>>> tf.RaggedTensor.from_tensor(dt, lengths=([2, 0, 3], [1, 1, 2, 0, 1]))
<tf.RaggedTensor [[[5], [7]], [], [[6, 0], [], [0]]]> </pre>
</div>
		</div>
	</div>
	<div id="from_tensor``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_tensor&lt;TClass&gt;</strong>(<span title="System.object">object</span> tensor, <span title="System.ValueTuple<IEnumerable<object>, object>">ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;</span> lengths, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> padding, <span title="System.int">int</span> ragged_rank, <span title="System.string">string</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> row_splits_dtype)
		</h4>
		<div class="content">Converts a <a href="..\tf\Tensor.md"><code>tf.Tensor</code></a> into a `RaggedTensor`. <p></p> The set of absent/default values may be specified using a vector of lengths
or a padding value (but not both).  If `lengths` is specified, then the
output tensor will satisfy `output[row] = tensor[row][:lengths[row]]`. If
'lengths' is a list of lists or tuple of lists, those lists will be used
as nested row lengths. If `padding` is specified, then any row *suffix*
consisting entirely of `padding` will be excluded from the returned
`RaggedTensor`.  If neither `lengths` nor `padding` is specified, then the
returned `RaggedTensor` will have no absent/default values. <p></p> Examples: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> tensor
						</dt>
						<dd>The `Tensor` to convert.  Must have rank `ragged_rank + 1` or
higher. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<IEnumerable<object>, object>">ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;</span></code> lengths
						</dt>
						<dd>An optional set of row lengths, specified using a 1-D integer
`Tensor` whose length is equal to `tensor.shape[0]` (the number of rows
in `tensor`).  If specified, then `output[row]` will contain
`tensor[row][:lengths[row]]`.  Negative lengths are treated as zero. You
may optionally pass a list or tuple of lengths to this argument, which
will be used as nested row lengths to construct a ragged tensor with
multiple ragged dimensions. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> padding
						</dt>
						<dd>An optional padding value.  If specified, then any row suffix
consisting entirely of `padding` will be excluded from the returned
RaggedTensor.  `padding` is a `Tensor` with the same dtype as `tensor`
and with `shape=tensor.shape[ragged_rank + 1:]`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> ragged_rank
						</dt>
						<dd>Integer specifying the ragged rank for the returned
`RaggedTensor`.  Must be greater than zero. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensors (optional). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> row_splits_dtype
						</dt>
						<dd>`dtype` for the returned `RaggedTensor`'s `row_splits`
tensor.  One of <a href="..\tf\dtypes\int32.md"><code>tf.int32</code></a> or <a href="..\tf\dtypes\int64.md"><code>tf.int64</code></a>. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor` with the specified `ragged_rank`.  The shape of the
returned ragged tensor is compatible with the shape of `tensor`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> dt = tf.constant([[5, 7, 0], [0, 3, 0], [6, 0, 0]])
            >>> tf.RaggedTensor.from_tensor(dt)
            <tf.RaggedTensor [[5, 7, 0], [0, 3, 0], [6, 0, 0]]>
            >>> tf.RaggedTensor.from_tensor(dt, lengths=[1, 0, 3])
            <tf.RaggedTensor [[5], [], [6, 0, 0]]> <p></p> >>> tf.RaggedTensor.from_tensor(dt, padding=0)
<tf.RaggedTensor [[5, 7], [0, 3], [6]]> <p></p> >>> dt = tf.constant([[[5, 0], [7, 0], [0, 0]],
                      [[0, 0], [3, 0], [0, 0]],
                      [[6, 0], [0, 0], [0, 0]]])
>>> tf.RaggedTensor.from_tensor(dt, lengths=([2, 0, 3], [1, 1, 2, 0, 1]))
<tf.RaggedTensor [[[5], [7]], [], [[6, 0], [], [0]]]> </pre>
</div>
		</div>
	</div>
	<div id="from_tensor``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_tensor&lt;TClass&gt;</strong>(<span title="System.object">object</span> tensor, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> lengths, <span title="System.int">int</span> padding, <span title="System.int">int</span> ragged_rank, <span title="System.string">string</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> row_splits_dtype)
		</h4>
		<div class="content">Converts a <a href="..\tf\Tensor.md"><code>tf.Tensor</code></a> into a `RaggedTensor`. <p></p> The set of absent/default values may be specified using a vector of lengths
or a padding value (but not both).  If `lengths` is specified, then the
output tensor will satisfy `output[row] = tensor[row][:lengths[row]]`. If
'lengths' is a list of lists or tuple of lists, those lists will be used
as nested row lengths. If `padding` is specified, then any row *suffix*
consisting entirely of `padding` will be excluded from the returned
`RaggedTensor`.  If neither `lengths` nor `padding` is specified, then the
returned `RaggedTensor` will have no absent/default values. <p></p> Examples: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> tensor
						</dt>
						<dd>The `Tensor` to convert.  Must have rank `ragged_rank + 1` or
higher. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> lengths
						</dt>
						<dd>An optional set of row lengths, specified using a 1-D integer
`Tensor` whose length is equal to `tensor.shape[0]` (the number of rows
in `tensor`).  If specified, then `output[row]` will contain
`tensor[row][:lengths[row]]`.  Negative lengths are treated as zero. You
may optionally pass a list or tuple of lengths to this argument, which
will be used as nested row lengths to construct a ragged tensor with
multiple ragged dimensions. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> padding
						</dt>
						<dd>An optional padding value.  If specified, then any row suffix
consisting entirely of `padding` will be excluded from the returned
RaggedTensor.  `padding` is a `Tensor` with the same dtype as `tensor`
and with `shape=tensor.shape[ragged_rank + 1:]`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> ragged_rank
						</dt>
						<dd>Integer specifying the ragged rank for the returned
`RaggedTensor`.  Must be greater than zero. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensors (optional). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> row_splits_dtype
						</dt>
						<dd>`dtype` for the returned `RaggedTensor`'s `row_splits`
tensor.  One of <a href="..\tf\dtypes\int32.md"><code>tf.int32</code></a> or <a href="..\tf\dtypes\int64.md"><code>tf.int64</code></a>. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor` with the specified `ragged_rank`.  The shape of the
returned ragged tensor is compatible with the shape of `tensor`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> dt = tf.constant([[5, 7, 0], [0, 3, 0], [6, 0, 0]])
            >>> tf.RaggedTensor.from_tensor(dt)
            <tf.RaggedTensor [[5, 7, 0], [0, 3, 0], [6, 0, 0]]>
            >>> tf.RaggedTensor.from_tensor(dt, lengths=[1, 0, 3])
            <tf.RaggedTensor [[5], [], [6, 0, 0]]> <p></p> >>> tf.RaggedTensor.from_tensor(dt, padding=0)
<tf.RaggedTensor [[5, 7], [0, 3], [6]]> <p></p> >>> dt = tf.constant([[[5, 0], [7, 0], [0, 0]],
                      [[0, 0], [3, 0], [0, 0]],
                      [[6, 0], [0, 0], [0, 0]]])
>>> tf.RaggedTensor.from_tensor(dt, lengths=([2, 0, 3], [1, 1, 2, 0, 1]))
<tf.RaggedTensor [[[5], [7]], [], [[6, 0], [], [0]]]> </pre>
</div>
		</div>
	</div>
	<div id="from_tensor``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_tensor&lt;TClass&gt;</strong>(<span title="System.object">object</span> tensor, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> lengths, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> padding, <a href="../tensorflow/Dimension.htm">Dimension</a> ragged_rank, <span title="System.string">string</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> row_splits_dtype)
		</h4>
		<div class="content">Converts a <a href="..\tf\Tensor.md"><code>tf.Tensor</code></a> into a `RaggedTensor`. <p></p> The set of absent/default values may be specified using a vector of lengths
or a padding value (but not both).  If `lengths` is specified, then the
output tensor will satisfy `output[row] = tensor[row][:lengths[row]]`. If
'lengths' is a list of lists or tuple of lists, those lists will be used
as nested row lengths. If `padding` is specified, then any row *suffix*
consisting entirely of `padding` will be excluded from the returned
`RaggedTensor`.  If neither `lengths` nor `padding` is specified, then the
returned `RaggedTensor` will have no absent/default values. <p></p> Examples: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> tensor
						</dt>
						<dd>The `Tensor` to convert.  Must have rank `ragged_rank + 1` or
higher. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> lengths
						</dt>
						<dd>An optional set of row lengths, specified using a 1-D integer
`Tensor` whose length is equal to `tensor.shape[0]` (the number of rows
in `tensor`).  If specified, then `output[row]` will contain
`tensor[row][:lengths[row]]`.  Negative lengths are treated as zero. You
may optionally pass a list or tuple of lengths to this argument, which
will be used as nested row lengths to construct a ragged tensor with
multiple ragged dimensions. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> padding
						</dt>
						<dd>An optional padding value.  If specified, then any row suffix
consisting entirely of `padding` will be excluded from the returned
RaggedTensor.  `padding` is a `Tensor` with the same dtype as `tensor`
and with `shape=tensor.shape[ragged_rank + 1:]`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/Dimension.htm">Dimension</a></code> ragged_rank
						</dt>
						<dd>Integer specifying the ragged rank for the returned
`RaggedTensor`.  Must be greater than zero. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensors (optional). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> row_splits_dtype
						</dt>
						<dd>`dtype` for the returned `RaggedTensor`'s `row_splits`
tensor.  One of <a href="..\tf\dtypes\int32.md"><code>tf.int32</code></a> or <a href="..\tf\dtypes\int64.md"><code>tf.int64</code></a>. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor` with the specified `ragged_rank`.  The shape of the
returned ragged tensor is compatible with the shape of `tensor`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> dt = tf.constant([[5, 7, 0], [0, 3, 0], [6, 0, 0]])
            >>> tf.RaggedTensor.from_tensor(dt)
            <tf.RaggedTensor [[5, 7, 0], [0, 3, 0], [6, 0, 0]]>
            >>> tf.RaggedTensor.from_tensor(dt, lengths=[1, 0, 3])
            <tf.RaggedTensor [[5], [], [6, 0, 0]]> <p></p> >>> tf.RaggedTensor.from_tensor(dt, padding=0)
<tf.RaggedTensor [[5, 7], [0, 3], [6]]> <p></p> >>> dt = tf.constant([[[5, 0], [7, 0], [0, 0]],
                      [[0, 0], [3, 0], [0, 0]],
                      [[6, 0], [0, 0], [0, 0]]])
>>> tf.RaggedTensor.from_tensor(dt, lengths=([2, 0, 3], [1, 1, 2, 0, 1]))
<tf.RaggedTensor [[[5], [7]], [], [[6, 0], [], [0]]]> </pre>
</div>
		</div>
	</div>
	<div id="from_tensor``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_tensor&lt;TClass&gt;</strong>(<span title="System.object">object</span> tensor, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> lengths, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> padding, <span title="System.int">int</span> ragged_rank, <span title="System.string">string</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> row_splits_dtype)
		</h4>
		<div class="content">Converts a <a href="..\tf\Tensor.md"><code>tf.Tensor</code></a> into a `RaggedTensor`. <p></p> The set of absent/default values may be specified using a vector of lengths
or a padding value (but not both).  If `lengths` is specified, then the
output tensor will satisfy `output[row] = tensor[row][:lengths[row]]`. If
'lengths' is a list of lists or tuple of lists, those lists will be used
as nested row lengths. If `padding` is specified, then any row *suffix*
consisting entirely of `padding` will be excluded from the returned
`RaggedTensor`.  If neither `lengths` nor `padding` is specified, then the
returned `RaggedTensor` will have no absent/default values. <p></p> Examples: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> tensor
						</dt>
						<dd>The `Tensor` to convert.  Must have rank `ragged_rank + 1` or
higher. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> lengths
						</dt>
						<dd>An optional set of row lengths, specified using a 1-D integer
`Tensor` whose length is equal to `tensor.shape[0]` (the number of rows
in `tensor`).  If specified, then `output[row]` will contain
`tensor[row][:lengths[row]]`.  Negative lengths are treated as zero. You
may optionally pass a list or tuple of lengths to this argument, which
will be used as nested row lengths to construct a ragged tensor with
multiple ragged dimensions. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> padding
						</dt>
						<dd>An optional padding value.  If specified, then any row suffix
consisting entirely of `padding` will be excluded from the returned
RaggedTensor.  `padding` is a `Tensor` with the same dtype as `tensor`
and with `shape=tensor.shape[ragged_rank + 1:]`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> ragged_rank
						</dt>
						<dd>Integer specifying the ragged rank for the returned
`RaggedTensor`.  Must be greater than zero. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensors (optional). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> row_splits_dtype
						</dt>
						<dd>`dtype` for the returned `RaggedTensor`'s `row_splits`
tensor.  One of <a href="..\tf\dtypes\int32.md"><code>tf.int32</code></a> or <a href="..\tf\dtypes\int64.md"><code>tf.int64</code></a>. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor` with the specified `ragged_rank`.  The shape of the
returned ragged tensor is compatible with the shape of `tensor`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> dt = tf.constant([[5, 7, 0], [0, 3, 0], [6, 0, 0]])
            >>> tf.RaggedTensor.from_tensor(dt)
            <tf.RaggedTensor [[5, 7, 0], [0, 3, 0], [6, 0, 0]]>
            >>> tf.RaggedTensor.from_tensor(dt, lengths=[1, 0, 3])
            <tf.RaggedTensor [[5], [], [6, 0, 0]]> <p></p> >>> tf.RaggedTensor.from_tensor(dt, padding=0)
<tf.RaggedTensor [[5, 7], [0, 3], [6]]> <p></p> >>> dt = tf.constant([[[5, 0], [7, 0], [0, 0]],
                      [[0, 0], [3, 0], [0, 0]],
                      [[6, 0], [0, 0], [0, 0]]])
>>> tf.RaggedTensor.from_tensor(dt, lengths=([2, 0, 3], [1, 1, 2, 0, 1]))
<tf.RaggedTensor [[[5], [7]], [], [[6, 0], [], [0]]]> </pre>
</div>
		</div>
	</div>
	<div id="from_tensor``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_tensor&lt;TClass&gt;</strong>(<span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span> tensor, <span title="System.ValueTuple<IEnumerable<object>, object>">ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;</span> lengths, <span title="System.int">int</span> padding, <a href="../tensorflow/Dimension.htm">Dimension</a> ragged_rank, <span title="System.string">string</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> row_splits_dtype)
		</h4>
		<div class="content">Converts a <a href="..\tf\Tensor.md"><code>tf.Tensor</code></a> into a `RaggedTensor`. <p></p> The set of absent/default values may be specified using a vector of lengths
or a padding value (but not both).  If `lengths` is specified, then the
output tensor will satisfy `output[row] = tensor[row][:lengths[row]]`. If
'lengths' is a list of lists or tuple of lists, those lists will be used
as nested row lengths. If `padding` is specified, then any row *suffix*
consisting entirely of `padding` will be excluded from the returned
`RaggedTensor`.  If neither `lengths` nor `padding` is specified, then the
returned `RaggedTensor` will have no absent/default values. <p></p> Examples: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span></code> tensor
						</dt>
						<dd>The `Tensor` to convert.  Must have rank `ragged_rank + 1` or
higher. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<IEnumerable<object>, object>">ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;</span></code> lengths
						</dt>
						<dd>An optional set of row lengths, specified using a 1-D integer
`Tensor` whose length is equal to `tensor.shape[0]` (the number of rows
in `tensor`).  If specified, then `output[row]` will contain
`tensor[row][:lengths[row]]`.  Negative lengths are treated as zero. You
may optionally pass a list or tuple of lengths to this argument, which
will be used as nested row lengths to construct a ragged tensor with
multiple ragged dimensions. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> padding
						</dt>
						<dd>An optional padding value.  If specified, then any row suffix
consisting entirely of `padding` will be excluded from the returned
RaggedTensor.  `padding` is a `Tensor` with the same dtype as `tensor`
and with `shape=tensor.shape[ragged_rank + 1:]`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/Dimension.htm">Dimension</a></code> ragged_rank
						</dt>
						<dd>Integer specifying the ragged rank for the returned
`RaggedTensor`.  Must be greater than zero. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensors (optional). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> row_splits_dtype
						</dt>
						<dd>`dtype` for the returned `RaggedTensor`'s `row_splits`
tensor.  One of <a href="..\tf\dtypes\int32.md"><code>tf.int32</code></a> or <a href="..\tf\dtypes\int64.md"><code>tf.int64</code></a>. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor` with the specified `ragged_rank`.  The shape of the
returned ragged tensor is compatible with the shape of `tensor`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> dt = tf.constant([[5, 7, 0], [0, 3, 0], [6, 0, 0]])
            >>> tf.RaggedTensor.from_tensor(dt)
            <tf.RaggedTensor [[5, 7, 0], [0, 3, 0], [6, 0, 0]]>
            >>> tf.RaggedTensor.from_tensor(dt, lengths=[1, 0, 3])
            <tf.RaggedTensor [[5], [], [6, 0, 0]]> <p></p> >>> tf.RaggedTensor.from_tensor(dt, padding=0)
<tf.RaggedTensor [[5, 7], [0, 3], [6]]> <p></p> >>> dt = tf.constant([[[5, 0], [7, 0], [0, 0]],
                      [[0, 0], [3, 0], [0, 0]],
                      [[6, 0], [0, 0], [0, 0]]])
>>> tf.RaggedTensor.from_tensor(dt, lengths=([2, 0, 3], [1, 1, 2, 0, 1]))
<tf.RaggedTensor [[[5], [7]], [], [[6, 0], [], [0]]]> </pre>
</div>
		</div>
	</div>
	<div id="from_tensor``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_tensor&lt;TClass&gt;</strong>(<span title="System.object">object</span> tensor, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> lengths, <span title="System.int">int</span> padding, <a href="../tensorflow/Dimension.htm">Dimension</a> ragged_rank, <span title="System.string">string</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> row_splits_dtype)
		</h4>
		<div class="content">Converts a <a href="..\tf\Tensor.md"><code>tf.Tensor</code></a> into a `RaggedTensor`. <p></p> The set of absent/default values may be specified using a vector of lengths
or a padding value (but not both).  If `lengths` is specified, then the
output tensor will satisfy `output[row] = tensor[row][:lengths[row]]`. If
'lengths' is a list of lists or tuple of lists, those lists will be used
as nested row lengths. If `padding` is specified, then any row *suffix*
consisting entirely of `padding` will be excluded from the returned
`RaggedTensor`.  If neither `lengths` nor `padding` is specified, then the
returned `RaggedTensor` will have no absent/default values. <p></p> Examples: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> tensor
						</dt>
						<dd>The `Tensor` to convert.  Must have rank `ragged_rank + 1` or
higher. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> lengths
						</dt>
						<dd>An optional set of row lengths, specified using a 1-D integer
`Tensor` whose length is equal to `tensor.shape[0]` (the number of rows
in `tensor`).  If specified, then `output[row]` will contain
`tensor[row][:lengths[row]]`.  Negative lengths are treated as zero. You
may optionally pass a list or tuple of lengths to this argument, which
will be used as nested row lengths to construct a ragged tensor with
multiple ragged dimensions. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> padding
						</dt>
						<dd>An optional padding value.  If specified, then any row suffix
consisting entirely of `padding` will be excluded from the returned
RaggedTensor.  `padding` is a `Tensor` with the same dtype as `tensor`
and with `shape=tensor.shape[ragged_rank + 1:]`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/Dimension.htm">Dimension</a></code> ragged_rank
						</dt>
						<dd>Integer specifying the ragged rank for the returned
`RaggedTensor`.  Must be greater than zero. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensors (optional). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> row_splits_dtype
						</dt>
						<dd>`dtype` for the returned `RaggedTensor`'s `row_splits`
tensor.  One of <a href="..\tf\dtypes\int32.md"><code>tf.int32</code></a> or <a href="..\tf\dtypes\int64.md"><code>tf.int64</code></a>. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor` with the specified `ragged_rank`.  The shape of the
returned ragged tensor is compatible with the shape of `tensor`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> dt = tf.constant([[5, 7, 0], [0, 3, 0], [6, 0, 0]])
            >>> tf.RaggedTensor.from_tensor(dt)
            <tf.RaggedTensor [[5, 7, 0], [0, 3, 0], [6, 0, 0]]>
            >>> tf.RaggedTensor.from_tensor(dt, lengths=[1, 0, 3])
            <tf.RaggedTensor [[5], [], [6, 0, 0]]> <p></p> >>> tf.RaggedTensor.from_tensor(dt, padding=0)
<tf.RaggedTensor [[5, 7], [0, 3], [6]]> <p></p> >>> dt = tf.constant([[[5, 0], [7, 0], [0, 0]],
                      [[0, 0], [3, 0], [0, 0]],
                      [[6, 0], [0, 0], [0, 0]]])
>>> tf.RaggedTensor.from_tensor(dt, lengths=([2, 0, 3], [1, 1, 2, 0, 1]))
<tf.RaggedTensor [[[5], [7]], [], [[6, 0], [], [0]]]> </pre>
</div>
		</div>
	</div>
	<div id="from_tensor``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_tensor&lt;TClass&gt;</strong>(<span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span> tensor, <span title="System.ValueTuple<IEnumerable<object>, object>">ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;</span> lengths, <span title="System.int">int</span> padding, <span title="System.int">int</span> ragged_rank, <span title="System.string">string</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> row_splits_dtype)
		</h4>
		<div class="content">Converts a <a href="..\tf\Tensor.md"><code>tf.Tensor</code></a> into a `RaggedTensor`. <p></p> The set of absent/default values may be specified using a vector of lengths
or a padding value (but not both).  If `lengths` is specified, then the
output tensor will satisfy `output[row] = tensor[row][:lengths[row]]`. If
'lengths' is a list of lists or tuple of lists, those lists will be used
as nested row lengths. If `padding` is specified, then any row *suffix*
consisting entirely of `padding` will be excluded from the returned
`RaggedTensor`.  If neither `lengths` nor `padding` is specified, then the
returned `RaggedTensor` will have no absent/default values. <p></p> Examples: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span></code> tensor
						</dt>
						<dd>The `Tensor` to convert.  Must have rank `ragged_rank + 1` or
higher. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<IEnumerable<object>, object>">ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;</span></code> lengths
						</dt>
						<dd>An optional set of row lengths, specified using a 1-D integer
`Tensor` whose length is equal to `tensor.shape[0]` (the number of rows
in `tensor`).  If specified, then `output[row]` will contain
`tensor[row][:lengths[row]]`.  Negative lengths are treated as zero. You
may optionally pass a list or tuple of lengths to this argument, which
will be used as nested row lengths to construct a ragged tensor with
multiple ragged dimensions. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> padding
						</dt>
						<dd>An optional padding value.  If specified, then any row suffix
consisting entirely of `padding` will be excluded from the returned
RaggedTensor.  `padding` is a `Tensor` with the same dtype as `tensor`
and with `shape=tensor.shape[ragged_rank + 1:]`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> ragged_rank
						</dt>
						<dd>Integer specifying the ragged rank for the returned
`RaggedTensor`.  Must be greater than zero. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensors (optional). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> row_splits_dtype
						</dt>
						<dd>`dtype` for the returned `RaggedTensor`'s `row_splits`
tensor.  One of <a href="..\tf\dtypes\int32.md"><code>tf.int32</code></a> or <a href="..\tf\dtypes\int64.md"><code>tf.int64</code></a>. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor` with the specified `ragged_rank`.  The shape of the
returned ragged tensor is compatible with the shape of `tensor`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> dt = tf.constant([[5, 7, 0], [0, 3, 0], [6, 0, 0]])
            >>> tf.RaggedTensor.from_tensor(dt)
            <tf.RaggedTensor [[5, 7, 0], [0, 3, 0], [6, 0, 0]]>
            >>> tf.RaggedTensor.from_tensor(dt, lengths=[1, 0, 3])
            <tf.RaggedTensor [[5], [], [6, 0, 0]]> <p></p> >>> tf.RaggedTensor.from_tensor(dt, padding=0)
<tf.RaggedTensor [[5, 7], [0, 3], [6]]> <p></p> >>> dt = tf.constant([[[5, 0], [7, 0], [0, 0]],
                      [[0, 0], [3, 0], [0, 0]],
                      [[6, 0], [0, 0], [0, 0]]])
>>> tf.RaggedTensor.from_tensor(dt, lengths=([2, 0, 3], [1, 1, 2, 0, 1]))
<tf.RaggedTensor [[[5], [7]], [], [[6, 0], [], [0]]]> </pre>
</div>
		</div>
	</div>
	<div id="from_tensor``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_tensor&lt;TClass&gt;</strong>(<span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span> tensor, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> lengths, <span title="System.int">int</span> padding, <a href="../tensorflow/Dimension.htm">Dimension</a> ragged_rank, <span title="System.string">string</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> row_splits_dtype)
		</h4>
		<div class="content">Converts a <a href="..\tf\Tensor.md"><code>tf.Tensor</code></a> into a `RaggedTensor`. <p></p> The set of absent/default values may be specified using a vector of lengths
or a padding value (but not both).  If `lengths` is specified, then the
output tensor will satisfy `output[row] = tensor[row][:lengths[row]]`. If
'lengths' is a list of lists or tuple of lists, those lists will be used
as nested row lengths. If `padding` is specified, then any row *suffix*
consisting entirely of `padding` will be excluded from the returned
`RaggedTensor`.  If neither `lengths` nor `padding` is specified, then the
returned `RaggedTensor` will have no absent/default values. <p></p> Examples: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span></code> tensor
						</dt>
						<dd>The `Tensor` to convert.  Must have rank `ragged_rank + 1` or
higher. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> lengths
						</dt>
						<dd>An optional set of row lengths, specified using a 1-D integer
`Tensor` whose length is equal to `tensor.shape[0]` (the number of rows
in `tensor`).  If specified, then `output[row]` will contain
`tensor[row][:lengths[row]]`.  Negative lengths are treated as zero. You
may optionally pass a list or tuple of lengths to this argument, which
will be used as nested row lengths to construct a ragged tensor with
multiple ragged dimensions. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> padding
						</dt>
						<dd>An optional padding value.  If specified, then any row suffix
consisting entirely of `padding` will be excluded from the returned
RaggedTensor.  `padding` is a `Tensor` with the same dtype as `tensor`
and with `shape=tensor.shape[ragged_rank + 1:]`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/Dimension.htm">Dimension</a></code> ragged_rank
						</dt>
						<dd>Integer specifying the ragged rank for the returned
`RaggedTensor`.  Must be greater than zero. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensors (optional). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> row_splits_dtype
						</dt>
						<dd>`dtype` for the returned `RaggedTensor`'s `row_splits`
tensor.  One of <a href="..\tf\dtypes\int32.md"><code>tf.int32</code></a> or <a href="..\tf\dtypes\int64.md"><code>tf.int64</code></a>. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor` with the specified `ragged_rank`.  The shape of the
returned ragged tensor is compatible with the shape of `tensor`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> dt = tf.constant([[5, 7, 0], [0, 3, 0], [6, 0, 0]])
            >>> tf.RaggedTensor.from_tensor(dt)
            <tf.RaggedTensor [[5, 7, 0], [0, 3, 0], [6, 0, 0]]>
            >>> tf.RaggedTensor.from_tensor(dt, lengths=[1, 0, 3])
            <tf.RaggedTensor [[5], [], [6, 0, 0]]> <p></p> >>> tf.RaggedTensor.from_tensor(dt, padding=0)
<tf.RaggedTensor [[5, 7], [0, 3], [6]]> <p></p> >>> dt = tf.constant([[[5, 0], [7, 0], [0, 0]],
                      [[0, 0], [3, 0], [0, 0]],
                      [[6, 0], [0, 0], [0, 0]]])
>>> tf.RaggedTensor.from_tensor(dt, lengths=([2, 0, 3], [1, 1, 2, 0, 1]))
<tf.RaggedTensor [[[5], [7]], [], [[6, 0], [], [0]]]> </pre>
</div>
		</div>
	</div>
	<div id="from_tensor``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_tensor&lt;TClass&gt;</strong>(<span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span> tensor, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> lengths, <span title="System.int">int</span> padding, <span title="System.int">int</span> ragged_rank, <span title="System.string">string</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> row_splits_dtype)
		</h4>
		<div class="content">Converts a <a href="..\tf\Tensor.md"><code>tf.Tensor</code></a> into a `RaggedTensor`. <p></p> The set of absent/default values may be specified using a vector of lengths
or a padding value (but not both).  If `lengths` is specified, then the
output tensor will satisfy `output[row] = tensor[row][:lengths[row]]`. If
'lengths' is a list of lists or tuple of lists, those lists will be used
as nested row lengths. If `padding` is specified, then any row *suffix*
consisting entirely of `padding` will be excluded from the returned
`RaggedTensor`.  If neither `lengths` nor `padding` is specified, then the
returned `RaggedTensor` will have no absent/default values. <p></p> Examples: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span></code> tensor
						</dt>
						<dd>The `Tensor` to convert.  Must have rank `ragged_rank + 1` or
higher. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> lengths
						</dt>
						<dd>An optional set of row lengths, specified using a 1-D integer
`Tensor` whose length is equal to `tensor.shape[0]` (the number of rows
in `tensor`).  If specified, then `output[row]` will contain
`tensor[row][:lengths[row]]`.  Negative lengths are treated as zero. You
may optionally pass a list or tuple of lengths to this argument, which
will be used as nested row lengths to construct a ragged tensor with
multiple ragged dimensions. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> padding
						</dt>
						<dd>An optional padding value.  If specified, then any row suffix
consisting entirely of `padding` will be excluded from the returned
RaggedTensor.  `padding` is a `Tensor` with the same dtype as `tensor`
and with `shape=tensor.shape[ragged_rank + 1:]`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> ragged_rank
						</dt>
						<dd>Integer specifying the ragged rank for the returned
`RaggedTensor`.  Must be greater than zero. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensors (optional). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> row_splits_dtype
						</dt>
						<dd>`dtype` for the returned `RaggedTensor`'s `row_splits`
tensor.  One of <a href="..\tf\dtypes\int32.md"><code>tf.int32</code></a> or <a href="..\tf\dtypes\int64.md"><code>tf.int64</code></a>. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor` with the specified `ragged_rank`.  The shape of the
returned ragged tensor is compatible with the shape of `tensor`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> dt = tf.constant([[5, 7, 0], [0, 3, 0], [6, 0, 0]])
            >>> tf.RaggedTensor.from_tensor(dt)
            <tf.RaggedTensor [[5, 7, 0], [0, 3, 0], [6, 0, 0]]>
            >>> tf.RaggedTensor.from_tensor(dt, lengths=[1, 0, 3])
            <tf.RaggedTensor [[5], [], [6, 0, 0]]> <p></p> >>> tf.RaggedTensor.from_tensor(dt, padding=0)
<tf.RaggedTensor [[5, 7], [0, 3], [6]]> <p></p> >>> dt = tf.constant([[[5, 0], [7, 0], [0, 0]],
                      [[0, 0], [3, 0], [0, 0]],
                      [[6, 0], [0, 0], [0, 0]]])
>>> tf.RaggedTensor.from_tensor(dt, lengths=([2, 0, 3], [1, 1, 2, 0, 1]))
<tf.RaggedTensor [[[5], [7]], [], [[6, 0], [], [0]]]> </pre>
</div>
		</div>
	</div>
	<div id="from_tensor``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_tensor&lt;TClass&gt;</strong>(<span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span> tensor, <span title="System.ValueTuple<IEnumerable<object>, object>">ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;</span> lengths, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> padding, <span title="System.int">int</span> ragged_rank, <span title="System.string">string</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> row_splits_dtype)
		</h4>
		<div class="content">Converts a <a href="..\tf\Tensor.md"><code>tf.Tensor</code></a> into a `RaggedTensor`. <p></p> The set of absent/default values may be specified using a vector of lengths
or a padding value (but not both).  If `lengths` is specified, then the
output tensor will satisfy `output[row] = tensor[row][:lengths[row]]`. If
'lengths' is a list of lists or tuple of lists, those lists will be used
as nested row lengths. If `padding` is specified, then any row *suffix*
consisting entirely of `padding` will be excluded from the returned
`RaggedTensor`.  If neither `lengths` nor `padding` is specified, then the
returned `RaggedTensor` will have no absent/default values. <p></p> Examples: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span></code> tensor
						</dt>
						<dd>The `Tensor` to convert.  Must have rank `ragged_rank + 1` or
higher. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<IEnumerable<object>, object>">ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;</span></code> lengths
						</dt>
						<dd>An optional set of row lengths, specified using a 1-D integer
`Tensor` whose length is equal to `tensor.shape[0]` (the number of rows
in `tensor`).  If specified, then `output[row]` will contain
`tensor[row][:lengths[row]]`.  Negative lengths are treated as zero. You
may optionally pass a list or tuple of lengths to this argument, which
will be used as nested row lengths to construct a ragged tensor with
multiple ragged dimensions. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> padding
						</dt>
						<dd>An optional padding value.  If specified, then any row suffix
consisting entirely of `padding` will be excluded from the returned
RaggedTensor.  `padding` is a `Tensor` with the same dtype as `tensor`
and with `shape=tensor.shape[ragged_rank + 1:]`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> ragged_rank
						</dt>
						<dd>Integer specifying the ragged rank for the returned
`RaggedTensor`.  Must be greater than zero. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensors (optional). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> row_splits_dtype
						</dt>
						<dd>`dtype` for the returned `RaggedTensor`'s `row_splits`
tensor.  One of <a href="..\tf\dtypes\int32.md"><code>tf.int32</code></a> or <a href="..\tf\dtypes\int64.md"><code>tf.int64</code></a>. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor` with the specified `ragged_rank`.  The shape of the
returned ragged tensor is compatible with the shape of `tensor`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> dt = tf.constant([[5, 7, 0], [0, 3, 0], [6, 0, 0]])
            >>> tf.RaggedTensor.from_tensor(dt)
            <tf.RaggedTensor [[5, 7, 0], [0, 3, 0], [6, 0, 0]]>
            >>> tf.RaggedTensor.from_tensor(dt, lengths=[1, 0, 3])
            <tf.RaggedTensor [[5], [], [6, 0, 0]]> <p></p> >>> tf.RaggedTensor.from_tensor(dt, padding=0)
<tf.RaggedTensor [[5, 7], [0, 3], [6]]> <p></p> >>> dt = tf.constant([[[5, 0], [7, 0], [0, 0]],
                      [[0, 0], [3, 0], [0, 0]],
                      [[6, 0], [0, 0], [0, 0]]])
>>> tf.RaggedTensor.from_tensor(dt, lengths=([2, 0, 3], [1, 1, 2, 0, 1]))
<tf.RaggedTensor [[[5], [7]], [], [[6, 0], [], [0]]]> </pre>
</div>
		</div>
	</div>
	<div id="from_tensor``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_tensor&lt;TClass&gt;</strong>(<span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span> tensor, <span title="System.ValueTuple<IEnumerable<object>, object>">ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;</span> lengths, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> padding, <a href="../tensorflow/Dimension.htm">Dimension</a> ragged_rank, <span title="System.string">string</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> row_splits_dtype)
		</h4>
		<div class="content">Converts a <a href="..\tf\Tensor.md"><code>tf.Tensor</code></a> into a `RaggedTensor`. <p></p> The set of absent/default values may be specified using a vector of lengths
or a padding value (but not both).  If `lengths` is specified, then the
output tensor will satisfy `output[row] = tensor[row][:lengths[row]]`. If
'lengths' is a list of lists or tuple of lists, those lists will be used
as nested row lengths. If `padding` is specified, then any row *suffix*
consisting entirely of `padding` will be excluded from the returned
`RaggedTensor`.  If neither `lengths` nor `padding` is specified, then the
returned `RaggedTensor` will have no absent/default values. <p></p> Examples: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span></code> tensor
						</dt>
						<dd>The `Tensor` to convert.  Must have rank `ragged_rank + 1` or
higher. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<IEnumerable<object>, object>">ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;</span></code> lengths
						</dt>
						<dd>An optional set of row lengths, specified using a 1-D integer
`Tensor` whose length is equal to `tensor.shape[0]` (the number of rows
in `tensor`).  If specified, then `output[row]` will contain
`tensor[row][:lengths[row]]`.  Negative lengths are treated as zero. You
may optionally pass a list or tuple of lengths to this argument, which
will be used as nested row lengths to construct a ragged tensor with
multiple ragged dimensions. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> padding
						</dt>
						<dd>An optional padding value.  If specified, then any row suffix
consisting entirely of `padding` will be excluded from the returned
RaggedTensor.  `padding` is a `Tensor` with the same dtype as `tensor`
and with `shape=tensor.shape[ragged_rank + 1:]`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/Dimension.htm">Dimension</a></code> ragged_rank
						</dt>
						<dd>Integer specifying the ragged rank for the returned
`RaggedTensor`.  Must be greater than zero. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensors (optional). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> row_splits_dtype
						</dt>
						<dd>`dtype` for the returned `RaggedTensor`'s `row_splits`
tensor.  One of <a href="..\tf\dtypes\int32.md"><code>tf.int32</code></a> or <a href="..\tf\dtypes\int64.md"><code>tf.int64</code></a>. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor` with the specified `ragged_rank`.  The shape of the
returned ragged tensor is compatible with the shape of `tensor`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> dt = tf.constant([[5, 7, 0], [0, 3, 0], [6, 0, 0]])
            >>> tf.RaggedTensor.from_tensor(dt)
            <tf.RaggedTensor [[5, 7, 0], [0, 3, 0], [6, 0, 0]]>
            >>> tf.RaggedTensor.from_tensor(dt, lengths=[1, 0, 3])
            <tf.RaggedTensor [[5], [], [6, 0, 0]]> <p></p> >>> tf.RaggedTensor.from_tensor(dt, padding=0)
<tf.RaggedTensor [[5, 7], [0, 3], [6]]> <p></p> >>> dt = tf.constant([[[5, 0], [7, 0], [0, 0]],
                      [[0, 0], [3, 0], [0, 0]],
                      [[6, 0], [0, 0], [0, 0]]])
>>> tf.RaggedTensor.from_tensor(dt, lengths=([2, 0, 3], [1, 1, 2, 0, 1]))
<tf.RaggedTensor [[[5], [7]], [], [[6, 0], [], [0]]]> </pre>
</div>
		</div>
	</div>
	<div id="from_tensor``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_tensor&lt;TClass&gt;</strong>(<span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span> tensor, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> lengths, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> padding, <a href="../tensorflow/Dimension.htm">Dimension</a> ragged_rank, <span title="System.string">string</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> row_splits_dtype)
		</h4>
		<div class="content">Converts a <a href="..\tf\Tensor.md"><code>tf.Tensor</code></a> into a `RaggedTensor`. <p></p> The set of absent/default values may be specified using a vector of lengths
or a padding value (but not both).  If `lengths` is specified, then the
output tensor will satisfy `output[row] = tensor[row][:lengths[row]]`. If
'lengths' is a list of lists or tuple of lists, those lists will be used
as nested row lengths. If `padding` is specified, then any row *suffix*
consisting entirely of `padding` will be excluded from the returned
`RaggedTensor`.  If neither `lengths` nor `padding` is specified, then the
returned `RaggedTensor` will have no absent/default values. <p></p> Examples: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span></code> tensor
						</dt>
						<dd>The `Tensor` to convert.  Must have rank `ragged_rank + 1` or
higher. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> lengths
						</dt>
						<dd>An optional set of row lengths, specified using a 1-D integer
`Tensor` whose length is equal to `tensor.shape[0]` (the number of rows
in `tensor`).  If specified, then `output[row]` will contain
`tensor[row][:lengths[row]]`.  Negative lengths are treated as zero. You
may optionally pass a list or tuple of lengths to this argument, which
will be used as nested row lengths to construct a ragged tensor with
multiple ragged dimensions. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> padding
						</dt>
						<dd>An optional padding value.  If specified, then any row suffix
consisting entirely of `padding` will be excluded from the returned
RaggedTensor.  `padding` is a `Tensor` with the same dtype as `tensor`
and with `shape=tensor.shape[ragged_rank + 1:]`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/Dimension.htm">Dimension</a></code> ragged_rank
						</dt>
						<dd>Integer specifying the ragged rank for the returned
`RaggedTensor`.  Must be greater than zero. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensors (optional). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> row_splits_dtype
						</dt>
						<dd>`dtype` for the returned `RaggedTensor`'s `row_splits`
tensor.  One of <a href="..\tf\dtypes\int32.md"><code>tf.int32</code></a> or <a href="..\tf\dtypes\int64.md"><code>tf.int64</code></a>. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor` with the specified `ragged_rank`.  The shape of the
returned ragged tensor is compatible with the shape of `tensor`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> dt = tf.constant([[5, 7, 0], [0, 3, 0], [6, 0, 0]])
            >>> tf.RaggedTensor.from_tensor(dt)
            <tf.RaggedTensor [[5, 7, 0], [0, 3, 0], [6, 0, 0]]>
            >>> tf.RaggedTensor.from_tensor(dt, lengths=[1, 0, 3])
            <tf.RaggedTensor [[5], [], [6, 0, 0]]> <p></p> >>> tf.RaggedTensor.from_tensor(dt, padding=0)
<tf.RaggedTensor [[5, 7], [0, 3], [6]]> <p></p> >>> dt = tf.constant([[[5, 0], [7, 0], [0, 0]],
                      [[0, 0], [3, 0], [0, 0]],
                      [[6, 0], [0, 0], [0, 0]]])
>>> tf.RaggedTensor.from_tensor(dt, lengths=([2, 0, 3], [1, 1, 2, 0, 1]))
<tf.RaggedTensor [[[5], [7]], [], [[6, 0], [], [0]]]> </pre>
</div>
		</div>
	</div>
	<div id="from_value_rowids_dyn``1" class="method">
		<h4>
			<span title="System.object">object</span> <strong>from_value_rowids_dyn&lt;TClass&gt;</strong>(<span title="System.object">object</span> values, <span title="System.object">object</span> value_rowids, <span title="System.object">object</span> nrows, <span title="System.object">object</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` with rows partitioned by `value_rowids`. <p></p> The returned `RaggedTensor` corresponds with the python list defined by: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> values
						</dt>
						<dd>A potentially ragged tensor with shape `[nvals,...]`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> value_rowids
						</dt>
						<dd>A 1-D integer tensor with shape `[nvals]`, which corresponds
one-to-one with `values`, and specifies each value's row index.  Must be
nonnegative, and must be sorted in ascending order. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> nrows
						</dt>
						<dd>An integer scalar specifying the number of rows.  This should be
specified if the `RaggedTensor` may containing empty training rows. Must
be greater than `value_rowids[-1]` (or zero if `value_rowids` is empty).
Defaults to `value_rowids[-1]` (or zero if `value_rowids` is empty). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = values.rank + 1`.
`result.ragged_rank = values.ragged_rank + 1`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = [[values[i] for i in range(len(values)) if value_rowids[i] == row]
                      for row in range(nrows)] </pre>
</div>
		</div>
	</div>
	<div id="from_value_rowids``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_value_rowids&lt;TClass&gt;</strong>(<span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span> values, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> value_rowids, <span title="System.object">object</span> nrows, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` with rows partitioned by `value_rowids`. <p></p> The returned `RaggedTensor` corresponds with the python list defined by: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span></code> values
						</dt>
						<dd>A potentially ragged tensor with shape `[nvals,...]`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> value_rowids
						</dt>
						<dd>A 1-D integer tensor with shape `[nvals]`, which corresponds
one-to-one with `values`, and specifies each value's row index.  Must be
nonnegative, and must be sorted in ascending order. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> nrows
						</dt>
						<dd>An integer scalar specifying the number of rows.  This should be
specified if the `RaggedTensor` may containing empty training rows. Must
be greater than `value_rowids[-1]` (or zero if `value_rowids` is empty).
Defaults to `value_rowids[-1]` (or zero if `value_rowids` is empty). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = values.rank + 1`.
`result.ragged_rank = values.ragged_rank + 1`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = [[values[i] for i in range(len(values)) if value_rowids[i] == row]
                      for row in range(nrows)] </pre>
</div>
		</div>
	</div>
	<div id="from_value_rowids``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_value_rowids&lt;TClass&gt;</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> values, <a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> value_rowids, <span title="System.object">object</span> nrows, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` with rows partitioned by `value_rowids`. <p></p> The returned `RaggedTensor` corresponds with the python list defined by: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> values
						</dt>
						<dd>A potentially ragged tensor with shape `[nvals,...]`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> value_rowids
						</dt>
						<dd>A 1-D integer tensor with shape `[nvals]`, which corresponds
one-to-one with `values`, and specifies each value's row index.  Must be
nonnegative, and must be sorted in ascending order. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> nrows
						</dt>
						<dd>An integer scalar specifying the number of rows.  This should be
specified if the `RaggedTensor` may containing empty training rows. Must
be greater than `value_rowids[-1]` (or zero if `value_rowids` is empty).
Defaults to `value_rowids[-1]` (or zero if `value_rowids` is empty). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = values.rank + 1`.
`result.ragged_rank = values.ragged_rank + 1`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = [[values[i] for i in range(len(values)) if value_rowids[i] == row]
                      for row in range(nrows)] </pre>
</div>
		</div>
	</div>
	<div id="from_value_rowids``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_value_rowids&lt;TClass&gt;</strong>(<span title="System.object">object</span> values, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> value_rowids, <span title="System.object">object</span> nrows, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` with rows partitioned by `value_rowids`. <p></p> The returned `RaggedTensor` corresponds with the python list defined by: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> values
						</dt>
						<dd>A potentially ragged tensor with shape `[nvals,...]`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> value_rowids
						</dt>
						<dd>A 1-D integer tensor with shape `[nvals]`, which corresponds
one-to-one with `values`, and specifies each value's row index.  Must be
nonnegative, and must be sorted in ascending order. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> nrows
						</dt>
						<dd>An integer scalar specifying the number of rows.  This should be
specified if the `RaggedTensor` may containing empty training rows. Must
be greater than `value_rowids[-1]` (or zero if `value_rowids` is empty).
Defaults to `value_rowids[-1]` (or zero if `value_rowids` is empty). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = values.rank + 1`.
`result.ragged_rank = values.ragged_rank + 1`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = [[values[i] for i in range(len(values)) if value_rowids[i] == row]
                      for row in range(nrows)] </pre>
</div>
		</div>
	</div>
	<div id="from_value_rowids``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_value_rowids&lt;TClass&gt;</strong>(<span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span> values, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> value_rowids, <span title="System.object">object</span> nrows, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` with rows partitioned by `value_rowids`. <p></p> The returned `RaggedTensor` corresponds with the python list defined by: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span></code> values
						</dt>
						<dd>A potentially ragged tensor with shape `[nvals,...]`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> value_rowids
						</dt>
						<dd>A 1-D integer tensor with shape `[nvals]`, which corresponds
one-to-one with `values`, and specifies each value's row index.  Must be
nonnegative, and must be sorted in ascending order. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> nrows
						</dt>
						<dd>An integer scalar specifying the number of rows.  This should be
specified if the `RaggedTensor` may containing empty training rows. Must
be greater than `value_rowids[-1]` (or zero if `value_rowids` is empty).
Defaults to `value_rowids[-1]` (or zero if `value_rowids` is empty). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = values.rank + 1`.
`result.ragged_rank = values.ragged_rank + 1`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = [[values[i] for i in range(len(values)) if value_rowids[i] == row]
                      for row in range(nrows)] </pre>
</div>
		</div>
	</div>
	<div id="from_value_rowids``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_value_rowids&lt;TClass&gt;</strong>(<span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span> values, <span title="System.int">int</span> value_rowids, <span title="System.object">object</span> nrows, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` with rows partitioned by `value_rowids`. <p></p> The returned `RaggedTensor` corresponds with the python list defined by: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span></code> values
						</dt>
						<dd>A potentially ragged tensor with shape `[nvals,...]`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> value_rowids
						</dt>
						<dd>A 1-D integer tensor with shape `[nvals]`, which corresponds
one-to-one with `values`, and specifies each value's row index.  Must be
nonnegative, and must be sorted in ascending order. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> nrows
						</dt>
						<dd>An integer scalar specifying the number of rows.  This should be
specified if the `RaggedTensor` may containing empty training rows. Must
be greater than `value_rowids[-1]` (or zero if `value_rowids` is empty).
Defaults to `value_rowids[-1]` (or zero if `value_rowids` is empty). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = values.rank + 1`.
`result.ragged_rank = values.ragged_rank + 1`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = [[values[i] for i in range(len(values)) if value_rowids[i] == row]
                      for row in range(nrows)] </pre>
</div>
		</div>
	</div>
	<div id="from_value_rowids``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_value_rowids&lt;TClass&gt;</strong>(<span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span> values, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> value_rowids, <span title="System.object">object</span> nrows, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` with rows partitioned by `value_rowids`. <p></p> The returned `RaggedTensor` corresponds with the python list defined by: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span></code> values
						</dt>
						<dd>A potentially ragged tensor with shape `[nvals,...]`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> value_rowids
						</dt>
						<dd>A 1-D integer tensor with shape `[nvals]`, which corresponds
one-to-one with `values`, and specifies each value's row index.  Must be
nonnegative, and must be sorted in ascending order. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> nrows
						</dt>
						<dd>An integer scalar specifying the number of rows.  This should be
specified if the `RaggedTensor` may containing empty training rows. Must
be greater than `value_rowids[-1]` (or zero if `value_rowids` is empty).
Defaults to `value_rowids[-1]` (or zero if `value_rowids` is empty). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = values.rank + 1`.
`result.ragged_rank = values.ragged_rank + 1`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = [[values[i] for i in range(len(values)) if value_rowids[i] == row]
                      for row in range(nrows)] </pre>
</div>
		</div>
	</div>
	<div id="from_value_rowids``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_value_rowids&lt;TClass&gt;</strong>(<span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span> values, <a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> value_rowids, <span title="System.object">object</span> nrows, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` with rows partitioned by `value_rowids`. <p></p> The returned `RaggedTensor` corresponds with the python list defined by: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<IGraphNodeBase>">IEnumerable&lt;IGraphNodeBase&gt;</span></code> values
						</dt>
						<dd>A potentially ragged tensor with shape `[nvals,...]`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> value_rowids
						</dt>
						<dd>A 1-D integer tensor with shape `[nvals]`, which corresponds
one-to-one with `values`, and specifies each value's row index.  Must be
nonnegative, and must be sorted in ascending order. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> nrows
						</dt>
						<dd>An integer scalar specifying the number of rows.  This should be
specified if the `RaggedTensor` may containing empty training rows. Must
be greater than `value_rowids[-1]` (or zero if `value_rowids` is empty).
Defaults to `value_rowids[-1]` (or zero if `value_rowids` is empty). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = values.rank + 1`.
`result.ragged_rank = values.ragged_rank + 1`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = [[values[i] for i in range(len(values)) if value_rowids[i] == row]
                      for row in range(nrows)] </pre>
</div>
		</div>
	</div>
	<div id="from_value_rowids``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_value_rowids&lt;TClass&gt;</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> values, <span title="System.int">int</span> value_rowids, <span title="System.object">object</span> nrows, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` with rows partitioned by `value_rowids`. <p></p> The returned `RaggedTensor` corresponds with the python list defined by: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> values
						</dt>
						<dd>A potentially ragged tensor with shape `[nvals,...]`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> value_rowids
						</dt>
						<dd>A 1-D integer tensor with shape `[nvals]`, which corresponds
one-to-one with `values`, and specifies each value's row index.  Must be
nonnegative, and must be sorted in ascending order. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> nrows
						</dt>
						<dd>An integer scalar specifying the number of rows.  This should be
specified if the `RaggedTensor` may containing empty training rows. Must
be greater than `value_rowids[-1]` (or zero if `value_rowids` is empty).
Defaults to `value_rowids[-1]` (or zero if `value_rowids` is empty). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = values.rank + 1`.
`result.ragged_rank = values.ragged_rank + 1`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = [[values[i] for i in range(len(values)) if value_rowids[i] == row]
                      for row in range(nrows)] </pre>
</div>
		</div>
	</div>
	<div id="from_value_rowids``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_value_rowids&lt;TClass&gt;</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> values, <span title="System.Collections.Generic.IEnumerable<PythonClassContainer>">IEnumerable&lt;PythonClassContainer&gt;</span> value_rowids, <span title="System.object">object</span> nrows, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` with rows partitioned by `value_rowids`. <p></p> The returned `RaggedTensor` corresponds with the python list defined by: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> values
						</dt>
						<dd>A potentially ragged tensor with shape `[nvals,...]`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<PythonClassContainer>">IEnumerable&lt;PythonClassContainer&gt;</span></code> value_rowids
						</dt>
						<dd>A 1-D integer tensor with shape `[nvals]`, which corresponds
one-to-one with `values`, and specifies each value's row index.  Must be
nonnegative, and must be sorted in ascending order. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> nrows
						</dt>
						<dd>An integer scalar specifying the number of rows.  This should be
specified if the `RaggedTensor` may containing empty training rows. Must
be greater than `value_rowids[-1]` (or zero if `value_rowids` is empty).
Defaults to `value_rowids[-1]` (or zero if `value_rowids` is empty). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = values.rank + 1`.
`result.ragged_rank = values.ragged_rank + 1`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = [[values[i] for i in range(len(values)) if value_rowids[i] == row]
                      for row in range(nrows)] </pre>
</div>
		</div>
	</div>
	<div id="from_value_rowids``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_value_rowids&lt;TClass&gt;</strong>(<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> values, <span title="System.Collections.Generic.IEnumerable<PythonClassContainer>">IEnumerable&lt;PythonClassContainer&gt;</span> value_rowids, <span title="System.object">object</span> nrows, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` with rows partitioned by `value_rowids`. <p></p> The returned `RaggedTensor` corresponds with the python list defined by: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code> values
						</dt>
						<dd>A potentially ragged tensor with shape `[nvals,...]`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<PythonClassContainer>">IEnumerable&lt;PythonClassContainer&gt;</span></code> value_rowids
						</dt>
						<dd>A 1-D integer tensor with shape `[nvals]`, which corresponds
one-to-one with `values`, and specifies each value's row index.  Must be
nonnegative, and must be sorted in ascending order. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> nrows
						</dt>
						<dd>An integer scalar specifying the number of rows.  This should be
specified if the `RaggedTensor` may containing empty training rows. Must
be greater than `value_rowids[-1]` (or zero if `value_rowids` is empty).
Defaults to `value_rowids[-1]` (or zero if `value_rowids` is empty). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = values.rank + 1`.
`result.ragged_rank = values.ragged_rank + 1`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = [[values[i] for i in range(len(values)) if value_rowids[i] == row]
                      for row in range(nrows)] </pre>
</div>
		</div>
	</div>
	<div id="from_value_rowids``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_value_rowids&lt;TClass&gt;</strong>(<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> values, <a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> value_rowids, <span title="System.object">object</span> nrows, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` with rows partitioned by `value_rowids`. <p></p> The returned `RaggedTensor` corresponds with the python list defined by: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code> values
						</dt>
						<dd>A potentially ragged tensor with shape `[nvals,...]`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> value_rowids
						</dt>
						<dd>A 1-D integer tensor with shape `[nvals]`, which corresponds
one-to-one with `values`, and specifies each value's row index.  Must be
nonnegative, and must be sorted in ascending order. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> nrows
						</dt>
						<dd>An integer scalar specifying the number of rows.  This should be
specified if the `RaggedTensor` may containing empty training rows. Must
be greater than `value_rowids[-1]` (or zero if `value_rowids` is empty).
Defaults to `value_rowids[-1]` (or zero if `value_rowids` is empty). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = values.rank + 1`.
`result.ragged_rank = values.ragged_rank + 1`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = [[values[i] for i in range(len(values)) if value_rowids[i] == row]
                      for row in range(nrows)] </pre>
</div>
		</div>
	</div>
	<div id="from_value_rowids``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_value_rowids&lt;TClass&gt;</strong>(<span title="System.object">object</span> values, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> value_rowids, <span title="System.object">object</span> nrows, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` with rows partitioned by `value_rowids`. <p></p> The returned `RaggedTensor` corresponds with the python list defined by: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> values
						</dt>
						<dd>A potentially ragged tensor with shape `[nvals,...]`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> value_rowids
						</dt>
						<dd>A 1-D integer tensor with shape `[nvals]`, which corresponds
one-to-one with `values`, and specifies each value's row index.  Must be
nonnegative, and must be sorted in ascending order. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> nrows
						</dt>
						<dd>An integer scalar specifying the number of rows.  This should be
specified if the `RaggedTensor` may containing empty training rows. Must
be greater than `value_rowids[-1]` (or zero if `value_rowids` is empty).
Defaults to `value_rowids[-1]` (or zero if `value_rowids` is empty). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = values.rank + 1`.
`result.ragged_rank = values.ragged_rank + 1`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = [[values[i] for i in range(len(values)) if value_rowids[i] == row]
                      for row in range(nrows)] </pre>
</div>
		</div>
	</div>
	<div id="from_value_rowids``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_value_rowids&lt;TClass&gt;</strong>(<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> values, <span title="System.int">int</span> value_rowids, <span title="System.object">object</span> nrows, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` with rows partitioned by `value_rowids`. <p></p> The returned `RaggedTensor` corresponds with the python list defined by: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code> values
						</dt>
						<dd>A potentially ragged tensor with shape `[nvals,...]`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> value_rowids
						</dt>
						<dd>A 1-D integer tensor with shape `[nvals]`, which corresponds
one-to-one with `values`, and specifies each value's row index.  Must be
nonnegative, and must be sorted in ascending order. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> nrows
						</dt>
						<dd>An integer scalar specifying the number of rows.  This should be
specified if the `RaggedTensor` may containing empty training rows. Must
be greater than `value_rowids[-1]` (or zero if `value_rowids` is empty).
Defaults to `value_rowids[-1]` (or zero if `value_rowids` is empty). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = values.rank + 1`.
`result.ragged_rank = values.ragged_rank + 1`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = [[values[i] for i in range(len(values)) if value_rowids[i] == row]
                      for row in range(nrows)] </pre>
</div>
		</div>
	</div>
	<div id="from_value_rowids``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_value_rowids&lt;TClass&gt;</strong>(<span title="System.object">object</span> values, <span title="System.int">int</span> value_rowids, <span title="System.object">object</span> nrows, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` with rows partitioned by `value_rowids`. <p></p> The returned `RaggedTensor` corresponds with the python list defined by: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> values
						</dt>
						<dd>A potentially ragged tensor with shape `[nvals,...]`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> value_rowids
						</dt>
						<dd>A 1-D integer tensor with shape `[nvals]`, which corresponds
one-to-one with `values`, and specifies each value's row index.  Must be
nonnegative, and must be sorted in ascending order. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> nrows
						</dt>
						<dd>An integer scalar specifying the number of rows.  This should be
specified if the `RaggedTensor` may containing empty training rows. Must
be greater than `value_rowids[-1]` (or zero if `value_rowids` is empty).
Defaults to `value_rowids[-1]` (or zero if `value_rowids` is empty). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = values.rank + 1`.
`result.ragged_rank = values.ragged_rank + 1`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = [[values[i] for i in range(len(values)) if value_rowids[i] == row]
                      for row in range(nrows)] </pre>
</div>
		</div>
	</div>
	<div id="from_value_rowids``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_value_rowids&lt;TClass&gt;</strong>(<span title="System.object">object</span> values, <a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a> value_rowids, <span title="System.object">object</span> nrows, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` with rows partitioned by `value_rowids`. <p></p> The returned `RaggedTensor` corresponds with the python list defined by: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> values
						</dt>
						<dd>A potentially ragged tensor with shape `[nvals,...]`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a></code> value_rowids
						</dt>
						<dd>A 1-D integer tensor with shape `[nvals]`, which corresponds
one-to-one with `values`, and specifies each value's row index.  Must be
nonnegative, and must be sorted in ascending order. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> nrows
						</dt>
						<dd>An integer scalar specifying the number of rows.  This should be
specified if the `RaggedTensor` may containing empty training rows. Must
be greater than `value_rowids[-1]` (or zero if `value_rowids` is empty).
Defaults to `value_rowids[-1]` (or zero if `value_rowids` is empty). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = values.rank + 1`.
`result.ragged_rank = values.ragged_rank + 1`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = [[values[i] for i in range(len(values)) if value_rowids[i] == row]
                      for row in range(nrows)] </pre>
</div>
		</div>
	</div>
	<div id="from_value_rowids``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_value_rowids&lt;TClass&gt;</strong>(<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> values, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> value_rowids, <span title="System.object">object</span> nrows, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` with rows partitioned by `value_rowids`. <p></p> The returned `RaggedTensor` corresponds with the python list defined by: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code> values
						</dt>
						<dd>A potentially ragged tensor with shape `[nvals,...]`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> value_rowids
						</dt>
						<dd>A 1-D integer tensor with shape `[nvals]`, which corresponds
one-to-one with `values`, and specifies each value's row index.  Must be
nonnegative, and must be sorted in ascending order. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> nrows
						</dt>
						<dd>An integer scalar specifying the number of rows.  This should be
specified if the `RaggedTensor` may containing empty training rows. Must
be greater than `value_rowids[-1]` (or zero if `value_rowids` is empty).
Defaults to `value_rowids[-1]` (or zero if `value_rowids` is empty). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = values.rank + 1`.
`result.ragged_rank = values.ragged_rank + 1`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = [[values[i] for i in range(len(values)) if value_rowids[i] == row]
                      for row in range(nrows)] </pre>
</div>
		</div>
	</div>
	<div id="from_value_rowids``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_value_rowids&lt;TClass&gt;</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> values, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> value_rowids, <span title="System.object">object</span> nrows, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` with rows partitioned by `value_rowids`. <p></p> The returned `RaggedTensor` corresponds with the python list defined by: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> values
						</dt>
						<dd>A potentially ragged tensor with shape `[nvals,...]`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> value_rowids
						</dt>
						<dd>A 1-D integer tensor with shape `[nvals]`, which corresponds
one-to-one with `values`, and specifies each value's row index.  Must be
nonnegative, and must be sorted in ascending order. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> nrows
						</dt>
						<dd>An integer scalar specifying the number of rows.  This should be
specified if the `RaggedTensor` may containing empty training rows. Must
be greater than `value_rowids[-1]` (or zero if `value_rowids` is empty).
Defaults to `value_rowids[-1]` (or zero if `value_rowids` is empty). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = values.rank + 1`.
`result.ragged_rank = values.ragged_rank + 1`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = [[values[i] for i in range(len(values)) if value_rowids[i] == row]
                      for row in range(nrows)] </pre>
</div>
		</div>
	</div>
	<div id="from_value_rowids``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_value_rowids&lt;TClass&gt;</strong>(<span title="System.object">object</span> values, <span title="System.Collections.Generic.IEnumerable<PythonClassContainer>">IEnumerable&lt;PythonClassContainer&gt;</span> value_rowids, <span title="System.object">object</span> nrows, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` with rows partitioned by `value_rowids`. <p></p> The returned `RaggedTensor` corresponds with the python list defined by: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> values
						</dt>
						<dd>A potentially ragged tensor with shape `[nvals,...]`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<PythonClassContainer>">IEnumerable&lt;PythonClassContainer&gt;</span></code> value_rowids
						</dt>
						<dd>A 1-D integer tensor with shape `[nvals]`, which corresponds
one-to-one with `values`, and specifies each value's row index.  Must be
nonnegative, and must be sorted in ascending order. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> nrows
						</dt>
						<dd>An integer scalar specifying the number of rows.  This should be
specified if the `RaggedTensor` may containing empty training rows. Must
be greater than `value_rowids[-1]` (or zero if `value_rowids` is empty).
Defaults to `value_rowids[-1]` (or zero if `value_rowids` is empty). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = values.rank + 1`.
`result.ragged_rank = values.ragged_rank + 1`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = [[values[i] for i in range(len(values)) if value_rowids[i] == row]
                      for row in range(nrows)] </pre>
</div>
		</div>
	</div>
	<div id="from_value_rowids``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_value_rowids&lt;TClass&gt;</strong>(<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> values, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> value_rowids, <span title="System.object">object</span> nrows, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` with rows partitioned by `value_rowids`. <p></p> The returned `RaggedTensor` corresponds with the python list defined by: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code> values
						</dt>
						<dd>A potentially ragged tensor with shape `[nvals,...]`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> value_rowids
						</dt>
						<dd>A 1-D integer tensor with shape `[nvals]`, which corresponds
one-to-one with `values`, and specifies each value's row index.  Must be
nonnegative, and must be sorted in ascending order. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> nrows
						</dt>
						<dd>An integer scalar specifying the number of rows.  This should be
specified if the `RaggedTensor` may containing empty training rows. Must
be greater than `value_rowids[-1]` (or zero if `value_rowids` is empty).
Defaults to `value_rowids[-1]` (or zero if `value_rowids` is empty). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = values.rank + 1`.
`result.ragged_rank = values.ragged_rank + 1`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = [[values[i] for i in range(len(values)) if value_rowids[i] == row]
                      for row in range(nrows)] </pre>
</div>
		</div>
	</div>
	<div id="from_value_rowids``1" class="method">
		<h4>
			<span title="tensorflow.TClass">TClass</span> <strong>from_value_rowids&lt;TClass&gt;</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> values, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> value_rowids, <span title="System.object">object</span> nrows, <span title="System.string">string</span> name, <span title="System.bool">bool</span> validate)
		</h4>
		<div class="content">Creates a `RaggedTensor` with rows partitioned by `value_rowids`. <p></p> The returned `RaggedTensor` corresponds with the python list defined by: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> values
						</dt>
						<dd>A potentially ragged tensor with shape `[nvals,...]`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> value_rowids
						</dt>
						<dd>A 1-D integer tensor with shape `[nvals]`, which corresponds
one-to-one with `values`, and specifies each value's row index.  Must be
nonnegative, and must be sorted in ascending order. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> nrows
						</dt>
						<dd>An integer scalar specifying the number of rows.  This should be
specified if the `RaggedTensor` may containing empty training rows. Must
be greater than `value_rowids[-1]` (or zero if `value_rowids` is empty).
Defaults to `value_rowids[-1]` (or zero if `value_rowids` is empty). 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the RaggedTensor (optional). 
						</dd>
						<dt>
							<code><span title="System.bool">bool</span></code> validate
						</dt>
						<dd>If true, then use assertions to check that the arguments form
a valid `RaggedTensor`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="tensorflow.TClass">TClass</span></code>
					</dt>
					<dd>A `RaggedTensor`.  `result.rank = values.rank + 1`.
`result.ragged_rank = values.ragged_rank + 1`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>result = [[values[i] for i in range(len(values)) if value_rowids[i] == row]
                      for row in range(nrows)] </pre>
</div>
		</div>
	</div>
	
	<h3 class="section">Public properties</h3>

	<div id="dtype" class="method">
		<h4>
			<span title="System.object">object</span> <strong>dtype</strong> get; 
		</h4>
		<div class="content">The `DType` of values in this tensor. 

		</div>
	</div>
	<div id="dtype_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>dtype_dyn</strong> get; 
		</h4>
		<div class="content">The `DType` of values in this tensor. 

		</div>
	</div>
	<div id="flat_values" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>flat_values</strong> get; 
		</h4>
		<div class="content">The innermost `values` tensor for this ragged tensor. <p></p> Concretely, if `rt.values` is a `Tensor`, then `rt.flat_values` is
`rt.values`; otherwise, `rt.flat_values` is `rt.values.flat_values`. <p></p> Conceptually, `flat_values` is the tensor formed by flattening the
outermost dimension and all of the ragged dimensions into a single
dimension. <p></p> `rt.flat_values.shape = [nvals] + rt.shape[rt.ragged_rank + 1:]`
(where `nvals` is the number of items in the flattened dimensions). 

		</div>
	</div>
	<div id="flat_values_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>flat_values_dyn</strong> get; 
		</h4>
		<div class="content">The innermost `values` tensor for this ragged tensor. <p></p> Concretely, if `rt.values` is a `Tensor`, then `rt.flat_values` is
`rt.values`; otherwise, `rt.flat_values` is `rt.values.flat_values`. <p></p> Conceptually, `flat_values` is the tensor formed by flattening the
outermost dimension and all of the ragged dimensions into a single
dimension. <p></p> `rt.flat_values.shape = [nvals] + rt.shape[rt.ragged_rank + 1:]`
(where `nvals` is the number of items in the flattened dimensions). 

		</div>
	</div>
	<div id="Item" class="method">
		<h4>
			<span title="System.object">object</span> <strong>Item</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="nested_row_splits" class="method">
		<h4>
			<span title="System.ValueTuple<object>">ValueTuple&lt;object&gt;</span> <strong>nested_row_splits</strong> get; 
		</h4>
		<div class="content">A tuple containing the row_splits for all ragged dimensions. <p></p> `rt.nested_row_splits` is a tuple containing the `row_splits` tensors for
all ragged dimensions in `rt`, ordered from outermost to innermost.  In
particular, `rt.nested_row_splits = (rt.row_splits,) + value_splits` where: <p></p> * `value_splits = ()` if `rt.values` is a `Tensor`.
* `value_splits = rt.values.nested_row_splits` otherwise. 

		</div>
	</div>
	<div id="nested_row_splits_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>nested_row_splits_dyn</strong> get; 
		</h4>
		<div class="content">A tuple containing the row_splits for all ragged dimensions. <p></p> `rt.nested_row_splits` is a tuple containing the `row_splits` tensors for
all ragged dimensions in `rt`, ordered from outermost to innermost.  In
particular, `rt.nested_row_splits = (rt.row_splits,) + value_splits` where: <p></p> * `value_splits = ()` if `rt.values` is a `Tensor`.
* `value_splits = rt.values.nested_row_splits` otherwise. 

		</div>
	</div>
	<div id="PythonObject" class="method">
		<h4>
			<span title="System.object">object</span> <strong>PythonObject</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="ragged_rank" class="method">
		<h4>
			<span title="System.int">int</span> <strong>ragged_rank</strong> get; 
		</h4>
		<div class="content">The number of ragged dimensions in this ragged tensor. 

		</div>
	</div>
	<div id="ragged_rank_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>ragged_rank_dyn</strong> get; 
		</h4>
		<div class="content">The number of ragged dimensions in this ragged tensor. 

		</div>
	</div>
	<div id="row_splits" class="method">
		<h4>
			<span title="System.object">object</span> <strong>row_splits</strong> get; 
		</h4>
		<div class="content">The row-split indices for this ragged tensor's `values`. <p></p> `rt.row_splits` specifies where the values for each row begin and end in
`rt.values`.  In particular, the values for row `rt[i]` are stored in
the slice `rt.values[rt.row_splits[i]:rt.row_splits[i+1]]`. 

		</div>
	</div>
	<div id="row_splits_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>row_splits_dyn</strong> get; 
		</h4>
		<div class="content">The row-split indices for this ragged tensor's `values`. <p></p> `rt.row_splits` specifies where the values for each row begin and end in
`rt.values`.  In particular, the values for row `rt[i]` are stored in
the slice `rt.values[rt.row_splits[i]:rt.row_splits[i+1]]`. 

		</div>
	</div>
	<div id="shape" class="method">
		<h4>
			<a href="../tensorflow/TensorShape.htm">TensorShape</a> <strong>shape</strong> get; 
		</h4>
		<div class="content">The statically known shape of this ragged tensor. 

		</div>
	</div>
	<div id="shape_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>shape_dyn</strong> get; 
		</h4>
		<div class="content">The statically known shape of this ragged tensor. 

		</div>
	</div>
	<div id="values" class="method">
		<h4>
			<span title="System.object">object</span> <strong>values</strong> get; 
		</h4>
		<div class="content">The concatenated rows for this ragged tensor. <p></p> `rt.values` is a potentially ragged tensor formed by flattening the two
outermost dimensions of `rt` into a single dimension. <p></p> `rt.values.shape = [nvals] + rt.shape[2:]` (where `nvals` is the
number of items in the outer two dimensions of `rt`). <p></p> `rt.ragged_rank = self.ragged_rank - 1` 

		</div>
	</div>
	<div id="values_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>values_dyn</strong> get; 
		</h4>
		<div class="content">The concatenated rows for this ragged tensor. <p></p> `rt.values` is a potentially ragged tensor formed by flattening the two
outermost dimensions of `rt` into a single dimension. <p></p> `rt.values.shape = [nvals] + rt.shape[2:]` (where `nvals` is the
number of items in the outer two dimensions of `rt`). <p></p> `rt.ragged_rank = self.ragged_rank - 1` 

		</div>
	</div>
	</section>
	</article><footer>
	<span id="version">Built from v1.15.0.0 of LostTech.TensorFlow</span>
	<span id="docu-link">
		Generated by <a href="http://docu.jagregory.com">docu</a>
	</span>
</footer>
  </body>
</html>