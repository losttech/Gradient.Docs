<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.0 Frameset//EN" "http://www.w3.org/TR/xhtml1/DTD/xhtml1-frameset.dtd">
<html xmlns="http://www.w3.org/1999/xhtml" xml:lang="en" lang="en">
  <head>
	<!--[if lt IE 9]>
	<script src="http://html5shiv.googlecode.com/svn/trunk/html5.js"></script>
	<![endif]-->
    <title>tf.ragged - LostTech.TensorFlow Documentation</title>
    <meta http-equiv="Content-Type" content="text/html; charset=iso-8859-1"/>
    <link type="text/css" rel="stylesheet" href="../main.css"/>
    <script type="text/javascript" src="../js/jquery-1.3.2.min.js"></script>
    <script type="text/javascript" src="../js/jquery.scrollTo-min.js"></script>
    <script type="text/javascript" src="../js/navigation.js"></script>
    <script type="text/javascript" src="../js/example.js"></script>
  </head>
  <body>
  	<header><h1>LostTech.TensorFlow : API Documentation</h1>
	</header>

    <nav id="namespaces">
      <iframe src="../namespaces.htm"></iframe>
    </nav><nav id="types">
  <h2 class="fixed">Types in tensorflow</h2>
	<div class="scroll">
		<ul>
				<li>
            <a href="../tensorflow/AggregationMethod.htm">AggregationMethod</a>
        </li>
				<li>
            <a href="../tensorflow/ConditionalAccumulator.htm">ConditionalAccumulator</a>
        </li>
				<li>
            <a href="../tensorflow/ConditionalAccumulatorBase.htm">ConditionalAccumulatorBase</a>
        </li>
				<li>
            <a href="../tensorflow/constant_initializer.htm">constant_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/CriticalSection.htm">CriticalSection</a>
        </li>
				<li>
            <a href="../tensorflow/DeviceSpec.htm">DeviceSpec</a>
        </li>
				<li>
            <a href="../tensorflow/Dimension.htm">Dimension</a>
        </li>
				<li>
            <a href="../tensorflow/DType.htm">DType</a>
        </li>
				<li>
            <a href="../tensorflow/FIFOQueue.htm">FIFOQueue</a>
        </li>
				<li>
            <a href="../tensorflow/FixedLenFeature.htm">FixedLenFeature</a>
        </li>
				<li>
            <a href="../tensorflow/FixedLengthRecordReader.htm">FixedLengthRecordReader</a>
        </li>
				<li>
            <a href="../tensorflow/FixedLenSequenceFeature.htm">FixedLenSequenceFeature</a>
        </li>
				<li>
            <a href="../tensorflow/glorot_normal_initializer.htm">glorot_normal_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/glorot_uniform_initializer.htm">glorot_uniform_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/GradientTape.htm">GradientTape</a>
        </li>
				<li>
            <a href="../tensorflow/Graph.htm">Graph</a>
        </li>
				<li>
            <a href="../tensorflow/Graph._ControlDependenciesController.htm">Graph._ControlDependenciesController</a>
        </li>
				<li>
            <a href="../tensorflow/Graph.I_ControlDependenciesController.htm">Graph.I_ControlDependenciesController</a>
        </li>
				<li>
            <a href="../tensorflow/GraphKeys.htm">GraphKeys</a>
        </li>
				<li>
            <a href="../tensorflow/HeadingAxes.htm">HeadingAxes</a>
        </li>
				<li>
            <a href="../tensorflow/IAggregationMethod.htm">IAggregationMethod</a>
        </li>
				<li>
            <a href="../tensorflow/IConditionalAccumulator.htm">IConditionalAccumulator</a>
        </li>
				<li>
            <a href="../tensorflow/IConditionalAccumulatorBase.htm">IConditionalAccumulatorBase</a>
        </li>
				<li>
            <a href="../tensorflow/Iconstant_initializer.htm">Iconstant_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/ICriticalSection.htm">ICriticalSection</a>
        </li>
				<li>
            <a href="../tensorflow/IdentityReader.htm">IdentityReader</a>
        </li>
				<li>
            <a href="../tensorflow/IDeviceSpec.htm">IDeviceSpec</a>
        </li>
				<li>
            <a href="../tensorflow/IDimension.htm">IDimension</a>
        </li>
				<li>
            <a href="../tensorflow/IDType.htm">IDType</a>
        </li>
				<li>
            <a href="../tensorflow/IFIFOQueue.htm">IFIFOQueue</a>
        </li>
				<li>
            <a href="../tensorflow/IFixedLenFeature.htm">IFixedLenFeature</a>
        </li>
				<li>
            <a href="../tensorflow/IFixedLengthRecordReader.htm">IFixedLengthRecordReader</a>
        </li>
				<li>
            <a href="../tensorflow/IFixedLenSequenceFeature.htm">IFixedLenSequenceFeature</a>
        </li>
				<li>
            <a href="../tensorflow/Iglorot_normal_initializer.htm">Iglorot_normal_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/Iglorot_uniform_initializer.htm">Iglorot_uniform_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/IGradientTape.htm">IGradientTape</a>
        </li>
				<li>
            <a href="../tensorflow/IGraph.htm">IGraph</a>
        </li>
				<li>
            <a href="../tensorflow/IGraphKeys.htm">IGraphKeys</a>
        </li>
				<li>
            <a href="../tensorflow/IIdentityReader.htm">IIdentityReader</a>
        </li>
				<li>
            <a href="../tensorflow/IIndexedSlices.htm">IIndexedSlices</a>
        </li>
				<li>
            <a href="../tensorflow/IIndexedSlicesSpec.htm">IIndexedSlicesSpec</a>
        </li>
				<li>
            <a href="../tensorflow/IInteractiveSession.htm">IInteractiveSession</a>
        </li>
				<li>
            <a href="../tensorflow/ILazyLoader.htm">ILazyLoader</a>
        </li>
				<li>
            <a href="../tensorflow/ILMDBReader.htm">ILMDBReader</a>
        </li>
				<li>
            <a href="../tensorflow/IModule.htm">IModule</a>
        </li>
				<li>
            <a href="../tensorflow/Iname_scope.htm">Iname_scope</a>
        </li>
				<li>
            <a href="../tensorflow/IndexedSlices.htm">IndexedSlices</a>
        </li>
				<li>
            <a href="../tensorflow/IndexedSlicesSpec.htm">IndexedSlicesSpec</a>
        </li>
				<li>
            <a href="../tensorflow/InteractiveSession.htm">InteractiveSession</a>
        </li>
				<li>
            <a href="../tensorflow/Iones_initializer.htm">Iones_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/IOperation.htm">IOperation</a>
        </li>
				<li>
            <a href="../tensorflow/IOpError.htm">IOpError</a>
        </li>
				<li>
            <a href="../tensorflow/IOptionalSpec.htm">IOptionalSpec</a>
        </li>
				<li>
            <a href="../tensorflow/Iorthogonal_initializer.htm">Iorthogonal_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/IPaddingFIFOQueue.htm">IPaddingFIFOQueue</a>
        </li>
				<li>
            <a href="../tensorflow/IPriorityQueue.htm">IPriorityQueue</a>
        </li>
				<li>
            <a href="../tensorflow/IQueueBase.htm">IQueueBase</a>
        </li>
				<li>
            <a href="../tensorflow/IRaggedTensor.htm">IRaggedTensor</a>
        </li>
				<li>
            <a href="../tensorflow/IRaggedTensorSpec.htm">IRaggedTensorSpec</a>
        </li>
				<li>
            <a href="../tensorflow/Irandom_normal_initializer.htm">Irandom_normal_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/Irandom_uniform_initializer.htm">Irandom_uniform_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/IRandomShuffleQueue.htm">IRandomShuffleQueue</a>
        </li>
				<li>
            <a href="../tensorflow/IReaderBase.htm">IReaderBase</a>
        </li>
				<li>
            <a href="../tensorflow/IRegisterGradient.htm">IRegisterGradient</a>
        </li>
				<li>
            <a href="../tensorflow/ISession.htm">ISession</a>
        </li>
				<li>
            <a href="../tensorflow/ISparseConditionalAccumulator.htm">ISparseConditionalAccumulator</a>
        </li>
				<li>
            <a href="../tensorflow/ISparseFeature.htm">ISparseFeature</a>
        </li>
				<li>
            <a href="../tensorflow/ISparseTensor.htm">ISparseTensor</a>
        </li>
				<li>
            <a href="../tensorflow/ISparseTensorSpec.htm">ISparseTensorSpec</a>
        </li>
				<li>
            <a href="../tensorflow/ISparseTensorValue.htm">ISparseTensorValue</a>
        </li>
				<li>
            <a href="../tensorflow/ITensor.htm">ITensor</a>
        </li>
				<li>
            <a href="../tensorflow/ITensorArray.htm">ITensorArray</a>
        </li>
				<li>
            <a href="../tensorflow/ITensorArraySpec.htm">ITensorArraySpec</a>
        </li>
				<li>
            <a href="../tensorflow/ITensorShape.htm">ITensorShape</a>
        </li>
				<li>
            <a href="../tensorflow/ITensorSpec.htm">ITensorSpec</a>
        </li>
				<li>
            <a href="../tensorflow/ITextLineReader.htm">ITextLineReader</a>
        </li>
				<li>
            <a href="../tensorflow/ITFRecordReader.htm">ITFRecordReader</a>
        </li>
				<li>
            <a href="../tensorflow/Itruncated_normal_initializer.htm">Itruncated_normal_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/ITypeSpec.htm">ITypeSpec</a>
        </li>
				<li>
            <a href="../tensorflow/IUnconnectedGradients.htm">IUnconnectedGradients</a>
        </li>
				<li>
            <a href="../tensorflow/Iuniform_unit_scaling_initializer.htm">Iuniform_unit_scaling_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/IVariable.htm">IVariable</a>
        </li>
				<li>
            <a href="../tensorflow/Ivariable_scope.htm">Ivariable_scope</a>
        </li>
				<li>
            <a href="../tensorflow/IVariableScope.htm">IVariableScope</a>
        </li>
				<li>
            <a href="../tensorflow/Ivariance_scaling_initializer.htm">Ivariance_scaling_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/IVarLenFeature.htm">IVarLenFeature</a>
        </li>
				<li>
            <a href="../tensorflow/IWholeFileReader.htm">IWholeFileReader</a>
        </li>
				<li>
            <a href="../tensorflow/Izeros_initializer.htm">Izeros_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/LazyLoader.htm">LazyLoader</a>
        </li>
				<li>
            <a href="../tensorflow/LMDBReader.htm">LMDBReader</a>
        </li>
				<li>
            <a href="../tensorflow/Module.htm">Module</a>
        </li>
				<li>
            <a href="../tensorflow/name_scope.htm">name_scope</a>
        </li>
				<li>
            <a href="../tensorflow/ones_initializer.htm">ones_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/Operation.htm">Operation</a>
        </li>
				<li>
            <a href="../tensorflow/Operation._InputList.htm">Operation._InputList</a>
        </li>
				<li>
            <a href="../tensorflow/Operation.I_InputList.htm">Operation.I_InputList</a>
        </li>
				<li>
            <a href="../tensorflow/OpError.htm">OpError</a>
        </li>
				<li>
            <a href="../tensorflow/OptionalSpec.htm">OptionalSpec</a>
        </li>
				<li>
            <a href="../tensorflow/orthogonal_initializer.htm">orthogonal_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/PaddingFIFOQueue.htm">PaddingFIFOQueue</a>
        </li>
				<li>
            <a href="../tensorflow/PriorityQueue.htm">PriorityQueue</a>
        </li>
				<li>
            <a href="../tensorflow/QueueBase.htm">QueueBase</a>
        </li>
				<li>
            <a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a>
        </li>
				<li>
            <a href="../tensorflow/RaggedTensorSpec.htm">RaggedTensorSpec</a>
        </li>
				<li>
            <a href="../tensorflow/random_normal_initializer.htm">random_normal_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/random_uniform_initializer.htm">random_uniform_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/RandomShuffleQueue.htm">RandomShuffleQueue</a>
        </li>
				<li>
            <a href="../tensorflow/ReaderBase.htm">ReaderBase</a>
        </li>
				<li>
            <a href="../tensorflow/RegisterGradient.htm">RegisterGradient</a>
        </li>
				<li>
            <a href="../tensorflow/Session.htm">Session</a>
        </li>
				<li>
            <a href="../tensorflow/SparseConditionalAccumulator.htm">SparseConditionalAccumulator</a>
        </li>
				<li>
            <a href="../tensorflow/SparseFeature.htm">SparseFeature</a>
        </li>
				<li>
            <a href="../tensorflow/SparseTensor.htm">SparseTensor</a>
        </li>
				<li>
            <a href="../tensorflow/SparseTensorSpec.htm">SparseTensorSpec</a>
        </li>
				<li>
            <a href="../tensorflow/SparseTensorValue.htm">SparseTensorValue</a>
        </li>
				<li>
            <a href="../tensorflow/Tensor.htm">Tensor</a>
        </li>
				<li>
            <a href="../tensorflow/Tensor`1.htm">Tensor&lt;T&gt;</a>
        </li>
				<li>
            <a href="../tensorflow/TensorArray.htm">TensorArray</a>
        </li>
				<li>
            <a href="../tensorflow/TensorArraySpec.htm">TensorArraySpec</a>
        </li>
				<li>
            <a href="../tensorflow/TensorDimension.htm">TensorDimension</a>
        </li>
				<li>
            <a href="../tensorflow/TensorDimensionSlice.htm">TensorDimensionSlice</a>
        </li>
				<li>
            <a href="../tensorflow/TensorShape.htm">TensorShape</a>
        </li>
				<li>
            <a href="../tensorflow/TensorSpec.htm">TensorSpec</a>
        </li>
				<li>
            <a href="../tensorflow/TextLineReader.htm">TextLineReader</a>
        </li>
				<li>
            <a href="../tensorflow/tf.htm">tf</a>
        </li>
				<li>
            <a href="../tensorflow/tf.audio.htm">tf.audio</a>
        </li>
				<li>
            <a href="../tensorflow/tf.autograph.htm">tf.autograph</a>
        </li>
				<li>
            <a href="../tensorflow/tf.autograph.experimental.htm">tf.autograph.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.bitwise.htm">tf.bitwise</a>
        </li>
				<li>
            <a href="../tensorflow/tf.compat.htm">tf.compat</a>
        </li>
				<li>
            <a href="../tensorflow/tf.config.htm">tf.config</a>
        </li>
				<li>
            <a href="../tensorflow/tf.config.experimental.htm">tf.config.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.config.optimizer.htm">tf.config.optimizer</a>
        </li>
				<li>
            <a href="../tensorflow/tf.config.threading.htm">tf.config.threading</a>
        </li>
				<li>
            <a href="../tensorflow/tf.data.htm">tf.data</a>
        </li>
				<li>
            <a href="../tensorflow/tf.data.experimental.htm">tf.data.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.debugging.htm">tf.debugging</a>
        </li>
				<li>
            <a href="../tensorflow/tf.distribute.htm">tf.distribute</a>
        </li>
				<li>
            <a href="../tensorflow/tf.distributions.htm">tf.distributions</a>
        </li>
				<li>
            <a href="../tensorflow/tf.errors.htm">tf.errors</a>
        </li>
				<li>
            <a href="../tensorflow/tf.estimator.htm">tf.estimator</a>
        </li>
				<li>
            <a href="../tensorflow/tf.estimator.experimental.htm">tf.estimator.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.estimator.export.htm">tf.estimator.export</a>
        </li>
				<li>
            <a href="../tensorflow/tf.estimator.inputs.htm">tf.estimator.inputs</a>
        </li>
				<li>
            <a href="../tensorflow/tf.experimental.htm">tf.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.feature_column.htm">tf.feature_column</a>
        </li>
				<li>
            <a href="../tensorflow/tf.gfile.htm">tf.gfile</a>
        </li>
				<li>
            <a href="../tensorflow/tf.graph_util.htm">tf.graph_util</a>
        </li>
				<li>
            <a href="../tensorflow/tf.image.htm">tf.image</a>
        </li>
				<li>
            <a href="../tensorflow/tf.initializers.htm">tf.initializers</a>
        </li>
				<li>
            <a href="../tensorflow/tf.io.htm">tf.io</a>
        </li>
				<li>
            <a href="../tensorflow/tf.io.gfile.htm">tf.io.gfile</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.htm">tf.keras</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.activations.htm">tf.keras.activations</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.htm">tf.keras.applications</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.densenet.htm">tf.keras.applications.densenet</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.imagenet_utils.htm">tf.keras.applications.imagenet_utils</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.inception_resnet_v2.htm">tf.keras.applications.inception_resnet_v2</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.inception_v3.htm">tf.keras.applications.inception_v3</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.mobilenet.htm">tf.keras.applications.mobilenet</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.mobilenet_v2.htm">tf.keras.applications.mobilenet_v2</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.nasnet.htm">tf.keras.applications.nasnet</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.resnet.htm">tf.keras.applications.resnet</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.resnet_v2.htm">tf.keras.applications.resnet_v2</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.vgg16.htm">tf.keras.applications.vgg16</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.vgg19.htm">tf.keras.applications.vgg19</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.applications.xception.htm">tf.keras.applications.xception</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.backend.htm">tf.keras.backend</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.constraints.htm">tf.keras.constraints</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.datasets.htm">tf.keras.datasets</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.datasets.boston_housing.htm">tf.keras.datasets.boston_housing</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.datasets.cifar10.htm">tf.keras.datasets.cifar10</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.datasets.cifar100.htm">tf.keras.datasets.cifar100</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.datasets.fashion_mnist.htm">tf.keras.datasets.fashion_mnist</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.datasets.imdb.htm">tf.keras.datasets.imdb</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.datasets.mnist.htm">tf.keras.datasets.mnist</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.datasets.reuters.htm">tf.keras.datasets.reuters</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.estimator.htm">tf.keras.estimator</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.experimental.htm">tf.keras.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.initializers.htm">tf.keras.initializers</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.layers.htm">tf.keras.layers</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.losses.htm">tf.keras.losses</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.metrics.htm">tf.keras.metrics</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.mixed_precision.htm">tf.keras.mixed_precision</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.mixed_precision.experimental.htm">tf.keras.mixed_precision.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.models.htm">tf.keras.models</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.optimizers.htm">tf.keras.optimizers</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.optimizers.schedules.htm">tf.keras.optimizers.schedules</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.preprocessing.htm">tf.keras.preprocessing</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.preprocessing.image.htm">tf.keras.preprocessing.image</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.regularizers.htm">tf.keras.regularizers</a>
        </li>
				<li>
            <a href="../tensorflow/tf.keras.utils.htm">tf.keras.utils</a>
        </li>
				<li>
            <a href="../tensorflow/tf.layers.htm">tf.layers</a>
        </li>
				<li>
            <a href="../tensorflow/tf.layers.experimental.htm">tf.layers.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.linalg.htm">tf.linalg</a>
        </li>
				<li>
            <a href="../tensorflow/tf.lite.htm">tf.lite</a>
        </li>
				<li>
            <a href="../tensorflow/tf.lite.experimental.htm">tf.lite.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.lite.experimental.microfrontend.htm">tf.lite.experimental.microfrontend</a>
        </li>
				<li>
            <a href="../tensorflow/tf.lite.experimental.microfrontend.python.htm">tf.lite.experimental.microfrontend.python</a>
        </li>
				<li>
            <a href="../tensorflow/tf.lite.experimental.microfrontend.python.ops.htm">tf.lite.experimental.microfrontend.python.ops</a>
        </li>
				<li>
            <a href="../tensorflow/tf.lite.experimental.nn.htm">tf.lite.experimental.nn</a>
        </li>
				<li>
            <a href="../tensorflow/tf.logging.htm">tf.logging</a>
        </li>
				<li>
            <a href="../tensorflow/tf.losses.htm">tf.losses</a>
        </li>
				<li>
            <a href="../tensorflow/tf.math.htm">tf.math</a>
        </li>
				<li>
            <a href="../tensorflow/tf.metrics.htm">tf.metrics</a>
        </li>
				<li>
            <a href="../tensorflow/tf.nest.htm">tf.nest</a>
        </li>
				<li>
            <a href="../tensorflow/tf.nn.htm">tf.nn</a>
        </li>
				<li>
            <a href="../tensorflow/tf.profiler.htm">tf.profiler</a>
        </li>
				<li>
            <a href="../tensorflow/tf.quantization.htm">tf.quantization</a>
        </li>
				<li>
            <a href="../tensorflow/tf.ragged.htm" class="current">tf.ragged</a>
        </li>
				<li>
            <a href="../tensorflow/tf.random.htm">tf.random</a>
        </li>
				<li>
            <a href="../tensorflow/tf.random.experimental.htm">tf.random.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.resource_loader.htm">tf.resource_loader</a>
        </li>
				<li>
            <a href="../tensorflow/tf.saved_model.htm">tf.saved_model</a>
        </li>
				<li>
            <a href="../tensorflow/tf.saved_model.main_op.htm">tf.saved_model.main_op</a>
        </li>
				<li>
            <a href="../tensorflow/tf.sets.htm">tf.sets</a>
        </li>
				<li>
            <a href="../tensorflow/tf.signal.htm">tf.signal</a>
        </li>
				<li>
            <a href="../tensorflow/tf.sparse.htm">tf.sparse</a>
        </li>
				<li>
            <a href="../tensorflow/tf.strings.htm">tf.strings</a>
        </li>
				<li>
            <a href="../tensorflow/tf.summary.htm">tf.summary</a>
        </li>
				<li>
            <a href="../tensorflow/tf.summary.experimental.htm">tf.summary.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.sysconfig.htm">tf.sysconfig</a>
        </li>
				<li>
            <a href="../tensorflow/tf.test.htm">tf.test</a>
        </li>
				<li>
            <a href="../tensorflow/tf.tpu.htm">tf.tpu</a>
        </li>
				<li>
            <a href="../tensorflow/tf.tpu.experimental.htm">tf.tpu.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.train.htm">tf.train</a>
        </li>
				<li>
            <a href="../tensorflow/tf.train.experimental.htm">tf.train.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/tf.user_ops.htm">tf.user_ops</a>
        </li>
				<li>
            <a href="../tensorflow/tf.xla.htm">tf.xla</a>
        </li>
				<li>
            <a href="../tensorflow/tf.xla.experimental.htm">tf.xla.experimental</a>
        </li>
				<li>
            <a href="../tensorflow/TFRecordReader.htm">TFRecordReader</a>
        </li>
				<li>
            <a href="../tensorflow/truncated_normal_initializer.htm">truncated_normal_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/TypeSpec.htm">TypeSpec</a>
        </li>
				<li>
            <a href="../tensorflow/UnconnectedGradients.htm">UnconnectedGradients</a>
        </li>
				<li>
            <a href="../tensorflow/uniform_unit_scaling_initializer.htm">uniform_unit_scaling_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/Variable.htm">Variable</a>
        </li>
				<li>
            <a href="../tensorflow/variable_scope.htm">variable_scope</a>
        </li>
				<li>
            <a href="../tensorflow/VariableAggregation.htm">VariableAggregation</a>
        </li>
				<li>
            <a href="../tensorflow/VariableScope.htm">VariableScope</a>
        </li>
				<li>
            <a href="../tensorflow/VariableSynchronization.htm">VariableSynchronization</a>
        </li>
				<li>
            <a href="../tensorflow/variance_scaling_initializer.htm">variance_scaling_initializer</a>
        </li>
				<li>
            <a href="../tensorflow/VarLenFeature.htm">VarLenFeature</a>
        </li>
				<li>
            <a href="../tensorflow/WholeFileReader.htm">WholeFileReader</a>
        </li>
				<li>
            <a href="../tensorflow/zeros_initializer.htm">zeros_initializer</a>
        </li>
		</ul>
	</div>
</nav>
	<article>
    <header>
		<p class="class"><strong>Type</strong> tf.ragged</p>
	</header>
	<section>
		<header>
		<p><strong>Namespace</strong> tensorflow</p>
		</header>
    <div class="sub-header">
		
		
			<h3 class="section">Methods</h3>
			<ul>
				<li><a href="../tensorflow/tf.ragged.htm#boolean_mask">boolean_mask</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#boolean_mask">boolean_mask</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#boolean_mask">boolean_mask</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#boolean_mask">boolean_mask</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#boolean_mask">boolean_mask</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#boolean_mask">boolean_mask</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#boolean_mask">boolean_mask</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#boolean_mask">boolean_mask</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#boolean_mask">boolean_mask</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#boolean_mask">boolean_mask</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#boolean_mask">boolean_mask</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#boolean_mask">boolean_mask</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#boolean_mask">boolean_mask</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#boolean_mask">boolean_mask</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#boolean_mask">boolean_mask</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#boolean_mask">boolean_mask</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#boolean_mask">boolean_mask</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#boolean_mask">boolean_mask</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#boolean_mask">boolean_mask</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#boolean_mask">boolean_mask</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#boolean_mask">boolean_mask</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#boolean_mask">boolean_mask</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#boolean_mask">boolean_mask</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#boolean_mask">boolean_mask</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#boolean_mask">boolean_mask</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#constant">constant</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#constant">constant</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#constant">constant</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#constant">constant</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#constant">constant</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#constant">constant</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#constant_dyn">constant_dyn</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#constant_value">constant_value</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#constant_value">constant_value</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#constant_value">constant_value</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#constant_value">constant_value</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#constant_value">constant_value</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#constant_value">constant_value</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#constant_value">constant_value</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#constant_value">constant_value</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#constant_value">constant_value</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#constant_value">constant_value</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#constant_value">constant_value</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#constant_value">constant_value</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#constant_value_dyn">constant_value_dyn</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#map_flat_values">map_flat_values</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#map_flat_values">map_flat_values</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#map_flat_values_dyn">map_flat_values_dyn</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#map_flat_values_dyn">map_flat_values_dyn</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#placeholder">placeholder</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#placeholder">placeholder</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#placeholder">placeholder</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#placeholder">placeholder</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#placeholder">placeholder</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#placeholder">placeholder</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#placeholder">placeholder</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#placeholder">placeholder</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#placeholder">placeholder</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#placeholder_dyn">placeholder_dyn</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#range">range</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#range">range</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#range">range</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#range">range</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#range">range</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#range">range</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#range">range</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#range">range</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#range">range</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#range">range</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#range">range</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#range">range</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#range">range</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#range">range</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#range">range</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#range">range</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#range_dyn">range_dyn</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#row_splits_to_segment_ids">row_splits_to_segment_ids</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#row_splits_to_segment_ids">row_splits_to_segment_ids</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#row_splits_to_segment_ids">row_splits_to_segment_ids</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#row_splits_to_segment_ids_dyn">row_splits_to_segment_ids_dyn</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#segment_ids_to_row_splits">segment_ids_to_row_splits</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#segment_ids_to_row_splits">segment_ids_to_row_splits</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#segment_ids_to_row_splits">segment_ids_to_row_splits</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#segment_ids_to_row_splits">segment_ids_to_row_splits</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#segment_ids_to_row_splits_dyn">segment_ids_to_row_splits_dyn</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#stack">stack</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#stack">stack</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#stack">stack</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#stack_dyn">stack_dyn</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#stack_dynamic_partitions">stack_dynamic_partitions</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#stack_dynamic_partitions">stack_dynamic_partitions</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#stack_dynamic_partitions">stack_dynamic_partitions</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#stack_dynamic_partitions">stack_dynamic_partitions</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#stack_dynamic_partitions">stack_dynamic_partitions</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#stack_dynamic_partitions">stack_dynamic_partitions</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#stack_dynamic_partitions">stack_dynamic_partitions</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#stack_dynamic_partitions">stack_dynamic_partitions</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#stack_dynamic_partitions">stack_dynamic_partitions</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#stack_dynamic_partitions">stack_dynamic_partitions</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#stack_dynamic_partitions">stack_dynamic_partitions</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#stack_dynamic_partitions">stack_dynamic_partitions</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#stack_dynamic_partitions">stack_dynamic_partitions</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#stack_dynamic_partitions">stack_dynamic_partitions</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#stack_dynamic_partitions">stack_dynamic_partitions</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#stack_dynamic_partitions">stack_dynamic_partitions</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#stack_dynamic_partitions">stack_dynamic_partitions</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#stack_dynamic_partitions">stack_dynamic_partitions</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#stack_dynamic_partitions">stack_dynamic_partitions</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#stack_dynamic_partitions">stack_dynamic_partitions</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#stack_dynamic_partitions">stack_dynamic_partitions</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#stack_dynamic_partitions">stack_dynamic_partitions</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#stack_dynamic_partitions">stack_dynamic_partitions</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#stack_dynamic_partitions">stack_dynamic_partitions</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#stack_dynamic_partitions">stack_dynamic_partitions</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#stack_dynamic_partitions_dyn">stack_dynamic_partitions_dyn</a></li>
			</ul>
		
			<h3 class="section">Properties</h3>
			<ul>
				<li><a href="../tensorflow/tf.ragged.htm#boolean_mask_fn">boolean_mask_fn</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#constant_fn">constant_fn</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#constant_value_fn">constant_value_fn</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#map_flat_values_fn">map_flat_values_fn</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#placeholder_fn">placeholder_fn</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#range_fn">range_fn</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#row_splits_to_segment_ids_fn">row_splits_to_segment_ids_fn</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#segment_ids_to_row_splits_fn">segment_ids_to_row_splits_fn</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#stack_dynamic_partitions_fn">stack_dynamic_partitions_fn</a></li>
				<li><a href="../tensorflow/tf.ragged.htm#stack_fn">stack_fn</a></li>
			</ul>
		
	</div>
	
	
	<h3 class="section">Public static methods</h3>

	<div id="boolean_mask" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>boolean_mask</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> data, <span title="System.object">object</span> mask, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Applies a boolean mask to `data` without flattening the mask dimensions. <p></p> Returns a potentially ragged tensor that is formed by retaining the elements
in `data` where the corresponding value in `mask` is `True`. <p></p> * `output[a1...aA, i, b1...bB] = data[a1...aA, j, b1...bB]` <p></p> Where `j` is the `i`th `True` entry of `mask[a1...aA]`. <p></p> Note that `output` preserves the mask dimensions `a1...aA`; this differs
from <a href="..\..\tf\boolean_mask.md"><code>tf.boolean_mask</code></a>, which flattens those dimensions. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> data
						</dt>
						<dd>A potentially ragged tensor. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> mask
						</dt>
						<dd>A potentially ragged boolean tensor.  `mask`'s shape must be a prefix
of `data`'s shape.  `rank(mask)` must be known statically. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A potentially ragged tensor that is formed by retaining the elements in
`data` where the corresponding value in `mask` is `True`. <p></p> * `rank(output) = rank(data)`.
* `output.ragged_rank = max(data.ragged_rank, rank(mask) - 1)`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="boolean_mask" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>boolean_mask</strong>(<span title="System.object">object</span> data, <a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> mask, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Applies a boolean mask to `data` without flattening the mask dimensions. <p></p> Returns a potentially ragged tensor that is formed by retaining the elements
in `data` where the corresponding value in `mask` is `True`. <p></p> * `output[a1...aA, i, b1...bB] = data[a1...aA, j, b1...bB]` <p></p> Where `j` is the `i`th `True` entry of `mask[a1...aA]`. <p></p> Note that `output` preserves the mask dimensions `a1...aA`; this differs
from <a href="..\..\tf\boolean_mask.md"><code>tf.boolean_mask</code></a>, which flattens those dimensions. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> data
						</dt>
						<dd>A potentially ragged tensor. 
						</dd>
						<dt>
							<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code> mask
						</dt>
						<dd>A potentially ragged boolean tensor.  `mask`'s shape must be a prefix
of `data`'s shape.  `rank(mask)` must be known statically. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A potentially ragged tensor that is formed by retaining the elements in
`data` where the corresponding value in `mask` is `True`. <p></p> * `rank(output) = rank(data)`.
* `output.ragged_rank = max(data.ragged_rank, rank(mask) - 1)`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="boolean_mask" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>boolean_mask</strong>(<span title="System.object">object</span> data, <a href="../tensorflow/DType.htm">DType</a> mask, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Applies a boolean mask to `data` without flattening the mask dimensions. <p></p> Returns a potentially ragged tensor that is formed by retaining the elements
in `data` where the corresponding value in `mask` is `True`. <p></p> * `output[a1...aA, i, b1...bB] = data[a1...aA, j, b1...bB]` <p></p> Where `j` is the `i`th `True` entry of `mask[a1...aA]`. <p></p> Note that `output` preserves the mask dimensions `a1...aA`; this differs
from <a href="..\..\tf\boolean_mask.md"><code>tf.boolean_mask</code></a>, which flattens those dimensions. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> data
						</dt>
						<dd>A potentially ragged tensor. 
						</dd>
						<dt>
							<code><a href="../tensorflow/DType.htm">DType</a></code> mask
						</dt>
						<dd>A potentially ragged boolean tensor.  `mask`'s shape must be a prefix
of `data`'s shape.  `rank(mask)` must be known statically. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A potentially ragged tensor that is formed by retaining the elements in
`data` where the corresponding value in `mask` is `True`. <p></p> * `rank(output) = rank(data)`.
* `output.ragged_rank = max(data.ragged_rank, rank(mask) - 1)`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="boolean_mask" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>boolean_mask</strong>(<span title="System.object">object</span> data, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> mask, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Applies a boolean mask to `data` without flattening the mask dimensions. <p></p> Returns a potentially ragged tensor that is formed by retaining the elements
in `data` where the corresponding value in `mask` is `True`. <p></p> * `output[a1...aA, i, b1...bB] = data[a1...aA, j, b1...bB]` <p></p> Where `j` is the `i`th `True` entry of `mask[a1...aA]`. <p></p> Note that `output` preserves the mask dimensions `a1...aA`; this differs
from <a href="..\..\tf\boolean_mask.md"><code>tf.boolean_mask</code></a>, which flattens those dimensions. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> data
						</dt>
						<dd>A potentially ragged tensor. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> mask
						</dt>
						<dd>A potentially ragged boolean tensor.  `mask`'s shape must be a prefix
of `data`'s shape.  `rank(mask)` must be known statically. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A potentially ragged tensor that is formed by retaining the elements in
`data` where the corresponding value in `mask` is `True`. <p></p> * `rank(output) = rank(data)`.
* `output.ragged_rank = max(data.ragged_rank, rank(mask) - 1)`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="boolean_mask" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>boolean_mask</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> data, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> mask, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Applies a boolean mask to `data` without flattening the mask dimensions. <p></p> Returns a potentially ragged tensor that is formed by retaining the elements
in `data` where the corresponding value in `mask` is `True`. <p></p> * `output[a1...aA, i, b1...bB] = data[a1...aA, j, b1...bB]` <p></p> Where `j` is the `i`th `True` entry of `mask[a1...aA]`. <p></p> Note that `output` preserves the mask dimensions `a1...aA`; this differs
from <a href="..\..\tf\boolean_mask.md"><code>tf.boolean_mask</code></a>, which flattens those dimensions. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> data
						</dt>
						<dd>A potentially ragged tensor. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> mask
						</dt>
						<dd>A potentially ragged boolean tensor.  `mask`'s shape must be a prefix
of `data`'s shape.  `rank(mask)` must be known statically. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A potentially ragged tensor that is formed by retaining the elements in
`data` where the corresponding value in `mask` is `True`. <p></p> * `rank(output) = rank(data)`.
* `output.ragged_rank = max(data.ragged_rank, rank(mask) - 1)`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="boolean_mask" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>boolean_mask</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> data, <a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> mask, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Applies a boolean mask to `data` without flattening the mask dimensions. <p></p> Returns a potentially ragged tensor that is formed by retaining the elements
in `data` where the corresponding value in `mask` is `True`. <p></p> * `output[a1...aA, i, b1...bB] = data[a1...aA, j, b1...bB]` <p></p> Where `j` is the `i`th `True` entry of `mask[a1...aA]`. <p></p> Note that `output` preserves the mask dimensions `a1...aA`; this differs
from <a href="..\..\tf\boolean_mask.md"><code>tf.boolean_mask</code></a>, which flattens those dimensions. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> data
						</dt>
						<dd>A potentially ragged tensor. 
						</dd>
						<dt>
							<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code> mask
						</dt>
						<dd>A potentially ragged boolean tensor.  `mask`'s shape must be a prefix
of `data`'s shape.  `rank(mask)` must be known statically. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A potentially ragged tensor that is formed by retaining the elements in
`data` where the corresponding value in `mask` is `True`. <p></p> * `rank(output) = rank(data)`.
* `output.ragged_rank = max(data.ragged_rank, rank(mask) - 1)`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="boolean_mask" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>boolean_mask</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> data, <a href="../tensorflow/DType.htm">DType</a> mask, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Applies a boolean mask to `data` without flattening the mask dimensions. <p></p> Returns a potentially ragged tensor that is formed by retaining the elements
in `data` where the corresponding value in `mask` is `True`. <p></p> * `output[a1...aA, i, b1...bB] = data[a1...aA, j, b1...bB]` <p></p> Where `j` is the `i`th `True` entry of `mask[a1...aA]`. <p></p> Note that `output` preserves the mask dimensions `a1...aA`; this differs
from <a href="..\..\tf\boolean_mask.md"><code>tf.boolean_mask</code></a>, which flattens those dimensions. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> data
						</dt>
						<dd>A potentially ragged tensor. 
						</dd>
						<dt>
							<code><a href="../tensorflow/DType.htm">DType</a></code> mask
						</dt>
						<dd>A potentially ragged boolean tensor.  `mask`'s shape must be a prefix
of `data`'s shape.  `rank(mask)` must be known statically. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A potentially ragged tensor that is formed by retaining the elements in
`data` where the corresponding value in `mask` is `True`. <p></p> * `rank(output) = rank(data)`.
* `output.ragged_rank = max(data.ragged_rank, rank(mask) - 1)`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="boolean_mask" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>boolean_mask</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> data, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> mask, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Applies a boolean mask to `data` without flattening the mask dimensions. <p></p> Returns a potentially ragged tensor that is formed by retaining the elements
in `data` where the corresponding value in `mask` is `True`. <p></p> * `output[a1...aA, i, b1...bB] = data[a1...aA, j, b1...bB]` <p></p> Where `j` is the `i`th `True` entry of `mask[a1...aA]`. <p></p> Note that `output` preserves the mask dimensions `a1...aA`; this differs
from <a href="..\..\tf\boolean_mask.md"><code>tf.boolean_mask</code></a>, which flattens those dimensions. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> data
						</dt>
						<dd>A potentially ragged tensor. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> mask
						</dt>
						<dd>A potentially ragged boolean tensor.  `mask`'s shape must be a prefix
of `data`'s shape.  `rank(mask)` must be known statically. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A potentially ragged tensor that is formed by retaining the elements in
`data` where the corresponding value in `mask` is `True`. <p></p> * `rank(output) = rank(data)`.
* `output.ragged_rank = max(data.ragged_rank, rank(mask) - 1)`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="boolean_mask" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>boolean_mask</strong>(<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> data, <span title="System.object">object</span> mask, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Applies a boolean mask to `data` without flattening the mask dimensions. <p></p> Returns a potentially ragged tensor that is formed by retaining the elements
in `data` where the corresponding value in `mask` is `True`. <p></p> * `output[a1...aA, i, b1...bB] = data[a1...aA, j, b1...bB]` <p></p> Where `j` is the `i`th `True` entry of `mask[a1...aA]`. <p></p> Note that `output` preserves the mask dimensions `a1...aA`; this differs
from <a href="..\..\tf\boolean_mask.md"><code>tf.boolean_mask</code></a>, which flattens those dimensions. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code> data
						</dt>
						<dd>A potentially ragged tensor. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> mask
						</dt>
						<dd>A potentially ragged boolean tensor.  `mask`'s shape must be a prefix
of `data`'s shape.  `rank(mask)` must be known statically. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A potentially ragged tensor that is formed by retaining the elements in
`data` where the corresponding value in `mask` is `True`. <p></p> * `rank(output) = rank(data)`.
* `output.ragged_rank = max(data.ragged_rank, rank(mask) - 1)`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="boolean_mask" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>boolean_mask</strong>(<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> data, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> mask, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Applies a boolean mask to `data` without flattening the mask dimensions. <p></p> Returns a potentially ragged tensor that is formed by retaining the elements
in `data` where the corresponding value in `mask` is `True`. <p></p> * `output[a1...aA, i, b1...bB] = data[a1...aA, j, b1...bB]` <p></p> Where `j` is the `i`th `True` entry of `mask[a1...aA]`. <p></p> Note that `output` preserves the mask dimensions `a1...aA`; this differs
from <a href="..\..\tf\boolean_mask.md"><code>tf.boolean_mask</code></a>, which flattens those dimensions. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code> data
						</dt>
						<dd>A potentially ragged tensor. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> mask
						</dt>
						<dd>A potentially ragged boolean tensor.  `mask`'s shape must be a prefix
of `data`'s shape.  `rank(mask)` must be known statically. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A potentially ragged tensor that is formed by retaining the elements in
`data` where the corresponding value in `mask` is `True`. <p></p> * `rank(output) = rank(data)`.
* `output.ragged_rank = max(data.ragged_rank, rank(mask) - 1)`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="boolean_mask" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>boolean_mask</strong>(<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> data, <a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> mask, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Applies a boolean mask to `data` without flattening the mask dimensions. <p></p> Returns a potentially ragged tensor that is formed by retaining the elements
in `data` where the corresponding value in `mask` is `True`. <p></p> * `output[a1...aA, i, b1...bB] = data[a1...aA, j, b1...bB]` <p></p> Where `j` is the `i`th `True` entry of `mask[a1...aA]`. <p></p> Note that `output` preserves the mask dimensions `a1...aA`; this differs
from <a href="..\..\tf\boolean_mask.md"><code>tf.boolean_mask</code></a>, which flattens those dimensions. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code> data
						</dt>
						<dd>A potentially ragged tensor. 
						</dd>
						<dt>
							<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code> mask
						</dt>
						<dd>A potentially ragged boolean tensor.  `mask`'s shape must be a prefix
of `data`'s shape.  `rank(mask)` must be known statically. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A potentially ragged tensor that is formed by retaining the elements in
`data` where the corresponding value in `mask` is `True`. <p></p> * `rank(output) = rank(data)`.
* `output.ragged_rank = max(data.ragged_rank, rank(mask) - 1)`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="boolean_mask" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>boolean_mask</strong>(<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> data, <a href="../tensorflow/DType.htm">DType</a> mask, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Applies a boolean mask to `data` without flattening the mask dimensions. <p></p> Returns a potentially ragged tensor that is formed by retaining the elements
in `data` where the corresponding value in `mask` is `True`. <p></p> * `output[a1...aA, i, b1...bB] = data[a1...aA, j, b1...bB]` <p></p> Where `j` is the `i`th `True` entry of `mask[a1...aA]`. <p></p> Note that `output` preserves the mask dimensions `a1...aA`; this differs
from <a href="..\..\tf\boolean_mask.md"><code>tf.boolean_mask</code></a>, which flattens those dimensions. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code> data
						</dt>
						<dd>A potentially ragged tensor. 
						</dd>
						<dt>
							<code><a href="../tensorflow/DType.htm">DType</a></code> mask
						</dt>
						<dd>A potentially ragged boolean tensor.  `mask`'s shape must be a prefix
of `data`'s shape.  `rank(mask)` must be known statically. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A potentially ragged tensor that is formed by retaining the elements in
`data` where the corresponding value in `mask` is `True`. <p></p> * `rank(output) = rank(data)`.
* `output.ragged_rank = max(data.ragged_rank, rank(mask) - 1)`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="boolean_mask" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>boolean_mask</strong>(<span title="System.object">object</span> data, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> mask, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Applies a boolean mask to `data` without flattening the mask dimensions. <p></p> Returns a potentially ragged tensor that is formed by retaining the elements
in `data` where the corresponding value in `mask` is `True`. <p></p> * `output[a1...aA, i, b1...bB] = data[a1...aA, j, b1...bB]` <p></p> Where `j` is the `i`th `True` entry of `mask[a1...aA]`. <p></p> Note that `output` preserves the mask dimensions `a1...aA`; this differs
from <a href="..\..\tf\boolean_mask.md"><code>tf.boolean_mask</code></a>, which flattens those dimensions. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> data
						</dt>
						<dd>A potentially ragged tensor. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> mask
						</dt>
						<dd>A potentially ragged boolean tensor.  `mask`'s shape must be a prefix
of `data`'s shape.  `rank(mask)` must be known statically. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A potentially ragged tensor that is formed by retaining the elements in
`data` where the corresponding value in `mask` is `True`. <p></p> * `rank(output) = rank(data)`.
* `output.ragged_rank = max(data.ragged_rank, rank(mask) - 1)`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="boolean_mask" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>boolean_mask</strong>(<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> data, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> mask, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Applies a boolean mask to `data` without flattening the mask dimensions. <p></p> Returns a potentially ragged tensor that is formed by retaining the elements
in `data` where the corresponding value in `mask` is `True`. <p></p> * `output[a1...aA, i, b1...bB] = data[a1...aA, j, b1...bB]` <p></p> Where `j` is the `i`th `True` entry of `mask[a1...aA]`. <p></p> Note that `output` preserves the mask dimensions `a1...aA`; this differs
from <a href="..\..\tf\boolean_mask.md"><code>tf.boolean_mask</code></a>, which flattens those dimensions. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code> data
						</dt>
						<dd>A potentially ragged tensor. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> mask
						</dt>
						<dd>A potentially ragged boolean tensor.  `mask`'s shape must be a prefix
of `data`'s shape.  `rank(mask)` must be known statically. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A potentially ragged tensor that is formed by retaining the elements in
`data` where the corresponding value in `mask` is `True`. <p></p> * `rank(output) = rank(data)`.
* `output.ragged_rank = max(data.ragged_rank, rank(mask) - 1)`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="boolean_mask" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>boolean_mask</strong>(<a href="../tensorflow/DType.htm">DType</a> data, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> mask, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Applies a boolean mask to `data` without flattening the mask dimensions. <p></p> Returns a potentially ragged tensor that is formed by retaining the elements
in `data` where the corresponding value in `mask` is `True`. <p></p> * `output[a1...aA, i, b1...bB] = data[a1...aA, j, b1...bB]` <p></p> Where `j` is the `i`th `True` entry of `mask[a1...aA]`. <p></p> Note that `output` preserves the mask dimensions `a1...aA`; this differs
from <a href="..\..\tf\boolean_mask.md"><code>tf.boolean_mask</code></a>, which flattens those dimensions. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/DType.htm">DType</a></code> data
						</dt>
						<dd>A potentially ragged tensor. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> mask
						</dt>
						<dd>A potentially ragged boolean tensor.  `mask`'s shape must be a prefix
of `data`'s shape.  `rank(mask)` must be known statically. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A potentially ragged tensor that is formed by retaining the elements in
`data` where the corresponding value in `mask` is `True`. <p></p> * `rank(output) = rank(data)`.
* `output.ragged_rank = max(data.ragged_rank, rank(mask) - 1)`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="boolean_mask" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>boolean_mask</strong>(<a href="../tensorflow/DType.htm">DType</a> data, <a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> mask, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Applies a boolean mask to `data` without flattening the mask dimensions. <p></p> Returns a potentially ragged tensor that is formed by retaining the elements
in `data` where the corresponding value in `mask` is `True`. <p></p> * `output[a1...aA, i, b1...bB] = data[a1...aA, j, b1...bB]` <p></p> Where `j` is the `i`th `True` entry of `mask[a1...aA]`. <p></p> Note that `output` preserves the mask dimensions `a1...aA`; this differs
from <a href="..\..\tf\boolean_mask.md"><code>tf.boolean_mask</code></a>, which flattens those dimensions. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/DType.htm">DType</a></code> data
						</dt>
						<dd>A potentially ragged tensor. 
						</dd>
						<dt>
							<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code> mask
						</dt>
						<dd>A potentially ragged boolean tensor.  `mask`'s shape must be a prefix
of `data`'s shape.  `rank(mask)` must be known statically. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A potentially ragged tensor that is formed by retaining the elements in
`data` where the corresponding value in `mask` is `True`. <p></p> * `rank(output) = rank(data)`.
* `output.ragged_rank = max(data.ragged_rank, rank(mask) - 1)`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="boolean_mask" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>boolean_mask</strong>(<a href="../tensorflow/DType.htm">DType</a> data, <a href="../tensorflow/DType.htm">DType</a> mask, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Applies a boolean mask to `data` without flattening the mask dimensions. <p></p> Returns a potentially ragged tensor that is formed by retaining the elements
in `data` where the corresponding value in `mask` is `True`. <p></p> * `output[a1...aA, i, b1...bB] = data[a1...aA, j, b1...bB]` <p></p> Where `j` is the `i`th `True` entry of `mask[a1...aA]`. <p></p> Note that `output` preserves the mask dimensions `a1...aA`; this differs
from <a href="..\..\tf\boolean_mask.md"><code>tf.boolean_mask</code></a>, which flattens those dimensions. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/DType.htm">DType</a></code> data
						</dt>
						<dd>A potentially ragged tensor. 
						</dd>
						<dt>
							<code><a href="../tensorflow/DType.htm">DType</a></code> mask
						</dt>
						<dd>A potentially ragged boolean tensor.  `mask`'s shape must be a prefix
of `data`'s shape.  `rank(mask)` must be known statically. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A potentially ragged tensor that is formed by retaining the elements in
`data` where the corresponding value in `mask` is `True`. <p></p> * `rank(output) = rank(data)`.
* `output.ragged_rank = max(data.ragged_rank, rank(mask) - 1)`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="boolean_mask" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>boolean_mask</strong>(<a href="../tensorflow/DType.htm">DType</a> data, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> mask, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Applies a boolean mask to `data` without flattening the mask dimensions. <p></p> Returns a potentially ragged tensor that is formed by retaining the elements
in `data` where the corresponding value in `mask` is `True`. <p></p> * `output[a1...aA, i, b1...bB] = data[a1...aA, j, b1...bB]` <p></p> Where `j` is the `i`th `True` entry of `mask[a1...aA]`. <p></p> Note that `output` preserves the mask dimensions `a1...aA`; this differs
from <a href="..\..\tf\boolean_mask.md"><code>tf.boolean_mask</code></a>, which flattens those dimensions. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/DType.htm">DType</a></code> data
						</dt>
						<dd>A potentially ragged tensor. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> mask
						</dt>
						<dd>A potentially ragged boolean tensor.  `mask`'s shape must be a prefix
of `data`'s shape.  `rank(mask)` must be known statically. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A potentially ragged tensor that is formed by retaining the elements in
`data` where the corresponding value in `mask` is `True`. <p></p> * `rank(output) = rank(data)`.
* `output.ragged_rank = max(data.ragged_rank, rank(mask) - 1)`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="boolean_mask" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>boolean_mask</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> data, <span title="System.object">object</span> mask, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Applies a boolean mask to `data` without flattening the mask dimensions. <p></p> Returns a potentially ragged tensor that is formed by retaining the elements
in `data` where the corresponding value in `mask` is `True`. <p></p> * `output[a1...aA, i, b1...bB] = data[a1...aA, j, b1...bB]` <p></p> Where `j` is the `i`th `True` entry of `mask[a1...aA]`. <p></p> Note that `output` preserves the mask dimensions `a1...aA`; this differs
from <a href="..\..\tf\boolean_mask.md"><code>tf.boolean_mask</code></a>, which flattens those dimensions. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> data
						</dt>
						<dd>A potentially ragged tensor. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> mask
						</dt>
						<dd>A potentially ragged boolean tensor.  `mask`'s shape must be a prefix
of `data`'s shape.  `rank(mask)` must be known statically. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A potentially ragged tensor that is formed by retaining the elements in
`data` where the corresponding value in `mask` is `True`. <p></p> * `rank(output) = rank(data)`.
* `output.ragged_rank = max(data.ragged_rank, rank(mask) - 1)`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="boolean_mask" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>boolean_mask</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> data, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> mask, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Applies a boolean mask to `data` without flattening the mask dimensions. <p></p> Returns a potentially ragged tensor that is formed by retaining the elements
in `data` where the corresponding value in `mask` is `True`. <p></p> * `output[a1...aA, i, b1...bB] = data[a1...aA, j, b1...bB]` <p></p> Where `j` is the `i`th `True` entry of `mask[a1...aA]`. <p></p> Note that `output` preserves the mask dimensions `a1...aA`; this differs
from <a href="..\..\tf\boolean_mask.md"><code>tf.boolean_mask</code></a>, which flattens those dimensions. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> data
						</dt>
						<dd>A potentially ragged tensor. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> mask
						</dt>
						<dd>A potentially ragged boolean tensor.  `mask`'s shape must be a prefix
of `data`'s shape.  `rank(mask)` must be known statically. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A potentially ragged tensor that is formed by retaining the elements in
`data` where the corresponding value in `mask` is `True`. <p></p> * `rank(output) = rank(data)`.
* `output.ragged_rank = max(data.ragged_rank, rank(mask) - 1)`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="boolean_mask" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>boolean_mask</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> data, <a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> mask, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Applies a boolean mask to `data` without flattening the mask dimensions. <p></p> Returns a potentially ragged tensor that is formed by retaining the elements
in `data` where the corresponding value in `mask` is `True`. <p></p> * `output[a1...aA, i, b1...bB] = data[a1...aA, j, b1...bB]` <p></p> Where `j` is the `i`th `True` entry of `mask[a1...aA]`. <p></p> Note that `output` preserves the mask dimensions `a1...aA`; this differs
from <a href="..\..\tf\boolean_mask.md"><code>tf.boolean_mask</code></a>, which flattens those dimensions. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> data
						</dt>
						<dd>A potentially ragged tensor. 
						</dd>
						<dt>
							<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code> mask
						</dt>
						<dd>A potentially ragged boolean tensor.  `mask`'s shape must be a prefix
of `data`'s shape.  `rank(mask)` must be known statically. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A potentially ragged tensor that is formed by retaining the elements in
`data` where the corresponding value in `mask` is `True`. <p></p> * `rank(output) = rank(data)`.
* `output.ragged_rank = max(data.ragged_rank, rank(mask) - 1)`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="boolean_mask" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>boolean_mask</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> data, <a href="../tensorflow/DType.htm">DType</a> mask, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Applies a boolean mask to `data` without flattening the mask dimensions. <p></p> Returns a potentially ragged tensor that is formed by retaining the elements
in `data` where the corresponding value in `mask` is `True`. <p></p> * `output[a1...aA, i, b1...bB] = data[a1...aA, j, b1...bB]` <p></p> Where `j` is the `i`th `True` entry of `mask[a1...aA]`. <p></p> Note that `output` preserves the mask dimensions `a1...aA`; this differs
from <a href="..\..\tf\boolean_mask.md"><code>tf.boolean_mask</code></a>, which flattens those dimensions. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> data
						</dt>
						<dd>A potentially ragged tensor. 
						</dd>
						<dt>
							<code><a href="../tensorflow/DType.htm">DType</a></code> mask
						</dt>
						<dd>A potentially ragged boolean tensor.  `mask`'s shape must be a prefix
of `data`'s shape.  `rank(mask)` must be known statically. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A potentially ragged tensor that is formed by retaining the elements in
`data` where the corresponding value in `mask` is `True`. <p></p> * `rank(output) = rank(data)`.
* `output.ragged_rank = max(data.ragged_rank, rank(mask) - 1)`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="boolean_mask" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>boolean_mask</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> data, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> mask, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Applies a boolean mask to `data` without flattening the mask dimensions. <p></p> Returns a potentially ragged tensor that is formed by retaining the elements
in `data` where the corresponding value in `mask` is `True`. <p></p> * `output[a1...aA, i, b1...bB] = data[a1...aA, j, b1...bB]` <p></p> Where `j` is the `i`th `True` entry of `mask[a1...aA]`. <p></p> Note that `output` preserves the mask dimensions `a1...aA`; this differs
from <a href="..\..\tf\boolean_mask.md"><code>tf.boolean_mask</code></a>, which flattens those dimensions. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> data
						</dt>
						<dd>A potentially ragged tensor. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> mask
						</dt>
						<dd>A potentially ragged boolean tensor.  `mask`'s shape must be a prefix
of `data`'s shape.  `rank(mask)` must be known statically. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A potentially ragged tensor that is formed by retaining the elements in
`data` where the corresponding value in `mask` is `True`. <p></p> * `rank(output) = rank(data)`.
* `output.ragged_rank = max(data.ragged_rank, rank(mask) - 1)`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="boolean_mask" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>boolean_mask</strong>(<a href="../tensorflow/DType.htm">DType</a> data, <span title="System.object">object</span> mask, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Applies a boolean mask to `data` without flattening the mask dimensions. <p></p> Returns a potentially ragged tensor that is formed by retaining the elements
in `data` where the corresponding value in `mask` is `True`. <p></p> * `output[a1...aA, i, b1...bB] = data[a1...aA, j, b1...bB]` <p></p> Where `j` is the `i`th `True` entry of `mask[a1...aA]`. <p></p> Note that `output` preserves the mask dimensions `a1...aA`; this differs
from <a href="..\..\tf\boolean_mask.md"><code>tf.boolean_mask</code></a>, which flattens those dimensions. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/DType.htm">DType</a></code> data
						</dt>
						<dd>A potentially ragged tensor. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> mask
						</dt>
						<dd>A potentially ragged boolean tensor.  `mask`'s shape must be a prefix
of `data`'s shape.  `rank(mask)` must be known statically. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A potentially ragged tensor that is formed by retaining the elements in
`data` where the corresponding value in `mask` is `True`. <p></p> * `rank(output) = rank(data)`.
* `output.ragged_rank = max(data.ragged_rank, rank(mask) - 1)`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="boolean_mask" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>boolean_mask</strong>(<span title="System.object">object</span> data, <span title="System.object">object</span> mask, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Applies a boolean mask to `data` without flattening the mask dimensions. <p></p> Returns a potentially ragged tensor that is formed by retaining the elements
in `data` where the corresponding value in `mask` is `True`. <p></p> * `output[a1...aA, i, b1...bB] = data[a1...aA, j, b1...bB]` <p></p> Where `j` is the `i`th `True` entry of `mask[a1...aA]`. <p></p> Note that `output` preserves the mask dimensions `a1...aA`; this differs
from <a href="..\..\tf\boolean_mask.md"><code>tf.boolean_mask</code></a>, which flattens those dimensions. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> data
						</dt>
						<dd>A potentially ragged tensor. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> mask
						</dt>
						<dd>A potentially ragged boolean tensor.  `mask`'s shape must be a prefix
of `data`'s shape.  `rank(mask)` must be known statically. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A potentially ragged tensor that is formed by retaining the elements in
`data` where the corresponding value in `mask` is `True`. <p></p> * `rank(output) = rank(data)`.
* `output.ragged_rank = max(data.ragged_rank, rank(mask) - 1)`. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="constant" class="method">
		<h4>
			<span title="System.object">object</span> <strong>constant</strong>(<span title="System.int">int</span> pylist, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> dtype, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> ragged_rank, <span title="System.Nullable<ValueTuple<int>>">Nullable&lt;ValueTuple&lt;int&gt;&gt;</span> inner_shape, <span title="System.string">string</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> row_splits_dtype)
		</h4>
		<div class="content">Constructs a constant RaggedTensor from a nested Python list. <p></p> Example:
All scalar values in `pylist` must have the same nesting depth `K`, and the
returned `RaggedTensor` will have rank `K`.  If `pylist` contains no scalar
values, then `K` is one greater than the maximum depth of empty lists in
`pylist`.  All scalar values in `pylist` must be compatible with `dtype`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> pylist
						</dt>
						<dd>A nested `list`, `tuple` or `np.ndarray`.  Any nested element that
is not a `list`, `tuple` or `np.ndarray` must be a scalar value
compatible with `dtype`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> dtype
						</dt>
						<dd>The type of elements for the returned `RaggedTensor`.  If not
specified, then a default is chosen based on the scalar values in
`pylist`. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> ragged_rank
						</dt>
						<dd>An integer specifying the ragged rank of the returned
`RaggedTensor`.  Must be nonnegative and less than `K`. Defaults to
`max(0, K - 1)` if `inner_shape` is not specified.  Defaults to `max(0, K
- 1 - len(inner_shape))` if `inner_shape` is specified. 
						</dd>
						<dt>
							<code><span title="System.Nullable<ValueTuple<int>>">Nullable&lt;ValueTuple&lt;int&gt;&gt;</span></code> inner_shape
						</dt>
						<dd>A tuple of integers specifying the shape for individual inner
values in the returned `RaggedTensor`.  Defaults to `()` if `ragged_rank`
is not specified.  If `ragged_rank` is specified, then a default is chosen
based on the contents of `pylist`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> row_splits_dtype
						</dt>
						<dd>data type for the constructed `RaggedTensor`'s row_splits.
One of <a href="..\..\tf\dtypes\int32.md"><code>tf.int32</code></a> or <a href="..\..\tf\dtypes\int64.md"><code>tf.int64</code></a>. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A potentially ragged tensor with rank `K` and the specified `ragged_rank`,
containing the values from `pylist`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> ragged.constant([[1, 2], [3], [4, 5, 6]]).eval()
            RaggedTensorValue(values=[1, 2, 3, 4, 5, 6], splits=[0, 2, 3, 6]) </pre>
</div>
		</div>
	</div>
	<div id="constant" class="method">
		<h4>
			<span title="System.object">object</span> <strong>constant</strong>(<a href="../numpy/ndarray.htm">ndarray</a> pylist, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> dtype, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> ragged_rank, <span title="System.Nullable<ValueTuple<int>>">Nullable&lt;ValueTuple&lt;int&gt;&gt;</span> inner_shape, <span title="System.string">string</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> row_splits_dtype)
		</h4>
		<div class="content">Constructs a constant RaggedTensor from a nested Python list. <p></p> Example:
All scalar values in `pylist` must have the same nesting depth `K`, and the
returned `RaggedTensor` will have rank `K`.  If `pylist` contains no scalar
values, then `K` is one greater than the maximum depth of empty lists in
`pylist`.  All scalar values in `pylist` must be compatible with `dtype`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> pylist
						</dt>
						<dd>A nested `list`, `tuple` or `np.ndarray`.  Any nested element that
is not a `list`, `tuple` or `np.ndarray` must be a scalar value
compatible with `dtype`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> dtype
						</dt>
						<dd>The type of elements for the returned `RaggedTensor`.  If not
specified, then a default is chosen based on the scalar values in
`pylist`. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> ragged_rank
						</dt>
						<dd>An integer specifying the ragged rank of the returned
`RaggedTensor`.  Must be nonnegative and less than `K`. Defaults to
`max(0, K - 1)` if `inner_shape` is not specified.  Defaults to `max(0, K
- 1 - len(inner_shape))` if `inner_shape` is specified. 
						</dd>
						<dt>
							<code><span title="System.Nullable<ValueTuple<int>>">Nullable&lt;ValueTuple&lt;int&gt;&gt;</span></code> inner_shape
						</dt>
						<dd>A tuple of integers specifying the shape for individual inner
values in the returned `RaggedTensor`.  Defaults to `()` if `ragged_rank`
is not specified.  If `ragged_rank` is specified, then a default is chosen
based on the contents of `pylist`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> row_splits_dtype
						</dt>
						<dd>data type for the constructed `RaggedTensor`'s row_splits.
One of <a href="..\..\tf\dtypes\int32.md"><code>tf.int32</code></a> or <a href="..\..\tf\dtypes\int64.md"><code>tf.int64</code></a>. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A potentially ragged tensor with rank `K` and the specified `ragged_rank`,
containing the values from `pylist`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> ragged.constant([[1, 2], [3], [4, 5, 6]]).eval()
            RaggedTensorValue(values=[1, 2, 3, 4, 5, 6], splits=[0, 2, 3, 6]) </pre>
</div>
		</div>
	</div>
	<div id="constant" class="method">
		<h4>
			<span title="System.object">object</span> <strong>constant</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> pylist, <a href="../tensorflow/DType.htm">DType</a> dtype, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> ragged_rank, <span title="System.Nullable<ValueTuple<int>>">Nullable&lt;ValueTuple&lt;int&gt;&gt;</span> inner_shape, <span title="System.string">string</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> row_splits_dtype)
		</h4>
		<div class="content">Constructs a constant RaggedTensor from a nested Python list. <p></p> Example:
All scalar values in `pylist` must have the same nesting depth `K`, and the
returned `RaggedTensor` will have rank `K`.  If `pylist` contains no scalar
values, then `K` is one greater than the maximum depth of empty lists in
`pylist`.  All scalar values in `pylist` must be compatible with `dtype`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> pylist
						</dt>
						<dd>A nested `list`, `tuple` or `np.ndarray`.  Any nested element that
is not a `list`, `tuple` or `np.ndarray` must be a scalar value
compatible with `dtype`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/DType.htm">DType</a></code> dtype
						</dt>
						<dd>The type of elements for the returned `RaggedTensor`.  If not
specified, then a default is chosen based on the scalar values in
`pylist`. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> ragged_rank
						</dt>
						<dd>An integer specifying the ragged rank of the returned
`RaggedTensor`.  Must be nonnegative and less than `K`. Defaults to
`max(0, K - 1)` if `inner_shape` is not specified.  Defaults to `max(0, K
- 1 - len(inner_shape))` if `inner_shape` is specified. 
						</dd>
						<dt>
							<code><span title="System.Nullable<ValueTuple<int>>">Nullable&lt;ValueTuple&lt;int&gt;&gt;</span></code> inner_shape
						</dt>
						<dd>A tuple of integers specifying the shape for individual inner
values in the returned `RaggedTensor`.  Defaults to `()` if `ragged_rank`
is not specified.  If `ragged_rank` is specified, then a default is chosen
based on the contents of `pylist`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> row_splits_dtype
						</dt>
						<dd>data type for the constructed `RaggedTensor`'s row_splits.
One of <a href="..\..\tf\dtypes\int32.md"><code>tf.int32</code></a> or <a href="..\..\tf\dtypes\int64.md"><code>tf.int64</code></a>. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A potentially ragged tensor with rank `K` and the specified `ragged_rank`,
containing the values from `pylist`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> ragged.constant([[1, 2], [3], [4, 5, 6]]).eval()
            RaggedTensorValue(values=[1, 2, 3, 4, 5, 6], splits=[0, 2, 3, 6]) </pre>
</div>
		</div>
	</div>
	<div id="constant" class="method">
		<h4>
			<span title="System.object">object</span> <strong>constant</strong>(<a href="../numpy/ndarray.htm">ndarray</a> pylist, <a href="../tensorflow/DType.htm">DType</a> dtype, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> ragged_rank, <span title="System.Nullable<ValueTuple<int>>">Nullable&lt;ValueTuple&lt;int&gt;&gt;</span> inner_shape, <span title="System.string">string</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> row_splits_dtype)
		</h4>
		<div class="content">Constructs a constant RaggedTensor from a nested Python list. <p></p> Example:
All scalar values in `pylist` must have the same nesting depth `K`, and the
returned `RaggedTensor` will have rank `K`.  If `pylist` contains no scalar
values, then `K` is one greater than the maximum depth of empty lists in
`pylist`.  All scalar values in `pylist` must be compatible with `dtype`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../numpy/ndarray.htm">ndarray</a></code> pylist
						</dt>
						<dd>A nested `list`, `tuple` or `np.ndarray`.  Any nested element that
is not a `list`, `tuple` or `np.ndarray` must be a scalar value
compatible with `dtype`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/DType.htm">DType</a></code> dtype
						</dt>
						<dd>The type of elements for the returned `RaggedTensor`.  If not
specified, then a default is chosen based on the scalar values in
`pylist`. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> ragged_rank
						</dt>
						<dd>An integer specifying the ragged rank of the returned
`RaggedTensor`.  Must be nonnegative and less than `K`. Defaults to
`max(0, K - 1)` if `inner_shape` is not specified.  Defaults to `max(0, K
- 1 - len(inner_shape))` if `inner_shape` is specified. 
						</dd>
						<dt>
							<code><span title="System.Nullable<ValueTuple<int>>">Nullable&lt;ValueTuple&lt;int&gt;&gt;</span></code> inner_shape
						</dt>
						<dd>A tuple of integers specifying the shape for individual inner
values in the returned `RaggedTensor`.  Defaults to `()` if `ragged_rank`
is not specified.  If `ragged_rank` is specified, then a default is chosen
based on the contents of `pylist`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> row_splits_dtype
						</dt>
						<dd>data type for the constructed `RaggedTensor`'s row_splits.
One of <a href="..\..\tf\dtypes\int32.md"><code>tf.int32</code></a> or <a href="..\..\tf\dtypes\int64.md"><code>tf.int64</code></a>. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A potentially ragged tensor with rank `K` and the specified `ragged_rank`,
containing the values from `pylist`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> ragged.constant([[1, 2], [3], [4, 5, 6]]).eval()
            RaggedTensorValue(values=[1, 2, 3, 4, 5, 6], splits=[0, 2, 3, 6]) </pre>
</div>
		</div>
	</div>
	<div id="constant" class="method">
		<h4>
			<span title="System.object">object</span> <strong>constant</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> pylist, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> dtype, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> ragged_rank, <span title="System.Nullable<ValueTuple<int>>">Nullable&lt;ValueTuple&lt;int&gt;&gt;</span> inner_shape, <span title="System.string">string</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> row_splits_dtype)
		</h4>
		<div class="content">Constructs a constant RaggedTensor from a nested Python list. <p></p> Example:
All scalar values in `pylist` must have the same nesting depth `K`, and the
returned `RaggedTensor` will have rank `K`.  If `pylist` contains no scalar
values, then `K` is one greater than the maximum depth of empty lists in
`pylist`.  All scalar values in `pylist` must be compatible with `dtype`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> pylist
						</dt>
						<dd>A nested `list`, `tuple` or `np.ndarray`.  Any nested element that
is not a `list`, `tuple` or `np.ndarray` must be a scalar value
compatible with `dtype`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> dtype
						</dt>
						<dd>The type of elements for the returned `RaggedTensor`.  If not
specified, then a default is chosen based on the scalar values in
`pylist`. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> ragged_rank
						</dt>
						<dd>An integer specifying the ragged rank of the returned
`RaggedTensor`.  Must be nonnegative and less than `K`. Defaults to
`max(0, K - 1)` if `inner_shape` is not specified.  Defaults to `max(0, K
- 1 - len(inner_shape))` if `inner_shape` is specified. 
						</dd>
						<dt>
							<code><span title="System.Nullable<ValueTuple<int>>">Nullable&lt;ValueTuple&lt;int&gt;&gt;</span></code> inner_shape
						</dt>
						<dd>A tuple of integers specifying the shape for individual inner
values in the returned `RaggedTensor`.  Defaults to `()` if `ragged_rank`
is not specified.  If `ragged_rank` is specified, then a default is chosen
based on the contents of `pylist`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> row_splits_dtype
						</dt>
						<dd>data type for the constructed `RaggedTensor`'s row_splits.
One of <a href="..\..\tf\dtypes\int32.md"><code>tf.int32</code></a> or <a href="..\..\tf\dtypes\int64.md"><code>tf.int64</code></a>. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A potentially ragged tensor with rank `K` and the specified `ragged_rank`,
containing the values from `pylist`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> ragged.constant([[1, 2], [3], [4, 5, 6]]).eval()
            RaggedTensorValue(values=[1, 2, 3, 4, 5, 6], splits=[0, 2, 3, 6]) </pre>
</div>
		</div>
	</div>
	<div id="constant" class="method">
		<h4>
			<span title="System.object">object</span> <strong>constant</strong>(<span title="System.int">int</span> pylist, <a href="../tensorflow/DType.htm">DType</a> dtype, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> ragged_rank, <span title="System.Nullable<ValueTuple<int>>">Nullable&lt;ValueTuple&lt;int&gt;&gt;</span> inner_shape, <span title="System.string">string</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> row_splits_dtype)
		</h4>
		<div class="content">Constructs a constant RaggedTensor from a nested Python list. <p></p> Example:
All scalar values in `pylist` must have the same nesting depth `K`, and the
returned `RaggedTensor` will have rank `K`.  If `pylist` contains no scalar
values, then `K` is one greater than the maximum depth of empty lists in
`pylist`.  All scalar values in `pylist` must be compatible with `dtype`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> pylist
						</dt>
						<dd>A nested `list`, `tuple` or `np.ndarray`.  Any nested element that
is not a `list`, `tuple` or `np.ndarray` must be a scalar value
compatible with `dtype`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/DType.htm">DType</a></code> dtype
						</dt>
						<dd>The type of elements for the returned `RaggedTensor`.  If not
specified, then a default is chosen based on the scalar values in
`pylist`. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> ragged_rank
						</dt>
						<dd>An integer specifying the ragged rank of the returned
`RaggedTensor`.  Must be nonnegative and less than `K`. Defaults to
`max(0, K - 1)` if `inner_shape` is not specified.  Defaults to `max(0, K
- 1 - len(inner_shape))` if `inner_shape` is specified. 
						</dd>
						<dt>
							<code><span title="System.Nullable<ValueTuple<int>>">Nullable&lt;ValueTuple&lt;int&gt;&gt;</span></code> inner_shape
						</dt>
						<dd>A tuple of integers specifying the shape for individual inner
values in the returned `RaggedTensor`.  Defaults to `()` if `ragged_rank`
is not specified.  If `ragged_rank` is specified, then a default is chosen
based on the contents of `pylist`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> row_splits_dtype
						</dt>
						<dd>data type for the constructed `RaggedTensor`'s row_splits.
One of <a href="..\..\tf\dtypes\int32.md"><code>tf.int32</code></a> or <a href="..\..\tf\dtypes\int64.md"><code>tf.int64</code></a>. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A potentially ragged tensor with rank `K` and the specified `ragged_rank`,
containing the values from `pylist`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> ragged.constant([[1, 2], [3], [4, 5, 6]]).eval()
            RaggedTensorValue(values=[1, 2, 3, 4, 5, 6], splits=[0, 2, 3, 6]) </pre>
</div>
		</div>
	</div>
	<div id="constant_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>constant_dyn</strong>(<span title="System.object">object</span> pylist, <span title="System.object">object</span> dtype, <span title="System.object">object</span> ragged_rank, <span title="System.object">object</span> inner_shape, <span title="System.object">object</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> row_splits_dtype)
		</h4>
		<div class="content">Constructs a constant RaggedTensor from a nested Python list. <p></p> Example:
All scalar values in `pylist` must have the same nesting depth `K`, and the
returned `RaggedTensor` will have rank `K`.  If `pylist` contains no scalar
values, then `K` is one greater than the maximum depth of empty lists in
`pylist`.  All scalar values in `pylist` must be compatible with `dtype`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> pylist
						</dt>
						<dd>A nested `list`, `tuple` or `np.ndarray`.  Any nested element that
is not a `list`, `tuple` or `np.ndarray` must be a scalar value
compatible with `dtype`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> dtype
						</dt>
						<dd>The type of elements for the returned `RaggedTensor`.  If not
specified, then a default is chosen based on the scalar values in
`pylist`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> ragged_rank
						</dt>
						<dd>An integer specifying the ragged rank of the returned
`RaggedTensor`.  Must be nonnegative and less than `K`. Defaults to
`max(0, K - 1)` if `inner_shape` is not specified.  Defaults to `max(0, K
- 1 - len(inner_shape))` if `inner_shape` is specified. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> inner_shape
						</dt>
						<dd>A tuple of integers specifying the shape for individual inner
values in the returned `RaggedTensor`.  Defaults to `()` if `ragged_rank`
is not specified.  If `ragged_rank` is specified, then a default is chosen
based on the contents of `pylist`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> row_splits_dtype
						</dt>
						<dd>data type for the constructed `RaggedTensor`'s row_splits.
One of <a href="..\..\tf\dtypes\int32.md"><code>tf.int32</code></a> or <a href="..\..\tf\dtypes\int64.md"><code>tf.int64</code></a>. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A potentially ragged tensor with rank `K` and the specified `ragged_rank`,
containing the values from `pylist`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> ragged.constant([[1, 2], [3], [4, 5, 6]]).eval()
            RaggedTensorValue(values=[1, 2, 3, 4, 5, 6], splits=[0, 2, 3, 6]) </pre>
</div>
		</div>
	</div>
	<div id="constant_value" class="method">
		<h4>
			<span title="System.Collections.Generic.IList<object>">IList&lt;object&gt;</span> <strong>constant_value</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> pylist, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> dtype, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> ragged_rank, <span title="System.object">object</span> inner_shape, <span title="System.string">string</span> row_splits_dtype)
		</h4>
		<div class="content">Constructs a RaggedTensorValue from a nested Python list. <p></p> Warning: This function returns a `RaggedTensorValue`, not a `RaggedTensor`.
If you wish to construct a constant `RaggedTensor`, use
[`ragged.constant(...)`](constant.md) instead. <p></p> Example:
All scalar values in `pylist` must have the same nesting depth `K`, and the
returned `RaggedTensorValue` will have rank `K`.  If `pylist` contains no
scalar values, then `K` is one greater than the maximum depth of empty lists
in `pylist`.  All scalar values in `pylist` must be compatible with `dtype`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> pylist
						</dt>
						<dd>A nested `list`, `tuple` or `np.ndarray`.  Any nested element that
is not a `list` or `tuple` must be a scalar value compatible with `dtype`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> dtype
						</dt>
						<dd>`numpy.dtype`.  The type of elements for the returned `RaggedTensor`.
If not specified, then a default is chosen based on the scalar values in
`pylist`. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> ragged_rank
						</dt>
						<dd>An integer specifying the ragged rank of the returned
`RaggedTensorValue`.  Must be nonnegative and less than `K`. Defaults to
`max(0, K - 1)` if `inner_shape` is not specified.  Defaults to `max(0, K
- 1 - len(inner_shape))` if `inner_shape` is specified. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> inner_shape
						</dt>
						<dd>A tuple of integers specifying the shape for individual inner
values in the returned `RaggedTensorValue`.  Defaults to `()` if
`ragged_rank` is not specified.  If `ragged_rank` is specified, then a
default is chosen based on the contents of `pylist`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> row_splits_dtype
						</dt>
						<dd>data type for the constructed `RaggedTensorValue`'s
row_splits.  One of `numpy.int32` or `numpy.int64`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.Collections.Generic.IList<object>">IList&lt;object&gt;</span></code>
					</dt>
					<dd>A `tf.RaggedTensorValue` or `numpy.array` with rank `K` and the specified
`ragged_rank`, containing the values from `pylist`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> ragged.constant_value([[1, 2], [3], [4, 5, 6]])
            RaggedTensorValue(values=[1, 2, 3, 4, 5, 6], splits=[0, 2, 3, 6]) </pre>
</div>
		</div>
	</div>
	<div id="constant_value" class="method">
		<h4>
			<span title="System.Collections.Generic.IList<object>">IList&lt;object&gt;</span> <strong>constant_value</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> pylist, <a href="../tensorflow/DType.htm">DType</a> dtype, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> ragged_rank, <span title="System.object">object</span> inner_shape, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> row_splits_dtype)
		</h4>
		<div class="content">Constructs a RaggedTensorValue from a nested Python list. <p></p> Warning: This function returns a `RaggedTensorValue`, not a `RaggedTensor`.
If you wish to construct a constant `RaggedTensor`, use
[`ragged.constant(...)`](constant.md) instead. <p></p> Example:
All scalar values in `pylist` must have the same nesting depth `K`, and the
returned `RaggedTensorValue` will have rank `K`.  If `pylist` contains no
scalar values, then `K` is one greater than the maximum depth of empty lists
in `pylist`.  All scalar values in `pylist` must be compatible with `dtype`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> pylist
						</dt>
						<dd>A nested `list`, `tuple` or `np.ndarray`.  Any nested element that
is not a `list` or `tuple` must be a scalar value compatible with `dtype`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/DType.htm">DType</a></code> dtype
						</dt>
						<dd>`numpy.dtype`.  The type of elements for the returned `RaggedTensor`.
If not specified, then a default is chosen based on the scalar values in
`pylist`. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> ragged_rank
						</dt>
						<dd>An integer specifying the ragged rank of the returned
`RaggedTensorValue`.  Must be nonnegative and less than `K`. Defaults to
`max(0, K - 1)` if `inner_shape` is not specified.  Defaults to `max(0, K
- 1 - len(inner_shape))` if `inner_shape` is specified. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> inner_shape
						</dt>
						<dd>A tuple of integers specifying the shape for individual inner
values in the returned `RaggedTensorValue`.  Defaults to `()` if
`ragged_rank` is not specified.  If `ragged_rank` is specified, then a
default is chosen based on the contents of `pylist`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> row_splits_dtype
						</dt>
						<dd>data type for the constructed `RaggedTensorValue`'s
row_splits.  One of `numpy.int32` or `numpy.int64`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.Collections.Generic.IList<object>">IList&lt;object&gt;</span></code>
					</dt>
					<dd>A `tf.RaggedTensorValue` or `numpy.array` with rank `K` and the specified
`ragged_rank`, containing the values from `pylist`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> ragged.constant_value([[1, 2], [3], [4, 5, 6]])
            RaggedTensorValue(values=[1, 2, 3, 4, 5, 6], splits=[0, 2, 3, 6]) </pre>
</div>
		</div>
	</div>
	<div id="constant_value" class="method">
		<h4>
			<span title="System.Collections.Generic.IList<object>">IList&lt;object&gt;</span> <strong>constant_value</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> pylist, <a href="../numpy/dtype.htm">dtype</a> dtype, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> ragged_rank, <span title="System.object">object</span> inner_shape, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> row_splits_dtype)
		</h4>
		<div class="content">Constructs a RaggedTensorValue from a nested Python list. <p></p> Warning: This function returns a `RaggedTensorValue`, not a `RaggedTensor`.
If you wish to construct a constant `RaggedTensor`, use
[`ragged.constant(...)`](constant.md) instead. <p></p> Example:
All scalar values in `pylist` must have the same nesting depth `K`, and the
returned `RaggedTensorValue` will have rank `K`.  If `pylist` contains no
scalar values, then `K` is one greater than the maximum depth of empty lists
in `pylist`.  All scalar values in `pylist` must be compatible with `dtype`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> pylist
						</dt>
						<dd>A nested `list`, `tuple` or `np.ndarray`.  Any nested element that
is not a `list` or `tuple` must be a scalar value compatible with `dtype`. 
						</dd>
						<dt>
							<code><a href="../numpy/dtype.htm">dtype</a></code> dtype
						</dt>
						<dd>`numpy.dtype`.  The type of elements for the returned `RaggedTensor`.
If not specified, then a default is chosen based on the scalar values in
`pylist`. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> ragged_rank
						</dt>
						<dd>An integer specifying the ragged rank of the returned
`RaggedTensorValue`.  Must be nonnegative and less than `K`. Defaults to
`max(0, K - 1)` if `inner_shape` is not specified.  Defaults to `max(0, K
- 1 - len(inner_shape))` if `inner_shape` is specified. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> inner_shape
						</dt>
						<dd>A tuple of integers specifying the shape for individual inner
values in the returned `RaggedTensorValue`.  Defaults to `()` if
`ragged_rank` is not specified.  If `ragged_rank` is specified, then a
default is chosen based on the contents of `pylist`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> row_splits_dtype
						</dt>
						<dd>data type for the constructed `RaggedTensorValue`'s
row_splits.  One of `numpy.int32` or `numpy.int64`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.Collections.Generic.IList<object>">IList&lt;object&gt;</span></code>
					</dt>
					<dd>A `tf.RaggedTensorValue` or `numpy.array` with rank `K` and the specified
`ragged_rank`, containing the values from `pylist`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> ragged.constant_value([[1, 2], [3], [4, 5, 6]])
            RaggedTensorValue(values=[1, 2, 3, 4, 5, 6], splits=[0, 2, 3, 6]) </pre>
</div>
		</div>
	</div>
	<div id="constant_value" class="method">
		<h4>
			<span title="System.Collections.Generic.IList<object>">IList&lt;object&gt;</span> <strong>constant_value</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> pylist, <a href="../tensorflow/DType.htm">DType</a> dtype, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> ragged_rank, <span title="System.object">object</span> inner_shape, <span title="System.string">string</span> row_splits_dtype)
		</h4>
		<div class="content">Constructs a RaggedTensorValue from a nested Python list. <p></p> Warning: This function returns a `RaggedTensorValue`, not a `RaggedTensor`.
If you wish to construct a constant `RaggedTensor`, use
[`ragged.constant(...)`](constant.md) instead. <p></p> Example:
All scalar values in `pylist` must have the same nesting depth `K`, and the
returned `RaggedTensorValue` will have rank `K`.  If `pylist` contains no
scalar values, then `K` is one greater than the maximum depth of empty lists
in `pylist`.  All scalar values in `pylist` must be compatible with `dtype`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> pylist
						</dt>
						<dd>A nested `list`, `tuple` or `np.ndarray`.  Any nested element that
is not a `list` or `tuple` must be a scalar value compatible with `dtype`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/DType.htm">DType</a></code> dtype
						</dt>
						<dd>`numpy.dtype`.  The type of elements for the returned `RaggedTensor`.
If not specified, then a default is chosen based on the scalar values in
`pylist`. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> ragged_rank
						</dt>
						<dd>An integer specifying the ragged rank of the returned
`RaggedTensorValue`.  Must be nonnegative and less than `K`. Defaults to
`max(0, K - 1)` if `inner_shape` is not specified.  Defaults to `max(0, K
- 1 - len(inner_shape))` if `inner_shape` is specified. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> inner_shape
						</dt>
						<dd>A tuple of integers specifying the shape for individual inner
values in the returned `RaggedTensorValue`.  Defaults to `()` if
`ragged_rank` is not specified.  If `ragged_rank` is specified, then a
default is chosen based on the contents of `pylist`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> row_splits_dtype
						</dt>
						<dd>data type for the constructed `RaggedTensorValue`'s
row_splits.  One of `numpy.int32` or `numpy.int64`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.Collections.Generic.IList<object>">IList&lt;object&gt;</span></code>
					</dt>
					<dd>A `tf.RaggedTensorValue` or `numpy.array` with rank `K` and the specified
`ragged_rank`, containing the values from `pylist`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> ragged.constant_value([[1, 2], [3], [4, 5, 6]])
            RaggedTensorValue(values=[1, 2, 3, 4, 5, 6], splits=[0, 2, 3, 6]) </pre>
</div>
		</div>
	</div>
	<div id="constant_value" class="method">
		<h4>
			<span title="System.Collections.Generic.IList<object>">IList&lt;object&gt;</span> <strong>constant_value</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> pylist, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> dtype, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> ragged_rank, <span title="System.object">object</span> inner_shape, <a href="../numpy/dtype.htm">dtype</a> row_splits_dtype)
		</h4>
		<div class="content">Constructs a RaggedTensorValue from a nested Python list. <p></p> Warning: This function returns a `RaggedTensorValue`, not a `RaggedTensor`.
If you wish to construct a constant `RaggedTensor`, use
[`ragged.constant(...)`](constant.md) instead. <p></p> Example:
All scalar values in `pylist` must have the same nesting depth `K`, and the
returned `RaggedTensorValue` will have rank `K`.  If `pylist` contains no
scalar values, then `K` is one greater than the maximum depth of empty lists
in `pylist`.  All scalar values in `pylist` must be compatible with `dtype`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> pylist
						</dt>
						<dd>A nested `list`, `tuple` or `np.ndarray`.  Any nested element that
is not a `list` or `tuple` must be a scalar value compatible with `dtype`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> dtype
						</dt>
						<dd>`numpy.dtype`.  The type of elements for the returned `RaggedTensor`.
If not specified, then a default is chosen based on the scalar values in
`pylist`. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> ragged_rank
						</dt>
						<dd>An integer specifying the ragged rank of the returned
`RaggedTensorValue`.  Must be nonnegative and less than `K`. Defaults to
`max(0, K - 1)` if `inner_shape` is not specified.  Defaults to `max(0, K
- 1 - len(inner_shape))` if `inner_shape` is specified. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> inner_shape
						</dt>
						<dd>A tuple of integers specifying the shape for individual inner
values in the returned `RaggedTensorValue`.  Defaults to `()` if
`ragged_rank` is not specified.  If `ragged_rank` is specified, then a
default is chosen based on the contents of `pylist`. 
						</dd>
						<dt>
							<code><a href="../numpy/dtype.htm">dtype</a></code> row_splits_dtype
						</dt>
						<dd>data type for the constructed `RaggedTensorValue`'s
row_splits.  One of `numpy.int32` or `numpy.int64`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.Collections.Generic.IList<object>">IList&lt;object&gt;</span></code>
					</dt>
					<dd>A `tf.RaggedTensorValue` or `numpy.array` with rank `K` and the specified
`ragged_rank`, containing the values from `pylist`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> ragged.constant_value([[1, 2], [3], [4, 5, 6]])
            RaggedTensorValue(values=[1, 2, 3, 4, 5, 6], splits=[0, 2, 3, 6]) </pre>
</div>
		</div>
	</div>
	<div id="constant_value" class="method">
		<h4>
			<span title="System.Collections.Generic.IList<object>">IList&lt;object&gt;</span> <strong>constant_value</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> pylist, <a href="../numpy/dtype.htm">dtype</a> dtype, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> ragged_rank, <span title="System.object">object</span> inner_shape, <a href="../numpy/dtype.htm">dtype</a> row_splits_dtype)
		</h4>
		<div class="content">Constructs a RaggedTensorValue from a nested Python list. <p></p> Warning: This function returns a `RaggedTensorValue`, not a `RaggedTensor`.
If you wish to construct a constant `RaggedTensor`, use
[`ragged.constant(...)`](constant.md) instead. <p></p> Example:
All scalar values in `pylist` must have the same nesting depth `K`, and the
returned `RaggedTensorValue` will have rank `K`.  If `pylist` contains no
scalar values, then `K` is one greater than the maximum depth of empty lists
in `pylist`.  All scalar values in `pylist` must be compatible with `dtype`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> pylist
						</dt>
						<dd>A nested `list`, `tuple` or `np.ndarray`.  Any nested element that
is not a `list` or `tuple` must be a scalar value compatible with `dtype`. 
						</dd>
						<dt>
							<code><a href="../numpy/dtype.htm">dtype</a></code> dtype
						</dt>
						<dd>`numpy.dtype`.  The type of elements for the returned `RaggedTensor`.
If not specified, then a default is chosen based on the scalar values in
`pylist`. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> ragged_rank
						</dt>
						<dd>An integer specifying the ragged rank of the returned
`RaggedTensorValue`.  Must be nonnegative and less than `K`. Defaults to
`max(0, K - 1)` if `inner_shape` is not specified.  Defaults to `max(0, K
- 1 - len(inner_shape))` if `inner_shape` is specified. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> inner_shape
						</dt>
						<dd>A tuple of integers specifying the shape for individual inner
values in the returned `RaggedTensorValue`.  Defaults to `()` if
`ragged_rank` is not specified.  If `ragged_rank` is specified, then a
default is chosen based on the contents of `pylist`. 
						</dd>
						<dt>
							<code><a href="../numpy/dtype.htm">dtype</a></code> row_splits_dtype
						</dt>
						<dd>data type for the constructed `RaggedTensorValue`'s
row_splits.  One of `numpy.int32` or `numpy.int64`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.Collections.Generic.IList<object>">IList&lt;object&gt;</span></code>
					</dt>
					<dd>A `tf.RaggedTensorValue` or `numpy.array` with rank `K` and the specified
`ragged_rank`, containing the values from `pylist`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> ragged.constant_value([[1, 2], [3], [4, 5, 6]])
            RaggedTensorValue(values=[1, 2, 3, 4, 5, 6], splits=[0, 2, 3, 6]) </pre>
</div>
		</div>
	</div>
	<div id="constant_value" class="method">
		<h4>
			<span title="System.Collections.Generic.IList<object>">IList&lt;object&gt;</span> <strong>constant_value</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> pylist, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> dtype, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> ragged_rank, <span title="System.object">object</span> inner_shape, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> row_splits_dtype)
		</h4>
		<div class="content">Constructs a RaggedTensorValue from a nested Python list. <p></p> Warning: This function returns a `RaggedTensorValue`, not a `RaggedTensor`.
If you wish to construct a constant `RaggedTensor`, use
[`ragged.constant(...)`](constant.md) instead. <p></p> Example:
All scalar values in `pylist` must have the same nesting depth `K`, and the
returned `RaggedTensorValue` will have rank `K`.  If `pylist` contains no
scalar values, then `K` is one greater than the maximum depth of empty lists
in `pylist`.  All scalar values in `pylist` must be compatible with `dtype`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> pylist
						</dt>
						<dd>A nested `list`, `tuple` or `np.ndarray`.  Any nested element that
is not a `list` or `tuple` must be a scalar value compatible with `dtype`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> dtype
						</dt>
						<dd>`numpy.dtype`.  The type of elements for the returned `RaggedTensor`.
If not specified, then a default is chosen based on the scalar values in
`pylist`. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> ragged_rank
						</dt>
						<dd>An integer specifying the ragged rank of the returned
`RaggedTensorValue`.  Must be nonnegative and less than `K`. Defaults to
`max(0, K - 1)` if `inner_shape` is not specified.  Defaults to `max(0, K
- 1 - len(inner_shape))` if `inner_shape` is specified. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> inner_shape
						</dt>
						<dd>A tuple of integers specifying the shape for individual inner
values in the returned `RaggedTensorValue`.  Defaults to `()` if
`ragged_rank` is not specified.  If `ragged_rank` is specified, then a
default is chosen based on the contents of `pylist`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> row_splits_dtype
						</dt>
						<dd>data type for the constructed `RaggedTensorValue`'s
row_splits.  One of `numpy.int32` or `numpy.int64`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.Collections.Generic.IList<object>">IList&lt;object&gt;</span></code>
					</dt>
					<dd>A `tf.RaggedTensorValue` or `numpy.array` with rank `K` and the specified
`ragged_rank`, containing the values from `pylist`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> ragged.constant_value([[1, 2], [3], [4, 5, 6]])
            RaggedTensorValue(values=[1, 2, 3, 4, 5, 6], splits=[0, 2, 3, 6]) </pre>
</div>
		</div>
	</div>
	<div id="constant_value" class="method">
		<h4>
			<span title="System.Collections.Generic.IList<object>">IList&lt;object&gt;</span> <strong>constant_value</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> pylist, <a href="../tensorflow/DType.htm">DType</a> dtype, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> ragged_rank, <span title="System.object">object</span> inner_shape, <a href="../numpy/dtype.htm">dtype</a> row_splits_dtype)
		</h4>
		<div class="content">Constructs a RaggedTensorValue from a nested Python list. <p></p> Warning: This function returns a `RaggedTensorValue`, not a `RaggedTensor`.
If you wish to construct a constant `RaggedTensor`, use
[`ragged.constant(...)`](constant.md) instead. <p></p> Example:
All scalar values in `pylist` must have the same nesting depth `K`, and the
returned `RaggedTensorValue` will have rank `K`.  If `pylist` contains no
scalar values, then `K` is one greater than the maximum depth of empty lists
in `pylist`.  All scalar values in `pylist` must be compatible with `dtype`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> pylist
						</dt>
						<dd>A nested `list`, `tuple` or `np.ndarray`.  Any nested element that
is not a `list` or `tuple` must be a scalar value compatible with `dtype`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/DType.htm">DType</a></code> dtype
						</dt>
						<dd>`numpy.dtype`.  The type of elements for the returned `RaggedTensor`.
If not specified, then a default is chosen based on the scalar values in
`pylist`. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> ragged_rank
						</dt>
						<dd>An integer specifying the ragged rank of the returned
`RaggedTensorValue`.  Must be nonnegative and less than `K`. Defaults to
`max(0, K - 1)` if `inner_shape` is not specified.  Defaults to `max(0, K
- 1 - len(inner_shape))` if `inner_shape` is specified. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> inner_shape
						</dt>
						<dd>A tuple of integers specifying the shape for individual inner
values in the returned `RaggedTensorValue`.  Defaults to `()` if
`ragged_rank` is not specified.  If `ragged_rank` is specified, then a
default is chosen based on the contents of `pylist`. 
						</dd>
						<dt>
							<code><a href="../numpy/dtype.htm">dtype</a></code> row_splits_dtype
						</dt>
						<dd>data type for the constructed `RaggedTensorValue`'s
row_splits.  One of `numpy.int32` or `numpy.int64`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.Collections.Generic.IList<object>">IList&lt;object&gt;</span></code>
					</dt>
					<dd>A `tf.RaggedTensorValue` or `numpy.array` with rank `K` and the specified
`ragged_rank`, containing the values from `pylist`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> ragged.constant_value([[1, 2], [3], [4, 5, 6]])
            RaggedTensorValue(values=[1, 2, 3, 4, 5, 6], splits=[0, 2, 3, 6]) </pre>
</div>
		</div>
	</div>
	<div id="constant_value" class="method">
		<h4>
			<span title="System.Collections.Generic.IList<object>">IList&lt;object&gt;</span> <strong>constant_value</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> pylist, <span title="System.Byte[]">Byte[]</span> dtype, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> ragged_rank, <span title="System.object">object</span> inner_shape, <span title="System.string">string</span> row_splits_dtype)
		</h4>
		<div class="content">Constructs a RaggedTensorValue from a nested Python list. <p></p> Warning: This function returns a `RaggedTensorValue`, not a `RaggedTensor`.
If you wish to construct a constant `RaggedTensor`, use
[`ragged.constant(...)`](constant.md) instead. <p></p> Example:
All scalar values in `pylist` must have the same nesting depth `K`, and the
returned `RaggedTensorValue` will have rank `K`.  If `pylist` contains no
scalar values, then `K` is one greater than the maximum depth of empty lists
in `pylist`.  All scalar values in `pylist` must be compatible with `dtype`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> pylist
						</dt>
						<dd>A nested `list`, `tuple` or `np.ndarray`.  Any nested element that
is not a `list` or `tuple` must be a scalar value compatible with `dtype`. 
						</dd>
						<dt>
							<code><span title="System.Byte[]">Byte[]</span></code> dtype
						</dt>
						<dd>`numpy.dtype`.  The type of elements for the returned `RaggedTensor`.
If not specified, then a default is chosen based on the scalar values in
`pylist`. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> ragged_rank
						</dt>
						<dd>An integer specifying the ragged rank of the returned
`RaggedTensorValue`.  Must be nonnegative and less than `K`. Defaults to
`max(0, K - 1)` if `inner_shape` is not specified.  Defaults to `max(0, K
- 1 - len(inner_shape))` if `inner_shape` is specified. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> inner_shape
						</dt>
						<dd>A tuple of integers specifying the shape for individual inner
values in the returned `RaggedTensorValue`.  Defaults to `()` if
`ragged_rank` is not specified.  If `ragged_rank` is specified, then a
default is chosen based on the contents of `pylist`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> row_splits_dtype
						</dt>
						<dd>data type for the constructed `RaggedTensorValue`'s
row_splits.  One of `numpy.int32` or `numpy.int64`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.Collections.Generic.IList<object>">IList&lt;object&gt;</span></code>
					</dt>
					<dd>A `tf.RaggedTensorValue` or `numpy.array` with rank `K` and the specified
`ragged_rank`, containing the values from `pylist`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> ragged.constant_value([[1, 2], [3], [4, 5, 6]])
            RaggedTensorValue(values=[1, 2, 3, 4, 5, 6], splits=[0, 2, 3, 6]) </pre>
</div>
		</div>
	</div>
	<div id="constant_value" class="method">
		<h4>
			<span title="System.Collections.Generic.IList<object>">IList&lt;object&gt;</span> <strong>constant_value</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> pylist, <span title="System.Byte[]">Byte[]</span> dtype, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> ragged_rank, <span title="System.object">object</span> inner_shape, <a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> row_splits_dtype)
		</h4>
		<div class="content">Constructs a RaggedTensorValue from a nested Python list. <p></p> Warning: This function returns a `RaggedTensorValue`, not a `RaggedTensor`.
If you wish to construct a constant `RaggedTensor`, use
[`ragged.constant(...)`](constant.md) instead. <p></p> Example:
All scalar values in `pylist` must have the same nesting depth `K`, and the
returned `RaggedTensorValue` will have rank `K`.  If `pylist` contains no
scalar values, then `K` is one greater than the maximum depth of empty lists
in `pylist`.  All scalar values in `pylist` must be compatible with `dtype`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> pylist
						</dt>
						<dd>A nested `list`, `tuple` or `np.ndarray`.  Any nested element that
is not a `list` or `tuple` must be a scalar value compatible with `dtype`. 
						</dd>
						<dt>
							<code><span title="System.Byte[]">Byte[]</span></code> dtype
						</dt>
						<dd>`numpy.dtype`.  The type of elements for the returned `RaggedTensor`.
If not specified, then a default is chosen based on the scalar values in
`pylist`. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> ragged_rank
						</dt>
						<dd>An integer specifying the ragged rank of the returned
`RaggedTensorValue`.  Must be nonnegative and less than `K`. Defaults to
`max(0, K - 1)` if `inner_shape` is not specified.  Defaults to `max(0, K
- 1 - len(inner_shape))` if `inner_shape` is specified. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> inner_shape
						</dt>
						<dd>A tuple of integers specifying the shape for individual inner
values in the returned `RaggedTensorValue`.  Defaults to `()` if
`ragged_rank` is not specified.  If `ragged_rank` is specified, then a
default is chosen based on the contents of `pylist`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> row_splits_dtype
						</dt>
						<dd>data type for the constructed `RaggedTensorValue`'s
row_splits.  One of `numpy.int32` or `numpy.int64`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.Collections.Generic.IList<object>">IList&lt;object&gt;</span></code>
					</dt>
					<dd>A `tf.RaggedTensorValue` or `numpy.array` with rank `K` and the specified
`ragged_rank`, containing the values from `pylist`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> ragged.constant_value([[1, 2], [3], [4, 5, 6]])
            RaggedTensorValue(values=[1, 2, 3, 4, 5, 6], splits=[0, 2, 3, 6]) </pre>
</div>
		</div>
	</div>
	<div id="constant_value" class="method">
		<h4>
			<span title="System.Collections.Generic.IList<object>">IList&lt;object&gt;</span> <strong>constant_value</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> pylist, <span title="System.Byte[]">Byte[]</span> dtype, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> ragged_rank, <span title="System.object">object</span> inner_shape, <a href="../numpy/dtype.htm">dtype</a> row_splits_dtype)
		</h4>
		<div class="content">Constructs a RaggedTensorValue from a nested Python list. <p></p> Warning: This function returns a `RaggedTensorValue`, not a `RaggedTensor`.
If you wish to construct a constant `RaggedTensor`, use
[`ragged.constant(...)`](constant.md) instead. <p></p> Example:
All scalar values in `pylist` must have the same nesting depth `K`, and the
returned `RaggedTensorValue` will have rank `K`.  If `pylist` contains no
scalar values, then `K` is one greater than the maximum depth of empty lists
in `pylist`.  All scalar values in `pylist` must be compatible with `dtype`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> pylist
						</dt>
						<dd>A nested `list`, `tuple` or `np.ndarray`.  Any nested element that
is not a `list` or `tuple` must be a scalar value compatible with `dtype`. 
						</dd>
						<dt>
							<code><span title="System.Byte[]">Byte[]</span></code> dtype
						</dt>
						<dd>`numpy.dtype`.  The type of elements for the returned `RaggedTensor`.
If not specified, then a default is chosen based on the scalar values in
`pylist`. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> ragged_rank
						</dt>
						<dd>An integer specifying the ragged rank of the returned
`RaggedTensorValue`.  Must be nonnegative and less than `K`. Defaults to
`max(0, K - 1)` if `inner_shape` is not specified.  Defaults to `max(0, K
- 1 - len(inner_shape))` if `inner_shape` is specified. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> inner_shape
						</dt>
						<dd>A tuple of integers specifying the shape for individual inner
values in the returned `RaggedTensorValue`.  Defaults to `()` if
`ragged_rank` is not specified.  If `ragged_rank` is specified, then a
default is chosen based on the contents of `pylist`. 
						</dd>
						<dt>
							<code><a href="../numpy/dtype.htm">dtype</a></code> row_splits_dtype
						</dt>
						<dd>data type for the constructed `RaggedTensorValue`'s
row_splits.  One of `numpy.int32` or `numpy.int64`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.Collections.Generic.IList<object>">IList&lt;object&gt;</span></code>
					</dt>
					<dd>A `tf.RaggedTensorValue` or `numpy.array` with rank `K` and the specified
`ragged_rank`, containing the values from `pylist`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> ragged.constant_value([[1, 2], [3], [4, 5, 6]])
            RaggedTensorValue(values=[1, 2, 3, 4, 5, 6], splits=[0, 2, 3, 6]) </pre>
</div>
		</div>
	</div>
	<div id="constant_value" class="method">
		<h4>
			<span title="System.Collections.Generic.IList<object>">IList&lt;object&gt;</span> <strong>constant_value</strong>(<span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> pylist, <a href="../numpy/dtype.htm">dtype</a> dtype, <span title="System.Nullable<int>">Nullable&lt;int&gt;</span> ragged_rank, <span title="System.object">object</span> inner_shape, <span title="System.string">string</span> row_splits_dtype)
		</h4>
		<div class="content">Constructs a RaggedTensorValue from a nested Python list. <p></p> Warning: This function returns a `RaggedTensorValue`, not a `RaggedTensor`.
If you wish to construct a constant `RaggedTensor`, use
[`ragged.constant(...)`](constant.md) instead. <p></p> Example:
All scalar values in `pylist` must have the same nesting depth `K`, and the
returned `RaggedTensorValue` will have rank `K`.  If `pylist` contains no
scalar values, then `K` is one greater than the maximum depth of empty lists
in `pylist`.  All scalar values in `pylist` must be compatible with `dtype`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> pylist
						</dt>
						<dd>A nested `list`, `tuple` or `np.ndarray`.  Any nested element that
is not a `list` or `tuple` must be a scalar value compatible with `dtype`. 
						</dd>
						<dt>
							<code><a href="../numpy/dtype.htm">dtype</a></code> dtype
						</dt>
						<dd>`numpy.dtype`.  The type of elements for the returned `RaggedTensor`.
If not specified, then a default is chosen based on the scalar values in
`pylist`. 
						</dd>
						<dt>
							<code><span title="System.Nullable<int>">Nullable&lt;int&gt;</span></code> ragged_rank
						</dt>
						<dd>An integer specifying the ragged rank of the returned
`RaggedTensorValue`.  Must be nonnegative and less than `K`. Defaults to
`max(0, K - 1)` if `inner_shape` is not specified.  Defaults to `max(0, K
- 1 - len(inner_shape))` if `inner_shape` is specified. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> inner_shape
						</dt>
						<dd>A tuple of integers specifying the shape for individual inner
values in the returned `RaggedTensorValue`.  Defaults to `()` if
`ragged_rank` is not specified.  If `ragged_rank` is specified, then a
default is chosen based on the contents of `pylist`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> row_splits_dtype
						</dt>
						<dd>data type for the constructed `RaggedTensorValue`'s
row_splits.  One of `numpy.int32` or `numpy.int64`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.Collections.Generic.IList<object>">IList&lt;object&gt;</span></code>
					</dt>
					<dd>A `tf.RaggedTensorValue` or `numpy.array` with rank `K` and the specified
`ragged_rank`, containing the values from `pylist`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> ragged.constant_value([[1, 2], [3], [4, 5, 6]])
            RaggedTensorValue(values=[1, 2, 3, 4, 5, 6], splits=[0, 2, 3, 6]) </pre>
</div>
		</div>
	</div>
	<div id="constant_value_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>constant_value_dyn</strong>(<span title="System.object">object</span> pylist, <span title="System.object">object</span> dtype, <span title="System.object">object</span> ragged_rank, <span title="System.object">object</span> inner_shape, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> row_splits_dtype)
		</h4>
		<div class="content">Constructs a RaggedTensorValue from a nested Python list. <p></p> Warning: This function returns a `RaggedTensorValue`, not a `RaggedTensor`.
If you wish to construct a constant `RaggedTensor`, use
[`ragged.constant(...)`](constant.md) instead. <p></p> Example:
All scalar values in `pylist` must have the same nesting depth `K`, and the
returned `RaggedTensorValue` will have rank `K`.  If `pylist` contains no
scalar values, then `K` is one greater than the maximum depth of empty lists
in `pylist`.  All scalar values in `pylist` must be compatible with `dtype`. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> pylist
						</dt>
						<dd>A nested `list`, `tuple` or `np.ndarray`.  Any nested element that
is not a `list` or `tuple` must be a scalar value compatible with `dtype`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> dtype
						</dt>
						<dd>`numpy.dtype`.  The type of elements for the returned `RaggedTensor`.
If not specified, then a default is chosen based on the scalar values in
`pylist`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> ragged_rank
						</dt>
						<dd>An integer specifying the ragged rank of the returned
`RaggedTensorValue`.  Must be nonnegative and less than `K`. Defaults to
`max(0, K - 1)` if `inner_shape` is not specified.  Defaults to `max(0, K
- 1 - len(inner_shape))` if `inner_shape` is specified. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> inner_shape
						</dt>
						<dd>A tuple of integers specifying the shape for individual inner
values in the returned `RaggedTensorValue`.  Defaults to `()` if
`ragged_rank` is not specified.  If `ragged_rank` is specified, then a
default is chosen based on the contents of `pylist`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> row_splits_dtype
						</dt>
						<dd>data type for the constructed `RaggedTensorValue`'s
row_splits.  One of `numpy.int32` or `numpy.int64`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `tf.RaggedTensorValue` or `numpy.array` with rank `K` and the specified
`ragged_rank`, containing the values from `pylist`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> ragged.constant_value([[1, 2], [3], [4, 5, 6]])
            RaggedTensorValue(values=[1, 2, 3, 4, 5, 6], splits=[0, 2, 3, 6]) </pre>
</div>
		</div>
	</div>
	<div id="map_flat_values" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>map_flat_values</strong>(<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> op, <span title="System.Object[]">Object[]</span> args)
		</h4>
		<div class="content">Applies `op` to the values of one or more RaggedTensors. <p></p> Replaces any `RaggedTensor` in `args` or `kwargs` with its `flat_values`
tensor, and then calls `op`.  Returns a `RaggedTensor` that is constructed
from the input `RaggedTensor`s' `nested_row_splits` and the value returned by
the `op`. <p></p> If the input arguments contain multiple `RaggedTensor`s, then they must have
identical `nested_row_splits`. <p></p> Examples: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> op
						</dt>
						<dd>The operation that should be applied to the RaggedTensor `flat_values`.
`op` is typically an element-wise operation (such as math_ops.add), but
any operation that preserves the size of the outermost dimension can be
used.  I.e., `shape[0]` of the value returned by `op` must match
`shape[0]` of the `RaggedTensor`s' `flat_values` tensors. 
						</dd>
						<dt>
							<code><span title="System.Object[]">Object[]</span></code> args
						</dt>
						<dd>Arguments for `op`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A `RaggedTensor` whose `ragged_rank` matches the `ragged_rank` of all
input `RaggedTensor`s. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> rt = ragged.constant([[1, 2, 3], [], [4, 5], [6]])
            >>> ragged.map_flat_values(tf.ones_like, rt).eval().tolist()
            [[1, 1, 1], [], [1, 1], [1]]
            >>> ragged.map_flat_values(tf.multiply, rt, rt).eval().tolist()
            [[1, 4, 9], [], [16, 25], [36]]
            >>> ragged.map_flat_values(tf.add, rt, 5).eval().tolist()
            [[6, 7, 8], [], [9, 10], [11]] </pre>
</div>
		</div>
	</div>
	<div id="map_flat_values" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>map_flat_values</strong>(<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> op, <span title="System.Collections.Generic.IDictionary<string, object>">IDictionary&lt;string, object&gt;</span> kwargs, <span title="System.Object[]">Object[]</span> args)
		</h4>
		<div class="content">Applies `op` to the values of one or more RaggedTensors. <p></p> Replaces any `RaggedTensor` in `args` or `kwargs` with its `flat_values`
tensor, and then calls `op`.  Returns a `RaggedTensor` that is constructed
from the input `RaggedTensor`s' `nested_row_splits` and the value returned by
the `op`. <p></p> If the input arguments contain multiple `RaggedTensor`s, then they must have
identical `nested_row_splits`. <p></p> Examples: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a></code> op
						</dt>
						<dd>The operation that should be applied to the RaggedTensor `flat_values`.
`op` is typically an element-wise operation (such as math_ops.add), but
any operation that preserves the size of the outermost dimension can be
used.  I.e., `shape[0]` of the value returned by `op` must match
`shape[0]` of the `RaggedTensor`s' `flat_values` tensors. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<string, object>">IDictionary&lt;string, object&gt;</span></code> kwargs
						</dt>
						<dd>Keyword arguments for `op`. 
						</dd>
						<dt>
							<code><span title="System.Object[]">Object[]</span></code> args
						</dt>
						<dd>Arguments for `op`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A `RaggedTensor` whose `ragged_rank` matches the `ragged_rank` of all
input `RaggedTensor`s. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> rt = ragged.constant([[1, 2, 3], [], [4, 5], [6]])
            >>> ragged.map_flat_values(tf.ones_like, rt).eval().tolist()
            [[1, 1, 1], [], [1, 1], [1]]
            >>> ragged.map_flat_values(tf.multiply, rt, rt).eval().tolist()
            [[1, 4, 9], [], [16, 25], [36]]
            >>> ragged.map_flat_values(tf.add, rt, 5).eval().tolist()
            [[6, 7, 8], [], [9, 10], [11]] </pre>
</div>
		</div>
	</div>
	<div id="map_flat_values_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>map_flat_values_dyn</strong>(<span title="System.object">object</span> op, <span title="System.Collections.Generic.IDictionary<string, object>">IDictionary&lt;string, object&gt;</span> kwargs, <span title="System.Object[]">Object[]</span> args)
		</h4>
		<div class="content">Applies `op` to the values of one or more RaggedTensors. <p></p> Replaces any `RaggedTensor` in `args` or `kwargs` with its `flat_values`
tensor, and then calls `op`.  Returns a `RaggedTensor` that is constructed
from the input `RaggedTensor`s' `nested_row_splits` and the value returned by
the `op`. <p></p> If the input arguments contain multiple `RaggedTensor`s, then they must have
identical `nested_row_splits`. <p></p> Examples: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> op
						</dt>
						<dd>The operation that should be applied to the RaggedTensor `flat_values`.
`op` is typically an element-wise operation (such as math_ops.add), but
any operation that preserves the size of the outermost dimension can be
used.  I.e., `shape[0]` of the value returned by `op` must match
`shape[0]` of the `RaggedTensor`s' `flat_values` tensors. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IDictionary<string, object>">IDictionary&lt;string, object&gt;</span></code> kwargs
						</dt>
						<dd>Keyword arguments for `op`. 
						</dd>
						<dt>
							<code><span title="System.Object[]">Object[]</span></code> args
						</dt>
						<dd>Arguments for `op`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `RaggedTensor` whose `ragged_rank` matches the `ragged_rank` of all
input `RaggedTensor`s. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> rt = ragged.constant([[1, 2, 3], [], [4, 5], [6]])
            >>> ragged.map_flat_values(tf.ones_like, rt).eval().tolist()
            [[1, 1, 1], [], [1, 1], [1]]
            >>> ragged.map_flat_values(tf.multiply, rt, rt).eval().tolist()
            [[1, 4, 9], [], [16, 25], [36]]
            >>> ragged.map_flat_values(tf.add, rt, 5).eval().tolist()
            [[6, 7, 8], [], [9, 10], [11]] </pre>
</div>
		</div>
	</div>
	<div id="map_flat_values_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>map_flat_values_dyn</strong>(<span title="System.object">object</span> op, <span title="System.Object[]">Object[]</span> args)
		</h4>
		<div class="content">Applies `op` to the values of one or more RaggedTensors. <p></p> Replaces any `RaggedTensor` in `args` or `kwargs` with its `flat_values`
tensor, and then calls `op`.  Returns a `RaggedTensor` that is constructed
from the input `RaggedTensor`s' `nested_row_splits` and the value returned by
the `op`. <p></p> If the input arguments contain multiple `RaggedTensor`s, then they must have
identical `nested_row_splits`. <p></p> Examples: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> op
						</dt>
						<dd>The operation that should be applied to the RaggedTensor `flat_values`.
`op` is typically an element-wise operation (such as math_ops.add), but
any operation that preserves the size of the outermost dimension can be
used.  I.e., `shape[0]` of the value returned by `op` must match
`shape[0]` of the `RaggedTensor`s' `flat_values` tensors. 
						</dd>
						<dt>
							<code><span title="System.Object[]">Object[]</span></code> args
						</dt>
						<dd>Arguments for `op`. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `RaggedTensor` whose `ragged_rank` matches the `ragged_rank` of all
input `RaggedTensor`s. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> rt = ragged.constant([[1, 2, 3], [], [4, 5], [6]])
            >>> ragged.map_flat_values(tf.ones_like, rt).eval().tolist()
            [[1, 1, 1], [], [1, 1], [1]]
            >>> ragged.map_flat_values(tf.multiply, rt, rt).eval().tolist()
            [[1, 4, 9], [], [16, 25], [36]]
            >>> ragged.map_flat_values(tf.add, rt, 5).eval().tolist()
            [[6, 7, 8], [], [9, 10], [11]] </pre>
</div>
		</div>
	</div>
	<div id="placeholder" class="method">
		<h4>
			<span title="System.object">object</span> <strong>placeholder</strong>(<a href="../tensorflow/DType.htm">DType</a> dtype, <span title="System.int">int</span> ragged_rank, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> value_shape, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Creates a placeholder for a <a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a> that will always be fed. <p></p> **Important**: This ragged tensor will produce an error if evaluated.
Its value must be fed using the `feed_dict` optional argument to
`Session.run()`, `Tensor.eval()`, or `Operation.run()`. <p></p> @compatibility{eager} Placeholders are not compatible with eager execution. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/DType.htm">DType</a></code> dtype
						</dt>
						<dd>The data type for the `RaggedTensor`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> ragged_rank
						</dt>
						<dd>The ragged rank for the `RaggedTensor` 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> value_shape
						</dt>
						<dd>The shape for individual flat values in the `RaggedTensor`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `RaggedTensor` that may be used as a handle for feeding a value, but
not evaluated directly. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="placeholder" class="method">
		<h4>
			<span title="System.object">object</span> <strong>placeholder</strong>(<a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> dtype, <span title="System.int">int</span> ragged_rank, <span title="System.object">object</span> value_shape, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Creates a placeholder for a <a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a> that will always be fed. <p></p> **Important**: This ragged tensor will produce an error if evaluated.
Its value must be fed using the `feed_dict` optional argument to
`Session.run()`, `Tensor.eval()`, or `Operation.run()`. <p></p> @compatibility{eager} Placeholders are not compatible with eager execution. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> dtype
						</dt>
						<dd>The data type for the `RaggedTensor`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> ragged_rank
						</dt>
						<dd>The ragged rank for the `RaggedTensor` 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> value_shape
						</dt>
						<dd>The shape for individual flat values in the `RaggedTensor`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `RaggedTensor` that may be used as a handle for feeding a value, but
not evaluated directly. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="placeholder" class="method">
		<h4>
			<span title="System.object">object</span> <strong>placeholder</strong>(<a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> dtype, <span title="System.int">int</span> ragged_rank, <span title="System.ValueTuple<int, object, int>">ValueTuple&lt;int, object, int&gt;</span> value_shape, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Creates a placeholder for a <a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a> that will always be fed. <p></p> **Important**: This ragged tensor will produce an error if evaluated.
Its value must be fed using the `feed_dict` optional argument to
`Session.run()`, `Tensor.eval()`, or `Operation.run()`. <p></p> @compatibility{eager} Placeholders are not compatible with eager execution. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> dtype
						</dt>
						<dd>The data type for the `RaggedTensor`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> ragged_rank
						</dt>
						<dd>The ragged rank for the `RaggedTensor` 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<int, object, int>">ValueTuple&lt;int, object, int&gt;</span></code> value_shape
						</dt>
						<dd>The shape for individual flat values in the `RaggedTensor`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `RaggedTensor` that may be used as a handle for feeding a value, but
not evaluated directly. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="placeholder" class="method">
		<h4>
			<span title="System.object">object</span> <strong>placeholder</strong>(<a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a> dtype, <span title="System.int">int</span> ragged_rank, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> value_shape, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Creates a placeholder for a <a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a> that will always be fed. <p></p> **Important**: This ragged tensor will produce an error if evaluated.
Its value must be fed using the `feed_dict` optional argument to
`Session.run()`, `Tensor.eval()`, or `Operation.run()`. <p></p> @compatibility{eager} Placeholders are not compatible with eager execution. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient/PythonClassContainer.htm">PythonClassContainer</a></code> dtype
						</dt>
						<dd>The data type for the `RaggedTensor`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> ragged_rank
						</dt>
						<dd>The ragged rank for the `RaggedTensor` 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> value_shape
						</dt>
						<dd>The shape for individual flat values in the `RaggedTensor`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `RaggedTensor` that may be used as a handle for feeding a value, but
not evaluated directly. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="placeholder" class="method">
		<h4>
			<span title="System.object">object</span> <strong>placeholder</strong>(<a href="../tensorflow/DType.htm">DType</a> dtype, <span title="System.int">int</span> ragged_rank, <span title="System.object">object</span> value_shape, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Creates a placeholder for a <a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a> that will always be fed. <p></p> **Important**: This ragged tensor will produce an error if evaluated.
Its value must be fed using the `feed_dict` optional argument to
`Session.run()`, `Tensor.eval()`, or `Operation.run()`. <p></p> @compatibility{eager} Placeholders are not compatible with eager execution. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/DType.htm">DType</a></code> dtype
						</dt>
						<dd>The data type for the `RaggedTensor`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> ragged_rank
						</dt>
						<dd>The ragged rank for the `RaggedTensor` 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> value_shape
						</dt>
						<dd>The shape for individual flat values in the `RaggedTensor`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `RaggedTensor` that may be used as a handle for feeding a value, but
not evaluated directly. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="placeholder" class="method">
		<h4>
			<span title="System.object">object</span> <strong>placeholder</strong>(<a href="../tensorflow/DType.htm">DType</a> dtype, <span title="System.int">int</span> ragged_rank, <span title="System.ValueTuple<int, object, int>">ValueTuple&lt;int, object, int&gt;</span> value_shape, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Creates a placeholder for a <a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a> that will always be fed. <p></p> **Important**: This ragged tensor will produce an error if evaluated.
Its value must be fed using the `feed_dict` optional argument to
`Session.run()`, `Tensor.eval()`, or `Operation.run()`. <p></p> @compatibility{eager} Placeholders are not compatible with eager execution. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/DType.htm">DType</a></code> dtype
						</dt>
						<dd>The data type for the `RaggedTensor`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> ragged_rank
						</dt>
						<dd>The ragged rank for the `RaggedTensor` 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<int, object, int>">ValueTuple&lt;int, object, int&gt;</span></code> value_shape
						</dt>
						<dd>The shape for individual flat values in the `RaggedTensor`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `RaggedTensor` that may be used as a handle for feeding a value, but
not evaluated directly. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="placeholder" class="method">
		<h4>
			<span title="System.object">object</span> <strong>placeholder</strong>(<a href="../numpy/dtype.htm">dtype</a> dtype, <span title="System.int">int</span> ragged_rank, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> value_shape, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Creates a placeholder for a <a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a> that will always be fed. <p></p> **Important**: This ragged tensor will produce an error if evaluated.
Its value must be fed using the `feed_dict` optional argument to
`Session.run()`, `Tensor.eval()`, or `Operation.run()`. <p></p> @compatibility{eager} Placeholders are not compatible with eager execution. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../numpy/dtype.htm">dtype</a></code> dtype
						</dt>
						<dd>The data type for the `RaggedTensor`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> ragged_rank
						</dt>
						<dd>The ragged rank for the `RaggedTensor` 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> value_shape
						</dt>
						<dd>The shape for individual flat values in the `RaggedTensor`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `RaggedTensor` that may be used as a handle for feeding a value, but
not evaluated directly. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="placeholder" class="method">
		<h4>
			<span title="System.object">object</span> <strong>placeholder</strong>(<a href="../numpy/dtype.htm">dtype</a> dtype, <span title="System.int">int</span> ragged_rank, <span title="System.ValueTuple<int, object, int>">ValueTuple&lt;int, object, int&gt;</span> value_shape, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Creates a placeholder for a <a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a> that will always be fed. <p></p> **Important**: This ragged tensor will produce an error if evaluated.
Its value must be fed using the `feed_dict` optional argument to
`Session.run()`, `Tensor.eval()`, or `Operation.run()`. <p></p> @compatibility{eager} Placeholders are not compatible with eager execution. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../numpy/dtype.htm">dtype</a></code> dtype
						</dt>
						<dd>The data type for the `RaggedTensor`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> ragged_rank
						</dt>
						<dd>The ragged rank for the `RaggedTensor` 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<int, object, int>">ValueTuple&lt;int, object, int&gt;</span></code> value_shape
						</dt>
						<dd>The shape for individual flat values in the `RaggedTensor`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `RaggedTensor` that may be used as a handle for feeding a value, but
not evaluated directly. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="placeholder" class="method">
		<h4>
			<span title="System.object">object</span> <strong>placeholder</strong>(<a href="../numpy/dtype.htm">dtype</a> dtype, <span title="System.int">int</span> ragged_rank, <span title="System.object">object</span> value_shape, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Creates a placeholder for a <a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a> that will always be fed. <p></p> **Important**: This ragged tensor will produce an error if evaluated.
Its value must be fed using the `feed_dict` optional argument to
`Session.run()`, `Tensor.eval()`, or `Operation.run()`. <p></p> @compatibility{eager} Placeholders are not compatible with eager execution. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../numpy/dtype.htm">dtype</a></code> dtype
						</dt>
						<dd>The data type for the `RaggedTensor`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> ragged_rank
						</dt>
						<dd>The ragged rank for the `RaggedTensor` 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> value_shape
						</dt>
						<dd>The shape for individual flat values in the `RaggedTensor`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `RaggedTensor` that may be used as a handle for feeding a value, but
not evaluated directly. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="placeholder_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>placeholder_dyn</strong>(<span title="System.object">object</span> dtype, <span title="System.object">object</span> ragged_rank, <span title="System.object">object</span> value_shape, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Creates a placeholder for a <a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a> that will always be fed. <p></p> **Important**: This ragged tensor will produce an error if evaluated.
Its value must be fed using the `feed_dict` optional argument to
`Session.run()`, `Tensor.eval()`, or `Operation.run()`. <p></p> @compatibility{eager} Placeholders are not compatible with eager execution. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> dtype
						</dt>
						<dd>The data type for the `RaggedTensor`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> ragged_rank
						</dt>
						<dd>The ragged rank for the `RaggedTensor` 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> value_shape
						</dt>
						<dd>The shape for individual flat values in the `RaggedTensor`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>A name for the operation (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `RaggedTensor` that may be used as a handle for feeding a value, but
not evaluated directly. 
					</dd>
				</dl>
			</div>

		</div>
	</div>
	<div id="range" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>range</strong>(<span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> starts, <span title="System.ValueTuple<IEnumerable<object>, object>">ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;</span> limits, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> deltas, <a href="../tensorflow/DType.htm">DType</a> dtype, <span title="System.string">string</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> row_splits_dtype)
		</h4>
		<div class="content">Returns a `RaggedTensor` containing the specified sequences of numbers. <p></p> Each row of the returned `RaggedTensor` contains a single sequence:
If `start[i] < limits[i] and deltas[i] > 0`, then `output[i]` will be an
empty list.  Similarly, if `start[i] > limits[i] and deltas[i] < 0`, then
`output[i]` will be an empty list.  This behavior is consistent with the
Python `range` function, but differs from the <a href="..\..\tf\range.md"><code>tf.range</code></a> op, which returns
an error for these cases. <p></p> Examples:
The input tensors `starts`, `limits`, and `deltas` may be scalars or vectors.
The vector inputs must all have the same size.  Scalar inputs are broadcast
to match the size of the vector inputs. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> starts
						</dt>
						<dd>Vector or scalar `Tensor`.  Specifies the first entry for each range
if `limits` is not `None`; otherwise, specifies the range limits, and the
first entries default to `0`. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<IEnumerable<object>, object>">ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;</span></code> limits
						</dt>
						<dd>Vector or scalar `Tensor`.  Specifies the exclusive upper limits for
each range. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> deltas
						</dt>
						<dd>Vector or scalar `Tensor`.  Specifies the increment for each range.
Defaults to `1`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/DType.htm">DType</a></code> dtype
						</dt>
						<dd>The type of the elements of the resulting tensor.  If not specified,
then a value is chosen based on the other args. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> row_splits_dtype
						</dt>
						<dd>`dtype` for the returned `RaggedTensor`'s `row_splits`
tensor.  One of <a href="..\..\tf\dtypes\int32.md"><code>tf.int32</code></a> or <a href="..\..\tf\dtypes\int64.md"><code>tf.int64</code></a>. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A `RaggedTensor` of type `dtype` with `ragged_rank=1`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>ragged.range(starts, limits, deltas)[i] ==
                tf.range(starts[i], limits[i], deltas[i]) </pre>
</div>
		</div>
	</div>
	<div id="range" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>range</strong>(<span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> starts, <span title="System.int">int</span> limits, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> deltas, <a href="../tensorflow/DType.htm">DType</a> dtype, <span title="System.string">string</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> row_splits_dtype)
		</h4>
		<div class="content">Returns a `RaggedTensor` containing the specified sequences of numbers. <p></p> Each row of the returned `RaggedTensor` contains a single sequence:
If `start[i] < limits[i] and deltas[i] > 0`, then `output[i]` will be an
empty list.  Similarly, if `start[i] > limits[i] and deltas[i] < 0`, then
`output[i]` will be an empty list.  This behavior is consistent with the
Python `range` function, but differs from the <a href="..\..\tf\range.md"><code>tf.range</code></a> op, which returns
an error for these cases. <p></p> Examples:
The input tensors `starts`, `limits`, and `deltas` may be scalars or vectors.
The vector inputs must all have the same size.  Scalar inputs are broadcast
to match the size of the vector inputs. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> starts
						</dt>
						<dd>Vector or scalar `Tensor`.  Specifies the first entry for each range
if `limits` is not `None`; otherwise, specifies the range limits, and the
first entries default to `0`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> limits
						</dt>
						<dd>Vector or scalar `Tensor`.  Specifies the exclusive upper limits for
each range. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> deltas
						</dt>
						<dd>Vector or scalar `Tensor`.  Specifies the increment for each range.
Defaults to `1`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/DType.htm">DType</a></code> dtype
						</dt>
						<dd>The type of the elements of the resulting tensor.  If not specified,
then a value is chosen based on the other args. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> row_splits_dtype
						</dt>
						<dd>`dtype` for the returned `RaggedTensor`'s `row_splits`
tensor.  One of <a href="..\..\tf\dtypes\int32.md"><code>tf.int32</code></a> or <a href="..\..\tf\dtypes\int64.md"><code>tf.int64</code></a>. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A `RaggedTensor` of type `dtype` with `ragged_rank=1`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>ragged.range(starts, limits, deltas)[i] ==
                tf.range(starts[i], limits[i], deltas[i]) </pre>
</div>
		</div>
	</div>
	<div id="range" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>range</strong>(<span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> starts, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> limits, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> deltas, <a href="../tensorflow/DType.htm">DType</a> dtype, <span title="System.string">string</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> row_splits_dtype)
		</h4>
		<div class="content">Returns a `RaggedTensor` containing the specified sequences of numbers. <p></p> Each row of the returned `RaggedTensor` contains a single sequence:
If `start[i] < limits[i] and deltas[i] > 0`, then `output[i]` will be an
empty list.  Similarly, if `start[i] > limits[i] and deltas[i] < 0`, then
`output[i]` will be an empty list.  This behavior is consistent with the
Python `range` function, but differs from the <a href="..\..\tf\range.md"><code>tf.range</code></a> op, which returns
an error for these cases. <p></p> Examples:
The input tensors `starts`, `limits`, and `deltas` may be scalars or vectors.
The vector inputs must all have the same size.  Scalar inputs are broadcast
to match the size of the vector inputs. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> starts
						</dt>
						<dd>Vector or scalar `Tensor`.  Specifies the first entry for each range
if `limits` is not `None`; otherwise, specifies the range limits, and the
first entries default to `0`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> limits
						</dt>
						<dd>Vector or scalar `Tensor`.  Specifies the exclusive upper limits for
each range. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> deltas
						</dt>
						<dd>Vector or scalar `Tensor`.  Specifies the increment for each range.
Defaults to `1`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/DType.htm">DType</a></code> dtype
						</dt>
						<dd>The type of the elements of the resulting tensor.  If not specified,
then a value is chosen based on the other args. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> row_splits_dtype
						</dt>
						<dd>`dtype` for the returned `RaggedTensor`'s `row_splits`
tensor.  One of <a href="..\..\tf\dtypes\int32.md"><code>tf.int32</code></a> or <a href="..\..\tf\dtypes\int64.md"><code>tf.int64</code></a>. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A `RaggedTensor` of type `dtype` with `ragged_rank=1`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>ragged.range(starts, limits, deltas)[i] ==
                tf.range(starts[i], limits[i], deltas[i]) </pre>
</div>
		</div>
	</div>
	<div id="range" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>range</strong>(<span title="System.ValueTuple<IEnumerable<object>, object>">ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;</span> starts, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> limits, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> deltas, <a href="../tensorflow/DType.htm">DType</a> dtype, <span title="System.string">string</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> row_splits_dtype)
		</h4>
		<div class="content">Returns a `RaggedTensor` containing the specified sequences of numbers. <p></p> Each row of the returned `RaggedTensor` contains a single sequence:
If `start[i] < limits[i] and deltas[i] > 0`, then `output[i]` will be an
empty list.  Similarly, if `start[i] > limits[i] and deltas[i] < 0`, then
`output[i]` will be an empty list.  This behavior is consistent with the
Python `range` function, but differs from the <a href="..\..\tf\range.md"><code>tf.range</code></a> op, which returns
an error for these cases. <p></p> Examples:
The input tensors `starts`, `limits`, and `deltas` may be scalars or vectors.
The vector inputs must all have the same size.  Scalar inputs are broadcast
to match the size of the vector inputs. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<IEnumerable<object>, object>">ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;</span></code> starts
						</dt>
						<dd>Vector or scalar `Tensor`.  Specifies the first entry for each range
if `limits` is not `None`; otherwise, specifies the range limits, and the
first entries default to `0`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> limits
						</dt>
						<dd>Vector or scalar `Tensor`.  Specifies the exclusive upper limits for
each range. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> deltas
						</dt>
						<dd>Vector or scalar `Tensor`.  Specifies the increment for each range.
Defaults to `1`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/DType.htm">DType</a></code> dtype
						</dt>
						<dd>The type of the elements of the resulting tensor.  If not specified,
then a value is chosen based on the other args. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> row_splits_dtype
						</dt>
						<dd>`dtype` for the returned `RaggedTensor`'s `row_splits`
tensor.  One of <a href="..\..\tf\dtypes\int32.md"><code>tf.int32</code></a> or <a href="..\..\tf\dtypes\int64.md"><code>tf.int64</code></a>. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A `RaggedTensor` of type `dtype` with `ragged_rank=1`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>ragged.range(starts, limits, deltas)[i] ==
                tf.range(starts[i], limits[i], deltas[i]) </pre>
</div>
		</div>
	</div>
	<div id="range" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>range</strong>(<span title="System.int">int</span> starts, <span title="System.int">int</span> limits, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> deltas, <a href="../tensorflow/DType.htm">DType</a> dtype, <span title="System.string">string</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> row_splits_dtype)
		</h4>
		<div class="content">Returns a `RaggedTensor` containing the specified sequences of numbers. <p></p> Each row of the returned `RaggedTensor` contains a single sequence:
If `start[i] < limits[i] and deltas[i] > 0`, then `output[i]` will be an
empty list.  Similarly, if `start[i] > limits[i] and deltas[i] < 0`, then
`output[i]` will be an empty list.  This behavior is consistent with the
Python `range` function, but differs from the <a href="..\..\tf\range.md"><code>tf.range</code></a> op, which returns
an error for these cases. <p></p> Examples:
The input tensors `starts`, `limits`, and `deltas` may be scalars or vectors.
The vector inputs must all have the same size.  Scalar inputs are broadcast
to match the size of the vector inputs. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> starts
						</dt>
						<dd>Vector or scalar `Tensor`.  Specifies the first entry for each range
if `limits` is not `None`; otherwise, specifies the range limits, and the
first entries default to `0`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> limits
						</dt>
						<dd>Vector or scalar `Tensor`.  Specifies the exclusive upper limits for
each range. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> deltas
						</dt>
						<dd>Vector or scalar `Tensor`.  Specifies the increment for each range.
Defaults to `1`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/DType.htm">DType</a></code> dtype
						</dt>
						<dd>The type of the elements of the resulting tensor.  If not specified,
then a value is chosen based on the other args. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> row_splits_dtype
						</dt>
						<dd>`dtype` for the returned `RaggedTensor`'s `row_splits`
tensor.  One of <a href="..\..\tf\dtypes\int32.md"><code>tf.int32</code></a> or <a href="..\..\tf\dtypes\int64.md"><code>tf.int64</code></a>. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A `RaggedTensor` of type `dtype` with `ragged_rank=1`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>ragged.range(starts, limits, deltas)[i] ==
                tf.range(starts[i], limits[i], deltas[i]) </pre>
</div>
		</div>
	</div>
	<div id="range" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>range</strong>(<span title="System.int">int</span> starts, <span title="System.ValueTuple<IEnumerable<object>, object>">ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;</span> limits, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> deltas, <a href="../tensorflow/DType.htm">DType</a> dtype, <span title="System.string">string</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> row_splits_dtype)
		</h4>
		<div class="content">Returns a `RaggedTensor` containing the specified sequences of numbers. <p></p> Each row of the returned `RaggedTensor` contains a single sequence:
If `start[i] < limits[i] and deltas[i] > 0`, then `output[i]` will be an
empty list.  Similarly, if `start[i] > limits[i] and deltas[i] < 0`, then
`output[i]` will be an empty list.  This behavior is consistent with the
Python `range` function, but differs from the <a href="..\..\tf\range.md"><code>tf.range</code></a> op, which returns
an error for these cases. <p></p> Examples:
The input tensors `starts`, `limits`, and `deltas` may be scalars or vectors.
The vector inputs must all have the same size.  Scalar inputs are broadcast
to match the size of the vector inputs. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> starts
						</dt>
						<dd>Vector or scalar `Tensor`.  Specifies the first entry for each range
if `limits` is not `None`; otherwise, specifies the range limits, and the
first entries default to `0`. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<IEnumerable<object>, object>">ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;</span></code> limits
						</dt>
						<dd>Vector or scalar `Tensor`.  Specifies the exclusive upper limits for
each range. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> deltas
						</dt>
						<dd>Vector or scalar `Tensor`.  Specifies the increment for each range.
Defaults to `1`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/DType.htm">DType</a></code> dtype
						</dt>
						<dd>The type of the elements of the resulting tensor.  If not specified,
then a value is chosen based on the other args. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> row_splits_dtype
						</dt>
						<dd>`dtype` for the returned `RaggedTensor`'s `row_splits`
tensor.  One of <a href="..\..\tf\dtypes\int32.md"><code>tf.int32</code></a> or <a href="..\..\tf\dtypes\int64.md"><code>tf.int64</code></a>. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A `RaggedTensor` of type `dtype` with `ragged_rank=1`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>ragged.range(starts, limits, deltas)[i] ==
                tf.range(starts[i], limits[i], deltas[i]) </pre>
</div>
		</div>
	</div>
	<div id="range" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>range</strong>(<span title="System.ValueTuple<IEnumerable<object>, object>">ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;</span> starts, <span title="System.int">int</span> limits, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> deltas, <a href="../tensorflow/DType.htm">DType</a> dtype, <span title="System.string">string</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> row_splits_dtype)
		</h4>
		<div class="content">Returns a `RaggedTensor` containing the specified sequences of numbers. <p></p> Each row of the returned `RaggedTensor` contains a single sequence:
If `start[i] < limits[i] and deltas[i] > 0`, then `output[i]` will be an
empty list.  Similarly, if `start[i] > limits[i] and deltas[i] < 0`, then
`output[i]` will be an empty list.  This behavior is consistent with the
Python `range` function, but differs from the <a href="..\..\tf\range.md"><code>tf.range</code></a> op, which returns
an error for these cases. <p></p> Examples:
The input tensors `starts`, `limits`, and `deltas` may be scalars or vectors.
The vector inputs must all have the same size.  Scalar inputs are broadcast
to match the size of the vector inputs. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<IEnumerable<object>, object>">ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;</span></code> starts
						</dt>
						<dd>Vector or scalar `Tensor`.  Specifies the first entry for each range
if `limits` is not `None`; otherwise, specifies the range limits, and the
first entries default to `0`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> limits
						</dt>
						<dd>Vector or scalar `Tensor`.  Specifies the exclusive upper limits for
each range. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> deltas
						</dt>
						<dd>Vector or scalar `Tensor`.  Specifies the increment for each range.
Defaults to `1`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/DType.htm">DType</a></code> dtype
						</dt>
						<dd>The type of the elements of the resulting tensor.  If not specified,
then a value is chosen based on the other args. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> row_splits_dtype
						</dt>
						<dd>`dtype` for the returned `RaggedTensor`'s `row_splits`
tensor.  One of <a href="..\..\tf\dtypes\int32.md"><code>tf.int32</code></a> or <a href="..\..\tf\dtypes\int64.md"><code>tf.int64</code></a>. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A `RaggedTensor` of type `dtype` with `ragged_rank=1`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>ragged.range(starts, limits, deltas)[i] ==
                tf.range(starts[i], limits[i], deltas[i]) </pre>
</div>
		</div>
	</div>
	<div id="range" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>range</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> starts, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> limits, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> deltas, <a href="../tensorflow/DType.htm">DType</a> dtype, <span title="System.string">string</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> row_splits_dtype)
		</h4>
		<div class="content">Returns a `RaggedTensor` containing the specified sequences of numbers. <p></p> Each row of the returned `RaggedTensor` contains a single sequence:
If `start[i] < limits[i] and deltas[i] > 0`, then `output[i]` will be an
empty list.  Similarly, if `start[i] > limits[i] and deltas[i] < 0`, then
`output[i]` will be an empty list.  This behavior is consistent with the
Python `range` function, but differs from the <a href="..\..\tf\range.md"><code>tf.range</code></a> op, which returns
an error for these cases. <p></p> Examples:
The input tensors `starts`, `limits`, and `deltas` may be scalars or vectors.
The vector inputs must all have the same size.  Scalar inputs are broadcast
to match the size of the vector inputs. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> starts
						</dt>
						<dd>Vector or scalar `Tensor`.  Specifies the first entry for each range
if `limits` is not `None`; otherwise, specifies the range limits, and the
first entries default to `0`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> limits
						</dt>
						<dd>Vector or scalar `Tensor`.  Specifies the exclusive upper limits for
each range. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> deltas
						</dt>
						<dd>Vector or scalar `Tensor`.  Specifies the increment for each range.
Defaults to `1`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/DType.htm">DType</a></code> dtype
						</dt>
						<dd>The type of the elements of the resulting tensor.  If not specified,
then a value is chosen based on the other args. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> row_splits_dtype
						</dt>
						<dd>`dtype` for the returned `RaggedTensor`'s `row_splits`
tensor.  One of <a href="..\..\tf\dtypes\int32.md"><code>tf.int32</code></a> or <a href="..\..\tf\dtypes\int64.md"><code>tf.int64</code></a>. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A `RaggedTensor` of type `dtype` with `ragged_rank=1`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>ragged.range(starts, limits, deltas)[i] ==
                tf.range(starts[i], limits[i], deltas[i]) </pre>
</div>
		</div>
	</div>
	<div id="range" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>range</strong>(<span title="System.ValueTuple<IEnumerable<object>, object>">ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;</span> starts, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> limits, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> deltas, <a href="../tensorflow/DType.htm">DType</a> dtype, <span title="System.string">string</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> row_splits_dtype)
		</h4>
		<div class="content">Returns a `RaggedTensor` containing the specified sequences of numbers. <p></p> Each row of the returned `RaggedTensor` contains a single sequence:
If `start[i] < limits[i] and deltas[i] > 0`, then `output[i]` will be an
empty list.  Similarly, if `start[i] > limits[i] and deltas[i] < 0`, then
`output[i]` will be an empty list.  This behavior is consistent with the
Python `range` function, but differs from the <a href="..\..\tf\range.md"><code>tf.range</code></a> op, which returns
an error for these cases. <p></p> Examples:
The input tensors `starts`, `limits`, and `deltas` may be scalars or vectors.
The vector inputs must all have the same size.  Scalar inputs are broadcast
to match the size of the vector inputs. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<IEnumerable<object>, object>">ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;</span></code> starts
						</dt>
						<dd>Vector or scalar `Tensor`.  Specifies the first entry for each range
if `limits` is not `None`; otherwise, specifies the range limits, and the
first entries default to `0`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> limits
						</dt>
						<dd>Vector or scalar `Tensor`.  Specifies the exclusive upper limits for
each range. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> deltas
						</dt>
						<dd>Vector or scalar `Tensor`.  Specifies the increment for each range.
Defaults to `1`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/DType.htm">DType</a></code> dtype
						</dt>
						<dd>The type of the elements of the resulting tensor.  If not specified,
then a value is chosen based on the other args. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> row_splits_dtype
						</dt>
						<dd>`dtype` for the returned `RaggedTensor`'s `row_splits`
tensor.  One of <a href="..\..\tf\dtypes\int32.md"><code>tf.int32</code></a> or <a href="..\..\tf\dtypes\int64.md"><code>tf.int64</code></a>. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A `RaggedTensor` of type `dtype` with `ragged_rank=1`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>ragged.range(starts, limits, deltas)[i] ==
                tf.range(starts[i], limits[i], deltas[i]) </pre>
</div>
		</div>
	</div>
	<div id="range" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>range</strong>(<span title="System.int">int</span> starts, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> limits, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> deltas, <a href="../tensorflow/DType.htm">DType</a> dtype, <span title="System.string">string</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> row_splits_dtype)
		</h4>
		<div class="content">Returns a `RaggedTensor` containing the specified sequences of numbers. <p></p> Each row of the returned `RaggedTensor` contains a single sequence:
If `start[i] < limits[i] and deltas[i] > 0`, then `output[i]` will be an
empty list.  Similarly, if `start[i] > limits[i] and deltas[i] < 0`, then
`output[i]` will be an empty list.  This behavior is consistent with the
Python `range` function, but differs from the <a href="..\..\tf\range.md"><code>tf.range</code></a> op, which returns
an error for these cases. <p></p> Examples:
The input tensors `starts`, `limits`, and `deltas` may be scalars or vectors.
The vector inputs must all have the same size.  Scalar inputs are broadcast
to match the size of the vector inputs. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> starts
						</dt>
						<dd>Vector or scalar `Tensor`.  Specifies the first entry for each range
if `limits` is not `None`; otherwise, specifies the range limits, and the
first entries default to `0`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> limits
						</dt>
						<dd>Vector or scalar `Tensor`.  Specifies the exclusive upper limits for
each range. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> deltas
						</dt>
						<dd>Vector or scalar `Tensor`.  Specifies the increment for each range.
Defaults to `1`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/DType.htm">DType</a></code> dtype
						</dt>
						<dd>The type of the elements of the resulting tensor.  If not specified,
then a value is chosen based on the other args. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> row_splits_dtype
						</dt>
						<dd>`dtype` for the returned `RaggedTensor`'s `row_splits`
tensor.  One of <a href="..\..\tf\dtypes\int32.md"><code>tf.int32</code></a> or <a href="..\..\tf\dtypes\int64.md"><code>tf.int64</code></a>. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A `RaggedTensor` of type `dtype` with `ragged_rank=1`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>ragged.range(starts, limits, deltas)[i] ==
                tf.range(starts[i], limits[i], deltas[i]) </pre>
</div>
		</div>
	</div>
	<div id="range" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>range</strong>(<span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> starts, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> limits, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> deltas, <a href="../tensorflow/DType.htm">DType</a> dtype, <span title="System.string">string</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> row_splits_dtype)
		</h4>
		<div class="content">Returns a `RaggedTensor` containing the specified sequences of numbers. <p></p> Each row of the returned `RaggedTensor` contains a single sequence:
If `start[i] < limits[i] and deltas[i] > 0`, then `output[i]` will be an
empty list.  Similarly, if `start[i] > limits[i] and deltas[i] < 0`, then
`output[i]` will be an empty list.  This behavior is consistent with the
Python `range` function, but differs from the <a href="..\..\tf\range.md"><code>tf.range</code></a> op, which returns
an error for these cases. <p></p> Examples:
The input tensors `starts`, `limits`, and `deltas` may be scalars or vectors.
The vector inputs must all have the same size.  Scalar inputs are broadcast
to match the size of the vector inputs. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> starts
						</dt>
						<dd>Vector or scalar `Tensor`.  Specifies the first entry for each range
if `limits` is not `None`; otherwise, specifies the range limits, and the
first entries default to `0`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> limits
						</dt>
						<dd>Vector or scalar `Tensor`.  Specifies the exclusive upper limits for
each range. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> deltas
						</dt>
						<dd>Vector or scalar `Tensor`.  Specifies the increment for each range.
Defaults to `1`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/DType.htm">DType</a></code> dtype
						</dt>
						<dd>The type of the elements of the resulting tensor.  If not specified,
then a value is chosen based on the other args. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> row_splits_dtype
						</dt>
						<dd>`dtype` for the returned `RaggedTensor`'s `row_splits`
tensor.  One of <a href="..\..\tf\dtypes\int32.md"><code>tf.int32</code></a> or <a href="..\..\tf\dtypes\int64.md"><code>tf.int64</code></a>. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A `RaggedTensor` of type `dtype` with `ragged_rank=1`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>ragged.range(starts, limits, deltas)[i] ==
                tf.range(starts[i], limits[i], deltas[i]) </pre>
</div>
		</div>
	</div>
	<div id="range" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>range</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> starts, <span title="System.ValueTuple<IEnumerable<object>, object>">ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;</span> limits, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> deltas, <a href="../tensorflow/DType.htm">DType</a> dtype, <span title="System.string">string</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> row_splits_dtype)
		</h4>
		<div class="content">Returns a `RaggedTensor` containing the specified sequences of numbers. <p></p> Each row of the returned `RaggedTensor` contains a single sequence:
If `start[i] < limits[i] and deltas[i] > 0`, then `output[i]` will be an
empty list.  Similarly, if `start[i] > limits[i] and deltas[i] < 0`, then
`output[i]` will be an empty list.  This behavior is consistent with the
Python `range` function, but differs from the <a href="..\..\tf\range.md"><code>tf.range</code></a> op, which returns
an error for these cases. <p></p> Examples:
The input tensors `starts`, `limits`, and `deltas` may be scalars or vectors.
The vector inputs must all have the same size.  Scalar inputs are broadcast
to match the size of the vector inputs. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> starts
						</dt>
						<dd>Vector or scalar `Tensor`.  Specifies the first entry for each range
if `limits` is not `None`; otherwise, specifies the range limits, and the
first entries default to `0`. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<IEnumerable<object>, object>">ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;</span></code> limits
						</dt>
						<dd>Vector or scalar `Tensor`.  Specifies the exclusive upper limits for
each range. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> deltas
						</dt>
						<dd>Vector or scalar `Tensor`.  Specifies the increment for each range.
Defaults to `1`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/DType.htm">DType</a></code> dtype
						</dt>
						<dd>The type of the elements of the resulting tensor.  If not specified,
then a value is chosen based on the other args. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> row_splits_dtype
						</dt>
						<dd>`dtype` for the returned `RaggedTensor`'s `row_splits`
tensor.  One of <a href="..\..\tf\dtypes\int32.md"><code>tf.int32</code></a> or <a href="..\..\tf\dtypes\int64.md"><code>tf.int64</code></a>. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A `RaggedTensor` of type `dtype` with `ragged_rank=1`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>ragged.range(starts, limits, deltas)[i] ==
                tf.range(starts[i], limits[i], deltas[i]) </pre>
</div>
		</div>
	</div>
	<div id="range" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>range</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> starts, <span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> limits, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> deltas, <a href="../tensorflow/DType.htm">DType</a> dtype, <span title="System.string">string</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> row_splits_dtype)
		</h4>
		<div class="content">Returns a `RaggedTensor` containing the specified sequences of numbers. <p></p> Each row of the returned `RaggedTensor` contains a single sequence:
If `start[i] < limits[i] and deltas[i] > 0`, then `output[i]` will be an
empty list.  Similarly, if `start[i] > limits[i] and deltas[i] < 0`, then
`output[i]` will be an empty list.  This behavior is consistent with the
Python `range` function, but differs from the <a href="..\..\tf\range.md"><code>tf.range</code></a> op, which returns
an error for these cases. <p></p> Examples:
The input tensors `starts`, `limits`, and `deltas` may be scalars or vectors.
The vector inputs must all have the same size.  Scalar inputs are broadcast
to match the size of the vector inputs. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> starts
						</dt>
						<dd>Vector or scalar `Tensor`.  Specifies the first entry for each range
if `limits` is not `None`; otherwise, specifies the range limits, and the
first entries default to `0`. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> limits
						</dt>
						<dd>Vector or scalar `Tensor`.  Specifies the exclusive upper limits for
each range. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> deltas
						</dt>
						<dd>Vector or scalar `Tensor`.  Specifies the increment for each range.
Defaults to `1`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/DType.htm">DType</a></code> dtype
						</dt>
						<dd>The type of the elements of the resulting tensor.  If not specified,
then a value is chosen based on the other args. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> row_splits_dtype
						</dt>
						<dd>`dtype` for the returned `RaggedTensor`'s `row_splits`
tensor.  One of <a href="..\..\tf\dtypes\int32.md"><code>tf.int32</code></a> or <a href="..\..\tf\dtypes\int64.md"><code>tf.int64</code></a>. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A `RaggedTensor` of type `dtype` with `ragged_rank=1`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>ragged.range(starts, limits, deltas)[i] ==
                tf.range(starts[i], limits[i], deltas[i]) </pre>
</div>
		</div>
	</div>
	<div id="range" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>range</strong>(<span title="System.int">int</span> starts, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> limits, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> deltas, <a href="../tensorflow/DType.htm">DType</a> dtype, <span title="System.string">string</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> row_splits_dtype)
		</h4>
		<div class="content">Returns a `RaggedTensor` containing the specified sequences of numbers. <p></p> Each row of the returned `RaggedTensor` contains a single sequence:
If `start[i] < limits[i] and deltas[i] > 0`, then `output[i]` will be an
empty list.  Similarly, if `start[i] > limits[i] and deltas[i] < 0`, then
`output[i]` will be an empty list.  This behavior is consistent with the
Python `range` function, but differs from the <a href="..\..\tf\range.md"><code>tf.range</code></a> op, which returns
an error for these cases. <p></p> Examples:
The input tensors `starts`, `limits`, and `deltas` may be scalars or vectors.
The vector inputs must all have the same size.  Scalar inputs are broadcast
to match the size of the vector inputs. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> starts
						</dt>
						<dd>Vector or scalar `Tensor`.  Specifies the first entry for each range
if `limits` is not `None`; otherwise, specifies the range limits, and the
first entries default to `0`. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> limits
						</dt>
						<dd>Vector or scalar `Tensor`.  Specifies the exclusive upper limits for
each range. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> deltas
						</dt>
						<dd>Vector or scalar `Tensor`.  Specifies the increment for each range.
Defaults to `1`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/DType.htm">DType</a></code> dtype
						</dt>
						<dd>The type of the elements of the resulting tensor.  If not specified,
then a value is chosen based on the other args. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> row_splits_dtype
						</dt>
						<dd>`dtype` for the returned `RaggedTensor`'s `row_splits`
tensor.  One of <a href="..\..\tf\dtypes\int32.md"><code>tf.int32</code></a> or <a href="..\..\tf\dtypes\int64.md"><code>tf.int64</code></a>. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A `RaggedTensor` of type `dtype` with `ragged_rank=1`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>ragged.range(starts, limits, deltas)[i] ==
                tf.range(starts[i], limits[i], deltas[i]) </pre>
</div>
		</div>
	</div>
	<div id="range" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>range</strong>(<span title="System.ValueTuple<IEnumerable<object>, object>">ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;</span> starts, <span title="System.ValueTuple<IEnumerable<object>, object>">ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;</span> limits, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> deltas, <a href="../tensorflow/DType.htm">DType</a> dtype, <span title="System.string">string</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> row_splits_dtype)
		</h4>
		<div class="content">Returns a `RaggedTensor` containing the specified sequences of numbers. <p></p> Each row of the returned `RaggedTensor` contains a single sequence:
If `start[i] < limits[i] and deltas[i] > 0`, then `output[i]` will be an
empty list.  Similarly, if `start[i] > limits[i] and deltas[i] < 0`, then
`output[i]` will be an empty list.  This behavior is consistent with the
Python `range` function, but differs from the <a href="..\..\tf\range.md"><code>tf.range</code></a> op, which returns
an error for these cases. <p></p> Examples:
The input tensors `starts`, `limits`, and `deltas` may be scalars or vectors.
The vector inputs must all have the same size.  Scalar inputs are broadcast
to match the size of the vector inputs. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<IEnumerable<object>, object>">ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;</span></code> starts
						</dt>
						<dd>Vector or scalar `Tensor`.  Specifies the first entry for each range
if `limits` is not `None`; otherwise, specifies the range limits, and the
first entries default to `0`. 
						</dd>
						<dt>
							<code><span title="System.ValueTuple<IEnumerable<object>, object>">ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;</span></code> limits
						</dt>
						<dd>Vector or scalar `Tensor`.  Specifies the exclusive upper limits for
each range. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> deltas
						</dt>
						<dd>Vector or scalar `Tensor`.  Specifies the increment for each range.
Defaults to `1`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/DType.htm">DType</a></code> dtype
						</dt>
						<dd>The type of the elements of the resulting tensor.  If not specified,
then a value is chosen based on the other args. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> row_splits_dtype
						</dt>
						<dd>`dtype` for the returned `RaggedTensor`'s `row_splits`
tensor.  One of <a href="..\..\tf\dtypes\int32.md"><code>tf.int32</code></a> or <a href="..\..\tf\dtypes\int64.md"><code>tf.int64</code></a>. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A `RaggedTensor` of type `dtype` with `ragged_rank=1`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>ragged.range(starts, limits, deltas)[i] ==
                tf.range(starts[i], limits[i], deltas[i]) </pre>
</div>
		</div>
	</div>
	<div id="range" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>range</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> starts, <span title="System.int">int</span> limits, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> deltas, <a href="../tensorflow/DType.htm">DType</a> dtype, <span title="System.string">string</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> row_splits_dtype)
		</h4>
		<div class="content">Returns a `RaggedTensor` containing the specified sequences of numbers. <p></p> Each row of the returned `RaggedTensor` contains a single sequence:
If `start[i] < limits[i] and deltas[i] > 0`, then `output[i]` will be an
empty list.  Similarly, if `start[i] > limits[i] and deltas[i] < 0`, then
`output[i]` will be an empty list.  This behavior is consistent with the
Python `range` function, but differs from the <a href="..\..\tf\range.md"><code>tf.range</code></a> op, which returns
an error for these cases. <p></p> Examples:
The input tensors `starts`, `limits`, and `deltas` may be scalars or vectors.
The vector inputs must all have the same size.  Scalar inputs are broadcast
to match the size of the vector inputs. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> starts
						</dt>
						<dd>Vector or scalar `Tensor`.  Specifies the first entry for each range
if `limits` is not `None`; otherwise, specifies the range limits, and the
first entries default to `0`. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> limits
						</dt>
						<dd>Vector or scalar `Tensor`.  Specifies the exclusive upper limits for
each range. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> deltas
						</dt>
						<dd>Vector or scalar `Tensor`.  Specifies the increment for each range.
Defaults to `1`. 
						</dd>
						<dt>
							<code><a href="../tensorflow/DType.htm">DType</a></code> dtype
						</dt>
						<dd>The type of the elements of the resulting tensor.  If not specified,
then a value is chosen based on the other args. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name for the operation. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> row_splits_dtype
						</dt>
						<dd>`dtype` for the returned `RaggedTensor`'s `row_splits`
tensor.  One of <a href="..\..\tf\dtypes\int32.md"><code>tf.int32</code></a> or <a href="..\..\tf\dtypes\int64.md"><code>tf.int64</code></a>. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A `RaggedTensor` of type `dtype` with `ragged_rank=1`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>ragged.range(starts, limits, deltas)[i] ==
                tf.range(starts[i], limits[i], deltas[i]) </pre>
</div>
		</div>
	</div>
	<div id="range_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>range_dyn</strong>(<span title="System.object">object</span> starts, <span title="System.object">object</span> limits, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> deltas, <span title="System.object">object</span> dtype, <span title="System.object">object</span> name, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> row_splits_dtype)
		</h4>
		<div class="content">Returns a `RaggedTensor` containing the specified sequences of numbers. <p></p> Each row of the returned `RaggedTensor` contains a single sequence:
If `start[i] < limits[i] and deltas[i] > 0`, then `output[i]` will be an
empty list.  Similarly, if `start[i] > limits[i] and deltas[i] < 0`, then
`output[i]` will be an empty list.  This behavior is consistent with the
Python `range` function, but differs from the <a href="..\..\tf\range.md"><code>tf.range</code></a> op, which returns
an error for these cases. <p></p> Examples:
The input tensors `starts`, `limits`, and `deltas` may be scalars or vectors.
The vector inputs must all have the same size.  Scalar inputs are broadcast
to match the size of the vector inputs. 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> starts
						</dt>
						<dd>Vector or scalar `Tensor`.  Specifies the first entry for each range
if `limits` is not `None`; otherwise, specifies the range limits, and the
first entries default to `0`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> limits
						</dt>
						<dd>Vector or scalar `Tensor`.  Specifies the exclusive upper limits for
each range. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> deltas
						</dt>
						<dd>Vector or scalar `Tensor`.  Specifies the increment for each range.
Defaults to `1`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> dtype
						</dt>
						<dd>The type of the elements of the resulting tensor.  If not specified,
then a value is chosen based on the other args. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>A name for the operation. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> row_splits_dtype
						</dt>
						<dd>`dtype` for the returned `RaggedTensor`'s `row_splits`
tensor.  One of <a href="..\..\tf\dtypes\int32.md"><code>tf.int32</code></a> or <a href="..\..\tf\dtypes\int64.md"><code>tf.int64</code></a>. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `RaggedTensor` of type `dtype` with `ragged_rank=1`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>ragged.range(starts, limits, deltas)[i] ==
                tf.range(starts[i], limits[i], deltas[i]) </pre>
</div>
		</div>
	</div>
	<div id="row_splits_to_segment_ids" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>row_splits_to_segment_ids</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> splits, <span title="System.string">string</span> name, <span title="System.object">object</span> out_type)
		</h4>
		<div class="content">Generates the segmentation corresponding to a RaggedTensor `row_splits`. <p></p> Returns an integer vector `segment_ids`, where `segment_ids[i] == j` if
`splits[j] <= i < splits[j+1]`.  Example: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> splits
						</dt>
						<dd>A sorted 1-D integer Tensor.  `splits[0]` must be zero. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> out_type
						</dt>
						<dd>The dtype for the return value.  Defaults to `splits.dtype`,
or <a href="..\..\tf\dtypes\int64.md"><code>tf.int64</code></a> if `splits` does not have a dtype. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A sorted 1-D integer Tensor, with `shape=[splits[-1]]` 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> ragged.row_splits_to_segment_ids([0, 3, 3, 5, 6, 9]).eval()
            [ 0 0 0 2 2 3 4 4 4 ] </pre>
</div>
		</div>
	</div>
	<div id="row_splits_to_segment_ids" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>row_splits_to_segment_ids</strong>(<span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> splits, <span title="System.string">string</span> name, <span title="System.object">object</span> out_type)
		</h4>
		<div class="content">Generates the segmentation corresponding to a RaggedTensor `row_splits`. <p></p> Returns an integer vector `segment_ids`, where `segment_ids[i] == j` if
`splits[j] <= i < splits[j+1]`.  Example: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> splits
						</dt>
						<dd>A sorted 1-D integer Tensor.  `splits[0]` must be zero. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> out_type
						</dt>
						<dd>The dtype for the return value.  Defaults to `splits.dtype`,
or <a href="..\..\tf\dtypes\int64.md"><code>tf.int64</code></a> if `splits` does not have a dtype. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A sorted 1-D integer Tensor, with `shape=[splits[-1]]` 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> ragged.row_splits_to_segment_ids([0, 3, 3, 5, 6, 9]).eval()
            [ 0 0 0 2 2 3 4 4 4 ] </pre>
</div>
		</div>
	</div>
	<div id="row_splits_to_segment_ids" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>row_splits_to_segment_ids</strong>(<span title="System.ValueTuple<IEnumerable<object>, object>">ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;</span> splits, <span title="System.string">string</span> name, <span title="System.object">object</span> out_type)
		</h4>
		<div class="content">Generates the segmentation corresponding to a RaggedTensor `row_splits`. <p></p> Returns an integer vector `segment_ids`, where `segment_ids[i] == j` if
`splits[j] <= i < splits[j+1]`.  Example: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.ValueTuple<IEnumerable<object>, object>">ValueTuple&lt;IEnumerable&lt;object&gt;, object&gt;</span></code> splits
						</dt>
						<dd>A sorted 1-D integer Tensor.  `splits[0]` must be zero. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> out_type
						</dt>
						<dd>The dtype for the return value.  Defaults to `splits.dtype`,
or <a href="..\..\tf\dtypes\int64.md"><code>tf.int64</code></a> if `splits` does not have a dtype. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A sorted 1-D integer Tensor, with `shape=[splits[-1]]` 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> ragged.row_splits_to_segment_ids([0, 3, 3, 5, 6, 9]).eval()
            [ 0 0 0 2 2 3 4 4 4 ] </pre>
</div>
		</div>
	</div>
	<div id="row_splits_to_segment_ids_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>row_splits_to_segment_ids_dyn</strong>(<span title="System.object">object</span> splits, <span title="System.object">object</span> name, <span title="System.object">object</span> out_type)
		</h4>
		<div class="content">Generates the segmentation corresponding to a RaggedTensor `row_splits`. <p></p> Returns an integer vector `segment_ids`, where `segment_ids[i] == j` if
`splits[j] <= i < splits[j+1]`.  Example: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> splits
						</dt>
						<dd>A sorted 1-D integer Tensor.  `splits[0]` must be zero. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> out_type
						</dt>
						<dd>The dtype for the return value.  Defaults to `splits.dtype`,
or <a href="..\..\tf\dtypes\int64.md"><code>tf.int64</code></a> if `splits` does not have a dtype. 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A sorted 1-D integer Tensor, with `shape=[splits[-1]]` 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> ragged.row_splits_to_segment_ids([0, 3, 3, 5, 6, 9]).eval()
            [ 0 0 0 2 2 3 4 4 4 ] </pre>
</div>
		</div>
	</div>
	<div id="segment_ids_to_row_splits" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>segment_ids_to_row_splits</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> segment_ids, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> num_segments, <span title="System.object">object</span> out_type, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Generates the RaggedTensor `row_splits` corresponding to a segmentation. <p></p> Returns an integer vector `splits`, where `splits[0] = 0` and
`splits[i] = splits[i-1] + count(segment_ids==i)`.  Example: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> segment_ids
						</dt>
						<dd>A 1-D integer Tensor. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> num_segments
						</dt>
						<dd>A scalar integer indicating the number of segments.  Defaults
to `max(segment_ids) + 1` (or zero if `segment_ids` is empty). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> out_type
						</dt>
						<dd>The dtype for the return value.  Defaults to `segment_ids.dtype`,
or <a href="..\..\tf\dtypes\int64.md"><code>tf.int64</code></a> if `segment_ids` does not have a dtype. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A sorted 1-D integer Tensor, with `shape=[num_segments + 1]`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> ragged.segment_ids_to_row_splits([0, 0, 0, 2, 2, 3, 4, 4, 4]).eval()
            [ 0 3 3 5 6 9 ] </pre>
</div>
		</div>
	</div>
	<div id="segment_ids_to_row_splits" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>segment_ids_to_row_splits</strong>(<span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> segment_ids, <span title="System.int">int</span> num_segments, <span title="System.object">object</span> out_type, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Generates the RaggedTensor `row_splits` corresponding to a segmentation. <p></p> Returns an integer vector `splits`, where `splits[0] = 0` and
`splits[i] = splits[i-1] + count(segment_ids==i)`.  Example: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> segment_ids
						</dt>
						<dd>A 1-D integer Tensor. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_segments
						</dt>
						<dd>A scalar integer indicating the number of segments.  Defaults
to `max(segment_ids) + 1` (or zero if `segment_ids` is empty). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> out_type
						</dt>
						<dd>The dtype for the return value.  Defaults to `segment_ids.dtype`,
or <a href="..\..\tf\dtypes\int64.md"><code>tf.int64</code></a> if `segment_ids` does not have a dtype. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A sorted 1-D integer Tensor, with `shape=[num_segments + 1]`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> ragged.segment_ids_to_row_splits([0, 0, 0, 2, 2, 3, 4, 4, 4]).eval()
            [ 0 3 3 5 6 9 ] </pre>
</div>
		</div>
	</div>
	<div id="segment_ids_to_row_splits" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>segment_ids_to_row_splits</strong>(<span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span> segment_ids, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> num_segments, <span title="System.object">object</span> out_type, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Generates the RaggedTensor `row_splits` corresponding to a segmentation. <p></p> Returns an integer vector `splits`, where `splits[0] = 0` and
`splits[i] = splits[i-1] + count(segment_ids==i)`.  Example: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<int>">IEnumerable&lt;int&gt;</span></code> segment_ids
						</dt>
						<dd>A 1-D integer Tensor. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> num_segments
						</dt>
						<dd>A scalar integer indicating the number of segments.  Defaults
to `max(segment_ids) + 1` (or zero if `segment_ids` is empty). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> out_type
						</dt>
						<dd>The dtype for the return value.  Defaults to `segment_ids.dtype`,
or <a href="..\..\tf\dtypes\int64.md"><code>tf.int64</code></a> if `segment_ids` does not have a dtype. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A sorted 1-D integer Tensor, with `shape=[num_segments + 1]`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> ragged.segment_ids_to_row_splits([0, 0, 0, 2, 2, 3, 4, 4, 4]).eval()
            [ 0 3 3 5 6 9 ] </pre>
</div>
		</div>
	</div>
	<div id="segment_ids_to_row_splits" class="method">
		<h4>
			<a href="../tensorflow/Tensor.htm">Tensor</a> <strong>segment_ids_to_row_splits</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> segment_ids, <span title="System.int">int</span> num_segments, <span title="System.object">object</span> out_type, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Generates the RaggedTensor `row_splits` corresponding to a segmentation. <p></p> Returns an integer vector `splits`, where `splits[0] = 0` and
`splits[i] = splits[i-1] + count(segment_ids==i)`.  Example: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> segment_ids
						</dt>
						<dd>A 1-D integer Tensor. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> num_segments
						</dt>
						<dd>A scalar integer indicating the number of segments.  Defaults
to `max(segment_ids) + 1` (or zero if `segment_ids` is empty). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> out_type
						</dt>
						<dd>The dtype for the return value.  Defaults to `segment_ids.dtype`,
or <a href="..\..\tf\dtypes\int64.md"><code>tf.int64</code></a> if `segment_ids` does not have a dtype. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/Tensor.htm">Tensor</a></code>
					</dt>
					<dd>A sorted 1-D integer Tensor, with `shape=[num_segments + 1]`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> ragged.segment_ids_to_row_splits([0, 0, 0, 2, 2, 3, 4, 4, 4]).eval()
            [ 0 3 3 5 6 9 ] </pre>
</div>
		</div>
	</div>
	<div id="segment_ids_to_row_splits_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>segment_ids_to_row_splits_dyn</strong>(<span title="System.object">object</span> segment_ids, <span title="System.object">object</span> num_segments, <span title="System.object">object</span> out_type, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Generates the RaggedTensor `row_splits` corresponding to a segmentation. <p></p> Returns an integer vector `splits`, where `splits[0] = 0` and
`splits[i] = splits[i-1] + count(segment_ids==i)`.  Example: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> segment_ids
						</dt>
						<dd>A 1-D integer Tensor. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> num_segments
						</dt>
						<dd>A scalar integer indicating the number of segments.  Defaults
to `max(segment_ids) + 1` (or zero if `segment_ids` is empty). 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> out_type
						</dt>
						<dd>The dtype for the return value.  Defaults to `segment_ids.dtype`,
or <a href="..\..\tf\dtypes\int64.md"><code>tf.int64</code></a> if `segment_ids` does not have a dtype. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A sorted 1-D integer Tensor, with `shape=[num_segments + 1]`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> ragged.segment_ids_to_row_splits([0, 0, 0, 2, 2, 3, 4, 4, 4]).eval()
            [ 0 3 3 5 6 9 ] </pre>
</div>
		</div>
	</div>
	<div id="stack" class="method">
		<h4>
			<span title="System.object">object</span> <strong>stack</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> values, <span title="System.int">int</span> axis, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Stacks a list of rank-`R` tensors into one rank-`(R+1)` `RaggedTensor`. <p></p> Given a list of tensors or ragged tensors with the same rank `R`
(`R >= axis`), returns a rank-`R+1` `RaggedTensor` `result` such that
`result[i0...iaxis]` is `[value[i0...iaxis] for value in values]`. <p></p> #### Example: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> values
						</dt>
						<dd>A list of <a href="..\..\tf\Tensor.md"><code>tf.Tensor</code></a> or <a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a>.  May not be empty. All
`values` must have the same rank and the same dtype; but unlike
<a href="..\..\tf\stack.md"><code>tf.stack</code></a>, they can have arbitrary dimension sizes. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> axis
						</dt>
						<dd>A python integer, indicating the dimension along which to stack.
(Note: Unlike <a href="..\..\tf\stack.md"><code>tf.stack</code></a>, the `axis` parameter must be statically known.)
Negative values are supported only if the rank of at least one
`values` value is statically known. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `RaggedTensor` with rank `R+1`.
`result.ragged_rank=1+max(axis, max(rt.ragged_rank for rt in values]))`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> t1 = tf.ragged.constant([[1, 2], [3, 4, 5]])
            >>> t2 = tf.ragged.constant([[6], [7, 8, 9]])
            >>> tf.ragged.stack([t1, t2], axis=0)
            [[[1, 2], [3, 4, 5]], [[6], [7, 9, 0]]]
            >>> tf.ragged.stack([t1, t2], axis=1)
            [[[1, 2], [6]], [[3, 4, 5], [7, 8, 9]]] <p></p> </pre>
</div>
		</div>
	</div>
	<div id="stack" class="method">
		<h4>
			<span title="System.object">object</span> <strong>stack</strong>(<span title="System.int">int</span> values, <span title="System.int">int</span> axis, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Stacks a list of rank-`R` tensors into one rank-`(R+1)` `RaggedTensor`. <p></p> Given a list of tensors or ragged tensors with the same rank `R`
(`R >= axis`), returns a rank-`R+1` `RaggedTensor` `result` such that
`result[i0...iaxis]` is `[value[i0...iaxis] for value in values]`. <p></p> #### Example: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> values
						</dt>
						<dd>A list of <a href="..\..\tf\Tensor.md"><code>tf.Tensor</code></a> or <a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a>.  May not be empty. All
`values` must have the same rank and the same dtype; but unlike
<a href="..\..\tf\stack.md"><code>tf.stack</code></a>, they can have arbitrary dimension sizes. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> axis
						</dt>
						<dd>A python integer, indicating the dimension along which to stack.
(Note: Unlike <a href="..\..\tf\stack.md"><code>tf.stack</code></a>, the `axis` parameter must be statically known.)
Negative values are supported only if the rank of at least one
`values` value is statically known. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `RaggedTensor` with rank `R+1`.
`result.ragged_rank=1+max(axis, max(rt.ragged_rank for rt in values]))`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> t1 = tf.ragged.constant([[1, 2], [3, 4, 5]])
            >>> t2 = tf.ragged.constant([[6], [7, 8, 9]])
            >>> tf.ragged.stack([t1, t2], axis=0)
            [[[1, 2], [3, 4, 5]], [[6], [7, 9, 0]]]
            >>> tf.ragged.stack([t1, t2], axis=1)
            [[[1, 2], [6]], [[3, 4, 5], [7, 8, 9]]] <p></p> </pre>
</div>
		</div>
	</div>
	<div id="stack" class="method">
		<h4>
			<span title="System.object">object</span> <strong>stack</strong>(<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> values, <span title="System.int">int</span> axis, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Stacks a list of rank-`R` tensors into one rank-`(R+1)` `RaggedTensor`. <p></p> Given a list of tensors or ragged tensors with the same rank `R`
(`R >= axis`), returns a rank-`R+1` `RaggedTensor` `result` such that
`result[i0...iaxis]` is `[value[i0...iaxis] for value in values]`. <p></p> #### Example: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code> values
						</dt>
						<dd>A list of <a href="..\..\tf\Tensor.md"><code>tf.Tensor</code></a> or <a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a>.  May not be empty. All
`values` must have the same rank and the same dtype; but unlike
<a href="..\..\tf\stack.md"><code>tf.stack</code></a>, they can have arbitrary dimension sizes. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> axis
						</dt>
						<dd>A python integer, indicating the dimension along which to stack.
(Note: Unlike <a href="..\..\tf\stack.md"><code>tf.stack</code></a>, the `axis` parameter must be statically known.)
Negative values are supported only if the rank of at least one
`values` value is statically known. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `RaggedTensor` with rank `R+1`.
`result.ragged_rank=1+max(axis, max(rt.ragged_rank for rt in values]))`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> t1 = tf.ragged.constant([[1, 2], [3, 4, 5]])
            >>> t2 = tf.ragged.constant([[6], [7, 8, 9]])
            >>> tf.ragged.stack([t1, t2], axis=0)
            [[[1, 2], [3, 4, 5]], [[6], [7, 9, 0]]]
            >>> tf.ragged.stack([t1, t2], axis=1)
            [[[1, 2], [6]], [[3, 4, 5], [7, 8, 9]]] <p></p> </pre>
</div>
		</div>
	</div>
	<div id="stack_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>stack_dyn</strong>(<span title="System.object">object</span> values, <a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a> axis, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Stacks a list of rank-`R` tensors into one rank-`(R+1)` `RaggedTensor`. <p></p> Given a list of tensors or ragged tensors with the same rank `R`
(`R >= axis`), returns a rank-`R+1` `RaggedTensor` `result` such that
`result[i0...iaxis]` is `[value[i0...iaxis] for value in values]`. <p></p> #### Example: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> values
						</dt>
						<dd>A list of <a href="..\..\tf\Tensor.md"><code>tf.Tensor</code></a> or <a href="..\..\tf\RaggedTensor.md"><code>tf.RaggedTensor</code></a>.  May not be empty. All
`values` must have the same rank and the same dtype; but unlike
<a href="..\..\tf\stack.md"><code>tf.stack</code></a>, they can have arbitrary dimension sizes. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient/ImplicitContainer`1.htm">ImplicitContainer&lt;T&gt;</a></code> axis
						</dt>
						<dd>A python integer, indicating the dimension along which to stack.
(Note: Unlike <a href="..\..\tf\stack.md"><code>tf.stack</code></a>, the `axis` parameter must be statically known.)
Negative values are supported only if the rank of at least one
`values` value is statically known. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `RaggedTensor` with rank `R+1`.
`result.ragged_rank=1+max(axis, max(rt.ragged_rank for rt in values]))`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> t1 = tf.ragged.constant([[1, 2], [3, 4, 5]])
            >>> t2 = tf.ragged.constant([[6], [7, 8, 9]])
            >>> tf.ragged.stack([t1, t2], axis=0)
            [[[1, 2], [3, 4, 5]], [[6], [7, 9, 0]]]
            >>> tf.ragged.stack([t1, t2], axis=1)
            [[[1, 2], [6]], [[3, 4, 5], [7, 8, 9]]] <p></p> </pre>
</div>
		</div>
	</div>
	<div id="stack_dynamic_partitions" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>stack_dynamic_partitions</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> data, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> partitions, <span title="System.object">object</span> num_partitions, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Stacks dynamic partitions of a Tensor or RaggedTensor. <p></p> Returns a RaggedTensor `output` with `num_partitions` rows, where the row
`output[i]` is formed by stacking all slices `data[j1...jN]` such that
`partitions[j1...jN] = i`.  Slices of `data` are stacked in row-major
order. <p></p> If `num_partitions` is an `int` (not a `Tensor`), then this is equivalent to
`tf.ragged.stack(tf.dynamic_partition(data, partitions, num_partitions))`. <p></p> ####Example: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> data
						</dt>
						<dd>A `Tensor` or `RaggedTensor` containing the values to stack. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> partitions
						</dt>
						<dd>An `int32` or `int64` `Tensor` or `RaggedTensor` specifying the
partition that each slice of `data` should be added to.
`partitions.shape` must be a prefix of `data.shape`.  Values must be
greater than or equal to zero, and less than `num_partitions`.
`partitions` is not required to be sorted. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> num_partitions
						</dt>
						<dd>An `int32` or `int64` scalar specifying the number of
partitions to output.  This determines the number of rows in `output`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A `RaggedTensor` containing the stacked partitions.  The returned tensor
has the same dtype as `data`, and its shape is
`[num_partitions, (D)] + data.shape[partitions.rank:]`, where `(D)` is a
ragged dimension whose length is the number of data slices stacked for
each `partition`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> data           = ['a', 'b', 'c', 'd', 'e']
            >>> partitions     = [  3,   0,   2,   2,   3]
            >>> num_partitions = 5
            >>> tf.ragged.stack_dynamic_partitions(data, partitions, num_partitions)
            <RaggedTensor [['b'], [], ['c', 'd'], ['a', 'e'], []]> <p></p> </pre>
</div>
		</div>
	</div>
	<div id="stack_dynamic_partitions" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>stack_dynamic_partitions</strong>(<span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> data, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> partitions, <span title="System.object">object</span> num_partitions, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Stacks dynamic partitions of a Tensor or RaggedTensor. <p></p> Returns a RaggedTensor `output` with `num_partitions` rows, where the row
`output[i]` is formed by stacking all slices `data[j1...jN]` such that
`partitions[j1...jN] = i`.  Slices of `data` are stacked in row-major
order. <p></p> If `num_partitions` is an `int` (not a `Tensor`), then this is equivalent to
`tf.ragged.stack(tf.dynamic_partition(data, partitions, num_partitions))`. <p></p> ####Example: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> data
						</dt>
						<dd>A `Tensor` or `RaggedTensor` containing the values to stack. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> partitions
						</dt>
						<dd>An `int32` or `int64` `Tensor` or `RaggedTensor` specifying the
partition that each slice of `data` should be added to.
`partitions.shape` must be a prefix of `data.shape`.  Values must be
greater than or equal to zero, and less than `num_partitions`.
`partitions` is not required to be sorted. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> num_partitions
						</dt>
						<dd>An `int32` or `int64` scalar specifying the number of
partitions to output.  This determines the number of rows in `output`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A `RaggedTensor` containing the stacked partitions.  The returned tensor
has the same dtype as `data`, and its shape is
`[num_partitions, (D)] + data.shape[partitions.rank:]`, where `(D)` is a
ragged dimension whose length is the number of data slices stacked for
each `partition`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> data           = ['a', 'b', 'c', 'd', 'e']
            >>> partitions     = [  3,   0,   2,   2,   3]
            >>> num_partitions = 5
            >>> tf.ragged.stack_dynamic_partitions(data, partitions, num_partitions)
            <RaggedTensor [['b'], [], ['c', 'd'], ['a', 'e'], []]> <p></p> </pre>
</div>
		</div>
	</div>
	<div id="stack_dynamic_partitions" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>stack_dynamic_partitions</strong>(<span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> data, <a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> partitions, <span title="System.object">object</span> num_partitions, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Stacks dynamic partitions of a Tensor or RaggedTensor. <p></p> Returns a RaggedTensor `output` with `num_partitions` rows, where the row
`output[i]` is formed by stacking all slices `data[j1...jN]` such that
`partitions[j1...jN] = i`.  Slices of `data` are stacked in row-major
order. <p></p> If `num_partitions` is an `int` (not a `Tensor`), then this is equivalent to
`tf.ragged.stack(tf.dynamic_partition(data, partitions, num_partitions))`. <p></p> ####Example: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> data
						</dt>
						<dd>A `Tensor` or `RaggedTensor` containing the values to stack. 
						</dd>
						<dt>
							<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code> partitions
						</dt>
						<dd>An `int32` or `int64` `Tensor` or `RaggedTensor` specifying the
partition that each slice of `data` should be added to.
`partitions.shape` must be a prefix of `data.shape`.  Values must be
greater than or equal to zero, and less than `num_partitions`.
`partitions` is not required to be sorted. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> num_partitions
						</dt>
						<dd>An `int32` or `int64` scalar specifying the number of
partitions to output.  This determines the number of rows in `output`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A `RaggedTensor` containing the stacked partitions.  The returned tensor
has the same dtype as `data`, and its shape is
`[num_partitions, (D)] + data.shape[partitions.rank:]`, where `(D)` is a
ragged dimension whose length is the number of data slices stacked for
each `partition`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> data           = ['a', 'b', 'c', 'd', 'e']
            >>> partitions     = [  3,   0,   2,   2,   3]
            >>> num_partitions = 5
            >>> tf.ragged.stack_dynamic_partitions(data, partitions, num_partitions)
            <RaggedTensor [['b'], [], ['c', 'd'], ['a', 'e'], []]> <p></p> </pre>
</div>
		</div>
	</div>
	<div id="stack_dynamic_partitions" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>stack_dynamic_partitions</strong>(<span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> data, <span title="System.int">int</span> partitions, <span title="System.object">object</span> num_partitions, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Stacks dynamic partitions of a Tensor or RaggedTensor. <p></p> Returns a RaggedTensor `output` with `num_partitions` rows, where the row
`output[i]` is formed by stacking all slices `data[j1...jN]` such that
`partitions[j1...jN] = i`.  Slices of `data` are stacked in row-major
order. <p></p> If `num_partitions` is an `int` (not a `Tensor`), then this is equivalent to
`tf.ragged.stack(tf.dynamic_partition(data, partitions, num_partitions))`. <p></p> ####Example: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> data
						</dt>
						<dd>A `Tensor` or `RaggedTensor` containing the values to stack. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> partitions
						</dt>
						<dd>An `int32` or `int64` `Tensor` or `RaggedTensor` specifying the
partition that each slice of `data` should be added to.
`partitions.shape` must be a prefix of `data.shape`.  Values must be
greater than or equal to zero, and less than `num_partitions`.
`partitions` is not required to be sorted. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> num_partitions
						</dt>
						<dd>An `int32` or `int64` scalar specifying the number of
partitions to output.  This determines the number of rows in `output`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A `RaggedTensor` containing the stacked partitions.  The returned tensor
has the same dtype as `data`, and its shape is
`[num_partitions, (D)] + data.shape[partitions.rank:]`, where `(D)` is a
ragged dimension whose length is the number of data slices stacked for
each `partition`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> data           = ['a', 'b', 'c', 'd', 'e']
            >>> partitions     = [  3,   0,   2,   2,   3]
            >>> num_partitions = 5
            >>> tf.ragged.stack_dynamic_partitions(data, partitions, num_partitions)
            <RaggedTensor [['b'], [], ['c', 'd'], ['a', 'e'], []]> <p></p> </pre>
</div>
		</div>
	</div>
	<div id="stack_dynamic_partitions" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>stack_dynamic_partitions</strong>(<span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> data, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> partitions, <span title="System.object">object</span> num_partitions, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Stacks dynamic partitions of a Tensor or RaggedTensor. <p></p> Returns a RaggedTensor `output` with `num_partitions` rows, where the row
`output[i]` is formed by stacking all slices `data[j1...jN]` such that
`partitions[j1...jN] = i`.  Slices of `data` are stacked in row-major
order. <p></p> If `num_partitions` is an `int` (not a `Tensor`), then this is equivalent to
`tf.ragged.stack(tf.dynamic_partition(data, partitions, num_partitions))`. <p></p> ####Example: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> data
						</dt>
						<dd>A `Tensor` or `RaggedTensor` containing the values to stack. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> partitions
						</dt>
						<dd>An `int32` or `int64` `Tensor` or `RaggedTensor` specifying the
partition that each slice of `data` should be added to.
`partitions.shape` must be a prefix of `data.shape`.  Values must be
greater than or equal to zero, and less than `num_partitions`.
`partitions` is not required to be sorted. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> num_partitions
						</dt>
						<dd>An `int32` or `int64` scalar specifying the number of
partitions to output.  This determines the number of rows in `output`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A `RaggedTensor` containing the stacked partitions.  The returned tensor
has the same dtype as `data`, and its shape is
`[num_partitions, (D)] + data.shape[partitions.rank:]`, where `(D)` is a
ragged dimension whose length is the number of data slices stacked for
each `partition`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> data           = ['a', 'b', 'c', 'd', 'e']
            >>> partitions     = [  3,   0,   2,   2,   3]
            >>> num_partitions = 5
            >>> tf.ragged.stack_dynamic_partitions(data, partitions, num_partitions)
            <RaggedTensor [['b'], [], ['c', 'd'], ['a', 'e'], []]> <p></p> </pre>
</div>
		</div>
	</div>
	<div id="stack_dynamic_partitions" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>stack_dynamic_partitions</strong>(<span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span> data, <span title="System.object">object</span> partitions, <span title="System.object">object</span> num_partitions, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Stacks dynamic partitions of a Tensor or RaggedTensor. <p></p> Returns a RaggedTensor `output` with `num_partitions` rows, where the row
`output[i]` is formed by stacking all slices `data[j1...jN]` such that
`partitions[j1...jN] = i`.  Slices of `data` are stacked in row-major
order. <p></p> If `num_partitions` is an `int` (not a `Tensor`), then this is equivalent to
`tf.ragged.stack(tf.dynamic_partition(data, partitions, num_partitions))`. <p></p> ####Example: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<string>">IEnumerable&lt;string&gt;</span></code> data
						</dt>
						<dd>A `Tensor` or `RaggedTensor` containing the values to stack. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> partitions
						</dt>
						<dd>An `int32` or `int64` `Tensor` or `RaggedTensor` specifying the
partition that each slice of `data` should be added to.
`partitions.shape` must be a prefix of `data.shape`.  Values must be
greater than or equal to zero, and less than `num_partitions`.
`partitions` is not required to be sorted. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> num_partitions
						</dt>
						<dd>An `int32` or `int64` scalar specifying the number of
partitions to output.  This determines the number of rows in `output`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A `RaggedTensor` containing the stacked partitions.  The returned tensor
has the same dtype as `data`, and its shape is
`[num_partitions, (D)] + data.shape[partitions.rank:]`, where `(D)` is a
ragged dimension whose length is the number of data slices stacked for
each `partition`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> data           = ['a', 'b', 'c', 'd', 'e']
            >>> partitions     = [  3,   0,   2,   2,   3]
            >>> num_partitions = 5
            >>> tf.ragged.stack_dynamic_partitions(data, partitions, num_partitions)
            <RaggedTensor [['b'], [], ['c', 'd'], ['a', 'e'], []]> <p></p> </pre>
</div>
		</div>
	</div>
	<div id="stack_dynamic_partitions" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>stack_dynamic_partitions</strong>(<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> data, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> partitions, <span title="System.object">object</span> num_partitions, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Stacks dynamic partitions of a Tensor or RaggedTensor. <p></p> Returns a RaggedTensor `output` with `num_partitions` rows, where the row
`output[i]` is formed by stacking all slices `data[j1...jN]` such that
`partitions[j1...jN] = i`.  Slices of `data` are stacked in row-major
order. <p></p> If `num_partitions` is an `int` (not a `Tensor`), then this is equivalent to
`tf.ragged.stack(tf.dynamic_partition(data, partitions, num_partitions))`. <p></p> ####Example: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code> data
						</dt>
						<dd>A `Tensor` or `RaggedTensor` containing the values to stack. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> partitions
						</dt>
						<dd>An `int32` or `int64` `Tensor` or `RaggedTensor` specifying the
partition that each slice of `data` should be added to.
`partitions.shape` must be a prefix of `data.shape`.  Values must be
greater than or equal to zero, and less than `num_partitions`.
`partitions` is not required to be sorted. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> num_partitions
						</dt>
						<dd>An `int32` or `int64` scalar specifying the number of
partitions to output.  This determines the number of rows in `output`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A `RaggedTensor` containing the stacked partitions.  The returned tensor
has the same dtype as `data`, and its shape is
`[num_partitions, (D)] + data.shape[partitions.rank:]`, where `(D)` is a
ragged dimension whose length is the number of data slices stacked for
each `partition`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> data           = ['a', 'b', 'c', 'd', 'e']
            >>> partitions     = [  3,   0,   2,   2,   3]
            >>> num_partitions = 5
            >>> tf.ragged.stack_dynamic_partitions(data, partitions, num_partitions)
            <RaggedTensor [['b'], [], ['c', 'd'], ['a', 'e'], []]> <p></p> </pre>
</div>
		</div>
	</div>
	<div id="stack_dynamic_partitions" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>stack_dynamic_partitions</strong>(<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> data, <a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> partitions, <span title="System.object">object</span> num_partitions, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Stacks dynamic partitions of a Tensor or RaggedTensor. <p></p> Returns a RaggedTensor `output` with `num_partitions` rows, where the row
`output[i]` is formed by stacking all slices `data[j1...jN]` such that
`partitions[j1...jN] = i`.  Slices of `data` are stacked in row-major
order. <p></p> If `num_partitions` is an `int` (not a `Tensor`), then this is equivalent to
`tf.ragged.stack(tf.dynamic_partition(data, partitions, num_partitions))`. <p></p> ####Example: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code> data
						</dt>
						<dd>A `Tensor` or `RaggedTensor` containing the values to stack. 
						</dd>
						<dt>
							<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code> partitions
						</dt>
						<dd>An `int32` or `int64` `Tensor` or `RaggedTensor` specifying the
partition that each slice of `data` should be added to.
`partitions.shape` must be a prefix of `data.shape`.  Values must be
greater than or equal to zero, and less than `num_partitions`.
`partitions` is not required to be sorted. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> num_partitions
						</dt>
						<dd>An `int32` or `int64` scalar specifying the number of
partitions to output.  This determines the number of rows in `output`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A `RaggedTensor` containing the stacked partitions.  The returned tensor
has the same dtype as `data`, and its shape is
`[num_partitions, (D)] + data.shape[partitions.rank:]`, where `(D)` is a
ragged dimension whose length is the number of data slices stacked for
each `partition`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> data           = ['a', 'b', 'c', 'd', 'e']
            >>> partitions     = [  3,   0,   2,   2,   3]
            >>> num_partitions = 5
            >>> tf.ragged.stack_dynamic_partitions(data, partitions, num_partitions)
            <RaggedTensor [['b'], [], ['c', 'd'], ['a', 'e'], []]> <p></p> </pre>
</div>
		</div>
	</div>
	<div id="stack_dynamic_partitions" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>stack_dynamic_partitions</strong>(<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> data, <span title="System.int">int</span> partitions, <span title="System.object">object</span> num_partitions, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Stacks dynamic partitions of a Tensor or RaggedTensor. <p></p> Returns a RaggedTensor `output` with `num_partitions` rows, where the row
`output[i]` is formed by stacking all slices `data[j1...jN]` such that
`partitions[j1...jN] = i`.  Slices of `data` are stacked in row-major
order. <p></p> If `num_partitions` is an `int` (not a `Tensor`), then this is equivalent to
`tf.ragged.stack(tf.dynamic_partition(data, partitions, num_partitions))`. <p></p> ####Example: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code> data
						</dt>
						<dd>A `Tensor` or `RaggedTensor` containing the values to stack. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> partitions
						</dt>
						<dd>An `int32` or `int64` `Tensor` or `RaggedTensor` specifying the
partition that each slice of `data` should be added to.
`partitions.shape` must be a prefix of `data.shape`.  Values must be
greater than or equal to zero, and less than `num_partitions`.
`partitions` is not required to be sorted. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> num_partitions
						</dt>
						<dd>An `int32` or `int64` scalar specifying the number of
partitions to output.  This determines the number of rows in `output`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A `RaggedTensor` containing the stacked partitions.  The returned tensor
has the same dtype as `data`, and its shape is
`[num_partitions, (D)] + data.shape[partitions.rank:]`, where `(D)` is a
ragged dimension whose length is the number of data slices stacked for
each `partition`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> data           = ['a', 'b', 'c', 'd', 'e']
            >>> partitions     = [  3,   0,   2,   2,   3]
            >>> num_partitions = 5
            >>> tf.ragged.stack_dynamic_partitions(data, partitions, num_partitions)
            <RaggedTensor [['b'], [], ['c', 'd'], ['a', 'e'], []]> <p></p> </pre>
</div>
		</div>
	</div>
	<div id="stack_dynamic_partitions" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>stack_dynamic_partitions</strong>(<span title="System.object">object</span> data, <a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> partitions, <span title="System.object">object</span> num_partitions, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Stacks dynamic partitions of a Tensor or RaggedTensor. <p></p> Returns a RaggedTensor `output` with `num_partitions` rows, where the row
`output[i]` is formed by stacking all slices `data[j1...jN]` such that
`partitions[j1...jN] = i`.  Slices of `data` are stacked in row-major
order. <p></p> If `num_partitions` is an `int` (not a `Tensor`), then this is equivalent to
`tf.ragged.stack(tf.dynamic_partition(data, partitions, num_partitions))`. <p></p> ####Example: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> data
						</dt>
						<dd>A `Tensor` or `RaggedTensor` containing the values to stack. 
						</dd>
						<dt>
							<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code> partitions
						</dt>
						<dd>An `int32` or `int64` `Tensor` or `RaggedTensor` specifying the
partition that each slice of `data` should be added to.
`partitions.shape` must be a prefix of `data.shape`.  Values must be
greater than or equal to zero, and less than `num_partitions`.
`partitions` is not required to be sorted. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> num_partitions
						</dt>
						<dd>An `int32` or `int64` scalar specifying the number of
partitions to output.  This determines the number of rows in `output`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A `RaggedTensor` containing the stacked partitions.  The returned tensor
has the same dtype as `data`, and its shape is
`[num_partitions, (D)] + data.shape[partitions.rank:]`, where `(D)` is a
ragged dimension whose length is the number of data slices stacked for
each `partition`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> data           = ['a', 'b', 'c', 'd', 'e']
            >>> partitions     = [  3,   0,   2,   2,   3]
            >>> num_partitions = 5
            >>> tf.ragged.stack_dynamic_partitions(data, partitions, num_partitions)
            <RaggedTensor [['b'], [], ['c', 'd'], ['a', 'e'], []]> <p></p> </pre>
</div>
		</div>
	</div>
	<div id="stack_dynamic_partitions" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>stack_dynamic_partitions</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> data, <a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> partitions, <span title="System.object">object</span> num_partitions, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Stacks dynamic partitions of a Tensor or RaggedTensor. <p></p> Returns a RaggedTensor `output` with `num_partitions` rows, where the row
`output[i]` is formed by stacking all slices `data[j1...jN]` such that
`partitions[j1...jN] = i`.  Slices of `data` are stacked in row-major
order. <p></p> If `num_partitions` is an `int` (not a `Tensor`), then this is equivalent to
`tf.ragged.stack(tf.dynamic_partition(data, partitions, num_partitions))`. <p></p> ####Example: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> data
						</dt>
						<dd>A `Tensor` or `RaggedTensor` containing the values to stack. 
						</dd>
						<dt>
							<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code> partitions
						</dt>
						<dd>An `int32` or `int64` `Tensor` or `RaggedTensor` specifying the
partition that each slice of `data` should be added to.
`partitions.shape` must be a prefix of `data.shape`.  Values must be
greater than or equal to zero, and less than `num_partitions`.
`partitions` is not required to be sorted. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> num_partitions
						</dt>
						<dd>An `int32` or `int64` scalar specifying the number of
partitions to output.  This determines the number of rows in `output`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A `RaggedTensor` containing the stacked partitions.  The returned tensor
has the same dtype as `data`, and its shape is
`[num_partitions, (D)] + data.shape[partitions.rank:]`, where `(D)` is a
ragged dimension whose length is the number of data slices stacked for
each `partition`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> data           = ['a', 'b', 'c', 'd', 'e']
            >>> partitions     = [  3,   0,   2,   2,   3]
            >>> num_partitions = 5
            >>> tf.ragged.stack_dynamic_partitions(data, partitions, num_partitions)
            <RaggedTensor [['b'], [], ['c', 'd'], ['a', 'e'], []]> <p></p> </pre>
</div>
		</div>
	</div>
	<div id="stack_dynamic_partitions" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>stack_dynamic_partitions</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> data, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> partitions, <span title="System.object">object</span> num_partitions, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Stacks dynamic partitions of a Tensor or RaggedTensor. <p></p> Returns a RaggedTensor `output` with `num_partitions` rows, where the row
`output[i]` is formed by stacking all slices `data[j1...jN]` such that
`partitions[j1...jN] = i`.  Slices of `data` are stacked in row-major
order. <p></p> If `num_partitions` is an `int` (not a `Tensor`), then this is equivalent to
`tf.ragged.stack(tf.dynamic_partition(data, partitions, num_partitions))`. <p></p> ####Example: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> data
						</dt>
						<dd>A `Tensor` or `RaggedTensor` containing the values to stack. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> partitions
						</dt>
						<dd>An `int32` or `int64` `Tensor` or `RaggedTensor` specifying the
partition that each slice of `data` should be added to.
`partitions.shape` must be a prefix of `data.shape`.  Values must be
greater than or equal to zero, and less than `num_partitions`.
`partitions` is not required to be sorted. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> num_partitions
						</dt>
						<dd>An `int32` or `int64` scalar specifying the number of
partitions to output.  This determines the number of rows in `output`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A `RaggedTensor` containing the stacked partitions.  The returned tensor
has the same dtype as `data`, and its shape is
`[num_partitions, (D)] + data.shape[partitions.rank:]`, where `(D)` is a
ragged dimension whose length is the number of data slices stacked for
each `partition`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> data           = ['a', 'b', 'c', 'd', 'e']
            >>> partitions     = [  3,   0,   2,   2,   3]
            >>> num_partitions = 5
            >>> tf.ragged.stack_dynamic_partitions(data, partitions, num_partitions)
            <RaggedTensor [['b'], [], ['c', 'd'], ['a', 'e'], []]> <p></p> </pre>
</div>
		</div>
	</div>
	<div id="stack_dynamic_partitions" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>stack_dynamic_partitions</strong>(<span title="System.int">int</span> data, <span title="System.object">object</span> partitions, <span title="System.object">object</span> num_partitions, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Stacks dynamic partitions of a Tensor or RaggedTensor. <p></p> Returns a RaggedTensor `output` with `num_partitions` rows, where the row
`output[i]` is formed by stacking all slices `data[j1...jN]` such that
`partitions[j1...jN] = i`.  Slices of `data` are stacked in row-major
order. <p></p> If `num_partitions` is an `int` (not a `Tensor`), then this is equivalent to
`tf.ragged.stack(tf.dynamic_partition(data, partitions, num_partitions))`. <p></p> ####Example: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> data
						</dt>
						<dd>A `Tensor` or `RaggedTensor` containing the values to stack. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> partitions
						</dt>
						<dd>An `int32` or `int64` `Tensor` or `RaggedTensor` specifying the
partition that each slice of `data` should be added to.
`partitions.shape` must be a prefix of `data.shape`.  Values must be
greater than or equal to zero, and less than `num_partitions`.
`partitions` is not required to be sorted. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> num_partitions
						</dt>
						<dd>An `int32` or `int64` scalar specifying the number of
partitions to output.  This determines the number of rows in `output`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A `RaggedTensor` containing the stacked partitions.  The returned tensor
has the same dtype as `data`, and its shape is
`[num_partitions, (D)] + data.shape[partitions.rank:]`, where `(D)` is a
ragged dimension whose length is the number of data slices stacked for
each `partition`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> data           = ['a', 'b', 'c', 'd', 'e']
            >>> partitions     = [  3,   0,   2,   2,   3]
            >>> num_partitions = 5
            >>> tf.ragged.stack_dynamic_partitions(data, partitions, num_partitions)
            <RaggedTensor [['b'], [], ['c', 'd'], ['a', 'e'], []]> <p></p> </pre>
</div>
		</div>
	</div>
	<div id="stack_dynamic_partitions" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>stack_dynamic_partitions</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> data, <span title="System.object">object</span> partitions, <span title="System.object">object</span> num_partitions, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Stacks dynamic partitions of a Tensor or RaggedTensor. <p></p> Returns a RaggedTensor `output` with `num_partitions` rows, where the row
`output[i]` is formed by stacking all slices `data[j1...jN]` such that
`partitions[j1...jN] = i`.  Slices of `data` are stacked in row-major
order. <p></p> If `num_partitions` is an `int` (not a `Tensor`), then this is equivalent to
`tf.ragged.stack(tf.dynamic_partition(data, partitions, num_partitions))`. <p></p> ####Example: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> data
						</dt>
						<dd>A `Tensor` or `RaggedTensor` containing the values to stack. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> partitions
						</dt>
						<dd>An `int32` or `int64` `Tensor` or `RaggedTensor` specifying the
partition that each slice of `data` should be added to.
`partitions.shape` must be a prefix of `data.shape`.  Values must be
greater than or equal to zero, and less than `num_partitions`.
`partitions` is not required to be sorted. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> num_partitions
						</dt>
						<dd>An `int32` or `int64` scalar specifying the number of
partitions to output.  This determines the number of rows in `output`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A `RaggedTensor` containing the stacked partitions.  The returned tensor
has the same dtype as `data`, and its shape is
`[num_partitions, (D)] + data.shape[partitions.rank:]`, where `(D)` is a
ragged dimension whose length is the number of data slices stacked for
each `partition`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> data           = ['a', 'b', 'c', 'd', 'e']
            >>> partitions     = [  3,   0,   2,   2,   3]
            >>> num_partitions = 5
            >>> tf.ragged.stack_dynamic_partitions(data, partitions, num_partitions)
            <RaggedTensor [['b'], [], ['c', 'd'], ['a', 'e'], []]> <p></p> </pre>
</div>
		</div>
	</div>
	<div id="stack_dynamic_partitions" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>stack_dynamic_partitions</strong>(<span title="System.int">int</span> data, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> partitions, <span title="System.object">object</span> num_partitions, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Stacks dynamic partitions of a Tensor or RaggedTensor. <p></p> Returns a RaggedTensor `output` with `num_partitions` rows, where the row
`output[i]` is formed by stacking all slices `data[j1...jN]` such that
`partitions[j1...jN] = i`.  Slices of `data` are stacked in row-major
order. <p></p> If `num_partitions` is an `int` (not a `Tensor`), then this is equivalent to
`tf.ragged.stack(tf.dynamic_partition(data, partitions, num_partitions))`. <p></p> ####Example: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> data
						</dt>
						<dd>A `Tensor` or `RaggedTensor` containing the values to stack. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> partitions
						</dt>
						<dd>An `int32` or `int64` `Tensor` or `RaggedTensor` specifying the
partition that each slice of `data` should be added to.
`partitions.shape` must be a prefix of `data.shape`.  Values must be
greater than or equal to zero, and less than `num_partitions`.
`partitions` is not required to be sorted. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> num_partitions
						</dt>
						<dd>An `int32` or `int64` scalar specifying the number of
partitions to output.  This determines the number of rows in `output`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A `RaggedTensor` containing the stacked partitions.  The returned tensor
has the same dtype as `data`, and its shape is
`[num_partitions, (D)] + data.shape[partitions.rank:]`, where `(D)` is a
ragged dimension whose length is the number of data slices stacked for
each `partition`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> data           = ['a', 'b', 'c', 'd', 'e']
            >>> partitions     = [  3,   0,   2,   2,   3]
            >>> num_partitions = 5
            >>> tf.ragged.stack_dynamic_partitions(data, partitions, num_partitions)
            <RaggedTensor [['b'], [], ['c', 'd'], ['a', 'e'], []]> <p></p> </pre>
</div>
		</div>
	</div>
	<div id="stack_dynamic_partitions" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>stack_dynamic_partitions</strong>(<span title="System.object">object</span> data, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> partitions, <span title="System.object">object</span> num_partitions, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Stacks dynamic partitions of a Tensor or RaggedTensor. <p></p> Returns a RaggedTensor `output` with `num_partitions` rows, where the row
`output[i]` is formed by stacking all slices `data[j1...jN]` such that
`partitions[j1...jN] = i`.  Slices of `data` are stacked in row-major
order. <p></p> If `num_partitions` is an `int` (not a `Tensor`), then this is equivalent to
`tf.ragged.stack(tf.dynamic_partition(data, partitions, num_partitions))`. <p></p> ####Example: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> data
						</dt>
						<dd>A `Tensor` or `RaggedTensor` containing the values to stack. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> partitions
						</dt>
						<dd>An `int32` or `int64` `Tensor` or `RaggedTensor` specifying the
partition that each slice of `data` should be added to.
`partitions.shape` must be a prefix of `data.shape`.  Values must be
greater than or equal to zero, and less than `num_partitions`.
`partitions` is not required to be sorted. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> num_partitions
						</dt>
						<dd>An `int32` or `int64` scalar specifying the number of
partitions to output.  This determines the number of rows in `output`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A `RaggedTensor` containing the stacked partitions.  The returned tensor
has the same dtype as `data`, and its shape is
`[num_partitions, (D)] + data.shape[partitions.rank:]`, where `(D)` is a
ragged dimension whose length is the number of data slices stacked for
each `partition`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> data           = ['a', 'b', 'c', 'd', 'e']
            >>> partitions     = [  3,   0,   2,   2,   3]
            >>> num_partitions = 5
            >>> tf.ragged.stack_dynamic_partitions(data, partitions, num_partitions)
            <RaggedTensor [['b'], [], ['c', 'd'], ['a', 'e'], []]> <p></p> </pre>
</div>
		</div>
	</div>
	<div id="stack_dynamic_partitions" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>stack_dynamic_partitions</strong>(<a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> data, <span title="System.int">int</span> partitions, <span title="System.object">object</span> num_partitions, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Stacks dynamic partitions of a Tensor or RaggedTensor. <p></p> Returns a RaggedTensor `output` with `num_partitions` rows, where the row
`output[i]` is formed by stacking all slices `data[j1...jN]` such that
`partitions[j1...jN] = i`.  Slices of `data` are stacked in row-major
order. <p></p> If `num_partitions` is an `int` (not a `Tensor`), then this is equivalent to
`tf.ragged.stack(tf.dynamic_partition(data, partitions, num_partitions))`. <p></p> ####Example: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> data
						</dt>
						<dd>A `Tensor` or `RaggedTensor` containing the values to stack. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> partitions
						</dt>
						<dd>An `int32` or `int64` `Tensor` or `RaggedTensor` specifying the
partition that each slice of `data` should be added to.
`partitions.shape` must be a prefix of `data.shape`.  Values must be
greater than or equal to zero, and less than `num_partitions`.
`partitions` is not required to be sorted. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> num_partitions
						</dt>
						<dd>An `int32` or `int64` scalar specifying the number of
partitions to output.  This determines the number of rows in `output`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A `RaggedTensor` containing the stacked partitions.  The returned tensor
has the same dtype as `data`, and its shape is
`[num_partitions, (D)] + data.shape[partitions.rank:]`, where `(D)` is a
ragged dimension whose length is the number of data slices stacked for
each `partition`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> data           = ['a', 'b', 'c', 'd', 'e']
            >>> partitions     = [  3,   0,   2,   2,   3]
            >>> num_partitions = 5
            >>> tf.ragged.stack_dynamic_partitions(data, partitions, num_partitions)
            <RaggedTensor [['b'], [], ['c', 'd'], ['a', 'e'], []]> <p></p> </pre>
</div>
		</div>
	</div>
	<div id="stack_dynamic_partitions" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>stack_dynamic_partitions</strong>(<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> data, <span title="System.object">object</span> partitions, <span title="System.object">object</span> num_partitions, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Stacks dynamic partitions of a Tensor or RaggedTensor. <p></p> Returns a RaggedTensor `output` with `num_partitions` rows, where the row
`output[i]` is formed by stacking all slices `data[j1...jN]` such that
`partitions[j1...jN] = i`.  Slices of `data` are stacked in row-major
order. <p></p> If `num_partitions` is an `int` (not a `Tensor`), then this is equivalent to
`tf.ragged.stack(tf.dynamic_partition(data, partitions, num_partitions))`. <p></p> ####Example: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code> data
						</dt>
						<dd>A `Tensor` or `RaggedTensor` containing the values to stack. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> partitions
						</dt>
						<dd>An `int32` or `int64` `Tensor` or `RaggedTensor` specifying the
partition that each slice of `data` should be added to.
`partitions.shape` must be a prefix of `data.shape`.  Values must be
greater than or equal to zero, and less than `num_partitions`.
`partitions` is not required to be sorted. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> num_partitions
						</dt>
						<dd>An `int32` or `int64` scalar specifying the number of
partitions to output.  This determines the number of rows in `output`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A `RaggedTensor` containing the stacked partitions.  The returned tensor
has the same dtype as `data`, and its shape is
`[num_partitions, (D)] + data.shape[partitions.rank:]`, where `(D)` is a
ragged dimension whose length is the number of data slices stacked for
each `partition`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> data           = ['a', 'b', 'c', 'd', 'e']
            >>> partitions     = [  3,   0,   2,   2,   3]
            >>> num_partitions = 5
            >>> tf.ragged.stack_dynamic_partitions(data, partitions, num_partitions)
            <RaggedTensor [['b'], [], ['c', 'd'], ['a', 'e'], []]> <p></p> </pre>
</div>
		</div>
	</div>
	<div id="stack_dynamic_partitions" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>stack_dynamic_partitions</strong>(<span title="System.object">object</span> data, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> partitions, <span title="System.object">object</span> num_partitions, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Stacks dynamic partitions of a Tensor or RaggedTensor. <p></p> Returns a RaggedTensor `output` with `num_partitions` rows, where the row
`output[i]` is formed by stacking all slices `data[j1...jN]` such that
`partitions[j1...jN] = i`.  Slices of `data` are stacked in row-major
order. <p></p> If `num_partitions` is an `int` (not a `Tensor`), then this is equivalent to
`tf.ragged.stack(tf.dynamic_partition(data, partitions, num_partitions))`. <p></p> ####Example: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> data
						</dt>
						<dd>A `Tensor` or `RaggedTensor` containing the values to stack. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> partitions
						</dt>
						<dd>An `int32` or `int64` `Tensor` or `RaggedTensor` specifying the
partition that each slice of `data` should be added to.
`partitions.shape` must be a prefix of `data.shape`.  Values must be
greater than or equal to zero, and less than `num_partitions`.
`partitions` is not required to be sorted. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> num_partitions
						</dt>
						<dd>An `int32` or `int64` scalar specifying the number of
partitions to output.  This determines the number of rows in `output`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A `RaggedTensor` containing the stacked partitions.  The returned tensor
has the same dtype as `data`, and its shape is
`[num_partitions, (D)] + data.shape[partitions.rank:]`, where `(D)` is a
ragged dimension whose length is the number of data slices stacked for
each `partition`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> data           = ['a', 'b', 'c', 'd', 'e']
            >>> partitions     = [  3,   0,   2,   2,   3]
            >>> num_partitions = 5
            >>> tf.ragged.stack_dynamic_partitions(data, partitions, num_partitions)
            <RaggedTensor [['b'], [], ['c', 'd'], ['a', 'e'], []]> <p></p> </pre>
</div>
		</div>
	</div>
	<div id="stack_dynamic_partitions" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>stack_dynamic_partitions</strong>(<span title="System.object">object</span> data, <span title="System.object">object</span> partitions, <span title="System.object">object</span> num_partitions, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Stacks dynamic partitions of a Tensor or RaggedTensor. <p></p> Returns a RaggedTensor `output` with `num_partitions` rows, where the row
`output[i]` is formed by stacking all slices `data[j1...jN]` such that
`partitions[j1...jN] = i`.  Slices of `data` are stacked in row-major
order. <p></p> If `num_partitions` is an `int` (not a `Tensor`), then this is equivalent to
`tf.ragged.stack(tf.dynamic_partition(data, partitions, num_partitions))`. <p></p> ####Example: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> data
						</dt>
						<dd>A `Tensor` or `RaggedTensor` containing the values to stack. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> partitions
						</dt>
						<dd>An `int32` or `int64` `Tensor` or `RaggedTensor` specifying the
partition that each slice of `data` should be added to.
`partitions.shape` must be a prefix of `data.shape`.  Values must be
greater than or equal to zero, and less than `num_partitions`.
`partitions` is not required to be sorted. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> num_partitions
						</dt>
						<dd>An `int32` or `int64` scalar specifying the number of
partitions to output.  This determines the number of rows in `output`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A `RaggedTensor` containing the stacked partitions.  The returned tensor
has the same dtype as `data`, and its shape is
`[num_partitions, (D)] + data.shape[partitions.rank:]`, where `(D)` is a
ragged dimension whose length is the number of data slices stacked for
each `partition`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> data           = ['a', 'b', 'c', 'd', 'e']
            >>> partitions     = [  3,   0,   2,   2,   3]
            >>> num_partitions = 5
            >>> tf.ragged.stack_dynamic_partitions(data, partitions, num_partitions)
            <RaggedTensor [['b'], [], ['c', 'd'], ['a', 'e'], []]> <p></p> </pre>
</div>
		</div>
	</div>
	<div id="stack_dynamic_partitions" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>stack_dynamic_partitions</strong>(<span title="System.int">int</span> data, <span title="System.int">int</span> partitions, <span title="System.object">object</span> num_partitions, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Stacks dynamic partitions of a Tensor or RaggedTensor. <p></p> Returns a RaggedTensor `output` with `num_partitions` rows, where the row
`output[i]` is formed by stacking all slices `data[j1...jN]` such that
`partitions[j1...jN] = i`.  Slices of `data` are stacked in row-major
order. <p></p> If `num_partitions` is an `int` (not a `Tensor`), then this is equivalent to
`tf.ragged.stack(tf.dynamic_partition(data, partitions, num_partitions))`. <p></p> ####Example: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> data
						</dt>
						<dd>A `Tensor` or `RaggedTensor` containing the values to stack. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> partitions
						</dt>
						<dd>An `int32` or `int64` `Tensor` or `RaggedTensor` specifying the
partition that each slice of `data` should be added to.
`partitions.shape` must be a prefix of `data.shape`.  Values must be
greater than or equal to zero, and less than `num_partitions`.
`partitions` is not required to be sorted. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> num_partitions
						</dt>
						<dd>An `int32` or `int64` scalar specifying the number of
partitions to output.  This determines the number of rows in `output`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A `RaggedTensor` containing the stacked partitions.  The returned tensor
has the same dtype as `data`, and its shape is
`[num_partitions, (D)] + data.shape[partitions.rank:]`, where `(D)` is a
ragged dimension whose length is the number of data slices stacked for
each `partition`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> data           = ['a', 'b', 'c', 'd', 'e']
            >>> partitions     = [  3,   0,   2,   2,   3]
            >>> num_partitions = 5
            >>> tf.ragged.stack_dynamic_partitions(data, partitions, num_partitions)
            <RaggedTensor [['b'], [], ['c', 'd'], ['a', 'e'], []]> <p></p> </pre>
</div>
		</div>
	</div>
	<div id="stack_dynamic_partitions" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>stack_dynamic_partitions</strong>(<span title="System.int">int</span> data, <a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> partitions, <span title="System.object">object</span> num_partitions, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Stacks dynamic partitions of a Tensor or RaggedTensor. <p></p> Returns a RaggedTensor `output` with `num_partitions` rows, where the row
`output[i]` is formed by stacking all slices `data[j1...jN]` such that
`partitions[j1...jN] = i`.  Slices of `data` are stacked in row-major
order. <p></p> If `num_partitions` is an `int` (not a `Tensor`), then this is equivalent to
`tf.ragged.stack(tf.dynamic_partition(data, partitions, num_partitions))`. <p></p> ####Example: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> data
						</dt>
						<dd>A `Tensor` or `RaggedTensor` containing the values to stack. 
						</dd>
						<dt>
							<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code> partitions
						</dt>
						<dd>An `int32` or `int64` `Tensor` or `RaggedTensor` specifying the
partition that each slice of `data` should be added to.
`partitions.shape` must be a prefix of `data.shape`.  Values must be
greater than or equal to zero, and less than `num_partitions`.
`partitions` is not required to be sorted. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> num_partitions
						</dt>
						<dd>An `int32` or `int64` scalar specifying the number of
partitions to output.  This determines the number of rows in `output`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A `RaggedTensor` containing the stacked partitions.  The returned tensor
has the same dtype as `data`, and its shape is
`[num_partitions, (D)] + data.shape[partitions.rank:]`, where `(D)` is a
ragged dimension whose length is the number of data slices stacked for
each `partition`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> data           = ['a', 'b', 'c', 'd', 'e']
            >>> partitions     = [  3,   0,   2,   2,   3]
            >>> num_partitions = 5
            >>> tf.ragged.stack_dynamic_partitions(data, partitions, num_partitions)
            <RaggedTensor [['b'], [], ['c', 'd'], ['a', 'e'], []]> <p></p> </pre>
</div>
		</div>
	</div>
	<div id="stack_dynamic_partitions" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>stack_dynamic_partitions</strong>(<span title="System.int">int</span> data, <span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span> partitions, <span title="System.object">object</span> num_partitions, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Stacks dynamic partitions of a Tensor or RaggedTensor. <p></p> Returns a RaggedTensor `output` with `num_partitions` rows, where the row
`output[i]` is formed by stacking all slices `data[j1...jN]` such that
`partitions[j1...jN] = i`.  Slices of `data` are stacked in row-major
order. <p></p> If `num_partitions` is an `int` (not a `Tensor`), then this is equivalent to
`tf.ragged.stack(tf.dynamic_partition(data, partitions, num_partitions))`. <p></p> ####Example: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.int">int</span></code> data
						</dt>
						<dd>A `Tensor` or `RaggedTensor` containing the values to stack. 
						</dd>
						<dt>
							<code><span title="System.Collections.Generic.IEnumerable<object>">IEnumerable&lt;object&gt;</span></code> partitions
						</dt>
						<dd>An `int32` or `int64` `Tensor` or `RaggedTensor` specifying the
partition that each slice of `data` should be added to.
`partitions.shape` must be a prefix of `data.shape`.  Values must be
greater than or equal to zero, and less than `num_partitions`.
`partitions` is not required to be sorted. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> num_partitions
						</dt>
						<dd>An `int32` or `int64` scalar specifying the number of
partitions to output.  This determines the number of rows in `output`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A `RaggedTensor` containing the stacked partitions.  The returned tensor
has the same dtype as `data`, and its shape is
`[num_partitions, (D)] + data.shape[partitions.rank:]`, where `(D)` is a
ragged dimension whose length is the number of data slices stacked for
each `partition`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> data           = ['a', 'b', 'c', 'd', 'e']
            >>> partitions     = [  3,   0,   2,   2,   3]
            >>> num_partitions = 5
            >>> tf.ragged.stack_dynamic_partitions(data, partitions, num_partitions)
            <RaggedTensor [['b'], [], ['c', 'd'], ['a', 'e'], []]> <p></p> </pre>
</div>
		</div>
	</div>
	<div id="stack_dynamic_partitions" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>stack_dynamic_partitions</strong>(<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> data, <a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a> partitions, <span title="System.object">object</span> num_partitions, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Stacks dynamic partitions of a Tensor or RaggedTensor. <p></p> Returns a RaggedTensor `output` with `num_partitions` rows, where the row
`output[i]` is formed by stacking all slices `data[j1...jN]` such that
`partitions[j1...jN] = i`.  Slices of `data` are stacked in row-major
order. <p></p> If `num_partitions` is an `int` (not a `Tensor`), then this is equivalent to
`tf.ragged.stack(tf.dynamic_partition(data, partitions, num_partitions))`. <p></p> ####Example: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code> data
						</dt>
						<dd>A `Tensor` or `RaggedTensor` containing the values to stack. 
						</dd>
						<dt>
							<code><a href="../LostTech.Gradient.ManualWrappers/IGraphNodeBase.htm">IGraphNodeBase</a></code> partitions
						</dt>
						<dd>An `int32` or `int64` `Tensor` or `RaggedTensor` specifying the
partition that each slice of `data` should be added to.
`partitions.shape` must be a prefix of `data.shape`.  Values must be
greater than or equal to zero, and less than `num_partitions`.
`partitions` is not required to be sorted. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> num_partitions
						</dt>
						<dd>An `int32` or `int64` scalar specifying the number of
partitions to output.  This determines the number of rows in `output`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A `RaggedTensor` containing the stacked partitions.  The returned tensor
has the same dtype as `data`, and its shape is
`[num_partitions, (D)] + data.shape[partitions.rank:]`, where `(D)` is a
ragged dimension whose length is the number of data slices stacked for
each `partition`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> data           = ['a', 'b', 'c', 'd', 'e']
            >>> partitions     = [  3,   0,   2,   2,   3]
            >>> num_partitions = 5
            >>> tf.ragged.stack_dynamic_partitions(data, partitions, num_partitions)
            <RaggedTensor [['b'], [], ['c', 'd'], ['a', 'e'], []]> <p></p> </pre>
</div>
		</div>
	</div>
	<div id="stack_dynamic_partitions" class="method">
		<h4>
			<a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a> <strong>stack_dynamic_partitions</strong>(<span title="System.object">object</span> data, <span title="System.int">int</span> partitions, <span title="System.object">object</span> num_partitions, <span title="System.string">string</span> name)
		</h4>
		<div class="content">Stacks dynamic partitions of a Tensor or RaggedTensor. <p></p> Returns a RaggedTensor `output` with `num_partitions` rows, where the row
`output[i]` is formed by stacking all slices `data[j1...jN]` such that
`partitions[j1...jN] = i`.  Slices of `data` are stacked in row-major
order. <p></p> If `num_partitions` is an `int` (not a `Tensor`), then this is equivalent to
`tf.ragged.stack(tf.dynamic_partition(data, partitions, num_partitions))`. <p></p> ####Example: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> data
						</dt>
						<dd>A `Tensor` or `RaggedTensor` containing the values to stack. 
						</dd>
						<dt>
							<code><span title="System.int">int</span></code> partitions
						</dt>
						<dd>An `int32` or `int64` `Tensor` or `RaggedTensor` specifying the
partition that each slice of `data` should be added to.
`partitions.shape` must be a prefix of `data.shape`.  Values must be
greater than or equal to zero, and less than `num_partitions`.
`partitions` is not required to be sorted. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> num_partitions
						</dt>
						<dd>An `int32` or `int64` scalar specifying the number of
partitions to output.  This determines the number of rows in `output`. 
						</dd>
						<dt>
							<code><span title="System.string">string</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><a href="../tensorflow/RaggedTensor.htm">RaggedTensor</a></code>
					</dt>
					<dd>A `RaggedTensor` containing the stacked partitions.  The returned tensor
has the same dtype as `data`, and its shape is
`[num_partitions, (D)] + data.shape[partitions.rank:]`, where `(D)` is a
ragged dimension whose length is the number of data slices stacked for
each `partition`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> data           = ['a', 'b', 'c', 'd', 'e']
            >>> partitions     = [  3,   0,   2,   2,   3]
            >>> num_partitions = 5
            >>> tf.ragged.stack_dynamic_partitions(data, partitions, num_partitions)
            <RaggedTensor [['b'], [], ['c', 'd'], ['a', 'e'], []]> <p></p> </pre>
</div>
		</div>
	</div>
	<div id="stack_dynamic_partitions_dyn" class="method">
		<h4>
			<span title="System.object">object</span> <strong>stack_dynamic_partitions_dyn</strong>(<span title="System.object">object</span> data, <span title="System.object">object</span> partitions, <span title="System.object">object</span> num_partitions, <span title="System.object">object</span> name)
		</h4>
		<div class="content">Stacks dynamic partitions of a Tensor or RaggedTensor. <p></p> Returns a RaggedTensor `output` with `num_partitions` rows, where the row
`output[i]` is formed by stacking all slices `data[j1...jN]` such that
`partitions[j1...jN] = i`.  Slices of `data` are stacked in row-major
order. <p></p> If `num_partitions` is an `int` (not a `Tensor`), then this is equivalent to
`tf.ragged.stack(tf.dynamic_partition(data, partitions, num_partitions))`. <p></p> ####Example: 


			<div class="parameters">
				<h5>Parameters</h5>
				<dl>
						<dt>
							<code><span title="System.object">object</span></code> data
						</dt>
						<dd>A `Tensor` or `RaggedTensor` containing the values to stack. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> partitions
						</dt>
						<dd>An `int32` or `int64` `Tensor` or `RaggedTensor` specifying the
partition that each slice of `data` should be added to.
`partitions.shape` must be a prefix of `data.shape`.  Values must be
greater than or equal to zero, and less than `num_partitions`.
`partitions` is not required to be sorted. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> num_partitions
						</dt>
						<dd>An `int32` or `int64` scalar specifying the number of
partitions to output.  This determines the number of rows in `output`. 
						</dd>
						<dt>
							<code><span title="System.object">object</span></code> name
						</dt>
						<dd>A name prefix for the returned tensor (optional). 
						</dd>
				</dl>
			</div>

			<div class="return">

				<h5>Returns</h5>
				<dl>
					<dt>
						<code><span title="System.object">object</span></code>
					</dt>
					<dd>A `RaggedTensor` containing the stacked partitions.  The returned tensor
has the same dtype as `data`, and its shape is
`[num_partitions, (D)] + data.shape[partitions.rank:]`, where `(D)` is a
ragged dimension whose length is the number of data slices stacked for
each `partition`. 
					</dd>
				</dl>
			</div>
<div class="example">
  <a href="javascript:void(0)">Show Example</a>
  <pre>>>> data           = ['a', 'b', 'c', 'd', 'e']
            >>> partitions     = [  3,   0,   2,   2,   3]
            >>> num_partitions = 5
            >>> tf.ragged.stack_dynamic_partitions(data, partitions, num_partitions)
            <RaggedTensor [['b'], [], ['c', 'd'], ['a', 'e'], []]> <p></p> </pre>
</div>
		</div>
	</div>
	
	<h3 class="section">Public properties</h3>

	<div id="boolean_mask_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>boolean_mask_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="constant_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>constant_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="constant_value_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>constant_value_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="map_flat_values_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>map_flat_values_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="placeholder_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>placeholder_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="range_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>range_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="row_splits_to_segment_ids_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>row_splits_to_segment_ids_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="segment_ids_to_row_splits_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>segment_ids_to_row_splits_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="stack_dynamic_partitions_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>stack_dynamic_partitions_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	<div id="stack_fn" class="method">
		<h4>
			<a href="../LostTech.Gradient/PythonFunctionContainer.htm">PythonFunctionContainer</a> <strong>stack_fn</strong> get; 
		</h4>
		<div class="content">

		</div>
	</div>
	</section>
	</article><footer>
	<span id="version">Built from v1.15.0.0 of LostTech.TensorFlow</span>
	<span id="docu-link">
		Generated by <a href="http://docu.jagregory.com">docu</a>
	</span>
</footer>
  </body>
</html>